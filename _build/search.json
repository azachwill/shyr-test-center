[
  {
    "objectID": "blog/posts/shiny-r-1.8.0/index.html",
    "href": "blog/posts/shiny-r-1.8.0/index.html",
    "title": "Shiny for R updates: new default look, dark mode, shinylive updates, and more",
    "section": "",
    "text": "The Shiny team is pleased to announce another round of updates for 13 different R packages, including shiny and bslib. There are too many improvements to cover in a single post, but we‚Äôd like to highlight some of the more notable additions. For a detailed list of changes, be sure to check out the release notes section of this post.\nbslib brings modern Bootstrap versions and new user layouts and inputs to Shiny, the web framework for data scientists. Install the latest versions of shiny and bslib from CRAN with:\ninstall.packages(c(\"shiny\", \"bslib\"))\nIn this post, we‚Äôll cover three main topics: the new shiny look, what‚Äôs new in shinylive and a long-awaited update to selectize.js in shiny."
  },
  {
    "objectID": "blog/posts/shiny-r-1.8.0/index.html#new-shiny-look",
    "href": "blog/posts/shiny-r-1.8.0/index.html#new-shiny-look",
    "title": "Shiny for R updates: new default look, dark mode, shinylive updates, and more",
    "section": "A shiny new look",
    "text": "A shiny new look\nIn our last post, we previewed a new look for bslib-powered UIs, which is designed with dashboards in mind. This release of bslib adds more polish to this new ‚Äúpreset‚Äù theme and makes it the default for bslib powered UIs.\nTo use the new layouts, simply create an app using any page_*() function in bslib for the UI. Here‚Äôs a very simple template you can use to get started. Notice that we‚Äôve used shinylive to make this example interactive ‚Äì the entire app is running in your browser, no server required! You can even edit the app right here in this post and see the changes live when you press the  play button. We‚Äôll talk more about shinylive later in this post.\n\n#| standalone: true\n#| components: [editor, viewer]\n#| viewerHeight: 400\n#| layout: vertical\nlibrary(shiny)\nlibrary(bslib)\n\nui &lt;- page_sidebar(\n  title = \"My dashboard\",\n  sidebar = sidebar(\n    title = \"Settings\",\n    sliderInput(\"n\", \"Observations\", 1, 100, 50, ticks = FALSE),\n    sliderInput(\"bins\", \"Bins\", 1, 10, 5, step = 1, ticks = FALSE),\n  ),\n  plotOutput(\"plot\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$plot &lt;- renderPlot({\n    hist(rnorm(input$n), breaks = input$bins, col = \"#007bc2\")\n  })\n}\n\nshinyApp(ui, server)\n\nWe‚Äôre calling this new look the shiny ‚Äúpreset‚Äù theme, because it‚Äôs a great place to start building your own theme. Remember, you can always customize the preset by passing additional arguments to bs_theme(). You can even switch back to the default preset = \"bootstrap\" look by using the following theme value in your page_*() function1:\n\n# use default Bootstrap styles\ntheme = bs_theme(preset = \"bootstrap\")\n\nThe new shiny preset is designed with dashboards in mind. Here‚Äôs a more complete example using a full dashboard app (source, demo) for exploring flight data from Chicago. Toggle between the new and old look to see what‚Äôs changed with this release.\n\n  \n  \n\n      Old\n    \n    \n      New\n    \n  \n\n    \n      \n\n    \n      \n\n  \n  \n\nThe rest of this section will explore a few highlights of the new default look, including:\n\nNew page-level styling\n\nDark mode support\nImproved value_box() styling\n\n\nRefreshed Shiny UI (inputs, modals, notifications, and more)\n\n\n\n\n\n\n\nQuarto and PyShiny dashboards\n\n\n\nDashboards are coming to Quarto!\nThe new Quarto dashboard format, as well as newer PyShiny components, are built on the same foundation as bslib. Thus, the concepts you‚Äôll learn while building dashboards with bslib should also largely apply there as well.\n\n\nPage-level styling\nAs we noted above, the new shiny preset is design with dashboards in mind, but it will make any shiny app look great. The new default look is designed to be light and minimal, with a white navbar and white sidebar framing the dashboard area. Cards are also entirely white, with subtle depth created by drop shadows under the cards. Value boxes provide colorful accents, as will the plots you add to showcase your data.\nHere‚Äôs an example taken straight from the getting started guide for bslib dashboards.\n\n  \n  \n\n      Old\n    \n    \n      New\n    \n  \n\n    \n      \n\n    \n      \n\n  \n  \n\nTo achieve the full dashboard effect, though, you have opt into the light gray background by adding class = \"bslib-page-dashboard\" to your page_sidebar() or the nav_panel() items in your page_navbar(). This class enables a few additional features, namely adding a soft gray background to the main content area under cards and value boxes that help them stand out. You can also add the class directly to page_fillable() or page() to get the same effect in apps with custom layouts.\n\n  \n\n      page_sidebar()\n    \n    \n      page_navbar()\n    \n    \n      page_fillable()\n    \n  \n\n    \n      library(shiny)\nlibrary(bslib)\n\nui &lt;- page_sidebar(\n  title = \"My Dashboard\",\n  class = \"bslib-page-dashboard\",\n  sidebar = sidebar(\n    title = \"Settings\",\n    # ... sidebar inputs ...\n  ),\n  # ... dashboard content ...\n)\n    \n    \n      library(shiny)\nlibrary(bslib)\n\nui &lt;- page_navbar(\n  title = \"My Dashboard\",\n  nav_panel(\n    title = \"Page 1\",\n    class = \"bslib-page-dashboard\",\n    # ... dashboard content ...\n  ),\n  nav_panel(\"About\", \"Regular content\")\n)\n    \n    \n      library(shiny)\nlibrary(bslib)\n\nui &lt;- page_fillable(\n  title = \"My Dashboard\",\n  class = \"bslib-page-dashboard\",\n  # ... custom layout and dashboard content ...\n)\n    \n  \n\n\n\nbs_theme() still supports Bootswatch presets too, like preset = \"flatly\".‚Ü©Ô∏é\nBuilt-in dark mode support ‚òÄÔ∏è üåô\nThis release of bslib brings built-in dark mode support to any Shiny app that uses bs_theme(), thanks to Bootstrap 5.3‚Äôs new client-side color mode feature! To enable dark mode in your app, add input_dark_mode() somewhere in your UI. In the example below, we‚Äôve put in the navbar.\n\n  \n  \n\n      Light\n    \n    \n      Dark\n    \n  \n\n    \n      \n\n    \n      \n\n  \n  \n\nFor the best results, make sure you have the latest version of shiny. Dark mode works with nearly any Bootstrap theme created with bs_theme(), including the new shiny preset, but it tends to work best when the theme is designed around light mode first. For matching plots and widgets to the current color mode, you can use thematic to automatically style plots or shiny::getCurrentOutputInfo() to manually set the colors of your R outputs.\nBy default, the color mode is picked from the user‚Äôs system settings ‚Äì i.e.¬†choosing dark mode if their system is also in dark mode ‚Äì but you can choose the initial color mode via the mode argument. If you give input_dark_mode() an id, it reports the current color mode as either \"light\" or \"dark\".\n\nlibrary(shiny)\nlibrary(bslib)\n\nui &lt;- page_navbar(\n  title = \"Dashboard\",\n  nav_spacer(), # push nav items to the right\n  nav_panel(\"Page 1\", \"Dashboard content\"),\n  nav_item(\n    input_dark_mode(id = \"dark_mode\", mode = \"light\")\n  )\n)\n\nserver &lt;- function(input, output, server) {\n  observeEvent(input$dark_mode, {\n    if (input$dark_mode == \"dark\") {\n      showNotification(\"Welcome to the dark side!\")\n    }\n  })\n}\n\nshinyApp(ui, server)\n\nValue box styling\nThe new default look includes improved styling for value_box() outputs, which are commonly used in dashboards. We‚Äôre also excited to announce a new Build-a-Box app to help build and explore value boxes themes and options in a live Shiny app.\nUse the tabs below to learn more about several new features and themes supported by value_box().\n\n\nText\nIcons\nGradient\n\n\n\n\n  \n    \n\n\nShowcase Bottom with Text-Color Theme\nThe new showcase_layout = \"bottom\" option is perfect for sparkline-style plots that fill the value box width and expand into full screen plots when the user clicks the expand button (enabled by full_screen = TRUE). See the Expandable sparklines section of the value box article for an example of how to create these plots with plotly and bslib.\nThis example also highlights the text-{color} value box themes that set the color of the text to a Bootstrap color.\n\nlayout_columns(\n  value_box(\n    title = \"Engagement rate\",\n    value = \"3.8%\",\n    theme = \"text-indigo\",\n    showcase = plotOutput(\"plot_engagement\"),\n    showcase_layout = \"bottom\",\n    full_screen = TRUE\n  ),\n  value_box(\n    title = \"Project Funding\",\n    value = \"$2,805\",\n    theme = \"text-success\",\n    showcase = plotOutput(\"plot_funding\"),\n    showcase_layout = \"bottom\",\n    full_screen = TRUE\n  ),\n  value_box(\n    title = \"Employee satisfaction\",\n    value = \"92.3%\",\n    theme = \"text-blue\",\n    showcase = plotOutput(\"plot_satisfaction\"),\n    showcase_layout = \"bottom\",\n    full_screen = TRUE\n  )\n)\n\n\n\n\n\n  \n    \n\n\nShowcase Left Center with Gradient Icons\nThis example uses the default value box styles in the new shiny preset. Icons receive a subtle gradient and are placed to the left of the value box content thanks to the default showcase_layout = \"left center\".\n\nlayout_columns(\n  value_box(\n    title = \"API Response Time\",\n    value = \"150ms\",\n    showcase = bsicons::bs_icon(\"arrow-left-square-fill\")\n  ),\n  value_box(\n    title = \"Revenue growth\",\n    value = \"+15.2%\",\n    showcase = bsicons::bs_icon(\"arrow-up-circle-fill\")\n  ),\n  value_box(\n    title = \"Market share\",\n    value = \"42%\",\n    showcase = fontawesome::fa_i(\"magnifying-glass-dollar\")\n  )\n)\n\n\n\n\n\n  \n    \n\n\nShowcase Top Right with Gradient Backgrounds\nThis example uses theme = \"bg-gradient-{from}-{to}\" for value boxes with vibrant gradient backgrounds. You can use any of the Bootstrap color names for the from or to colors. showcase_layout = \"top right\" places the icon in the top right corner of the value box.\n\nlayout_columns(\n  value_box(\n    title = \"Average wait\",\n    value = \"4 minutes\",\n    theme = \"bg-gradient-purple-cyan\",\n    showcase = bsicons::bs_icon(\"stopwatch\"),\n    showcase_layout = \"top right\"\n  ),\n  value_box(\n    title = \"Customer churn\",\n    value = \"5%\",\n    theme = \"bg-gradient-orange-indigo\",\n    showcase = fontawesome::fa_i(\"tent-arrow-turn-left\"),\n    showcase_layout = \"top right\"\n  ),\n  value_box(\n    title = \"Daily Active Users\",\n    value = \"8,507\",\n    theme = \"bg-gradient-teal-purple\",\n    showcase = fontawesome::fa_i(\"arrow-up-right-dots\"),\n    showcase_layout = \"top right\"\n  )\n)\n\n\n\n\n\nRefreshed Shiny UI\nThe new default look includes a refreshed Shiny UI, which includes new styling for inputs, modals, notifications, and more.\n\n  \n\n      Inputs\n    \n    \n      Notifications\n    \n    \n      Progress Bars\n    \n    \n      Modals"
  },
  {
    "objectID": "blog/posts/shiny-r-1.8.0/index.html#shinylive-updates",
    "href": "blog/posts/shiny-r-1.8.0/index.html#shinylive-updates",
    "title": "Shiny for R updates: new default look, dark mode, shinylive updates, and more",
    "section": "Shinylive updates",
    "text": "Shinylive updates\nThanks to the exceptional work by George Stagg on webR in collaboration with the Shiny team, shinylive can now run Shiny applications entirely in a web browser, without the need for a separate server running R!\nWhile sharing a traditional Shiny app requires you to deploy the app to a server, such as shinyapps.io, shinylive allows you to share your app by simply sharing a URL or by embedding the shinylive app in a Quarto webpage. The app runs entirely in the browser, directly on the user‚Äôs device.\nWe‚Äôre please to announce several venues for writing and sharing Shiny apps via shinylive:\n\nshinylive.io/r contains a gallery of example Shiny apps that you can run in your browser. You can also use shinylive.io/r/editor as an online playground to write and share your own apps.\nThe shinylive R package is now on CRAN! This package helps you turn an existing Shiny app into a ready-to-share shinylive app.\nThe shinylive Quarto extension now supports both R and Python Shiny apps ‚Äì even on the same page! With the shinylive-r and shinylive-python code cells, you can embed Shiny apps directly in Quarto web documents. This is perfect for blog posts, like this one! See the example near the start of this post.\n\nwebR and shinylive are under active development, so expect ongoing updates and improvements. Currently, shinylive apps download packages from webR‚Äôs CRAN-like repository at run time, which adds a delay to the initial startup time. In the future, we hope to make this faster and to allow package installation from more sources. We‚Äôre also really excited that R-universe now builds WASM binaries for R packages!"
  },
  {
    "objectID": "blog/posts/shiny-r-1.8.0/index.html#selectize-js",
    "href": "blog/posts/shiny-r-1.8.0/index.html#selectize-js",
    "title": "Shiny for R updates: new default look, dark mode, shinylive updates, and more",
    "section": "Selectize.js update",
    "text": "Selectize.js update\nShiny‚Äôs selectInput() and selectizeInput() functions create dropdown menus that allow users to select one or more items from a list. These inputs are powered by the selectize.js library, and shiny 1.8.0 upgrades selectize.js from version 0.12.4 to 0.15.2.\nThis upgrade resolved a number of outstanding bugs and issues with selectizeInput() (as well as introducing some new ones that we had to squash before release). Most users won‚Äôt notice a difference in the select inputs ‚Äì now they‚Äôll just work better ‚Äì but if you do notice a change in behavior, please let use know by filing an issue.\nPower users will find even more selectize.js options now available, including more plugins. We highly recommend trying both the clear_button and remove_button plugins to give users a clear visual cue for removing options:\n\n\n\n\nlibrary(shiny)\nlibrary(bslib)\n\nui &lt;- page_fixed(\n    selectizeInput(\n        \"single\", \"Single select\", state.name,\n        options = list(plugins = \"clear_button\")\n    ),\n    selectizeInput(\n        \"multiple\", \"Multiple select\", state.name,\n        multiple = TRUE,\n        options = list(plugins = \"remove_button\")\n    )\n)\n\nserver &lt;- function(input, output, session) {\n\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "blog/posts/shiny-r-1.8.0/index.html#release-notes",
    "href": "blog/posts/shiny-r-1.8.0/index.html#release-notes",
    "title": "Shiny for R updates: new default look, dark mode, shinylive updates, and more",
    "section": "Release notes",
    "text": "Release notes\nThis post doesn‚Äôt cover all of the changes and updates that happened in the Shiny universe in this release cycle. To learn more about specific changes in each package, dive into the release notes linked below!\nBig shout out to everyone involved! üíô We‚Äôd want to extend a huge thank you to everyone who contributed pull requests, bug reports and feature requests. Your contributions make Shiny brilliant!\nbslib v0.6.0\n\n@antoine4ucsd, @awcm0n, @barnesparker, @cpsievert, @ctrlxctrlc, @daattali, @DavZim, @durraniu, @gadenbuie, @gsmolinski, @jcheng5, @jmbarbone, @JohnCoene, @kelly-sovacool, @lmullany, @m-austen, @MayaGans, @mhanf, @ncullen93, @ngoodkindGSI, @oude-gao, @schloerke, @scrapeable, @tuge98, and @wch.\nbsicons v0.1.2\n\n@cpsievert.\ncrosstalk v1.2.1\n\n@cpsievert, @ctedja, @daattali, @danielludolf, @DataStrategist, @dmresearch15, @gadenbuie, @helgasoft, @hlydecker, @JacobBraslaw22, @jcheng5, @jonathanmburns, @jonspring, @LDSamson, @MichaelChirico, @mmfc, @novotny1akub, @oobd, @pfh, @schloerke, @tbrittoborges, @ThierryO, @tomsing1, @ulyngs, @warnes, @yb2125, and @yogat3ch.\nhistoslider v0.1.1\n\n@cpsievert.\nhtmltools v0.5.7\n\n@bjcarothers, @cpsievert, @gadenbuie, @HenningLorenzen-ext-bayer, @mgirlich, and @stla.\nhtmlwidgets v1.6.3\n\n@barracuda156, @cpsievert, @DavisVaughan, @dmurdoch, @gadenbuie, @pietrodito, and @yihui.\nhttpuv v1.6.12\n\n@Camilo-Mora, @gadenbuie, @jcheng5, @jeroen, @nealrichardson, and @wfulp.\nleaflet.providers v2.0.0\n\n@gadenbuie, @schloerke, and @SimonGoring.\nleaflet v2.2.1\n\n@barracuda156, @Bryan1qr, @gadenbuie, @gtalavera, @jmelichar, @mjdzr, and @PietrH.\nlearnr v0.11.4\n\n@davidkane9, @gadenbuie, @jimjam-slam, @katieravenwood, and @NaturallyAsh.\nplotly v4.10.3\n\n@AdroMine, @AlexisDerumigny, @Apompetti-Cori, @cashfields, @cpsievert, @CristianRiccio, @davidhodge931, @DrMattG, @geejaytee, @jacole3, @jrbarber37, @lennartraman, @LouisLeNezet, @MichalLauer, @mjdzr, @mumbarkar, @Obsidian-user, @olivroy, @OverLordGoldDragon, @rsbivand, @stephanmg, @stla, @TheAnalyticalEdge, @ThierryO, @tomasnobrega, @tvedebrink, @uriahf, @whitejf, @wholmes105, @wmay, @yogat3ch, and @zeehio.\nshiny v1.8.0\n\n@avsdev-cw, @bathyscapher, @chlebowa, @cpsievert, @deining, @flachboard, @gadenbuie, @jcheng5, @karangattu, @nstrayer, @wbakerrobinson, and @wch.\nshinyvalidate v0.1.3\n\n@BajczA475, @bhogan-mitre, @chlebowa, @cleber-n-borges, @cpsievert, @dependabot[bot], @DivadNojnarg, @doncqueurs, @Sebastian-T-T, @stefanoborini, @stephenwilliams22, @Teebusch, and @Wezz0234.\nthematic 0.1.4\n\n@AlbertRapp, @cpsievert, and @jfulponi."
  },
  {
    "objectID": "blog/posts/shiny-r-1.8.1/index.html",
    "href": "blog/posts/shiny-r-1.8.1/index.html",
    "title": "Shiny for R updates: Extended tasks, JavaScript errors, and many bslib improvements",
    "section": "",
    "text": "The Shiny team is delighted to announce another round of updates for 9 different R packages. In this post, we‚Äôll introduce three notable things: non-blocking operations, a JavaScript error dialog and many bslib improvements. For a detailed list of changes, be sure to check out the release notes section of this post.\nAlthough 9 packages received updates, the focus of this post is on shiny and bslib, which you can install with the following command:\ninstall.packages(c(\"shiny\", \"bslib\"))"
  },
  {
    "objectID": "blog/posts/shiny-r-1.8.1/index.html#nonblocking",
    "href": "blog/posts/shiny-r-1.8.1/index.html#nonblocking",
    "title": "Shiny for R updates: Extended tasks, JavaScript errors, and many bslib improvements",
    "section": "Non-blocking operations",
    "text": "Non-blocking operations\nThe biggest new feature in this release is the ability to run truly non-blocking operations in Shiny via ExtendedTask.\nThe promise of async programming\nFor years, we‚Äôve promoted asynchronous programming with the promises package as a way to improve the performance of large Shiny apps. promises can be used to prevent operations in one user session from blocking operations in another user‚Äôs session, helping scale your app to multiple concurrent users supported by a single R process.\nHowever, promises alone won‚Äôt prevent an operation in one session from blocking other operations in that same session.\nIntroducing ExtendedTask\nWe‚Äôre introducing ExtendedTask as a new way to manage long-running operations that won‚Äôt block within or across sessions, meaning that a user can launch an ExtendedTask and still interact with the app while it‚Äôs running.\nAdditionally, we‚Äôve found that ExtendedTask provides an elegant way to manage async operations. Within the task, you‚Äôll use promises to create the async operation, but in the rest of your app you can use ExtendedTask methods to start the task or react to results when they arrive.\nAs a result, ExtendedTask is now our recommended starting point for non-blocking tasks in Shiny. We‚Äôd love to show you a full example right now, but for the sake of space in this blog post we‚Äôll urge you to visit the Non-blocking operations article, also on this blog, for a complete introduction.\nA new task button\nAs a companion to ExtendedTask, we‚Äôve created bslib::input_task_button(), a special button that displays visual feedback when a task is in progress. As it turns out, input_task_button() provides a nice experience for any long-running task, not just ExtendedTask. Think of it like an actionButton() that, when clicked, shows a busy indicator (and prevents further clicks) up until the next time the server is idle. Here‚Äôs an example of it in action in a basic Shiny app:\nlibrary(shiny)\nlibrary(bslib)\n\nui &lt;- page_fixed(\n  input_task_button(\"launch_task\", \"Launch task\"),\n  textOutput(\"result\")\n)\n\nserver &lt;- function(input, output) {\n\n  output$result &lt;- renderText({\n    req(input$launch_task)     # require a button press to launch\n\n    Sys.sleep(3)               # simulate expensive operation\n    paste(\"Number of clicks:\", input$launch_task)\n  })\n\n}\n\nshinyApp(ui, server)\n\n\nThe task button showing a busy indication while the result is still processing"
  },
  {
    "objectID": "blog/posts/shiny-r-1.8.1/index.html#js-errors",
    "href": "blog/posts/shiny-r-1.8.1/index.html#js-errors",
    "title": "Shiny for R updates: Extended tasks, JavaScript errors, and many bslib improvements",
    "section": "JS error dialog",
    "text": "JS error dialog\nAnother exciting new feature is Shiny‚Äôs JavaScript error dialog, which makes critical client-side errors more discoverable. To use the error dialog, turn on Shiny‚Äôs developer features by calling shiny::devmode() before running your app locally1.\nIn addition to the dialog, we‚Äôve also started throwing more errors in situations where behavior is undefined, such as when two inputs (or outputs) have the same ID. For example:\nlibrary(shiny)\nlibrary(bslib)\n\nui &lt;- page_fixed(\n  textInput(\"x\", NULL),\n  textInput(\"x\", NULL)\n)\n\nshinyApp(ui, \\(...) {})\n\n\nThe error dialog displaying the duplicate IDs error\n\n\n\n\nRead more about shiny devmode in our docs. If you‚Äôd like to turn on dev mode for all of your local interactive session, you can add the following snippet your .Rprofile either in your home directory or your project directory (use usethis::edit_r_profile() to open either):\nif (interactive() && requireNamespace(\"shiny\", quietly = TRUE)) {\n  shiny::devmode()\n}\n‚Ü©Ô∏é"
  },
  {
    "objectID": "blog/posts/shiny-r-1.8.1/index.html#bslib",
    "href": "blog/posts/shiny-r-1.8.1/index.html#bslib",
    "title": "Shiny for R updates: Extended tasks, JavaScript errors, and many bslib improvements",
    "section": "bslib improvements",
    "text": "bslib improvements\nIn addition to the new input_task_button(), bslib received many improvements and fixes in this release. Most of these improvements are focused on sidebar()s, cards()s, layout_columns()s, and the default bs_theme().\nTo highlight a new feature, card() now reports its full_screen state to the server, which can be useful for various things like providing more context in a full-screen view. Just give the card an id and read input${id}_full_screen in the server, replacing {id} with the actual id value of your card.\n\n\nAn expandable card that shows some additional text when it goes full screen.\n\n\nCodelibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\n\nui &lt;- page_fixed(\n  card(\n    full_screen = TRUE,\n    id = \"my_card\",\n    card_header(\"My plot\"),\n    # fill ensures the plot fills when full_screen\n    uiOutput(\"visual\", fill = TRUE)\n  )\n)\n\nserver &lt;- function(input, output, session) {\n\n  output$visual &lt;- renderUI({\n    plot &lt;- plotOutput(\"plot\")\n\n    if (isTRUE(input$my_card_full_screen)) {\n      # In full screen mode, show the plot plus some additional text\n      layout_columns(\n        plot,\n        lorem::ipsum(2),\n        col_widths = c(8, 4)\n      )\n    } else {\n      # otherwise, just show the plot\n      plot\n    }\n  })\n\n  output$plot &lt;- renderPlot({\n    ggplot(mtcars, aes(mpg, wt)) +\n      geom_point() +\n      theme_minimal(base_size = 20)\n  })\n\n}\n\nshinyApp(ui, server)"
  },
  {
    "objectID": "blog/posts/shiny-r-1.8.1/index.html#release-notes",
    "href": "blog/posts/shiny-r-1.8.1/index.html#release-notes",
    "title": "Shiny for R updates: Extended tasks, JavaScript errors, and many bslib improvements",
    "section": "Release notes",
    "text": "Release notes\nThis post doesn‚Äôt cover all of the changes and updates that happened in the Shiny universe in this release cycle. To learn more about specific changes in each package, dive into the release notes linked below!\nBig shout out to everyone involved! üíô We‚Äôd want to extend a huge thank you to everyone who contributed pull requests, bug reports and feature requests. Your contributions make Shiny brilliant!\nbslib v0.7.0\n\n@benubah, @CIOData, @clementlefevre, @cpsievert, @Damonsoul, @davemcg, @davos-i, @gadenbuie, @howardbaek, @ideusoes, @jcheng5, @kalimu, @lukebandy, @malcolmbarrett, @Milko-B, @ocstringham, @rickhelmus, @royfrancis, @stla, @tai-mi, @tanho63, @toxintoxin, @TymekDev, @udurraniAtPresage, @WickM, @wish1832, and @zross.\nhtmltools v0.5.8\n\n@cpsievert, @Emanuel-1986, @gadenbuie, @olivroy, @romainfrancois, and @russHyde.\nhttpuv v1.6.12\n\n@cpsievert, @gadenbuie, and @nunotexbsd.\nleaflet v2.2.2\n\n@ainefairbrother, @amegbor, @asitemade4u, @bmaitner, @cderv, @cpsievert, @gadenbuie, @jebyrnes, @mkoohafkan, @olivroy, @olyerickson, @SpeckledJim2, and @yoelii.\nplotly v4.10.4\n\n@AdroMine, @AlexisDerumigny, @aloboa, @aniskara, @Balaika, @baranovskypd, @brennanfalcy, @Brishan200, @byandell, @cpsievert, @dgrignol, @dvg-p4, @FunctionalUrology, @jeffandcyrus, @Jensxy, @JinTonique, @KarlKaise, @KatChampion, @lukelockley, @meldarionqeusse, @morrisseyj, @mot12341234, @msgoussi, @nlooije, @noamross, @olivroy, @OverLordGoldDragon, @peter-atkinson, @salim-b, @syeddans, @TheAnalyticalEdge, @tomasnobrega, and @TopBottomTau.\nplumber v1.2.2\n\n@alexverse, @apalacio9502, @apriandito, @ArcadeAntics, @aronatkins, @BioTimHaley, @ColinFay, @cpsievert, @edavidaja, @enriquecaballero, @ex0ticOne, @feodosiikraft, @fmalk, @GraphZal, @hedsnz, @howardbaek, @ihamod, @jangorecki, @jasonheffner, @jonthegeek, @jpdugo, @jwebbsoma, @king-of-poppk, @m-muecke, @meztez, @MJSchut, @mmuurr, @pietervosnl, @pinduzera, @r2evans, @schloerke, @sdgd165, @slodge, @slodge-work, @statasaurus, @timeddilation, @tylerlittlefield, and @wikithink.\nsass v0.4.9\n\n@cpsievert, @jeroen, and @yulric.\nshiny v1.8.1\n\n@apalacio9502, @Arthfael, @avoidaway, @bioinformzhang, @chendaniely, @cpsievert, @Daishoulu, @davidmacro, @etbrand, @gadenbuie, @gunawebs, @hadley, @HugoGit39, @ismirsehregal, @jcheng5, @JohnCoene, @jsendak, @laresbernardo, @MartinBaumga, @nstrayer, @olivroy, @Roleren, @RSchwinn, @saleforecast1, @sharitian, @skaltman, @stla, @trafficonese, @TymekDev, @ugurdar, and @wch.\nthematic v0.1.5\n\n@cpsievert, and @teunbrand."
  },
  {
    "objectID": "blog/posts/shiny-vscode-1.0.0/index.html",
    "href": "blog/posts/shiny-vscode-1.0.0/index.html",
    "title": "Reintroducing the Shiny Extension for VS¬†Code",
    "section": "",
    "text": "When we introduced the Shiny for Python VS Code extension, its name made a lot of sense: the extension helped Shiny for Python developers run their apps in VS Code. But with the latest v1.0.0 release, we‚Äôve expanded the extension to support running Shiny for R apps ‚Äì as well as a few new features for moving between local files and ShinyLive links ‚Äì and we wanted a name that reflected that. In this post, we‚Äôll talk through the new features and show you how to use them."
  },
  {
    "objectID": "blog/posts/shiny-vscode-1.0.0/index.html#installing-the-shiny-extension",
    "href": "blog/posts/shiny-vscode-1.0.0/index.html#installing-the-shiny-extension",
    "title": "Reintroducing the Shiny Extension for VS¬†Code",
    "section": "Installing the Shiny extension",
    "text": "Installing the Shiny extension\n\n\n\n\n\nIf you‚Äôre a new Shiny + VS Code user, you can install the extension from the VS Code Marketplace or the Open VSX Registry, or by searching for ‚ÄúShiny‚Äù in the Extensions view in VS Code. Be sure to avoid the extension named ‚ÄúShiny (deprecated)‚Äù üòâ\nIf you‚Äôre already using the Shiny for Python extension, you can simply update the old extension to kick off a seamless transition in which the new extension will be automatically installed. Once installed, the new extension will prompt you to uninstall the older version."
  },
  {
    "objectID": "blog/posts/shiny-vscode-1.0.0/index.html#shiny-for-r-support",
    "href": "blog/posts/shiny-vscode-1.0.0/index.html#shiny-for-r-support",
    "title": "Reintroducing the Shiny Extension for VS¬†Code",
    "section": "Shiny for R Support",
    "text": "Shiny for R Support\nWith the Shiny extension installed, whenever you open an app.R file ‚Äî or another appropriately named Shiny for R app file1 ‚Äî the editor‚Äôs play button () becomes a ‚ÄúRun Shiny App‚Äù button. Clicking the  starts your app in a new terminal session and even enables Shiny‚Äôs developer mode for a better local development experience, including automatically restarting your app when you update and save the app‚Äôs source files2."
  },
  {
    "objectID": "blog/posts/shiny-vscode-1.0.0/index.html#shinylive",
    "href": "blog/posts/shiny-vscode-1.0.0/index.html#shinylive",
    "title": "Reintroducing the Shiny Extension for VS¬†Code",
    "section": "ShinyLive",
    "text": "ShinyLive\nShinyLive is a free service for sharing Shiny apps via static hosting, where Shiny apps run entirely in the browser without the need for a server. Head to shinylive.io/py or shinylive.io/r to get started with the language of your choice. When your app is ready, share the ShinyLive link with others for instant deployment!\nWhile ShinyLive features an online editor (for R or Python), sometimes you might want to create a ShinyLive link from files you‚Äôre editing in your IDE. The Shiny extension now gives you two ways to do this.\n\nCreate a ShinyLive link from the active file\nFor single-file apps, run the Create ShinyLive Link from Active File from the command palette with an app.py or app.R open and active in the editor.\n\n\n  \n  \n\n\n\n\nCreate a ShinyLive link from multiple files\nFor multi-file apps, select all of the files or directories you want to include in your ShinyLive app in the Explorer pane. Then right click on the selection and choose Create ShinyLive Link from Selected Files.\n\n\n  \n  \n\n\nAfter picking your file(s) for the ShinyLive link, the Shiny extension will ask you which app mode you want to use (display the app or show an editor next to the app) and what action to take (to open or copy the link). You can also configure these options in the extension settings.\n\n\nSave the app from a ShinyLive link\nYou can also create local files from a ShinyLive link using the Save App from ShinyLive Link command in the command palette. You‚Äôll be prompted to paste the ShinyLive link and then to choose where the app will be saved in your workspace."
  },
  {
    "objectID": "blog/posts/shiny-vscode-1.0.0/index.html#new-snippets-and-settings",
    "href": "blog/posts/shiny-vscode-1.0.0/index.html#new-snippets-and-settings",
    "title": "Reintroducing the Shiny Extension for VS¬†Code",
    "section": "New snippets and settings",
    "text": "New snippets and settings\nSnippets in VS Code are templates of reusable code accessible via the Insert snippet command in the Command Palette or as a tab-completion when you type out the snippet trigger text. The Shiny extension includes three text snippets to help you quickly create a Shiny app or Shiny module:\n\nshinyapp creates a new Shiny application template\nshinymod creates a new Shiny module template\nshinyexpress creates a new Shiny Express app template (in Python)\n\nWe‚Äôve also expanded the settings available to the Shiny extension. Most notably, the added shiny.previewType setting determines whether the app preview is opened inside VS Code (internal), in an external browser, or not at all (none). A number of ShinyLive settings allow you to choose default values to speed up link creation. The full list of extension settings are available in the extension page in VS Code or in the extension repository."
  },
  {
    "objectID": "blog/posts/shiny-vscode-1.0.0/index.html#thanks",
    "href": "blog/posts/shiny-vscode-1.0.0/index.html#thanks",
    "title": "Reintroducing the Shiny Extension for VS¬†Code",
    "section": "Thanks!",
    "text": "Thanks!\nThank you for trying out the Shiny extension for VS Code! If you find it helpful, please rate the extension on the marketplace or the open-vsx registry."
  },
  {
    "objectID": "blog/posts/shiny-vscode-1.0.0/index.html#footnotes",
    "href": "blog/posts/shiny-vscode-1.0.0/index.html#footnotes",
    "title": "Reintroducing the Shiny Extension for VS¬†Code",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nA valid Shiny for R app is an R file that includes the word ‚Äúshiny‚Äù in its contents and is named app.R, ui.R, server.R, or has a name that starts or ends with app.‚Ü©Ô∏é\nDeveloper mode enables a few Shiny options that improve the local development experience and can be turned on at the R console by calling shiny::devmode(). Notable among these options is setting options(shiny.autoreload = TRUE) to automatically reload the app whenever its source files change. An extension setting can be used to disable devmode.‚Ü©Ô∏é"
  },
  {
    "objectID": "r/articles/improve/nonblocking/index.html",
    "href": "r/articles/improve/nonblocking/index.html",
    "title": "Non-blocking operations",
    "section": "",
    "text": "Sometimes in a Shiny app, you need to perform a long-running operation, like loading a large dataset or doing an expensive computation. If you do this in a reactive context, it will block the rest of the application from running until the operation completes. This can be frustrating for users, who may think that the app has crashed.\nWorse, if you have multiple users, then one user‚Äôs long-running operation will block the other users‚Äô apps from running as well. These other users will not even be aware that their slow performance is due to another user‚Äôs actions.\nIn this article, you‚Äôll learn how you can keep your Shiny apps responsive in the face of these long operations, by using the Extended Task feature.",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Non-blocking operations"
    ]
  },
  {
    "objectID": "r/articles/improve/nonblocking/index.html#a-blocking-app-example",
    "href": "r/articles/improve/nonblocking/index.html#a-blocking-app-example",
    "title": "Non-blocking operations",
    "section": "A blocking app example",
    "text": "A blocking app example\nIn the app below, the first thing in the UI is a reactive output that displays the current time. Click the button and notice that, during the five seconds that the app is waiting for the (artificially slow) sum calculation to complete, the time does not update.\n\n\n\n\nlibrary(shiny)\nlibrary(bslib)\n\nui &lt;- page_fluid(\n  p(\"The time is \", textOutput(\"current_time\", inline=TRUE)),\n  hr(),\n  numericInput(\"x\", \"x\", value = 1),\n  numericInput(\"y\", \"y\", value = 2),\n  input_task_button(\"btn\", \"Add numbers\"),\n  textOutput(\"sum\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$current_time &lt;- renderText({\n    invalidateLater(1000)\n    format(Sys.time(), \"%H:%M:%S %p\")\n  })\n\n  sum_values &lt;- eventReactive(input$btn, {\n    Sys.sleep(5)\n    input$x + input$y\n  })\n\n  output$sum &lt;- renderText({\n    sum_values()\n  })\n}\n\nshinyApp(ui, server)\nIn this app, the sum_values reactive expression is where the slow work is done. Pressing the button causes the sum_values reactive expression to run, and the app will be unresponsive until it completes. You can see that the current time stops updating for five seconds.",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Non-blocking operations"
    ]
  },
  {
    "objectID": "r/articles/improve/nonblocking/index.html#adding-extendedtask",
    "href": "r/articles/improve/nonblocking/index.html#adding-extendedtask",
    "title": "Non-blocking operations",
    "section": "Adding ExtendedTask",
    "text": "Adding ExtendedTask\nNow we‚Äôll adapt the example to use an ExtendedTask instead of a reactive expression. Click the button, and you‚Äôll notice that the time continues to update every second, even while the sum is being calculated.\n\n\n\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(future)\nlibrary(promises)\nfuture::plan(multisession)\n\nui &lt;- page_fluid(\n  p(\"The time is \", textOutput(\"current_time\", inline=TRUE)),\n  hr(),\n  numericInput(\"x\", \"x\", value = 1),\n  numericInput(\"y\", \"y\", value = 2),\n  input_task_button(\"btn\", \"Add numbers\"),\n  textOutput(\"sum\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$current_time &lt;- renderText({\n    invalidateLater(1000)\n    format(Sys.time(), \"%H:%M:%S %p\")\n  })\n\n  sum_values &lt;- ExtendedTask$new(function(x, y) {\n    future_promise({\n      Sys.sleep(5)\n      x + y\n    })\n  }) |&gt; bind_task_button(\"btn\")\n\n  observeEvent(input$btn, {\n    sum_values$invoke(input$x, input$y)\n  })\n\n  output$sum &lt;- renderText({\n    sum_values$result()\n  })\n}\n\nshinyApp(ui, server)\nThe slow logic used to be part of an eventReactive, and now it‚Äôs been moved to an ExtendedTask object. The code looks not too different from the original, but something very different is now happening under the hood.\nFirst, this slow code is no longer running in the same R process as the rest of the Shiny app‚Äìit‚Äôs running in a separate R process, thanks to the future_promise() call that wraps the slow code. (If you haven‚Äôt heard of the future package, it‚Äôs a convenient way to run R code in the background, in separate R processes. Note the call to future::plan(multisession) at the top‚Äìthis is essential future configuration that tells the future package to use multiple R processes.)\nSecond, the slow code is no longer running in a reactive context. Rather than being run inside of a reactive context (eventReactive in this case, but it could‚Äôve been observeEvent, reactive, or a renderXXX, etc.) the ExtendedTask object is specifically designed to run outside of the reactive graph. This extremely important detail is why the rest of the app can remain responsive while the slow code is running‚Äìthe reactive graph can quickly go back to being idle while the ExtendedTask object manages the running of the code.\nThere are certain rules you need to know when using ExtendedTask.",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Non-blocking operations"
    ]
  },
  {
    "objectID": "r/articles/improve/nonblocking/index.html#creating-an-extendedtask-object",
    "href": "r/articles/improve/nonblocking/index.html#creating-an-extendedtask-object",
    "title": "Non-blocking operations",
    "section": "Creating an ExtendedTask object",
    "text": "Creating an ExtendedTask object\nWhen creating the ExtendedTask object, you pass in a function that takes the inputs to the task as arguments. In this function, it‚Äôs your responsibility to run the long-running task in a non-blocking way; if you simply put blocking code in this function, you won‚Äôt get the benefits of ExtendedTask. The most common way to do this is to wrap the slow code in a future_promise({...}) call, as shown in the example above. (See the two articles on the promises website about future and future_promise for more details. But technically, you can use any method you like to run the code in a non-blocking way‚Äìas long as you return a promise object from this function.\nYou can have setup code in this function that runs outside of a future, but keep in mind that this code will run in the main R process, and will block the rest of the app from running‚Äìso try to minimize how much work you do here.\nIn the body of the function you pass to ExtendedTask, you cannot directly read reactive inputs, reactive values, reactive expressions, or any other reactive objects. (And Shiny goes out of its way to remind you if you forget: if you try, you‚Äôll get an error.) Because this code is executing outside of the reactive graph, those values could be changing while the code is running, and that would make it impossible to reason about the behavior of the code. Instead, any values you need to perform the extended task should be declared as parameters on the function (x and y in this example), and passed in when you call the invoke method (sum_values$invoke(input$x, input$y)). In this way, those values are snapshotted at the time of the call, while it‚Äôs still safe to access reactive values.\nIt‚Äôs also worth noting where the extended task object is declared: it‚Äôs declared at the top level of the server function (not the top level of the app.R file), outside of any reactive context. By putting it at the top level of the server function, it‚Äôs created once per Shiny session; it ‚Äúbelongs‚Äù to an individual visitor to the app, and is not shared across visitors.1",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Non-blocking operations"
    ]
  },
  {
    "objectID": "r/articles/improve/nonblocking/index.html#binding-to-a-task-button",
    "href": "r/articles/improve/nonblocking/index.html#binding-to-a-task-button",
    "title": "Non-blocking operations",
    "section": "Binding to a task button",
    "text": "Binding to a task button\nBefore assigning the ExtendedTask object to the sum_values variable name, the example above uses the bind_task_button method to bind the task to the btn input. This is an important step whenever you use a bslib::input_task_button to invoke an ExtendedTask object, as it synchronizes the two objects so the button can give a ‚ÄúProcessing‚Ä¶‚Äù visual cue while the task is running.\nIf you use some other UI gesture or condition besides bslib::input_task_button to invoke the task, don‚Äôt bother including the bind_task_button method‚Äìit doesn‚Äôt work with shiny::actionButton, for example.",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Non-blocking operations"
    ]
  },
  {
    "objectID": "r/articles/improve/nonblocking/index.html#invoking-the-task",
    "href": "r/articles/improve/nonblocking/index.html#invoking-the-task",
    "title": "Non-blocking operations",
    "section": "Invoking the task",
    "text": "Invoking the task\nUnlike reactive or eventReactive, an ExtendedTask object does not automatically run when you try to access its results for the first time. Instead, you need to explicitly call its invoke method, passing in the inputs to the task. Most commonly, you‚Äôll call invoke from an observeEvent tied to some kind of user action, like a button click, as is the case in our example.\nIf necessary, you can call invoke on an ExtendedTask object that‚Äôs already running, and it will queue up the new invocation to run when any previous invocations are done. (If you were hoping for a way to run the same long-running task multiple times concurrently, we‚Äôd love to hear your use case‚Äìplease file a GitHub issue telling us what you‚Äôre trying to do.)\nRemember that whatever parameters are expected by the ExtendedTask object‚Äôs function should be passed to invoke as arguments. These arguments will be eagerly evaluated at the time of the invoke call.",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Non-blocking operations"
    ]
  },
  {
    "objectID": "r/articles/improve/nonblocking/index.html#retrieving-results",
    "href": "r/articles/improve/nonblocking/index.html#retrieving-results",
    "title": "Non-blocking operations",
    "section": "Retrieving results",
    "text": "Retrieving results\nThe ExtendedTask object has a result method that you can call to get the result of the task. This is the most subtle and interesting aspect of ExtendedTask, as it serves as the bridge back from the background task to the realm of reactive programming.\nHere‚Äôs how it‚Äôs used above:\noutput$sum &lt;- renderText({\n  sum_values$result()\n})\nThe sum output is a regular renderText, which reads sum_values$result() to get the result of the extended task. This output actually does not ‚Äúwait for‚Äù the extended task to complete, exactly; instead, it will run multiple times, as the extended task goes through different states. For each state, sum_values$result() will behave differently:\n\nNot yet invoked: Raises a silent exception, which will cause the sum output to display nothing.\nRunning: Raises a special type of exception that tells Shiny to put the output in the ‚Äúin progress‚Äù state.\nSuccessfully completed: Returns the return value of the ExtendedTask object‚Äôs function. This is not a promise object, but the actual value that the promise resolved to.\nCompleted with an exception: If the ExtendedTask object‚Äôs function raised an exception while processing, then re-raises that same exception, causing it to be displayed to the user in the sum output.\n\nIt‚Äôs not necessary to memorize these states. Just remember that sum_values$result() is a reactive, synchronous method that knows how to do right thing based on the state of the extended task, and will trigger a reactive invalidation whenever the task‚Äôs state changes.",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Non-blocking operations"
    ]
  },
  {
    "objectID": "r/articles/improve/nonblocking/index.html#multiple-invocations",
    "href": "r/articles/improve/nonblocking/index.html#multiple-invocations",
    "title": "Non-blocking operations",
    "section": "Multiple invocations",
    "text": "Multiple invocations\nAn extended task can run concurrently to reactive code and to other extended tasks; that‚Äôs its whole purpose. However, a single extended task object cannot run itself multiple times concurrently. If you call sum_values$invoke() while it is already running, it will enqueue the new invocation and run it after the first one completes.\nThis is often not the behavior you want, especially if the task takes a long time to complete. A user may accidentally click an action button twice, or they may click it again because they think the first click didn‚Äôt work. To prevent this, use bslib::input_action_button instead of shiny::actionButton to invoke the task, since the former automatically prevents subsequent clicks until the task completes.",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Non-blocking operations"
    ]
  },
  {
    "objectID": "r/articles/improve/nonblocking/index.html#summary",
    "href": "r/articles/improve/nonblocking/index.html#summary",
    "title": "Non-blocking operations",
    "section": "Summary",
    "text": "Summary\nTo achieve non-blocking behavior in Shiny applications, factor your slow code into an ExtendedTask object and wrap it with future_promise({...}). Take out any reactive reads and turn those into parameters. Then call its $invoke() method from a reactive effect, and read its result() method from a render function or reactive expression.",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Non-blocking operations"
    ]
  },
  {
    "objectID": "r/articles/improve/nonblocking/index.html#footnotes",
    "href": "r/articles/improve/nonblocking/index.html#footnotes",
    "title": "Non-blocking operations",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nIt‚Äôs conceivable that you might want to share an extended task across all visitors, so anyone can invoke it and everyone can see the results‚Äìif that‚Äôs the case, you‚Äôd declare it at the top level of the app.R file, outside of any function.‚Ü©Ô∏é",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Non-blocking operations"
    ]
  },
  {
    "objectID": "r/articles/build/js-introjs/index.html#introduction",
    "href": "r/articles/build/js-introjs/index.html#introduction",
    "title": "How to develop an interactive, dynamic help system for your app with introJS",
    "section": "Introduction",
    "text": "Introduction\nIn the previous tutorials, we focused on using JavaScript to create htmlwidgets based on C3. To do this, we used three pivotal functions:\n\nthe R function sendCustomMessage, which you can call via the session object, i.e session$sendCustomMessage\nthe JavaScript function Shiny.onInputChange\nthe JavaScript function Shiny.addCustomMessageHandler.\n\nIn this tutorial, we will show you how to use the same functions to create a dynamic interactive help system for Shiny apps, based on the JavaScript library introJS.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to develop an interactive, dynamic help system for your app with introJS"
    ]
  },
  {
    "objectID": "r/articles/build/js-introjs/index.html#intro.js-basics-and-jsfiddle",
    "href": "r/articles/build/js-introjs/index.html#intro.js-basics-and-jsfiddle",
    "title": "How to develop an interactive, dynamic help system for your app with introJS",
    "section": "Intro.js basics and jsFiddle",
    "text": "Intro.js basics and jsFiddle\nIntroJS lets you create a step-by-step guide for a website. It will draw a nice box around elements of your choice, combined with an annotation layer and a navigation system.\nUsing introJS in a piece of HTML code is very simple. Let‚Äôs first set up a jsFiddle example that uses a bootstrap grid of 3 rows, with 3 columns each. In addition, let‚Äôs add a button that you can click to activate introJS. Click the green start button in the example below to see introJS in action.\n\n\n\npress the green start button to activate introJS\n\n We can add introJS to the app in three steps, described in detail here:\n\nInclude introjs.css and intro.js with your page.\nFor each element in the tour, add a data-intro, a data-position, and an optional data-step attribute.  These respectively specify the display text, the position of the box displayed by introJS, and the step number of the tour.\nIn order to start the tour, in JavaScript, call introJs().start();.\n\nIn the HTML tab of our fiddle, we see that the first row is created via:\n&lt;div class=\"row\"&gt;\n  &lt;div class=\"col-sm-4 well\" data-step=\"1\" data-intro=\"text step 1\" data-position='bottom'&gt;element 1&lt;/div&gt;\n  &lt;div class=\"col-sm-4 well\" data-step=\"2\" data-intro=\"text step 2\" data-position='bottom'&gt;element 2&lt;/div&gt;\n  &lt;div class=\"col-sm-4 well\" data-step=\"3\" data-intro=\"text step 3\" data-position='bottom'&gt;element 3&lt;/div&gt;\n&lt;/div&gt;\nThe classes row, col-sm-4, and well are all bootstrap classes, which define the grid layout. Bootstrap is the most popular HTML, CSS, and JavaScript framework for developing responsive, mobile first projects on the web. For some inspiration, see these examples. For more complete use cases, see these templates.\nOf note, many layout functions in Shiny are directly based on bootstrap. For instance, in a Shiny context the R code snippet:\nfluidRow(\n  column(4,\"element 1\")\n)\nproduces an output that resembles row 1 in our example (but without the introJS attributes and well classes).\nComing back to introJS, from the HTML code in the example above we see that it is quite easy to add the data-step, data-intro and data-position attributes.\nNext, in the JavaScript tab of our fiddle, we‚Äôve attached an event handler to our button using jQuery (see also tutorial 3). Here we use the event handler to start introJS on a button click, i.e.¬†via the JavaScript code:\n$(\"button\").on(\"click\", function(){\n    introJs().start();\n})\nIn the CSS tab of our jsFiddle, we‚Äôve set some styling options to center the button and the text in the example. In the CSS definitions we use flexbox to center the button. Even though flexbox is by no means a focus point of this tutorial and is a relative new addition to the CSS language, it greatly enhances your abilities to create page layouts via CSS. For a complete guide to flexbox, see this article by CSS-tricks!\nFinally, you may wonder, where did we included the JavaScript and CSS file from step 1? You can find the links when pressing the  button, located at the top right in our example fiddle. This opens up a new display with a panel on the left hand side that contains an External Resources tab, which includes all the external dependencies for our jsFiddle, i.e.¬†the introjs CSS and JavaScript files, Bootstrap and jQuery.\nOf note, in a standard Shiny app you don‚Äôt need to explicitly load either Bootstrap or jQuery as they are included automatically by Shiny. However, if you base your app on HTML Templates, then be careful you don‚Äôt mistakenly include multiple jQuery or Bootstrap instances. In case you need to, you can also suppress specific web dependencies via suppressDependencies. This function can be helpful if distinct widgets include different versions of the same library e.g.¬†different versions of d3.js.\n\nUsing JSON to setup introJS\nEven though the previous example creates a tour, it‚Äôs not very convenient to manually set all the attributes for each element. Luckily, introJS allows you to use a JSON array to specify all relevant options, in which each step can use a CSS selector to indicate where we want to draw a box, what should be in it and where the box should be displayed relative to the selected element, among other things. The fiddle below shows an implementation using this concept.\n\n\n\npress the green start button to activate introJS\n\n\nThe output is identical to the fiddle in the previous section. However, you can see in the HTML tab that we greatly simplified the HTML markup and now only need an id field. Furthermore, in the JavaScript tab you can see that we specified an array that contains objects that describe the individual steps in the tour. The array for the first two steps looks like this:\nvar Steps = [\n    {\n      element: '#step1',\n      intro: \"text step 1\",\n      position: 'bottom'\n    },\n    {\n      element: '#step2',\n      intro: \"text step 2\",\n      position: 'bottom'\n    }\n];\nFinally, we created an instance of introJS, loaded the data via the setOptions method and subsequently started the tour. The relevant code looks like this:\n// initialize an introjs instance\nvar intro = introJs();\n\n// pass in the Steps array created earlier\nintro.setOptions({steps: Steps });\n\n// start intro.js\nintro.start();\nNote that all of this code is located inside the callback function for our button click event handler. Hence, this code will only fire after we press the button!\n\n\nCustomization and additional methods\nIntroJS is a versatile library, which offers many additional functions and options next to those discussed here. For a more comprehensive overview of additional attributes that allow customization, see here.\nIn addition, introJS offers a rich set of methods such as: introJs.nextStep(), introJs.previousStep() and introJs.exit().\nThese methods allow you to control the direction of the guided tour. For many of these methods, introJS let‚Äôs you call a JavaScript function, before, during or after completion, e.g.¬†via: introJs.onchange, introJs.oncomplete and introJs.onexit.\nA complete list of methods is provided here.\nCaveat: for some functionality in more recent versions of introJS (\\(\\geq\\) 2), an inexpensive licence is required for commercial applications. All functionality in this tutorial work with earlier versions though.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to develop an interactive, dynamic help system for your app with introJS"
    ]
  },
  {
    "objectID": "r/articles/build/js-introjs/index.html#using-introjs-in-a-shiny-app",
    "href": "r/articles/build/js-introjs/index.html#using-introjs-in-a-shiny-app",
    "title": "How to develop an interactive, dynamic help system for your app with introJS",
    "section": "Using introJS in a Shiny app",
    "text": "Using introJS in a Shiny app\nNow that we have a better grasp on what introJS offers, let‚Äôs see how we can use introJS in a Shiny context. The idea is quite simple.\nFrom the previous tutorial, we know that we can call any JavaScript function from R by using session$sendCustomMessage, which sends a message to an event handler, which we can create via Shiny.addCustomMessageHandler. Furthermore, we can use Shiny.onInputChange inside a JavaScript function to send a message back to the Shiny input object, e.g.¬†when we click on a box.\nNow that we know which JavaScript functions to call and what our data should look like, we can setup Shiny to make these calls.\nFor our first Shiny based introJS app, we are not going to put the code in an R package. This makes the steps easier to follow. It also makes it easier for you to experiment with the code. For readers who just want to use introJS in a Shiny app, without knowing all the details, we made an R package that you can download and use. We explain how to use this package in the next section.\nA live version of the end result of a first basic Shiny implementation can be found here and the source code can be found here.\n  \n\nClick the image to see a live shiny app!\n\nWe proceed by discussing the various steps needed to make the above demo app work and how you can start making your own JavaScript powered apps.\n\nCreate small toy examples first\nWhen you‚Äôre building new Shiny functionality, it is often useful to first build a small prototype in HTML and JavaScript (without Shiny). This let‚Äôs you focus on:\n\nwhich CSS and JavaScript files to include\nhow to structure your data\nhow to call specific library functions\n\nEssentially, this is the role that our jsFiddle examples fill in our tutorials. After you‚Äôre comfortable that your mini application works the way you want, the sole trick is to let Shiny include the files you need, and to use Shiny to build the HTML elements you need. After that, just let Shiny call whatever JavaScript function(s) you need to call and pass any data via jsonlite (Shiny will implicitly do this for you, see here).\nIn the case at hand, to go from the fiddle shown above, to a Shiny app, we have to implement the following steps:\n\nMake Shiny include the correct CSS and JavaScript files\nLet Shiny spit out the HTML you need\nIn R, send a custom message to the client i.e.¬†JavaScript, with the data we need introJS to have\nIn JavaScript, setup a custom message handler that can call introJS and pass it the data it needs\n\n\n\nCreating the UI code\nComing back to our jsFiddle, note that many layout functions rely on bootstrap classes. In fact, in Shiny, the fluidRow and column functions create divs with a row and col-sm-x class, respectively. Hence, these functions almost provide the HTML output of our first introJS fiddle example. We only need to add an extra div to each column to make it right.\nFirst, we start by copying the CSS we defined in the fiddle into a separate file, i.e.¬†app.css, such that we can use the custom well and flexcontainer classes.\nThe ui.R code snippet below shows how to get the first row of elements, including the start button, as well as how to load all of the dependencies that we need. We also include a file called app.js, which contains all of the client side code that we need to update the help contents and start the help (see below).\n# Include IntroJS styling\nincludeCSS(\"introjs.min.css\"),\n\n# Include styling for the app\nincludeCSS(\"app.css\"),\n\n# Include IntroJS library\nincludeScript(\"intro.min.js\"),\n\n# Include JavaScript code to make shiny communicate with introJS\nincludeScript(\"app.js\")\n\n# setup grid\n# row 1\nfluidRow(\n  column(4, div(id=\"step1\", class=\"well\", \"element1\")),\n  column(4, div(id=\"step2\", class=\"well\", \"element2\")),\n  column(4, div(id=\"step3\", class=\"well\", \"element3\"))\n),\n...\n\n# centered button\ndiv(class=\"flexcontainer\",\n\n    # action button\n    actionButton(inputId=\"startHelp\", label=\"start\", class=\"btn-success\")\n)\n\n\nSend help contents from the server to the client\nNext, let‚Äôs see what we should put in app.js.\nThe first thing we need to do is to initiate introJS. We can do this exactly like in our fiddle i.e.¬†via var intro = introJs();. Next, instead of setting the help contents in JavaScript, we want to be able to set the help contents dynamically from Shiny.\nAs mentioned above, we can use the JavaScript method Shiny.addCustomMessageHandler to create a custom message handler that we can invoke from R. In our case, the handler must be able to receive tour data in the same format as described in the fiddle above and to pass this data to the introJS object intro.\nPutting these steps together results in the following JavaScript code:\n// initialize an introjs instance\nvar intro = introJs();\n\n// handler 1\nShiny.addCustomMessageHandler(\"setHelpContent\",\n\n  // callback function.\n  // note: data is passed by shiny and contains the tour data\n  function(data){\n\n    // load data\n    intro.setOptions({steps: data});\n  }\n);\nOur handler is called setHelpContent, which is the name we‚Äôll use when sending information from R via session$sendCustomMessage (see below).\nTo conveniently configure our help system, we can put the help contents into a comma separated configuration file, e.g.help.csv.\nIn our case, help.csv looks like this:\n\n\n\n\n\n\n From left to right, the columns respectively indicate: the step number, the display text for that step, the CSS selector and the position in which we want the text box to appear. The value for the latter option can be either top, left, right, bottom, bottom-left-aligned, bottom-middle-aligned, bottom-right-aligned or auto. If left empty, the default option equals bottom.\nOnce we have our dataframe ready to go (here called steps), we can send it to introJS via:\n# set help content\nsession$sendCustomMessage(type = 'setHelpContent', message = list(steps = toJSON(steps) ))\nEssentially, you can use one of three basic strategies to send information that introJS needs from R to JavaScript:\n\nSend the information from R in a convenient R structure. Then further modify the object in JavaScript to create the object JavaScript needs.\nReshape the information in R so that when Shiny passes it as jsonlite (see tutorial 2 & 3), it ends up as the precise object that JavaScript needs.\nA combination of strategies 2 and 3.\n\nNote that we didn‚Äôt send steps from R directly. Instead, we sent toJSON(steps), which means we went with strategy 2. This is only to ensure that JavaScript gets the object it needs. In practice, this step often needs some experimentation to see how you can best send an object from R to JavaScript. Similar logic holds for sending objects from JavaScript to R.\n\n\nStart the help from the server\nAll that remains is to create a mechanism to start the help from the server. As you might have guessed, this mechanism is again constructed via a custom message handler, in which we invoke introJS.start():\n// handler 2\nShiny.addCustomMessageHandler(\"startHelp\", function(message) {\n\n    // start intro.js\n    // note: we don't need information from shiny, just start introJS\n    intro.start();\n  }\n);\nNote that we could also directly add an onClick attribute to our button like we did in the examples above. An advantage of the approach taken here is that we have more control over our help because we can now invoke it from the server i.e.¬†Shiny.\nTo invoke the help from the server, we add an observeEvent block in R. This block listens to our button and calls sendCustomMessage to invoke our startHelp handler as defined above:\n# listen to the action button\nobserveEvent(input$startHelp,{\n\n  # on click, send custom message to start help\n  session$sendCustomMessage(type = 'startHelp', message = list(\"\"))\n})\n\n\nintroJS demo package\nBelow we present a Shiny demo app that contains a compete implementation of the various aspects discussed above. For convenience, we made the code available as an R package.\nWe won‚Äôt cover the complete code base in detail as this involves various aspects related to package building e.g.¬†using addResourcePath to include dependencies, which is outside the scope of this tutorial. The complete code for this example app can be downloaded here, while the accompanying R package can be downloaded here.\nIn short, the R library lets you:\n\nLoad a definition of the help content via a dataframe, which is subsequently transformed into a JSON array (like in the jsFiddle above)\nAutomatically add a help button to the page to activate introJS\nAutomatically add all introJS related JavaScript and CSS dependencies to the app\nAutomatically create an introJS instance\nAutomatically pass the help settings from step 1 to the introJS instance\n\nTo see the package in action, press the screenshot below!\n\n\n\nShiny C3 dashboard app with basic help system using the R introJS package\n\n\nIn the remainder of this tutorial, we describe how you can use our introJS R package in a real Shiny app. This is illustrated in an extended version of the dashboard app that we showed in the previous tutorials.\n\n\nUsing the introJS package in a Shiny app\nWith the help of our introJS package, using introJS in a Shiny application is a breeze! Only the following 3 simple steps are needed:\n\nin global.R, create a dataframe, e.g.¬†called helpData, in which each row specifies:  i) the step number, ii) the display text for that step iii) the CSS selector to select the correct element iv) the position we want the text box to appear in \nin ui.R, call addIntroJS()\nin server.R, call initIntroJS and pass in session and helpData\n\nThat‚Äôs it! The package will handle:\n\ncreating of the JSON object\nsetting up the message handlers\ninserting the associate introJS, CSS, and JavaScript files\ncreating of the button\nsetting up the click handler\npassing the data to introJS, and\nactivating introJS.\n\nIn the example app, we created a dataframe similar to the one discussed above by reading in a predefined CVS file whose contents look like this:\n\n\n\n\n\n\n\nImplemenation details\nBriefly, the package implementation contains an R file, called FRISSIntroJS.R, which contains the addIntroJS and initIntroJS functions, as well as a JavaScript file, called IntroJSBinding.js, which is located in the package www folder. The latter file contains the JavaScript logic for the introJS component. Please feel free to inspect the annotated source code to familiarize yourself with the various aspects of package building.\nObviously, many different implementations of introJS are possible, so don‚Äôt be too worried if you don‚Äôt understand all of the aspects of this code base or feel another way of implementing some features is more appropriate. Furthermore, our package is by no means a full fledged implementation and only serves to illustrate alternative uses of the key JavaScript functions discussed above.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to develop an interactive, dynamic help system for your app with introJS"
    ]
  },
  {
    "objectID": "r/articles/build/js-introjs/index.html#advanced-example",
    "href": "r/articles/build/js-introjs/index.html#advanced-example",
    "title": "How to develop an interactive, dynamic help system for your app with introJS",
    "section": "Advanced example",
    "text": "Advanced example\nAs a bonus, we present a completely tricked out toy example app, that allows you to use introJS, switch tab panels in a Shiny app via introJS, use voice recognition to activate introJS, and dynamically update the content inside an introJS message box. The app even uses voice synthesis to speak out the text inside each box! A full discussion of this code base is well beyond the scope of this tutorial. However, it serves as a nice illustration to see what‚Äôs possible when combining JavaScript with Shiny code! Here speech recognition is based on annyang.\nCaveat 1: most parts of this code only work in recent versions of the Chrome browser.\nCaveat 2: the current voice recognition capabilities of Chrome are rather limited and often buggy, which likely leave production applications out of scope based on our approach.\nTo see this demo in action, navigate a recent version of the Chrome browser to this link. You can download the complete code base here.\n\n\n\nShiny C3 dashboard app advanced example, with tab switching via introJS, using voice recognition and voice synthesis.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to develop an interactive, dynamic help system for your app with introJS"
    ]
  },
  {
    "objectID": "r/articles/improve/google-analytics/index.html",
    "href": "r/articles/improve/google-analytics/index.html",
    "title": "Add Google Analytics",
    "section": "",
    "text": "This article will show you how to add Google Analytics to a Shiny app. If you don‚Äôt know any JavaScript or jQuery, you can still add simple analytics by following the steps outlined in this article, but customizing the type of analytics you collect will require that you know a little about JavaScript and jQuery (which we will not teach here).\nGoogle Analytics is a free service offered by Google that collects information about who visits your website and what they do while they are there. You can learn more about Google Analytics at support.google.com/analytics, which explains how to set up and use Google Analytics with a web page.\nFrom time to time Google changes how they do content tracking. The following information is current as of August 2023. If you find that the information is out of date at any point, please let us know on RStudio Community.",
    "crumbs": [
      "Improve",
      "Scale",
      "Measure usage",
      "Add Google Analytics"
    ]
  },
  {
    "objectID": "r/articles/improve/google-analytics/index.html#add-analytics-to-an-app",
    "href": "r/articles/improve/google-analytics/index.html#add-analytics-to-an-app",
    "title": "Add Google Analytics",
    "section": "Add analytics to an app",
    "text": "Add analytics to an app\nYou can use Google Analytics with a Shiny app, since Shiny apps are a type of web page. In this article, we will add Google Analytics to the Sunshine app, pictured below.\nThe Sunshine app displays the distribution of annual sunlight in the United States. The app is hosted on shinyapps.io at gallery.shinyapps.io/google-analytics. If you‚Äôd like a copy of the app, including its JavaScript and CSS files, you can find them here.\n\nYou can add analytics to the app (and collect results) with the five steps below.\n\nStep 1 - Create an account\nTo use Google Analytics, you must open a free account at google.com/analytics.\n\n\n\nStep 2 - Add a property\nNext, you must register your Shiny app as a property in your Google Analytics account. You can do this on the sign up page, or‚Äîif you already have a Google Analytics account‚Äîyou can do this in the Admin tab.\n\nYou will need to provide a web address for your app to Google Analytics. Since the Sunshine app is hosted at https://gallery.shinyapps.io/google-analytics, I‚Äôll use this address.\n\nOnce you have entered the necessary information, click ‚ÄúCreate‚Äù at the bottom of the form. Google Analytics will open a new window that contains a tracking ID number for your app as well as a short JavaScript script.\n\nThis script will allow Google Analytics to track traffic to and from your app. To use it, you‚Äôll need to put the script in the head of your app‚Äôs DOM, the subject of Step 3.\n\n\nStep 3 - Embed tracking script\nYou should place the Google Analytics tracking script at the end of the head section of the HTML DOM that describes your Shiny app.\nThis is very easy to do if you build your Shiny app around an HTML file, as described in Build your entire UI with HTML.\nIf you built your Shiny app with a app.R file (the traditional method), use the tags$head and includeHTML functions to include the script.\nFor example, Google Analytics has given us the script below to embed in the Sunshine app. Note that your Google tag will be different from ours, which starts with GT- and is used in two places below. The Google tag is an identifier for the content you created on Google Analytics.\n\n\ngoogle-analytics.html\n\n&lt;!-- Global site tag (gtag.js) - Google Analytics --&gt;\n&lt;script async src=\"https://www.googletagmanager.com/gtag/js?id=GT-XXXXXX\"&gt;&lt;/script&gt;\n&lt;script&gt;\n  window.dataLayer = window.dataLayer || [];\n  function gtag(){dataLayer.push(arguments);}\n  gtag('js', new Date());\n\n  gtag('config', 'GT-XXXXXX');\n&lt;/script&gt;\n\nTo include the script in your app, first save it to its own file. Here I‚Äôve saved the script as a file named google-analytics.html, which I have placed in the working directory of the Sunshine app.\n\nTo embed the script in the Sunshine app, call tags$head(includeScript(\"google-analytics.js\")) in the ui.R file. includeScript will import the script and pass it to tags$head(), which will place the script in the head section of your app‚Äôs DOM.\nincludeHTML requires one argument: \"google-analytics.html\", the file path from the App directory to the google-analytics.html file.\nThe final ui of my app will look like the following.\n\n\napp.R\n\nui &lt;- fluidPage(\n  tags$head(includeHTML(\"google-analytics.html\")),\n  includeCSS(\"cerulean.css\"),\n\n  titlePanel(\"Sunlight in the US\"),\n\n  helpText(\"Use this Shiny app to explore the distribution of sunlight in\n           the United States. The map can display three variables by state.\"),\n\n  br(),\n\n  selectInput(\"var\", \"Display\",\n    choices = c(\n      \"Percent of time sunny\" = \"sun_percent\",\n      \"Annual hours of sunshine\" = \"total_hours\",\n      \"Annual clear days\" = \"clear_days\"\n    )\n  ),\n\n  actionButton(\"update_plot\", \"Update Plot\"),\n\n  br(),\n\n  plotOutput(\"map\", width = \"90%\")\n)\n\nSince the app is hosted on shinyapps.io, I will need to redeploy the app to shinyapps.io for the new app.R file to take effect.\nThe Google Analytics script tracks how visitors move from one web page to the next. With it, you can learn a little about:\n\nwho visits your app\nwhere they come from\nhow long they stay on the app while they are there\n\nYou can also use Google Analytics to track how visitors use your app, but to do that you will need to set up specific event trackers.\n\n\nStep 4 - Create event trackers\nAn event tracker is a piece of code that notifies Google Analytics whenever a visitor interacts with a specific part of your app, such as a link or a widget. You create a separate event tracker for each unique event that you want to track.\nWith Google Analytics, you use the basic script to track how people move to and from your page, and you use event trackers to track what they do while they are there. Note that you will need to embed the basic Google Analytics tracking script into your app before you create any event trackers. Event trackers will not work without the basic script.\nTo create an event tracker, you arrange to have a web element‚Äôs event handler execute a simple JavaScript command that looks like this:\ngtag('event', 'action', { key: value });\nWhen the element executes the command, gtag sends an event notification to Google Analytics that lets Google Analytics know that an event occurred. The notification will contain the values of action and event data as a JavaScript object in the form key-value pairs. Later on, you will be able to see these values, as well as when the event occurred, from your Google Analytics dashboard.\nFor example, you can track when users click on a specific link by having the link‚Äôs onClick attribute call gtag:\n&lt;a href=\"http://www.example.com\"\n   onclick=\"tag('event', 'link', { action: 'click': label: 'IKnow' })\"&gt;\n   I know when you click me\n&lt;/a&gt;;\nThis works for tracking events on simple web elements, but you must use a different approach to track events on Shiny widgets.\nShiny does not let you set arbitrary attributes on widgets when you create them. To set an event tracker on a Shiny widget, you will need to identify and modify the widget after it has been created, which you can do with a jQuery script.\nFor example, the Sunshine app has two widgets: a select box and a button. I would like to track how users interact with each of the widgets. To do this I will need to create two event trackers, one for the select box widget and one for the button widget. I will also need to set these event trackers on the widgets with jQuery.\n\nThe following script attaches an event handler to the select box widget. The handler will execute for change events that occur on the widget. In other words, the tracker will notify Google Analytics whenever a visitor changes the value of the select box widget.\nI‚Äôve chosen to have the event report include ‚Äúwidget‚Äù for the category value and ‚Äúselect data‚Äù for the action value. The last argument will return the value of the new selection as the label argument. This tracker will not return a value value; value arguments are optional.\n$(document).on('change', 'select', function(e) {\n  gtag('event', 'widget', {\n    action: 'select data',\n    label: $(e.currentTarget).val()\n  });\n});\nI can track the app‚Äôs ‚ÄúUpdate Plot‚Äù button in a similar way. The script below will send an event notification whenever a user clicks on a button class object in the DOM, e.g.¬†the ‚ÄúUpdate Plot‚Äù button:\n$(document).on('click', 'button', function() {\n  gtag('event', 'button', { action: 'update plot' });\n});\nNote: to write effective jQuery code, you will need to be able to uniquely identify the widgets that you wish to track. This may require you to explore the document structure of the finished app, for example in your browser‚Äôs developer tools console.\nWhen working with Shiny apps, use jQuery code that creates delegated event handling, like the code above does. Delegated events work more nimbly with the dynamic nature of Shiny apps than do direct events.\nNow, that I‚Äôve written the code that will allow event tracking, I need to add it to the app.R file of the Sunshine app. The easiest way to do this is to include the code in the google-analytics.html file that gets added to the app‚Äôs head.\nMy final google-analytics.html file will look like this:\n\n\ngoogle-analytics.html\n\n&lt;!-- Global site tag (gtag.js) - Google Analytics --&gt;\n&lt;script async src=\"https://www.googletagmanager.com/gtag/js?id=GT-XXXXXX\"&gt;&lt;/script&gt;\n&lt;script&gt;\n  window.dataLayer = window.dataLayer || [];\n  function gtag(){dataLayer.push(arguments);}\n  gtag('js', new Date());\n\n  gtag('config', 'GT-XXXXXX');\n\n  $(document).on('change', 'select', function(e) {\n    gtag('event', 'widget', {\n      action: 'select data',\n      label: $(e.currentTarget).val()\n    });\n  });\n\n  $(document).on('click', 'button', function() {\n    gtag('event', 'button', { action: 'update plot' });\n  });\n&lt;/script&gt;\n\nI‚Äôll need to redeploy the app to https://shinyapps.io to make sure the hosted version of the app uses this code.\n\n\nStep 5 - Collect reports\nOnce you have set up your app to use Google Analytics, you can use your account portal as a dashboard to track traffic on your app. The Real-Time tracking features should begin almost immediately, but other tracking features may take a couple hours to a couple days before they start reporting results.\nYou can also extract and analyze traffic data from Google Analytics data with R. The googleAnalyticsR package has extensive documentation with some examples.",
    "crumbs": [
      "Improve",
      "Scale",
      "Measure usage",
      "Add Google Analytics"
    ]
  },
  {
    "objectID": "r/articles/improve/google-analytics/index.html#add-google-analytics-with-shiny-server-open-source-and-shiny-server-pro",
    "href": "r/articles/improve/google-analytics/index.html#add-google-analytics-with-shiny-server-open-source-and-shiny-server-pro",
    "title": "Add Google Analytics",
    "section": "Add Google Analytics with Shiny Server Open Source and Shiny Server Pro",
    "text": "Add Google Analytics with Shiny Server Open Source and Shiny Server Pro\nAlternatively, you can use Shiny Server to add Google Analytics to your apps. This will let you manage your Google Analytics configuration at a higher level‚Äîso if you want all apps deployed on a server to share Google Analytics code, you could put this code at the top level of your config and all your apps would automatically inherit it. To learn more, visit the Shiny Server user guide.",
    "crumbs": [
      "Improve",
      "Scale",
      "Measure usage",
      "Add Google Analytics"
    ]
  },
  {
    "objectID": "r/articles/improve/google-analytics/index.html#recap",
    "href": "r/articles/improve/google-analytics/index.html#recap",
    "title": "Add Google Analytics",
    "section": "Recap",
    "text": "Recap\nTo add Google Analytics to a Shiny app:\n\nSet up a Google Analytics account.\nAdd the Shiny app to the account as a web property.\nPlace the Google Analytics tracking script into the head section of your app‚Äôs DOM.\nCreate event trackers to track specific events within your app. The easiest way to do this is to modify Shiny widgets with delegated event handlers managed by jQuery.\nUse R or your Google Analytics dashboard to explore the results.\n\nGoogle Analytics isn‚Äôt the only website monitoring service, but it is the most popular. You can add similar services to your app with the same techniques.\nThese techniques serve as a proof of concept that will allow you to track how visitors use your apps. We will look to make it easier to track Shiny apps in future development.",
    "crumbs": [
      "Improve",
      "Scale",
      "Measure usage",
      "Add Google Analytics"
    ]
  },
  {
    "objectID": "r/gallery/index.html#feature-demos",
    "href": "r/gallery/index.html#feature-demos",
    "title": "Gallery",
    "section": "Feature Demos",
    "text": "Feature Demos"
  },
  {
    "objectID": "r/gallery/index.html#user-showcase",
    "href": "r/gallery/index.html#user-showcase",
    "title": "Gallery",
    "section": "User Showcase",
    "text": "User Showcase"
  },
  {
    "objectID": "blog/posts/shinyswatch-0.7.0/index.html",
    "href": "blog/posts/shinyswatch-0.7.0/index.html",
    "title": "shinyswatch v0.7.0",
    "section": "",
    "text": "We‚Äôre happy to announce the release of shinyswatch v0.7.0. shinyswatch brings Bootstwatch themes to Shiny for Python, allowing you to easily customize the appearance of your Shiny apps with a variety of themes.\nYou can install the latest version of shinyswatch from PyPI with:\nThis release includes a number of new features that we‚Äôre excited to share with you. Some of these changes may require you to update your existing code, so please read on to learn more!\nPrior to shinyswatch v0.7.0, the Shiny themes provided by shinyswatch were fixed and could not be customized. With this release, we‚Äôre taking advantage of new theming features added in Shiny v1.0 to allow you to customize the shinyswatch themes!\nThis change, however, necessitated a few small breaking changes in shinyswatch that we‚Äôll cover first."
  },
  {
    "objectID": "blog/posts/shinyswatch-0.7.0/index.html#migrating-to-v0.7.0",
    "href": "blog/posts/shinyswatch-0.7.0/index.html#migrating-to-v0.7.0",
    "title": "shinyswatch v0.7.0",
    "section": "Migrating to v0.7.0",
    "text": "Migrating to v0.7.0\n\nSetting the app theme\nPrior to v0.7.0, to set the theme of a Shiny app, you could add the shinyswatch theme object to your app‚Äôs UI anywhere you wanted.\n\nExpressCore\n\n\n\n\napp.py\n\nfrom shiny.express import input, ui\n\nimport shinyswatch\n\nshinyswatch.theme.darkly  # No longer allowed \n\nui.input_slider(\"num\", \"Number:\", min=10, max=100, value=30)\nui.output_text_verbatim(\"slider_val\")\n\n\n# the rest of your app ...\n\n\n\n\n\napp.py\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\n\nimport shinyswatch\n\napp_ui = ui.page_fluid(\n    shinyswatch.theme.darkly,  # No longer allowed \n    ui.input_slider(\"num\", \"Number:\", min=10, max=100, value=30),\n    ui.output_text_verbatim(\"slider_val\"),\n)\n\n# server ...\n\n\n\n\nWith shinyswatch v0.7.0, you now need to pass the shinyswatch.theme object to the theme argument of shiny.express.ui.page_opts() or of any shiny.ui.page_*() function.\n\nExpressCore\n\n\n\n\napp.py\n\nfrom shiny.express import input, ui\n\nimport shinyswatch\n\nui.page_opts(theme=shinyswatch.theme.darkly)  \n\nui.input_slider(\"num\", \"Number:\", min=10, max=100, value=30)\nui.output_text_verbatim(\"slider_val\")\n\n\n# the rest of your app ...\n\n\n\n\n\napp.py\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\n\nimport shinyswatch\n\napp_ui = ui.page_fluid(\n    ui.input_slider(\"num\", \"Number:\", min=10, max=100, value=30),\n    ui.output_text_verbatim(\"slider_val\"),\n    theme=shinyswatch.theme.darkly,  \n)\n\n# server ...\n\n\n\n\nRead about the customizable theme features below to learn about the feature that required this change.\n\n\nChoosing an initial theme with the theme picker\nIn shinyswatch v0.6.0 we added a default argument to shinyswatch.theme_picker_ui() that could be used to choose the initial theme. This short-lived argument is now deprecated.\nInstead, in shinyswatch v0.7.0, the initial app theme must be set separately from the theme picker UI, using the same method described above.\n\nExpressCore\n\n\n\nBeforeAfter\n\n\n\n\napp.py\n\nfrom shiny.express import input, ui\n\nimport shinyswatch\n\nshinyswatch.theme_picker_ui(default=\"darkly\")  \n\nui.input_slider(\"num\", \"Number:\", min=10, max=100, value=30)\nui.output_text_verbatim(\"slider_val\")\n\n# the rest of your app ...\n\n\n\n\n\napp.py\n\nfrom shiny.express import input, ui\n\nimport shinyswatch\n\nshinyswatch.theme_picker_ui()  \nui.page_opts(theme=shinyswatch.theme.darkly)  \n\nui.input_slider(\"num\", \"Number:\", min=10, max=100, value=30)\nui.output_text_verbatim(\"slider_val\")\n\n# the rest of your app ...\n\n\n\n\n\n\n\nBeforeAfter\n\n\n\n\napp.py\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\n\nimport shinyswatch\n\napp_ui = ui.page_fluid(\n    shinyswatch.theme_picker_ui(default=\"darkly\"),  \n    ui.input_slider(\"num\", \"Number:\", min=10, max=100, value=30),\n    ui.output_text_verbatim(\"slider_val\"),\n)\n\n# server ...\n\n\n\n\n\napp.py\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\n\nimport shinyswatch\n\napp_ui = ui.page_fluid(\n    shinyswatch.theme_picker_ui(),  \n    ui.input_slider(\"num\", \"Number:\", min=10, max=100, value=30),\n    ui.output_text_verbatim(\"slider_val\"),\n    theme=shinyswatch.theme.darkly,  \n)\n\n# server ...\n\n\n\n\n\n\n\nThis change accompanies a set of new theme picker features described below."
  },
  {
    "objectID": "blog/posts/shinyswatch-0.7.0/index.html#customizing-theme",
    "href": "blog/posts/shinyswatch-0.7.0/index.html#customizing-theme",
    "title": "shinyswatch v0.7.0",
    "section": "Customizing a shinyswatch theme",
    "text": "Customizing a shinyswatch theme\nEach shinyswatch.theme is now a subclass of shiny.ui.Theme, an abstraction around the Sass files that compile to a complete Shiny theme.\nThis means that you can now customize the themes by changing the Sass variables that define the theme‚Äôs colors, fonts, and other properties, using the .add_defaults(), .add_mixins() and .add_rules() methods. Each of these chainable methods take Sass variables or Sass rules as strings and insert them into the theme‚Äôs Sass file:\n\n.add_defaults() adds Sass variables to the theme, prior to the theme‚Äôs own variables.\n.add_mixins() adds Sass mixins or rules to the theme, after the theme‚Äôs own mixins. (Mixins are after defaults.)\n.add_rules() adds Sass rules to the theme, after the theme‚Äôs own rules.\n\nimport shinyswatch\n\n(\n  shinyswatch.theme.zephyr\n  .add_defaults(\n    primary=\"#aa00ff\",  # purple\n    secondary=\"#bfff00\",  # lime green\n  )\n  .add_rules(\n    \"\"\"\n    strong {\n      color: $primary;\n    }\n    \"\"\"\n  )\n)\nYou can use this approach to tweak an existing shinyswatch theme to better match your organizations branding or your personal preferences. Pass the customized theme object to the theme argument of shiny.express.ui.page_opts() or of any shiny.ui.page_*() function to apply the changes to your app."
  },
  {
    "objectID": "blog/posts/shinyswatch-0.7.0/index.html#theme-picker-improvements",
    "href": "blog/posts/shinyswatch-0.7.0/index.html#theme-picker-improvements",
    "title": "shinyswatch v0.7.0",
    "section": "Theme picker improvements",
    "text": "Theme picker improvements\nThe theme picker has been updated in two notable ways:\n\nAdditional options. The theme picker dropdown will now automatically select the app‚Äôs initial theme, i.e.¬†the theme passed to the page-level theme argument. This initial theme could be the default Shiny theme, a shinyswatch theme, or a custom theme created with shiny.ui.Theme(). We also include shiny and bootstrap themes in the picker by default, so your users can return to Shiny‚Äôs default theme if they want.\nRemembering the user‚Äôs choice. The theme picker will now remember the user‚Äôs theme choice across sessions. This means that if a user selects a theme, closes the app, and reopens it later, the app will remember the user‚Äôs theme choice. This feature uses the browser‚Äôs local storage1 to remember the user‚Äôs choice."
  },
  {
    "objectID": "blog/posts/shinyswatch-0.7.0/index.html#footnotes",
    "href": "blog/posts/shinyswatch-0.7.0/index.html#footnotes",
    "title": "shinyswatch v0.7.0",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nLocal storage is a browser feature that allows web applications to store data locally within the user‚Äôs browser. This data persists even after the user closes the browser, but is scoped in two important ways. First, the data is only accessible to Shiny apps on the same domain, i.e.¬†all apps on myusername.shinyapps.io using the theme picker will share the same local storage. Second, the data is only accessible in the browser that stored it, i.e.¬†the user‚Äôs theme choice will not be remembered if they open the app in a different browser or on a different device.‚Ü©Ô∏é"
  },
  {
    "objectID": "blog/posts/shiny-express/index.html",
    "href": "blog/posts/shiny-express/index.html",
    "title": "Introducing: Shiny Express",
    "section": "",
    "text": "Today we‚Äôre officially announcing the most important addition to Shiny for Python since its inception: Shiny Express, a new way to write Shiny apps in Python!\nShiny Express is designed to make it significantly easier to get started with Shiny, and to write simple apps with a minimum of boilerplate.\nHere‚Äôs what a simple ‚ÄúHello, World‚Äù app looks like in Shiny Express:\nThe ui.input_text() function creates a text input, and the @render.text decorator makes the output of the greeting() function appear on the page.\nAfter installing Shiny with pip install shiny, you can save this code as app.py and start the app with shiny run app.py. Or, skip the install and try the app in our online editor.\nHere‚Äôs another example with more features of Shiny Express, including UI container components (sidebar and card) and a plot:"
  },
  {
    "objectID": "blog/posts/shiny-express/index.html#simple-yet-powerful",
    "href": "blog/posts/shiny-express/index.html#simple-yet-powerful",
    "title": "Introducing: Shiny Express",
    "section": "Simple, yet powerful",
    "text": "Simple, yet powerful\nWhile Shiny Express is easy to pick up, it‚Äôs powered by Shiny‚Äôs proven reactive programming framework, extensive (and growing) suite of components, and deeply customizable approach to UI‚Äîjust in a more approachable syntax that minimizes the fuss. It‚Äôs suitable for writing everything from throwaway prototypes, to realtime dashboards, to cutting edge model demos, to production-quality business workflow apps.\n\n\n\n\n\n Build this app in our User Interfaces tutorial. View app on shinylive.io."
  },
  {
    "objectID": "blog/posts/shiny-express/index.html#one-framework-two-ways-to-author",
    "href": "blog/posts/shiny-express/index.html#one-framework-two-ways-to-author",
    "title": "Introducing: Shiny Express",
    "section": "One framework, two ways to author",
    "text": "One framework, two ways to author\nOur traditional syntax for writing Shiny apps is now called Shiny Core. If you‚Äôre already happily using Shiny, no need to change what you‚Äôre doing! We think of Shiny Express and Shiny Core as complementary, and intend to support both syntaxes indefinitely.\nShiny Core is a more structured approach to writing Shiny apps, and we think it‚Äôs still the best choice for larger, more complex apps. Here‚Äôs what that same ‚ÄúHello, World‚Äù app looks like in Shiny Core:\nfrom shiny import App, ui, render\n\napp_ui = ui.page_fluid(\n    ui.input_text(\"name\", \"What's your name?\", value=\"World\"),\n    ui.output_text(\"greeting\"),\n)\n\ndef server(input, output, session):\n    @render.text\n    def greeting():\n        return f\"Hello, {input.name()}!\"\n\napp = App(app_ui, server)\nAlthough there‚Äôs more to learn and more to type, the enforced discipline of separating UI and server logic can be a benefit for larger apps.\nThat being said, we think most new Shiny users will be more successful starting their learning journey with Shiny Express, so we‚Äôve overhauled our main tutorial to encourage people to start there. The more advanced topics are written for both Express and Core, as are our Component and Layout galleries."
  },
  {
    "objectID": "blog/posts/shiny-express/index.html#learn-more",
    "href": "blog/posts/shiny-express/index.html#learn-more",
    "title": "Introducing: Shiny Express",
    "section": "Learn more",
    "text": "Learn more\nYou can get started with Shiny today by jumping into the tutorial. Thanks to Shiny Express, it‚Äôs never been easier!\nOr if you‚Äôre already experienced with Shiny, you find out more about the differences between Express and Core.\nQuestions? Comments? We‚Äôd love to hear from you! Please join us on Discord."
  },
  {
    "objectID": "blog/posts/shiny-express/index.html#questions",
    "href": "blog/posts/shiny-express/index.html#questions",
    "title": "Introducing: Shiny Express",
    "section": "Questions",
    "text": "Questions\nHow do I install Shiny Express? Is it an add-on package?\nShiny Express is built into shiny 0.7.0. You can install it with pip install shiny (or upgrade with pip install -U shiny).\nIs Shiny Core syntax really going to stay around in the future?\nShiny Express is not intended to replace Shiny Core. In fact, Shiny Express could not exist without Shiny Core, because it is implemented using Shiny Core! As we were building Shiny Express, we were very pleased to find that Shiny Core provides a solid foundation on which to build this new set of abstractions.\nIs Shiny Express available for R?\nWe don‚Äôt have immediate plans to bring Shiny Express to R. Given the size and maturity of the Shiny for R ecosystem, it would be a much larger undertaking to introduce a new syntax.\nThat being said, we‚Äôre excited to see how the Python community responds to Shiny Express, and we‚Äôll be watching closely to see if there‚Äôs interest in a similar syntax for R.\nIn the meantime, if you‚Äôre a Shiny for R user and the syntax changes in Shiny Express resonate with you, the Shiny Document syntax is actually extremely similar to Shiny Express."
  },
  {
    "objectID": "blog/posts/shiny-python-0.5.0/index.html",
    "href": "blog/posts/shiny-python-0.5.0/index.html",
    "title": "Shiny for Python 0.5.0",
    "section": "",
    "text": "Another Shiny for Python release has arrived! In fact, we released 0.5.0 and then quickly followed it with 0.5.1, which fixes a sidebar bug we introduced in 0.5.0. Sorry about that!\nYou can upgrade to Shiny for Python 0.5.1 by running pip install -U shiny or conda install -c conda-forge shiny."
  },
  {
    "objectID": "blog/posts/shiny-python-0.5.0/index.html#style-tweaks",
    "href": "blog/posts/shiny-python-0.5.0/index.html#style-tweaks",
    "title": "Shiny for Python 0.5.0",
    "section": "Style tweaks",
    "text": "Style tweaks\nWe‚Äôve tweaked the default Shiny CSS theme to make your apps look cleaner and more modern. In the screenshots below, you‚Äôll notice differences in the slider and button, as well as shifts in the default typeface, font weights, and colors.\n(The old theme is on the left, and the new theme is on the right.)\n\n\n(old theme)\n\n\n \n\n\n(new theme)\n\nWe‚Äôve found that tick marks are usually not that helpful on slider inputs, since you get instant feedback above the handle as you drag. If you want them back, you can pass ticks=True to input_slider().\nThese theme changes will be available to Shiny for R as well, via a new bslib CRAN release that should drop this week."
  },
  {
    "objectID": "blog/posts/shiny-python-0.5.0/index.html#data-table-filtering",
    "href": "blog/posts/shiny-python-0.5.0/index.html#data-table-filtering",
    "title": "Shiny for Python 0.5.0",
    "section": "Data table filtering",
    "text": "Data table filtering\nIn case you missed it, last month we introduced an interactive data table output that‚Äôs designed to easily scale to tens of thousands of rows. This month, we‚Äôve added the ability to let viewers filter the data table by column.\n\nCurrently, the filter feature must be enabled by passing filters=True when creating your render.DataGrid or render.DataTable object:\n  @output\n  @render.data_frame\n  def mygrid():\n    return render.DataGrid(my_df, filters=True)\n\nTry it out with Shinylive\nAPI documentation"
  },
  {
    "objectID": "blog/posts/shiny-python-0.5.0/index.html#tooltips",
    "href": "blog/posts/shiny-python-0.5.0/index.html#tooltips",
    "title": "Shiny for Python 0.5.0",
    "section": "Tooltips",
    "text": "Tooltips\nWe‚Äôve added a new tooltip feature, available in shiny.experimental namespace. They‚Äôre useful for providing additional information about an input or output, without taking up any extra space in your app.\nfrom shiny import ui\nimport shiny.experimental as x\n\nx.ui.tooltip(\n    ui.input_slider(\"n\", \"N\", 0, 100, 20),\n    \"A value to be doubled\"\n)\n\n\nTry it out with Shinylive\nAPI documentation\n\nTooltips can be combined with help icons, which are available in the faicons package. You can add tooltip help icons in input labels by passing a list to the label argument of input_*() functions:\nimport shiny.experimental as x\nfrom faicons import icon_svg\n\nui.input_text(\n    \"name\",\n    label=[\n        \"Name \",\n        x.ui.tooltip(\n            icon_svg(\"circle-info\", fill_opacity=0.5),\n            \"Your full name\"\n        )\n    ],\n)\n]\n\nTry it out with Shinylive"
  },
  {
    "objectID": "blog/posts/shiny-python-0.5.0/index.html#talk-python-podcast",
    "href": "blog/posts/shiny-python-0.5.0/index.html#talk-python-podcast",
    "title": "Shiny for Python 0.5.0",
    "section": "Talk Python podcast",
    "text": "Talk Python podcast\nI had a great time talking with Michael Kennedy on the Talk Python to Me podcast about Shiny for Python. We covered a lot of ground, including who Shiny is designed for, how Shiny differs from Jupyter notebooks, and how it compares to other Python web frameworks. Check it out!\n\n\nThat‚Äôs it for today! As always, if you have any questions or feedback, please join us on Discord or open an issue on GitHub. And if you‚Äôre enjoying Shiny for Python, please consider starring us on GitHub to show your support!"
  },
  {
    "objectID": "r/reference/shiny/index.html#latest-version",
    "href": "r/reference/shiny/index.html#latest-version",
    "title": "Reference",
    "section": "Latest version",
    "text": "Latest version\n\n\n\n\nshiny 1.9.0\nUpgrade notes\nFunction reference\n\n\n\n\n\nPrevious versions\n\n\n\n\nshiny 1.8.1\nUpgrade notes\nFunction reference\n\n\nshiny 1.8.0\nUpgrade notes\nFunction reference\n\n\nshiny 1.7.5\nUpgrade notes\nFunction reference\n\n\nshiny 1.7.4\nUpgrade notes\nFunction reference\n\n\nshiny 1.7.3\nUpgrade notes\nFunction reference\n\n\nshiny 1.7.2\nUpgrade notes\nFunction reference\n\n\nshiny 1.7.1\nUpgrade notes\nFunction reference\n\n\nshiny 1.7.0\nUpgrade notes\nFunction reference\n\n\nshiny 1.6.0\nUpgrade notes\nFunction reference\n\n\nshiny 1.5.0\nUpgrade notes\nFunction reference\n\n\nshiny 1.4.0\nUpgrade notes\nFunction reference\n\n\nshiny 1.3.2\nUpgrade notes\nFunction reference\n\n\nshiny 1.3.1\nUpgrade notes\nFunction reference\n\n\nshiny 1.3.0\nUpgrade notes\nFunction reference\n\n\nshiny 1.2.0\nUpgrade notes\nFunction reference\n\n\nshiny 1.1.0\nUpgrade notes\nFunction reference\n\n\nshiny 1.0.5\nUpgrade notes\nFunction reference\n\n\nshiny 1.0.4\nUpgrade notes\nFunction reference\n\n\nshiny 1.0.3\nUpgrade notes\nFunction reference\n\n\nshiny 1.0.2\nUpgrade notes\nFunction reference\n\n\nshiny 1.0.1\nUpgrade notes\nFunction reference\n\n\nshiny 1.0.0\nUpgrade notes\nFunction reference\n\n\nshiny 0.14.2\nUpgrade notes\nFunction reference\n\n\nshiny 0.14.1\nUpgrade notes\nFunction reference\n\n\nshiny 0.14\nUpgrade notes\nFunction reference\n\n\nshiny 0.13.2\nUpgrade notes\nFunction reference\n\n\nshiny 0.13.1\nUpgrade notes\nFunction reference\n\n\nshiny 0.13.0\nUpgrade notes\nFunction reference\n\n\nshiny 0.12.2\nUpgrade notes\nFunction reference\n\n\nshiny 0.12.1\nUpgrade notes\nFunction reference\n\n\nshiny 0.12.0\nUpgrade notes\nFunction reference\n\n\nshiny 0.11.1\nUpgrade notes\nFunction reference\n\n\nshiny 0.11\nUpgrade notes\nFunction reference"
  },
  {
    "objectID": "r/reference/shiny/1.8.1/upgrade.html#new-features-and-improvements",
    "href": "r/reference/shiny/1.8.1/upgrade.html#new-features-and-improvements",
    "title": "Upgrade notes for Shiny 1.8.1",
    "section": "New features and improvements",
    "text": "New features and improvements\n\nAdded ExtendedTask, a new simple way to launch long-running asynchronous tasks that are truly non-blocking. That is, even within a session, an ExtendedTask won‚Äôt block the main thread from flushing the reactive graph (i.e., UI updates won‚Äôt be blocked). ExtendedTask pairs nicely with new bslib::input_task_button() and bslib::bind_task_button() functions, which help give user feedback and prevent extra button clicks. (#3958)\nAdded a JavaScript error dialog, reporting errors that previously were only discoverable by opening the browser‚Äôs devtools open. Since this dialog is mainly useful for debugging and development, it must be enabled with shiny::devmode(). (#3931)\nrunExamples() now uses the bslib package to generate a better looking result. It also gains a package argument so that other packages can leverage this same function to run Shiny app examples. For more, see ?runExamples. (#3963, #4005)\nAdded onUnhandledError() to register a function that will be called when an unhandled error occurs in a Shiny app. Note that this handler doesn‚Äôt stop the error or prevent the session from closing, but it can be used to log the error or to clean up session-specific resources. (thanks @JohnCoene, #3993)"
  },
  {
    "objectID": "r/reference/shiny/1.8.1/upgrade.html#changes",
    "href": "r/reference/shiny/1.8.1/upgrade.html#changes",
    "title": "Upgrade notes for Shiny 1.8.1",
    "section": "Changes",
    "text": "Changes\n\nrenderDataTable()/dataTableOutput() are officially deprecated in favor of their {DT} equivalents. Migrating to DT, in most cases, just requires changing renderDataTable() to DT::renderDT() and dataTableOutput() to DT::DTOutput(). Also, to promote migration, when a recent version of DT is available, renderDataTable()/dataTableOutput() now automatically use their DT equivalent (and provide a message that they are doing so). If this happens to degrade an existing app, set options(shiny.legacy.datatable = TRUE) to get the old (i.e., non-DT) implementation. (#3998)\nBoth conditionalPanel() and uiOutput() are now styled with display: contents by default in Shiny apps that use Bootstrap 5. This means that the elements they contain are positioned as if they were direct children of the parent container holding the conditionalPanel() or uiOutput(). This is probably what most users intend when they use these functions, but it may break apps that applied styles directly to the container elements created by these two functions. In that case, you may include CSS rules to set display: block for the .shiny-panel-conditional or .shiny-html-output classes. (#3957, #3960)"
  },
  {
    "objectID": "r/reference/shiny/1.8.1/upgrade.html#bug-fixes",
    "href": "r/reference/shiny/1.8.1/upgrade.html#bug-fixes",
    "title": "Upgrade notes for Shiny 1.8.1",
    "section": "Bug fixes",
    "text": "Bug fixes\n\nNotifications are now constrained to the width of the viewport for window widths smaller the default notification panel size. (#3949)\nFixed #2392: downloadButton() now visibly returns its HTML tag so that it renders correctly in R Markdown and Quarto output. (Thanks to @fennovj, #2672)\nCalling updateSelectizeInput() with choices and selected now clears the current selection before updating the choices and selected value. (#3967)\nLoading a Shiny app in a package-like directory will no longer warn if autoloading is disabled by the presence of an R/_disable_autoload.R file. (Thanks to @krlmlr and @tanho63, #3513)"
  },
  {
    "objectID": "r/reference/shiny/1.7.5/upgrade.html#possibly-breaking-changes",
    "href": "r/reference/shiny/1.7.5/upgrade.html#possibly-breaking-changes",
    "title": "Upgrade notes for Shiny 1.7.5",
    "section": "Possibly breaking changes",
    "text": "Possibly breaking changes\n\nFor reactiveValues() objects, whenever the $names() or $values() methods are called, the keys are now returned in the order that they were inserted. (#3774)\nThe value provided to options(shiny.json.digits) is now interpreted as number of digits after the decimal instead of significant digits. To treat the value as significant digits, wrap it in I() (e.g., options(shiny.json.digits = I(4))). This new default behavior not only helps with reducing digits in testing snapshots, but is also more consistent with jsonlite‚Äôs default behavior. (#3819)"
  },
  {
    "objectID": "r/reference/shiny/1.7.5/upgrade.html#new-features-and-improvements",
    "href": "r/reference/shiny/1.7.5/upgrade.html#new-features-and-improvements",
    "title": "Upgrade notes for Shiny 1.7.5",
    "section": "New features and improvements",
    "text": "New features and improvements\n\nClosed #789: Dynamic UI is now rendered asynchronously, thanks in part to the newly exported Shiny.renderDependenciesAsync(), Shiny.renderHtmlAsync(), and Shiny.renderContentAsync(). Importantly, this means &lt;script&gt; tags are now loaded asynchronously (the old way used XMLHttpRequest, which is synchronous). In addition, Shiny now manages a queue of async tasks (exposed via Shiny.shinyapp.taskQueue) so that order of execution is preserved. (#3666)\nFixes #3840: updateSliderInput() now warns when attempting to set invalid min, max, or value values. Sending an invalid update message to an input no longer causes other update messages to fail. (#3843)\nsliderInput() now has a larger target area for clicking or tapping on the slider handle or range. (#3859)\nClosed #2956: Component authors can now prevent Shiny from creating an input binding on specific elements by adding the data-shiny-no-bind-input attribute to the element. The attribute may have any or no value; its presence will prevent binding. This feature is primarily useful for input component authors who want to use standard HTML input elements without causing Shiny to create an input binding for them. Additionally, Shiny now adds custom classes to its inputs. For example, checkboxInput() now has a shiny-input-checkbox class. These custom classes may be utilized in future updates to Shiny‚Äôs input binding logic. (#3861)\nMap objects are now initialized at load time instead of build time. This avoids potential problems that could arise from storing fastmap objects into the built Shiny package. (#3775)"
  },
  {
    "objectID": "r/reference/shiny/1.7.5/upgrade.html#bug-fixes",
    "href": "r/reference/shiny/1.7.5/upgrade.html#bug-fixes",
    "title": "Upgrade notes for Shiny 1.7.5",
    "section": "Bug fixes",
    "text": "Bug fixes\n\nFixed #3771: Sometimes the error ion.rangeSlider.min.js: i.stopPropagation is not a function would appear in the JavaScript console. (#3772)\nFixed #3833: When width is provided to textAreaInput(), we now correctly set the width of the &lt;textarea&gt; element. (#3838)"
  },
  {
    "objectID": "r/reference/shiny/1.7.3/upgrade.html",
    "href": "r/reference/shiny/1.7.3/upgrade.html",
    "title": "Upgrade notes for Shiny 1.7.3",
    "section": "",
    "text": "Bug fixes\n\nShiny 1.7.0 changed the icon(lib=\"fontawesome\") implementation from a bundled copy of fontawesome, to the {fontawesome} package. This led to issue #3688, where icons that were previously working, were now breaking. That‚Äôs because {fontawesome} 0.3.0 and earlier did not have support for icon names used in Font Awesome 5 and earlier, only the newest icon names used in Font Awesome 6. Now, {fontawesome} 0.4.0 has restored support for those older icon names, and Shiny 1.7.2.1 has updated its {fontawesome} requirement to &gt;=0.4.0."
  },
  {
    "objectID": "r/reference/shiny/1.7.1/upgrade.html#bug-fixes",
    "href": "r/reference/shiny/1.7.1/upgrade.html#bug-fixes",
    "title": "Upgrade notes for Shiny 1.7.1",
    "section": "Bug Fixes",
    "text": "Bug Fixes\n\nClosed #3516: Fix regression in repeated calls to appendTab() when navbarMenu() is already present within a tabsetPanel()/navbarPage(). (#3518)\nRe-arranged conditions for testthat 1.0.0 compatibility. (#3512)"
  },
  {
    "objectID": "r/reference/shiny/1.6.0/upgrade.html",
    "href": "r/reference/shiny/1.6.0/upgrade.html",
    "title": "Upgrade notes for Shiny 1.6.0",
    "section": "",
    "text": "This release focuses on improvements in three main areas:"
  },
  {
    "objectID": "r/reference/shiny/1.6.0/upgrade.html#full-changelog",
    "href": "r/reference/shiny/1.6.0/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 1.6.0",
    "section": "Full changelog",
    "text": "Full changelog\n\nBreaking changes\n\nClosed #3074: Shiny no longer supports file uploads for Internet Explorer 8 or 9. (#3075)\nSubtle changes, and some soft-deprecations, have come to freezeReactiveValue and freezeReactiveVal (#3055). These functions have been fragile at best in previous releases (issues #1791, #2463, #2946). In this release, we‚Äôve solved all the problems we know about with freezeReactiveValue(input, \"x\"), by 1) invalidating input$x and set it to NULL whenever we freeze, and 2) ensuring that, after a freeze, even if the effect of renderUI or updateXXXInput is to set input$x to the same value it already has, this will result in an invalidation (whereas by default, Shiny filters out such spurious assignments).\nSimilar problems may exist when using freezeReactiveVal, and when using freezeReactiveValue with non-input reactive values objects. But support for those was added mostly for symmetry with freezeReactiveValue(input), and given the above issues, it‚Äôs not clear to us how you could have used these successfully in the past, or why you would even want to. For this release, we‚Äôre soft-deprecating both of those uses, but we‚Äôre more than willing to un-deprecate if it turns out people are using these; if that includes you, please join the conversation at https://github.com/rstudio/shiny/issues/3063. In the meantime, you can squelch the deprecation messages for these functions specifically, by setting options(shiny.deprecation.messages.freeze = FALSE).\n\n\n\nAccessibility\n\nAdded bootstrap accessibility plugin under the hood to improve accessibility of shiny apps for screen-reader and keyboard users: the enhancements include better navigations for alert, tooltip, popover, modal dialog, dropdown, tab Panel, collapse, and carousel elements. (#2911)\nClosed #2987: Improved accessibility of ‚Äúlive regions‚Äù ‚Äì namely, *Output() bindings and update*Input(). (#3042)\nAdded appropriate labels to icon() element to provide screen-reader users with alternative descriptions for the fontawesome and glyphicon: aria-label is automatically applied based on the fontawesome name. For example, icon(\"calendar\") will be announced as ‚Äúcalendar icon‚Äù to screen readers. ‚Äúpresentation‚Äù aria role has also been attached to icon() to remove redundant semantic info for screen readers. (#2917)\nClosed #2929: Fixed keyboard accessibility for file picker button: keyboard users can now tab to focus on fileInput() widget. (#2937)\nFixed #2951: screen readers correctly announce labels and date formats for dateInput() and dateRangeInput() widgets. (#2978)\nClosed #2847: selectInput() is reasonably accessible for screen readers even when selectize option is set to TRUE. To improve selectize.js accessibility, we have added selectize-plugin-a11y by default. (#2993)\nClosed #612: Added alt argument to renderPlot() and renderCachedPlot() to specify descriptive texts for plotOutput() objects, which is essential for screen readers. By default, alt text is set to the static text, ‚ÄúPlot object,‚Äù but even dynamic text can be made with reactive function. (#3006, thanks @trafficonese and @leonawicz for the original PR and discussion via #2494)\nAdded semantic landmarks for mainPanel() and sidebarPanel() so that assistive technologies can recognize them as ‚Äúmain‚Äù and ‚Äúcomplementary‚Äù region respectively. (#3009)\nClosed #2844: Added lang argument to ui *Page() functions (e.g., fluidPage, bootstrapPage) that specifies document-level language within the app for the accessibility of screen readers and search-engine parsers. By default, it is set to empty string which is commonly recognized as a browser‚Äôs default locale. (#2920)\nImproved accessibility for radioButtons() and checkboxGroupInput(): All options are now grouped together semantically for assistive technologies. (thanks @jooyoungseo, #3187).\n\n\n\nMinor new features and improvements\n\nAdded support for Shiny Developer Mode. Developer Mode enables a number of options() to make a developer‚Äôs life easier, like enabling non-minified JS and printing messages about deprecated functions and options. See ?devmode() for more details. (#3174)\nNew reactiveConsole() makes it easier to interactively experiment with reactivity at the console (#2518).\nWhen UI is specified as a function (e.g.¬†ui &lt;- function(req) { ... }), the response can now be an HTTP response as returned from the (newly exported) httpResponse() function. (#2970)\nselectInput and selectizeInput now warn about performance implications when thousands of choices are used, and recommend server-side selectize be used instead. (#2959)\nClosed #2980: addResourcePath() now allows paths with a leading . (thanks to @ColinFay). (#2981)\nClosed #2972: runExample() now supports the shiny.port option (thanks to @ColinFay). (#2982)\nClosed #2692: downloadButton() icon can now be changed via the icon parameter (thanks to @ColinFay). (#3010)\nClosed #2984: improved documentation for renderCachedPlot() (thanks to @aalucaci). (#3016)\nreactiveValuesToList() will save its reactlog label as reactiveValuesToList(&lt;ID&gt;) vs as.list(&lt;ID&gt;) (#3017)\nRemoved unused (and non-exported) cacheContext class.\ntestServer() can accept a single server function as input (#2965).\nshinyOptions() now has session-level scoping, in addition to global and application-level scoping. (#3080)\nrunApp() now warns when running an application in an R package directory. (#3114)\nShiny now uses cache_mem from the cachem package, instead of memoryCache and diskCache. (#3118)\nClosed #3140: Added support for ... argument in icon(). (#3143)\nClosed #629: All update* functions now have a default value for session, and issue an informative warning if it is missing. (#3195, #3199)\nImproved error messages when reading reactive values outside of a reactive domain (e.g., reactiveVal()()). (#3007)\n\n\n\nBug fixes\n\nFixed #1942: Calling runApp(\"app.R\") no longer ignores options passed into shinyApp(). This makes it possible for Shiny apps to specify what port/host should be used by default. (#2969)\nFixed #3033: When a DiskCache was created with both max_n and max_size, too many items could get pruned when prune() was called. (#3034)\nFixed #2703: Fixed numerous issues with some combinations of min/value/max causing issues with date[Range]Input() and updateDate[Range]Input(). (#3038, #3201)\nFixed #2936: dateYMD was giving a warning when passed a vector of dates from dateInput which was greater than length 1. The length check was removed because it was not needed. (#3061)\nFixed #2266, #2688: radioButtons and updateRadioButtons now accept character(0) to indicate that none of the options should be selected (thanks to @ColinFay). (#3043)\nFixed a bug that textAreaInput() doesn‚Äôt work as expected for relative width (thanks to @shrektan). (#2049)\nFixed #2859: renderPlot() wasn‚Äôt correctly setting showtext::showtext_opts()‚Äôs dpi setting with the correct resolution on high resolution displays; which means, if the font was rendered by showtext, font sizes would look smaller than they should on such displays. (#2941)\nClosed #2910, #2909, #1552: sliderInput() warns if the value is outside of min and max, and errors if value is NULL or NA. (#3194)\n\n\n\nLibrary updates\n\nRemoved html5shiv and respond.js, which were used for IE 8 and IE 9 compatibility. (#2973)"
  },
  {
    "objectID": "r/reference/shiny/1.4.0/upgrade.html#full-changelog",
    "href": "r/reference/shiny/1.4.0/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 1.4.0",
    "section": "Full changelog",
    "text": "Full changelog\n\nBreaking changes\n\nResolved #2554: Upgraded jQuery from v.1.12.4 to v3.4.1 and bootstrap from v3.3.7 to v3.4.1. (#2557). Since the jQuery upgrade may introduce breaking changes to user code, there is an option to switch back to the old version by setting options(shiny.jquery.version = 1). If you‚Äôve hard-coded shared/jquery[.min].js in the HTML of your Shiny app, in order to downgrade, you‚Äôll have to change that filepath to shared/legacy/jquery[.min].js.\n\n\n\nImprovements\n\nResolved #1433: plotOutput()‚Äôs coordmap info now includes discrete axis limits for ggplot2 plots. As a result, any shinytest tests that contain ggplot2 plots with discrete axes (that were recorded before this change) will now report differences that can safely be updated. This new coordmap info was added to correctly infer what data points are within an input brush and/or near input click/hover in scenarios where a non-trivial discrete axis scale is involved (e.g., whenever scale_[x/y]_discrete(limits = ...) and/or free scales across multiple discrete axes are used). (#2410)\nResolved #2402: An informative warning is now thrown for mis-specified (date) strings in dateInput(), updateDateInput(), dateRangeInput(), and updateDateRangeInput(). (#2403)\nIf the shiny.autoload.r option is set to TRUE, all files ending in .r or .R contained in a directory named R/ adjacent to your application are sourced when your app is started. This will become the default Shiny behavior in a future release (#2547)\nResolved #2442: The shiny:inputchanged JavaScript event now triggers on the related input element instead of document. Existing event listeners bound to document will still detect the event due to event bubbling. (#2446)\nFixed #1393, #2223: For plots with any interactions enabled, the image is no longer draggable. (#2460)\nResolved #2469: renderText now takes a sep argument that is passed to cat. (#2497)\nAdded resourcePaths() and removeResourcePaths() functions. (#2459)\nResolved #2433: An informative warning is now thrown if subdirectories of the app‚Äôs www/ directory are masked by other resource prefixes and/or the same resource prefix is mapped to different local file paths. (#2434)\nResolved #2478: cmd + shift + f3 and ctrl + shift + f3 can now be used to add a reactlog mark. If reactlog keybindings are used and the reactlog is not enabled, an error page is displayed showing how to enable reactlog recordings. (#2560)\n\n\n\nBug fixes\n\nPartially resolved #2423: Reactivity in Shiny leaked some memory, because R can leak memory whenever a new symbols is interned, which happens whenever a new name/key is used in an environment. R now uses the fastmap package, which avoids this problem. (#2429)\nFixed #2267: Fixed a memory leak with invalidateLater. (#2555)\nFixed #1548: The reactivePoll function leaked an observer; that is the observer would continue to exist even if the reactivePoll object was no longer accessible. #2522\nFixed #2116: Fixed an issue where dynamic tabs could not be added when on a hosted platform. (#2545)\nResolved #2515: selectInput() and selectizeInput() now deal appropriately with named factors. Note that updateSelectInput() and updateSelectizeInput() do not yet handle factors; their behavior is unchanged. (#2524, #2540, #2625)\nResolved #2471: Large file uploads to a Windows computer were slow. (#2579)\nFixed #2387: Updating a sliderInput()‚Äôs type from numeric to date no longer changes the rate policy from debounced to immediate. More generally, updating an input binding with a new type should (no longer) incorrectly alter the input rate policy. (#2404)\nFixed #868: If an input is initialized with a NULL label, it can now be updated with a string. Moreover, if an input label is initialized with a string, it can now be removed by updating with label=character(0) (similar to how choices and selected can be cleared in updateSelectInput()). (#2406)\nFixed #2250: updateSliderInput() now works with un-specified (or zero-length) min, max, and value. (#2416)\nFixed #2396: selectInput(\"myID\", ...) resulting in an extra myID-selectized input (introduced in v1.2.0). (#2418)\nFixed #2233: verbatimTextOutput() produced wrapped text on Safari, but the text should not be wrapped. (#2353)\nFixed #2335: When dateInput()‚Äôs value was unspecified, and max and/or min was set to Sys.Date(), the value was not being set properly. (#2526)\nFixed #2591: Providing malformed date-strings to min or max no longer results in JS errors for dateInput() and dateRangeInput(). (#2592)\nFixed rstudio/reactlog#36: Changes to reactive values not displaying accurately in reactlog. (#2424)\nFixed #2598: Showcase files don‚Äôt appear with a wide window. (#2582)"
  },
  {
    "objectID": "r/reference/shiny/1.3.1/upgrade.html#full-changelog",
    "href": "r/reference/shiny/1.3.1/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 1.3.1",
    "section": "Full changelog",
    "text": "Full changelog\n\nBug fixes"
  },
  {
    "objectID": "r/reference/shiny/1.2.0/upgrade.html",
    "href": "r/reference/shiny/1.2.0/upgrade.html",
    "title": "Upgrade notes for Shiny 1.2.0",
    "section": "",
    "text": "This release features plot caching, an important new tool for improving performance and scalability. Using renderCachedPlot in place of renderPlot can greatly improve responsiveness for apps that show the same plot many times (for example, a dashboard or report where all users view the same data). Shiny gives you a fair amount of control in where the cache is stored and how cached plots are invalidated, so be sure to read this article to get the most out of this feature."
  },
  {
    "objectID": "r/reference/shiny/1.2.0/upgrade.html#full-changelog",
    "href": "r/reference/shiny/1.2.0/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 1.2.0",
    "section": "Full changelog",
    "text": "Full changelog\n\nBreaking changes\n\nThe URL paths for FontAwesome CSS/JS/font assets have changed, due to our upgrade from FontAwesome 4 to 5. This shouldn‚Äôt affect you unless you‚Äôre using www/index.html to provide your UI and have hardcoded the old FontAwesome paths into your HTML. If that‚Äôs you, consider switching to HTML templates, which give you the syntax of raw HTML while still taking advantage of Shiny‚Äôs automatic management of web dependencies.\n\n\n\nNew features\n\nAdded renderCachedPlot(), which stores plots in a cache so that they can be served up almost instantly. (#1997)\n\n\n\nMinor new features and improvements\n\nUpgrade FontAwesome from 4.7.0 to 5.3.1 and made icon tags browsable, which means they will display in a web browser or RStudio viewer by default (#2186). Note that if your application or library depends on FontAwesome directly using custom CSS, you may need to make some or all of the changes recommended in Upgrade from Version 4. Font Awesome icons can also now be used in static R Markdown documents.\nAddress #174: Added datesdisabled and daysofweekdisabled as new parameters to dateInput(). This resolves #174 and exposes the underlying arguments of Bootstrap Datepicker. datesdisabled expects a character vector with values in yyyy/mm/dd format and daysofweekdisabled expects an integer vector with day interger ids (Sunday=0, Saturday=6). The default value for both is NULL, which leaves all days selectable. Thanks, @nathancday! (#2147)\nSupport for selecting variables of a data frame with the output values to be used within tidy evaluation. Added functions: varSelectInput, varSelectizeInput, updateVarSelectInput, updateVarSelectizeInput. (#2091)\nAddressed #2042: dates outside of min/max date range are now a lighter shade of grey to highlight the allowed range. (#2087)\nAdded support for plot interaction when the plot is scaled. (#2125)\nFixed #1933: extended server-side selectize to lists and optgroups. (#2102)\nAdded namespace support when freezing reactiveValue keys. #2080\nUpgrade selectize.js from 0.12.1 to 0.12.4 #2028\nAddressed #2079: Added coords_img, coords_css, and img_css_ratio fields containing x and y location information for plot brush, hover, and click events. #2183\n\n\n\nBug fixes\n\nFixed #2033: RStudio Viewer window not closed on shiny::stopApp(). Thanks, @vnijs! #2047\nFixed #1935: correctly returns plot coordinates when using outer margins. (#2108)\nResolved #2019: updateSliderInput now changes the slider formatting if the input type changes. (#2099)\nFixed #2138: Inputs that are part of a renderUI were no longer restoring correctly from bookmarked state. #2139\nFixed #2093: Make sure bookmark scope directory does not exist before trying to create it. #2168\nFixed #2177: The session name is now being recorded when exiting a context. Multiple sessions can now view their respective reactlogs. #2180\nFixed #2162: selectInput was sending spurious duplicate values to the server when using backspace. Thanks, @sada1993! #2187\nFixed #2142: Dropping files on fileInputs stopped working on recent releases of Firefox. Thanks @dmenne for reporting! #2203\nFixed #2204: updateDateInput could set the wrong date on days where DST begins. (Thanks @GaGaMan1101!) #2212\nFixed #2225: Input event queue can stall in apps that use async. #2226\nFixed #2228: reactiveTimer fails when not owned by a session. Thanks, @P-Bettega! #2229\n\n\n\nDocumentation Updates\n\nAddressed #1864 by changing optgroup documentation to use list instead of c. (#2084)"
  },
  {
    "objectID": "r/reference/shiny/1.0.5/upgrade.html#full-changelog",
    "href": "r/reference/shiny/1.0.5/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 1.0.5",
    "section": "Full changelog",
    "text": "Full changelog\n\nBug fixes\n\nFixed #1818: conditionalPanel() expressions that have a newline character in them caused the application to not work. (#1820)\nAdded a safe wrapper function for internal calls to jsonlite::fromJSON(). (#1822)"
  },
  {
    "objectID": "r/reference/shiny/1.0.3/upgrade.html",
    "href": "r/reference/shiny/1.0.3/upgrade.html",
    "title": "Upgrade notes for Shiny 1.0.3",
    "section": "",
    "text": "This is a hotfix release of Shiny. With previous versions of Shiny, when running an application on the newly-released version of R, 3.4.0, it would print a message: Warning in body(fun) : argument is not a function. This has no effect on the application, but because the message could be alarming to users, we are releasing a new version of Shiny that fixes this issue."
  },
  {
    "objectID": "r/reference/shiny/1.0.3/upgrade.html#full-changelog",
    "href": "r/reference/shiny/1.0.3/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 1.0.3",
    "section": "Full changelog",
    "text": "Full changelog\n\nBug fixes\n\nFixed #1672: When an error occurred while uploading a file, the progress bar did not change colors. (#1673)"
  },
  {
    "objectID": "r/reference/shiny/1.0.1/upgrade.html",
    "href": "r/reference/shiny/1.0.1/upgrade.html",
    "title": "Upgrade notes for Shiny 1.0.1",
    "section": "",
    "text": "This is a maintenance release of Shiny, mostly aimed at fixing bugs and introducing minor features. The most notable additions in this version of Shiny are the introduction of the reactiveVal() function (it‚Äôs like reactiveValues(), but it only stores a single value), and that the choices of radioButtons() and checkboxGroupInput() can now contain HTML content instead of just plain text."
  },
  {
    "objectID": "r/reference/shiny/1.0.1/upgrade.html#full-changelog",
    "href": "r/reference/shiny/1.0.1/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 1.0.1",
    "section": "Full changelog",
    "text": "Full changelog\n\nBreaking changes\n\nThe functions radioButtons(), checkboxGroupInput() and selectInput() (and the corresponding updateXXX() functions) no longer accept a selected argument whose value is the name of a choice, instead of the value of the choice. This feature had been deprecated since Shiny 0.10 (it printed a warning message, but still tried to match the name to the right choice) and it‚Äôs now completely unsupported.\n\n\n\nNew features\n\nAdded reactiveVal function, for storing a single value which can be (reactively) read and written. Similar to reactiveValues, except that reactiveVal just lets you store a single value instead of storing multiple values by name. (#1614)\n\n\n\nMinor new features and improvements\n\nAddressed #1348 and #1437 by adding two new arguments to radioButtons() and checkboxGroupInput(): choiceNames (list or vector) and choiceValues (list or vector). These can be passed in as an alternative to choices, with the added benefit that the elements in choiceNames can be arbitrary UI (i.e.¬†anything created by HTML() and the tags() functions, like icons and images). While the underlying values for each choice (passed in through choiceValues) must still be simple text, their visual representation on the app (what the user actually clicks to select a different option) can be any valid HTML element. See ?radioButtons for a small example. (#1521)\nUpdated tools/README.md with more detailed instructions. (##1616)\nFixed #1565, which meant that resources with spaces in their names return HTTP 404. (#1566)\nExported session$user (if it exists) to the client-side; it‚Äôs accessible in the Shiny object: Shiny.user. (#1563)\nAdded support for HTML5‚Äôs pushState which allows for pseudo-navigation in shiny apps. For more info, see the documentation (?updateQueryString and ?getQueryString). (#1447)\nFixed #1121: plot interactions with ggplot2 now support coord_fixed(). (#1525)\nAdded snapshotExclude function, which marks an output so that it is not recorded in a test snapshot. (#1559)\nAdded shiny:filedownload JavaScript event, which is triggered when a downloadButton or downloadLink is clicked. Also, the values of downloadHandlers are not recorded in test snapshots, because the values change every time the application is run. (#1559)\nAdded support for plot interactions with ggplot2 &gt; 2.2.1. (#1578)\nFixed #1577: Improved escapeHTML (util.js) in terms of the order dependency of replacing, XSS risk attack and performance. (#1579)\nThe shiny:inputchanged JavaScript event now includes two new fields, binding and el, which contain the input binding and DOM element, respectively. Additionally, Shiny.onInputChange() now accepts an optional argument, opts, which can contain the same fields. (#1596)\nThe NS() function now returns a vectorized function. (#1613)\nFixed #1617: fileInput can have customized text for the button and the placeholder. (#1619)\n\n\n\nBug fixes\n\nFixed #1511: fileInputs did not trigger the shiny:inputchanged event on the client. Also removed shiny:fileuploaded JavaScript event, because it is no longer needed after this fix. (#1541, #1570)\nFixed #1472: With a Progress object, calling set(value=NULL) made the progress bar go to 100%. Now it does not change the value of the progress bar. The documentation also incorrectly said that setting the value to NULL would hide the progress bar. (#1547)\nFixed #162: When a dynamically-generated input changed to a different inputType, it might be incorrectly deduplicated. (#1594)\nRemoved redundant call to inputs.setInput. (#1595)\nFixed bug where dateRangeInput did not respect weekstart argument. (#1592)\nFixed #1598: setBookmarkExclude() did not work properly inside of modules. (#1599)\nFixed #1605: sliders did not move when clicked on the bar area. (#1610)\nFixed #1621: if a reactiveTimer‚Äôs session was closed before the first time that the reactiveTimer fired, then the reactiveTimer would not get cleared and would keep firing indefinitely. (#1623)\n\n\n\nLibrary updates"
  },
  {
    "objectID": "r/reference/shiny/0.14/upgrade.html",
    "href": "r/reference/shiny/0.14/upgrade.html",
    "title": "Upgrade notes for Shiny 0.14",
    "section": "",
    "text": "A new Shiny release is upon us! There are many new exciting features, bug fixes, and library updates. We‚Äôll just highlight the most important changes here, but you can browse through the full changelog below for details. This will likely be the last release before shiny 1.0, so get out your party hats!"
  },
  {
    "objectID": "r/reference/shiny/0.14/upgrade.html#bookmarkable-state",
    "href": "r/reference/shiny/0.14/upgrade.html#bookmarkable-state",
    "title": "Upgrade notes for Shiny 0.14",
    "section": "Bookmarkable state",
    "text": "Bookmarkable state\nShiny now supports bookmarkable state: users can save the state of an application and get a URL which will restore the application with that state. There are two types of bookmarking: encoding the state in a URL, and saving the state to the server. With an encoded state, the entire state of the application is contained in the URL‚Äôs query string. You can see this in action with this app: https://gallery.shinyapps.io/113-bookmarking-url/. An example of a bookmark URL for this app is https://gallery.shinyapps.io/113-bookmarking-url/?_inputs_&n=200. When the state is saved to the server, the URL might look something like: https://gallery.shinyapps.io/bookmark-saved/?_state_id_=d80625dc681e913a (note that this URL is not for an active app).\nImportant note:\n\nSaved-to-server bookmarking currently works with Shiny Server Open Source. Support on Shiny Server Pro, RStudio Connect, and shinyapps.io is under development and testing. However, URL-encoded bookmarking works on all hosting platforms.\n\nSee this article to get started with bookmarkable state. There is also an advanced-level article (for apps that have a complex state), and a modules article that details how to use bookmarking in conjunction with modules."
  },
  {
    "objectID": "r/reference/shiny/0.14/upgrade.html#notifications",
    "href": "r/reference/shiny/0.14/upgrade.html#notifications",
    "title": "Upgrade notes for Shiny 0.14",
    "section": "Notifications",
    "text": "Notifications\nShiny can now display notifications on the client browser by using the showNotification() function. Use this demo app to play around with the notification API. Here‚Äôs a screenshot of a very simple notification (shown when the button is clicked):\n\n\n\nHere‚Äôs our article about it, and the reference documentation."
  },
  {
    "objectID": "r/reference/shiny/0.14/upgrade.html#progress-indicators",
    "href": "r/reference/shiny/0.14/upgrade.html#progress-indicators",
    "title": "Upgrade notes for Shiny 0.14",
    "section": "Progress indicators",
    "text": "Progress indicators\nIf your Shiny app contains computations that take a long time to complete, a progress bar can improve the user experience by communicating how far along the computation is, and how much is left. Progress bars were added in Shiny 0.10.2. In Shiny 0.14, they were changed to use the notifications system, which gives them a different look.\nImportant note:\n\nIf you were already using progress bars and had customized them with your own CSS, you can add the style = \"old\" argument to your withProgress() call (or Progress$new()). This will result in the same appearance as before. You can also call shinyOptions(progress.style = \"old\") in your app‚Äôs server function to make all progress indicators use the old styling.\n\nTo see new progress bars in action, see this app in the gallery. You can also learn more about this in our article and in the reference documentation (either for the easier withProgress functional API or the more complicated, but more powerful, Progress object-oriented API."
  },
  {
    "objectID": "r/reference/shiny/0.14/upgrade.html#reconnection",
    "href": "r/reference/shiny/0.14/upgrade.html#reconnection",
    "title": "Upgrade notes for Shiny 0.14",
    "section": "Reconnection",
    "text": "Reconnection\nShiny can now automatically reconnect to your Shiny session if you temporarily lose network access."
  },
  {
    "objectID": "r/reference/shiny/0.14/upgrade.html#modal-windows",
    "href": "r/reference/shiny/0.14/upgrade.html#modal-windows",
    "title": "Upgrade notes for Shiny 0.14",
    "section": "Modal windows",
    "text": "Modal windows\nShiny has now built-in support for displaying modal dialogs like the one below (live app here):\n\n\n\nTo learn more about this, read our article and the reference documentation."
  },
  {
    "objectID": "r/reference/shiny/0.14/upgrade.html#insertui-and-removeui",
    "href": "r/reference/shiny/0.14/upgrade.html#insertui-and-removeui",
    "title": "Upgrade notes for Shiny 0.14",
    "section": "insertUI and removeUI",
    "text": "insertUI and removeUI\nSometimes in a Shiny app, arbitrary HTML UI may need to be created on-the-fly in response to user input. The existing uiOutput and renderUI functions let you continue using reactive logic to call UI functions and make the results appear in a predetermined place in the UI. The insertUI and removeUI functions, which are used in the server code, allow you to use imperative logic to add and remove arbitrary chunks of HTML (all independent from one another), as many times as you want, whenever you want, wherever you want. This option may be more convenient when you want to, for example, add a new model to your app each time the user selects a different option (and leave previous models unchanged, rather than substitute the previous one for the latest one).\nSee this simple demo app of how one could use insertUI and removeUI to insert and remove text elements using a queue. Also see this other app that demonstrates how to insert and remove a few common Shiny input objects. Finally, this app shows how to dynamically insert modules using insertUI.\nFor more, read our article about dynamic UI generation and the reference documentation about insertUI and removeUI."
  },
  {
    "objectID": "r/reference/shiny/0.14/upgrade.html#documentation-for-connecting-to-an-external-database",
    "href": "r/reference/shiny/0.14/upgrade.html#documentation-for-connecting-to-an-external-database",
    "title": "Upgrade notes for Shiny 0.14",
    "section": "Documentation for connecting to an external database",
    "text": "Documentation for connecting to an external database\nMany Shiny users have asked about best practices for accessing external databases from their Shiny applications. Although database access has long been possible using various database connector packages in R, it can be challenging to use them robustly in the dynamic environment that Shiny provides. So far, it has been mostly up to application authors to find the appropriate database drivers and to discover how to manage the database connections within an application. In order to demystify this process, we wrote a series of articles (first one here) that covers the basics of connecting to an external database, as well as some security precautions to keep in mind (e.g.¬†how to avoid SQL injection attacks).\nThere are a few packages that you should look at if you‚Äôre using a relational database in a Shiny app: the dplyr and DBI packages (both featured in the article linked to above), and the brand new pool package, which provides a further layer of abstraction to make it easier and safer to use either DBI or dplyr. pool is not yet on CRAN. In particular, pool will take care of managing connections, preventing memory leaks, and ensuring the best performance. See this pool basics article and the more advanced-level article if you‚Äôre feeling adventurous! (Both of these articles contain Shiny app examples that use DBI to connect to an external MySQL database.) If you are more comfortable with dplyr than DBI, don‚Äôt miss the article about the integration of pool and dplyr.\nIf you‚Äôre new to databases in the Shiny world, we recommend using dplyr and pool if possible. If you need greater control than dplyr offers (for example, if you need to modify data in the database or use transactions), then use DBI and pool. The pool package was introduced to make your life easier, but in no way constrains you, so we don‚Äôt envision any situation in which you‚Äôd be better off not using it. The only caveat is that pool is not yet on CRAN, so you may prefer to wait for that."
  },
  {
    "objectID": "r/reference/shiny/0.14/upgrade.html#others",
    "href": "r/reference/shiny/0.14/upgrade.html#others",
    "title": "Upgrade notes for Shiny 0.14",
    "section": "Others",
    "text": "Others\nThere are many more minor features, small improvements, and bug fixes than we can cover here, so we‚Äôll just mention a few of the more noteworthy ones (the full changelog, with links to all the relevant issues and pull requests, is right below this section):\n\nError Sanitization: you now have the option to sanitize error messages; in other words, the content of the original error message can be suppressed so that it doesn‚Äôt leak any sensitive information. To sanitize errors everywhere in your app, just add options(shiny.sanitize.errors = TRUE) somewhere in your app. Read this article for more, or play with the demo app.\nCode Diagnostics: if there is an error parsing ui.R, server.R, app.R, or global.R, Shiny will search the code for missing commas, extra commas, and unmatched braces, parens, and brackets, and will print out messages pointing out those problems. (#1126)\nReactlog visualization: by default, the showReactLog() function (which brings up the reactive graph) also displays the time that each reactive and observer were active for:\n\n\n\nThis new feature can be turned off with showReactLog(time = FALSE). This may be convenient if you have a large graph and don‚Äôt want to have this new information cluttering it up. The elapsed time info shows up above each relevant node‚Äôs label, and the time is also coded by color: the slowest reactive will be dark red and the fastest will be light red.\nAdditionally, to organize the graph, you can now drag any of the nodes to a specific position and leave it there.\nNicer-looking tables: we‚Äôve made tables generated with renderTable() look cleaner and more modern. While this won‚Äôt break any older code, the finished look of your table will be quite a bit different, as the following image shows:\n\n\n\nFor more, read our short article about this update, experiment with all the new features in this demo app, or check out the reference documentation."
  },
  {
    "objectID": "r/reference/shiny/0.14/upgrade.html#full-changelog",
    "href": "r/reference/shiny/0.14/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 0.14",
    "section": "Full changelog",
    "text": "Full changelog\n\nBreaking changes\n\nProgress indicators can now either use the new notification API, using style = \"notification\" (default), or be displayed with the previous styling, using style = \"old\". You can also call shinyOptions(progress.style = \"old\") in the server function to make all progress indicators use the old styling. Note that if you had customized your progress indicators with additional CSS, you‚Äôll need to use the old style if you want your UI to look the same (#1160 and #1329).\nClosed #1161: Deprecated the position argument to tabsetPanel() since Bootstrap 3 stopped supporting this feature.\nThe long-deprecated ability to pass a func argument to many of the render functions has been removed.\n\n\n\nNew features\n\nAdded the ability to bookmark and restore application state. (main PR: #1209)\nAdded a new notification API. From R, there are new functions showNotification and hideNotification. From JavaScript, there is a new Shiny.notification object that controls notifications. (#1141)\nProgress indicators now use the notification API. (#1160)\nAdded the ability for the client browser to reconnect to a new session on the server, by setting session$allowReconnect(TRUE). This requires a version of Shiny Server that supports reconnections. (#1074)\nAdded modal dialogs. (#1157)\nAdded insertUI and removeUI functions to be able to add and remove chunks of UI, standalone, and all independent of one another. (#1174 and #1189)\nImproved renderTable() function to make the tables look prettier and also provide the user with a lot more parameters to customize their tables with. (#1129)\nAdded support for the pool package (use Shiny‚Äôs timer/scheduler). (#1226)\n\n\n\nMinor new features and improvements\n\nAdded cancelOutput argument to req(). This causes the currently executing reactive to cancel its execution, and leave its previous state alone (as opposed to clearing the output). (#1272)\nDisplay: Showcase now displays the .js, .html and .css files in the www directory by default. In order to use showcase mode and not display these, include a new line in your Description file: IncludeWWW: False. (#1185)\nAdded an error sanitization option: options(shiny.sanitize.errors = TRUE). By default, this option is FALSE. When TRUE, normal errors will be sanitized, displaying only a generic error message. This changes the look of an app when errors are printed (but the console log remains the same). (#1156)\nAdded the option of passing arguments to an xxxOutput() function through the corresponding renderXXX() function via an outputArgs parameter to the latter. This is only valid for snippets of Shiny code in an interactive runtime: shiny Rmd document (never for full apps, even if embedded in an Rmd). (#1443)\nAdded updateActionButton() function, so the user can change an actionButton‚Äôs (or actionLink‚Äôs) label and/or icon. It also checks that the icon argument (for both creation and updating of a button) is valid and throws a warning otherwise. (#1134)\nAdded code diagnostics: if there is an error parsing ui.R, server.R, app.R, or global.R, Shiny will search the code for missing commas, extra commas, and unmatched braces, parens, and brackets, and will print out messages pointing out those problems. (#1126)\nAdded support for horizontal dividers in navbarMenu. (#1147)\nAdded placeholder option to passwordInput. (#1152)\nAdded session$resetBrush(brushId) (R) and Shiny.resetBrush(brushId) (JS) to programatically clear brushes from imageOutput/plotOutput. (#1197)\nAdded textAreaInput. (thanks, @nuno-agostinho! #1300)\nAdded session$sendBinaryMessage(type, message) method for sending custom binary data to the client. See ?session. (thanks, @daef! #1316 and #1320)\nAlmost all code examples now have a runnable example with shinyApp(), so that users can run the examples and see them in action. (#1158)\nWhen resized, plots are drawn with replayPlot(), instead of re-executing all plotting code. This results in faster plot rendering. (#1112)\nExported the isTruthy() function. (part of PR #1272)\nReactive log now shows elapsed time for reactives and observers. (#1132)\nNodes in the reactlog visualization are now sticky if the user drags them. (#1283)\n\n\n\nBug fixes\n\nFixed #1350: Highlighting of reactives didn‚Äôt work in showcase mode.\nFixed #1331: renderPlot() now correctly records and replays plots when execOnResize = FALSE.\nupdateDateInput() and updateDateRangeInput() can now clear the date input fields. (thanks, @gaborcsardi! #1299, #1315 and #1317)\nFixed #561: DataTables previously might pop up a warning when the data was updated extremely frequently.\nFixed #776: In some browsers, plots sometimes flickered when updated.\nFixed #543 and #855: When navbarPage() had a navbarMenu() as the first item, it did not automatically select an item.\nFixed #970: navbarPage() previously did not have an option to set the selected tab.\nFixed #1253: Memory could leak when an observer was destroyed without first being invalidated.\nFixed #931: Nested observers could leak memory.\nFixed #1144: updateRadioButton() and updateCheckboxGroupInput() broke controls when used in modules (thanks, @sipemu!).\nFixed #1093: updateRadioButtons() and updateCheckboxGroupInput() didn‚Äôt work if choices was numeric vector.\nFixed #1122: downloadHandler() popped up empty browser window if the file wasn‚Äôt present. It now gives a 404 error code.\nFixed #1278: Reactive system was being flushed too often (usually this just means a more-expensive no-op than necessary).\nFixed #803 and #1179: handling malformed dates in dateInput and updateDateInput().\nFixed #1257: updateSelectInput() didn‚Äôt work correctly in IE 11 and Edge.\nFixed #971: runApp() would give confusing error if port was not numeric.\nShiny now avoids using ports that Chrome deems unsafe. (#1222)\nAdded workaround for quartz graphics device resolution bug, where resolution is hard-coded to 72 ppi.\n\n\n\nLibrary updates\n\nUpdated to ion.RangeSlider 2.1.2.\nUpdated to Font Awesome 4.6.3.\nUpdated to Bootstrap 3.3.7."
  },
  {
    "objectID": "r/reference/shiny/0.14.1/upgrade.html",
    "href": "r/reference/shiny/0.14.1/upgrade.html",
    "title": "Upgrade notes for Shiny 0.14.1",
    "section": "",
    "text": "This is a maintenance release of Shiny, with some bug fixes and minor new features."
  },
  {
    "objectID": "r/reference/shiny/0.14.1/upgrade.html#full-changelog",
    "href": "r/reference/shiny/0.14.1/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 0.14.1",
    "section": "Full changelog",
    "text": "Full changelog\n\nMinor new features and improvements\n\nRestored file inputs are now copied on restore, so that the restored application can‚Äôt modify the bookmarked file. (#1370)\nAdded support for plot interaction in the development version of ggplot2, 2.1.0.9000. Also added support for ggplot2 plots with coord_flip() (in the development version of ggplot2). (hadley/ggplot2#1781, #1392)\n\n\n\nBug fixes\n\nFixed #1093 better: updateRadioButtons() and updateCheckboxGroupInput() were not working correctly if the choices were given as a numeric vector. This had been solved in #1291, but that introduced a different bug #1396 that this better fix avoids. (#1370)\nFixed #1368: If an app with a file input was bookmarked and restored, and then the restored app was bookmarked and restored (without uploading a new file), then it would fail to restore the file the second time. (#1370)\nFixed #1369: sliderInput() did not allow showing numbers without a thousands separator.\nFixed #1346 and #1107 : jQuery UI‚Äôs datepicker conflicted with the bootstrap-datepicker used by Shiny‚Äôs dateInput() and dateRangeInput(). (#1374)\n\n\n\nLibrary updates\n\nUpdated to bootstrap-datepicker 1.6.4. (#1218, #1374)"
  },
  {
    "objectID": "r/reference/shiny/0.13.1/upgrade.html",
    "href": "r/reference/shiny/0.13.1/upgrade.html",
    "title": "Upgrade notes for Shiny 0.13.1",
    "section": "",
    "text": "flexCol did not work on RStudio for Windows or Linux.\nFixed RStudio debugger integration."
  },
  {
    "objectID": "r/reference/shiny/0.12.2/upgrade.html",
    "href": "r/reference/shiny/0.12.2/upgrade.html",
    "title": "Upgrade notes for Shiny 0.12.2",
    "section": "",
    "text": "GitHub changed URLs for gists from .tar.gz to .zip, so runGist was updated to work with the new URLs.\nCallbacks from the session object are now guaranteed to execute in the order in which registration occurred.\nMinor bugs in sliderInput‚Äôs animation behavior have been fixed. (#852)\nUpdated to ion.rangeSlider to 2.0.12.\nAdded shiny.minified option, which controls whether the minified version of shiny.js is used. Setting it to FALSe can be useful for debugging. (#826, #850)\nFixed an issue for outputting plots from ggplot objects which also have an additional class whose print method takes precedence over print.ggplot. (#840, 841)\nAdded width option to Shiny‚Äôs input functions. (#589, #834)\nAdded two alias functions of updateTabsetPanel() to update the selected tab: updateNavbarPage() and updateNavlistPanel(). (#881)\nAll non-base functions are now explicitly namespaced, to pass checks in R-devel."
  },
  {
    "objectID": "r/reference/shiny/0.12.0/upgrade.html",
    "href": "r/reference/shiny/0.12.0/upgrade.html",
    "title": "Upgrade notes for Shiny 0.12",
    "section": "",
    "text": "In addition to the changes listed in the NEWS file for Shiny 0.12.0, there is an infrastructure change that could affect existing Shiny apps.\n\nJSON serialization\nIn Shiny 0.12.0, we‚Äôve switched from RJSONIO to jsonlite. For the vast majority of users, this will result in no noticeable changes; however, if you use any packages in your Shiny apps which rely on the htmlwidgets, you will also need to update htmlwidgets to 0.4.0. Both of these packages will issue a message when loaded, if the other package needs to be upgraded.\nPOSIXt objects are now serialized to JSON in UTC8601 format (like ‚Äú2015-03-20T20:00:00Z‚Äù), instead of as seconds from the epoch. If you have a Shiny app which uses sendCustomMessage() to send datetime (POSIXt) objects, then you may need to modify your Javascript code to receive time data in this format.\n\n\nA note about Data Tables"
  },
  {
    "objectID": "r/reference/shiny/0.11.1/upgrade.html",
    "href": "r/reference/shiny/0.11.1/upgrade.html",
    "title": "Upgrade notes for Shiny 0.11.1",
    "section": "",
    "text": "Major client-side performance improvements for pages that have many conditionalPanels, tabPanels, and plotOutputs. (#693, #717, #723)\ntabPanels now use the title for value by default. This fixes a bug in which an icon in the title caused problems with a conditionalPanel‚Äôs test condition. (#725, #728)\nselectInput now has a size argument to control the height of the input box. (#729)\nnavbarPage no longer includes a first row of extra whitespace when header=NULL. (#722)\nselectInputs now use Bootstrap styling when selectize=FALSE. (#724)\nBetter vertical spacing of label for checkbox groups and radio buttons.\nselectInput correctly uses width for both selectize and non-selectize inputs. (#702)\nThe wrapper tag generated by htmlOutput and uiOutput can now be any type of HTML tag, instead of just span and div. Also, custom classes are now allowed on the tag. (#704)\nSlider problems in IE 11 and Chrome on touchscreen-equipped Windows computers have been fixed. (#700)\nSliders now work correctly with draggable panels. (#711)\nFixed arguments in fixedPanel. (#709)"
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson7/index.html",
    "href": "r/getstarted/shiny-basics/lesson7/index.html",
    "title": "Share your apps",
    "section": "",
    "text": "You can now build a useful Shiny app, but can you share it with others? This lesson will show you several ways to share your Shiny apps.\nWhen it comes to sharing Shiny apps, you have two basic options:",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Share your apps"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson7/index.html#share-as-r-scripts",
    "href": "r/getstarted/shiny-basics/lesson7/index.html#share-as-r-scripts",
    "title": "Share your apps",
    "section": "Share as R scripts",
    "text": "Share as R scripts\nAnyone with R can run your Shiny app. They will need a copy of your app.R file, as well as any supplementary materials used in your app (e.g., www folders or helpers.R files).\nTo send your files to another user, email the files (perhaps in a zip file) or host the files online.\nYour user can place the files into an app directory in their working directory. They can launch the app in R with the same commands you used on your computer.\n# install.packages(\"shiny\")\nlibrary(shiny)\nrunApp(\"census-app\")\n\n\n\nShiny has three built in commands that make it easy to use files that are hosted online: runUrl, runGitHub, and runGist.\n\nrunUrl\nrunUrl will download and launch a Shiny app straight from a weblink.\nTo use runURL:\n\nSave your Shiny app‚Äôs directory as a zip file\nHost that zip file at its own link on a web page. Anyone with access to the link can launch the app from inside R by running:\n\nlibrary(shiny)\nrunUrl( \"&lt;the weblink&gt;\")\n\n\nrunGitHub\nIf you don‚Äôt have your own web page to host the files at, you can host your the files for free at www.github.com.\nGitHub is a popular project hosting site for R developers since it does more than just host files. GitHub provides many features to support collaboration, such as issue trackers, wikis, and close integration with the git version control system. To use GitHub, you‚Äôll need to sign up (it‚Äôs free) and choose a user name.\nTo share an app through GitHub, create a project repository on GitHub. Then store your app.R file in the repository, along with any supplementary files that the app uses.\nYour users can launch your app by running:\nrunGitHub( \"&lt;your repository name&gt;\", \"&lt;your user name&gt;\")\n\n\nrunGist\nIf you want an anonymous way to post files online, GitHub offers a pasteboard service for sharing files at gist.github.com. You don‚Äôt need to sign up for a GitHub account to use this service. Even if you have a GitHub account, gist can be a simple, quick way to share Shiny projects.\nTo share your app as a gist:\n\nCopy and paste your app.R files to the gist web page.\nNote the URL that GitHub gives the gist.\n\nOnce you‚Äôve made a gist, your users can launch the app with runGist(\"&lt;gist number&gt;\") where \"&lt;gist number&gt;\" is the number that appears at the end of your Gist‚Äôs web address.\nHere is an example of an app hosted as a gist. You could launch this app with:\nrunGist(\"eb3470beb1c0252bd0289cbc89bcf36f\")",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Share your apps"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson7/index.html#share-as-a-web-page",
    "href": "r/getstarted/shiny-basics/lesson7/index.html#share-as-a-web-page",
    "title": "Share your apps",
    "section": "Share as a web page",
    "text": "Share as a web page\nAll of the above methods share the same limitation. They require your user to have R and Shiny installed on their computer.\nHowever, Shiny creates the perfect opportunity to share output with people who do not have R (and have no intention of getting it). Your Shiny app happens to be one of the most widely used communication tools in the world: a web page. If you host the app at its own URL, users can visit the app (and not need to worry about the code that generates it).\nIf you are familiar with web hosting or have access to an IT department, you can host your Shiny apps yourself.\nIf you‚Äôd prefer an easier experience or need support, Posit (formerly RStudio) offers three ways to host your Shiny app as a web page:\n\nshinyapps.io\nShiny Server\nPosit Connect\n\n\nShinyapps.io\nThe easiest way to turn your Shiny app into a web page is to use shinyapps.io, Posit‚Äôs hosting service for Shiny apps.\nshinyapps.io lets you upload your app straight from your R session to a server hosted by Posit. You have complete control over your app including server administration tools. You can find out more about shinyapps.io by visiting shinyapps.io.\n\n\nShiny Server\nShiny Server is a companion program to Shiny that builds a web server designed to host Shiny apps. It‚Äôs free, open source, and available from GitHub.\nShiny Server is a server program that Linux servers can run to host a Shiny app as a web page. To use Shiny Server, you‚Äôll need a Linux server that has explicit support for Ubuntu 12.04 or greater (64 bit) and CentOS/RHEL 5 (64 bit). If you are not using an explicitly supported distribution, you can still use Shiny Server by building it from source.\nYou can host multiple Shiny applications on multiple web pages with the same Shiny Server, and you can deploy the apps from behind a firewall.\nTo see detailed instructions for installing and configuring a Shiny Server, visit the Shiny Server guide.\n\n\nPosit Connect\nIf you use Shiny in a for-profit setting, you may want to give yourself the server tools that come with most paid server programs, such as\n\nPassword authentication\nSSL support\nAdministrator tools\nPriority support\n\nIf so, check out Posit Connect, a publishing platform for the work your teams create in R. Share Shiny applications, R Markdown reports, dashboards, plots, Jupyter Notebooks, and more in one convenient place. With Posit Connect, you can publish from the RStudio IDE with the push of a button and schedule execution of reports and flexible security policies.\nIf you‚Äôd like to learn more about Posit Connect and the features it offers, see here.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Share your apps"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson7/index.html#recap",
    "href": "r/getstarted/shiny-basics/lesson7/index.html#recap",
    "title": "Share your apps",
    "section": "Recap",
    "text": "Recap\nShiny apps are easy to share. You can share your app as a couple of R scripts, or as a fully functioning web app with its own URL. Each method has its own advantages.\nYou learned:\n\nAnyone can launch your app as long as they have a copy of R, Shiny, and a copy of your app‚Äôs files.\nrunUrl, runGitHub, and runGist make it simple to share and retrieve Shiny files from web links.\nYou can turn your app into a live web app at its own URL with shinyapps.io.\nYou can use the open source Shiny Server to build a Linux server that hosts Shiny apps.\nIf you need closer control, or want to manage large volumes of traffic, you can purchase Posit Connect from Posit.\n\nCongratulations. You‚Äôve worked through the entire Shiny development process. You can build a sophisticated, reactive app, deploy it, and share it with others. Users can interact with your data and follow your stories in a new way.\nThe next step is to practice, and then explore the advanced features of Shiny.\nThe Shiny Dev Center can help you along the way. It hosts a gallery of inspiring apps, along with the code that makes the apps.\nThe Shiny Dev Center also includes an articles section for continuing education. Each article examines an intermediate to advanced Shiny topic in depth.\nYou now know enough to build your own Shiny apps. See what you can do!",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Share your apps"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson5/index.html",
    "href": "r/getstarted/shiny-basics/lesson5/index.html",
    "title": "Use R scripts and data",
    "section": "",
    "text": "This lesson will show you how to load data, R Scripts, and packages to use in your Shiny apps. Along the way, you will build a sophisticated app that visualizes US Census data.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Use R scripts and data"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson5/index.html#counties.rds",
    "href": "r/getstarted/shiny-basics/lesson5/index.html#counties.rds",
    "title": "Use R scripts and data",
    "section": "counties.rds",
    "text": "counties.rds\ncounties.rds is a dataset of demographic data for each county in the United States, collected with the UScensus2010 R package. You can download it here.\nOnce you have the file,\n\nCreate a new folder named data in your census-app directory.\nMove counties.rds into the data folder.\n\nWhen you‚Äôre done, your census-app folder should look like this.\n\n\n\nThe dataset in counties.rds contains\n\nthe name of each county in the United States\nthe total population of the county\nthe percent of residents in the county who are White, Black, Hispanic, or Asian\n\ncounties &lt;- readRDS(\"census-app/data/counties.rds\")\nhead(counties)\n             name total.pop white black hispanic asian\n1 alabama,autauga     54571  77.2  19.3      2.4   0.9\n2 alabama,baldwin    182265  83.5  10.9      4.4   0.7\n3 alabama,barbour     27457  46.8  47.8      5.1   0.4\n4    alabama,bibb     22915  75.0  22.9      1.8   0.1\n5  alabama,blount     57322  88.9   2.5      8.1   0.2\n6 alabama,bullock     10914  21.9  71.0      7.1   0.2",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Use R scripts and data"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson5/index.html#helpers.r",
    "href": "r/getstarted/shiny-basics/lesson5/index.html#helpers.r",
    "title": "Use R scripts and data",
    "section": "helpers.R",
    "text": "helpers.R\nhelpers.R is an R script that can help you make choropleth maps, like the ones pictured above. A choropleth map is a map that uses color to display the regional variation of a variable. In our case, helpers.R will create percent_map, a function designed to map the data in counties.rds. You can download helpers.R here.\nhelpers.R uses the maps and mapproj packages in R. If you‚Äôve never installed these packages before, you‚Äôll need to do so before you make this app. Run\ninstall.packages(c(\"maps\", \"mapproj\"))\nSave helpers.R inside your census-app directory, like below.\n\n\n\nThe percent_map function in helpers.R takes five arguments:\n\n\n\n\n\n\n\nArgument\nInput\n\n\n\n\nvar\na column vector from the counties.rds dataset\n\n\ncolor\nany character string you see in the output of colors()\n\n\nlegend.title\nA character string to use as the title of the plot‚Äôs legend\n\n\nmax\nA parameter for controlling shade range (defaults to 100)\n\n\nmin\nA parameter for controlling shade range (defaults to 0)\n\n\n\nYou can use percent_map at the command line to plot the counties data as a choropleth map, like this.\nlibrary(maps)\nlibrary(mapproj)\nsource(\"census-app/helpers.R\")\ncounties &lt;- readRDS(\"census-app/data/counties.rds\")\npercent_map(counties$white, \"darkgreen\", \"% White\")\nNote: The code above assumes that census-app is a sub-directory in your working directory. Make certain to set your working directory as the parent directory for census-app. To change your working directory location, click on Session &gt; Set Working Directory &gt; Choose Directory‚Ä¶ in the RStudio menu bar.\npercent_map plots the counties data as a choropleth map. Here it will plot the percent of white residents in the counties in the color dark green.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Use R scripts and data"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson5/index.html#loading-files-and-file-paths",
    "href": "r/getstarted/shiny-basics/lesson5/index.html#loading-files-and-file-paths",
    "title": "Use R scripts and data",
    "section": "Loading files and file paths",
    "text": "Loading files and file paths\nTake a look at the above code. To use percent_map, we first ran helpers.R with the source function, and then loaded counties.rds with the readRDS function. We also ran library(maps) and library(mapproj).\nYou will need to ask Shiny to call the same functions before it uses percent_map in your app, but how you write these functions will change. Both source and readRDS require a file path, and file paths do not behave the same way in a Shiny app as they do at the command line.\nWhen Shiny runs the commands in server.R, it will treat all file paths as if they begin in the same directory as server.R. In other words, the directory that you save server.R in will become the working directory of your Shiny app.\nSince you saved helpers.R in the same directory as server.R, you can ask Shiny to load it with\nsource(\"helpers.R\")\nSince you saved counties.rds in a sub-directory (named data) of the directory that server.R is in, you can load it with.\ncounties &lt;- readRDS(\"data/counties.rds\")\nYou can load the maps and mapproj packages in the normal way with\nlibrary(maps)\nlibrary(mapproj)\nwhich does not require a file path.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Use R scripts and data"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson5/index.html#execution",
    "href": "r/getstarted/shiny-basics/lesson5/index.html#execution",
    "title": "Use R scripts and data",
    "section": "Execution",
    "text": "Execution\nShiny will execute all of these commands if you place them in your app.R script. However, where you place them will determine how many times they are run (or re-run), which will in turn affect the performance of your app, since Shiny will run some sections your app.R script more often than others.\nShiny will run the whole script the first time you call runApp. This causes Shiny to execute the server function.\n\n\n\nShiny saves the server function until a new user arrives. Each time a new user visits your app, Shiny runs the server function again, one time. The function helps Shiny build a distinct set of reactive objects for each user.\n\n\n\nAs users interact with the widgets and change their values, Shiny will re-run the R expressions assigned to each reactive object that depend on a widget whose value was changed. If your user is very active, these expressions may be re-run many, many times a second.\n\n\n\nHere‚Äôs what we‚Äôve learned so far:\n\nThe shinyApp function is run once, when you launch your app\nThe server function is run once each time a user visits your app\nThe R expressions inside render* functions are run many times. Shiny runs them once each time a user change the value of a widget.\n\nHow can you use this information?\nSource scripts, load libraries, and read data sets at the beginning of app.R outside of the server function. Shiny will only run this code once, which is all you need to set your server up to run the R expressions contained in server.\nDefine user specific objects inside server function, but outside of any render* calls. These would be objects that you think each user will need their own personal copy of. For example, an object that records the user‚Äôs session information. This code will be run once per user.\nOnly place code that Shiny must rerun to build an object inside of a render* function. Shiny will rerun all of the code in a render* chunk each time a user changes a widget mentioned in the chunk. This can be quite often.\nYou should generally avoid placing code inside a render function that does not need to be there. Doing so will slow down the entire app.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Use R scripts and data"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson5/index.html#your-turn-1",
    "href": "r/getstarted/shiny-basics/lesson5/index.html#your-turn-1",
    "title": "Use R scripts and data",
    "section": "Your Turn 1",
    "text": "Your Turn 1\nCopy and paste the following app.R file to your census-app directory. Then add\nsource(\"helpers.R\")\ncounties &lt;- readRDS(\"data/counties.rds\")\nlibrary(maps)\nlibrary(mapproj)\nto your app.R script. Be sure to place the commands in an efficient location.\nNote: This is the first of two steps that will complete your app. Choose the best place to insert the code above, but do not try to run the app. Your app will return an error until you replace # some arguments with real code in Your Turn 2.\n\nui.R\n# User interface ----\nui &lt;- page_sidebar(\n  title = \"censusVis\",\n\n  sidebar = sidebar(\n    helpText(\n      \"Create demographic maps with information from the 2010 US Census.\"\n    ),\n    selectInput(\n      \"var\",\n      label = \"Choose a variable to display\",\n      choices =\n        c(\n          \"Percent White\",\n          \"Percent Black\",\n          \"Percent Hispanic\",\n          \"Percent Asian\"\n        ),\n      selected = \"Percent White\"\n    ),\n    sliderInput(\n      \"range\",\n      label = \"Range of interest:\",\n      min = 0, \n      max = 100, \n      value = c(0, 100)\n    )\n  ),\n\n  card(plotOutput(\"map\"))\n)\n\n# Server logic ----\nserver &lt;- function(input, output) {\n  output$map &lt;- renderPlot({\n    percent_map( # some arguments )\n  })\n}\n\n# Run app ----\nshinyApp(ui, server)\n\n\nModel Answer 1\n\n\n\n\n\n\nView Answer\n\n\n\n\n\nSince your app only needs to load helpers.R and counties.rds once, they should go outside of the ui and server functions. This is also a good place to load the maps library (which percent_map uses).\nlibrary(maps)\nlibrary(mapproj)\nsource(\"helpers.R\")\ncounties &lt;- readRDS(\"data/counties.rds\")\n\n# User interface ----\nui &lt;- page_sidebar(\n  title = \"censusVis\",\n  sidebar = sidebar(\n    helpText(\n      \"Create demographic maps with information from the 2010 US Census.\"\n    ),\n    selectInput(\n      \"var\",\n      label = \"Choose a variable to display\",\n      choices =\n        c(\n          \"Percent White\",\n          \"Percent Black\",\n          \"Percent Hispanic\",\n          \"Percent Asian\"\n        ),\n      selected = \"Percent White\"\n    ),\n    sliderInput(\n      \"range\",\n      label = \"Range of interest:\",\n      min = 0,\n      max = 100,\n      value = c(0, 100)\n    ),\n  ),\n  card(plotOutput(\"map\"))\n)\n\n# Server logic ----\nserver &lt;- function(input, output) {\n  output$map &lt;- renderPlot({\n    percent_map( # some arguments )\n  })\n}\n\n# Run app ----\nshinyApp(ui, server)\nYou may wonder, ‚ÄúWon‚Äôt each user need their own copy of counties and percent_map?‚Äù (which would imply that the code should go inside of the server function). No, each user will not.\nKeep in mind that your user‚Äôs computer won‚Äôt run any of the R code in your Shiny app. In fact, their computer won‚Äôt even see the R code. The computer that you use as a server will run all of the R code necessary for all of your users. It will send the results over to your users as HTML elements.\nYour server can rely on a single global copy of counties.rds and percent_map to do all of the R execution necessary for all of the users. You only need to build a separate object for each user if the objects will have different values for each of your users.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Use R scripts and data"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson5/index.html#finishing-the-app",
    "href": "r/getstarted/shiny-basics/lesson5/index.html#finishing-the-app",
    "title": "Use R scripts and data",
    "section": "Finishing the app",
    "text": "Finishing the app\nThe census visualization app has one reactive object, a plot named \"map\". The plot is built with the percent_map function, which takes five arguments.\n\nThe first three arguments, var, color, and legend.title, depend on the value of the select box widget.\nThe last two arguments, max and min, should be the max and min values of the slider bar widget.\n\nThe server function below shows one way to craft reactive arguments for percent_map. R‚Äôs switch function can transform the output of a select box widget to whatever you like. However, the script is incomplete. It does not provide values for color, legend.title, max, or min. Note: the script will not run as is. You will need to finish the script before you run it, which is the task of Your Turn 2.\nserver &lt;- function(input, output) {\n  output$map &lt;- renderPlot({\n    data &lt;- switch(input$var,\n                   \"Percent White\" = counties$white,\n                   \"Percent Black\" = counties$black,\n                   \"Percent Hispanic\" = counties$hispanic,\n                   \"Percent Asian\" = counties$asian)\n\n    percent_map(var = data, color = ?, legend.title = ?, max = ?, min = ?)\n  })\n}",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Use R scripts and data"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson5/index.html#your-turn-2",
    "href": "r/getstarted/shiny-basics/lesson5/index.html#your-turn-2",
    "title": "Use R scripts and data",
    "section": "Your Turn 2",
    "text": "Your Turn 2\nComplete the code to build a working census visualization app.\nWhen you‚Äôre ready to deploy your app, save your app.R file and run runApp(\"census-app\"). If everything works, your app should look like the picture below.\nYou‚Äôll need to decide\n\nhow to create the argument values for percent_map, and\nwhere to put the code that creates these arguments.\n\nRemember, you‚Äôll want the argument values to switch whenever a user changes the associated widget. When you are finished, or if you get stuck, read on below for a model answer.\n\n\n\n\nCensus app\n\n\n\n\nModel Answers 2\n\n\n\n\n\n\nView Answer\n\n\n\n\n\n# Load packages ----\nlibrary(shiny)\nlibrary(maps)\nlibrary(mapproj)\n\n# Load data ----\ncounties &lt;- readRDS(\"data/counties.rds\")\n\n# Source helper functions -----\nsource(\"helpers.R\")\n\n# User interface ----\nui &lt;- page_sidebar(\n  title = \"censusVis\",\n  sidebar = sidebar(\n    helpText(\n      \"Create demographic maps with information from the 2010 US Census.\"\n    ),\n    selectInput(\n      \"var\",\n      label = \"Choose a variable to display\",\n      choices =\n        c(\n          \"Percent White\",\n          \"Percent Black\",\n          \"Percent Hispanic\",\n          \"Percent Asian\"\n        ),\n      selected = \"Percent White\"\n    ),\n    sliderInput(\n      \"range\",\n      label = \"Range of interest:\",\n      min = 0,\n      max = 100,\n      value = c(0, 100)\n    )\n  ),\n  card(plotOutput(\"map\"))\n)\n\n# Server logic ----\nserver &lt;- function(input, output) {\n  output$map &lt;- renderPlot({\n    data &lt;- switch(input$var,\n                   \"Percent White\" = counties$white,\n                   \"Percent Black\" = counties$black,\n                   \"Percent Hispanic\" = counties$hispanic,\n                   \"Percent Asian\" = counties$asian)\n\n    color &lt;- switch(input$var,\n                    \"Percent White\" = \"darkgreen\",\n                    \"Percent Black\" = \"black\",\n                    \"Percent Hispanic\" = \"darkorange\",\n                    \"Percent Asian\" = \"darkviolet\")\n\n    legend &lt;- switch(input$var,\n                     \"Percent White\" = \"% White\",\n                     \"Percent Black\" = \"% Black\",\n                     \"Percent Hispanic\" = \"% Hispanic\",\n                     \"Percent Asian\" = \"% Asian\")\n\n    percent_map(data, color, legend, input$range[1], input$range[2])\n  })\n}\n\n# Run app ----\nshinyApp(ui, server)\nA more concise version of the server function:\nserver &lt;- function(input, output) {\n  output$map &lt;- renderPlot({\n    args &lt;- switch(input$var,\n      \"Percent White\" = list(counties$white, \"darkgreen\", \"% White\"),\n      \"Percent Black\" = list(counties$black, \"black\", \"% Black\"),\n      \"Percent Hispanic\" = list(counties$hispanic, \"darkorange\", \"% Hispanic\"),\n      \"Percent Asian\" = list(counties$asian, \"darkviolet\", \"% Asian\"))\n\n    args$min &lt;- input$range[1]\n    args$max &lt;- input$range[2]\n\n    do.call(percent_map, args)\n  })\n}",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Use R scripts and data"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson5/index.html#recap",
    "href": "r/getstarted/shiny-basics/lesson5/index.html#recap",
    "title": "Use R scripts and data",
    "section": "Recap",
    "text": "Recap\nYou can create more complicated Shiny apps by loading R Scripts, packages, and data sets.\nKeep in mind:\n\nThe directory that app.R appears in will become the working directory of the Shiny app\nShiny will run code placed at the start of app.R, before the server function, only once during the life of the app.\nShiny will run code placed inside server function multiple times, which can slow down the app.\n\nYou also learned that switch is a useful companion to multiple choice Shiny widgets. Use switch to change the values of a widget into R expressions.\nAs your apps become more complex, they can become inefficient and slow. Lesson 6 will show you how to build fast, modular apps with reactive expressions.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Use R scripts and data"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson3/index.html",
    "href": "r/getstarted/shiny-basics/lesson3/index.html",
    "title": "Add control widgets",
    "section": "",
    "text": "This lesson will show you how to add control widgets to your Shiny apps. What‚Äôs a widget? A web element that your users can interact with. Widgets provide a way for your users to send messages to the Shiny app.\nShiny widgets collect a value from your user. When a user changes the widget, the value will change as well. This sets up opportunities that we‚Äôll explore in Lesson 4.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Add control widgets"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson3/index.html#control-widgets",
    "href": "r/getstarted/shiny-basics/lesson3/index.html#control-widgets",
    "title": "Add control widgets",
    "section": "Control widgets",
    "text": "Control widgets\n\n\n\nShiny comes with a family of pre-built widgets, each created with a transparently named R function. For example, Shiny provides a function named actionButton that creates an Action Button and a function named sliderInput that creates a slider bar.\nThe standard Shiny widgets are:\n\n\n\nfunction\nwidget\n\n\n\n\nactionButton\nAction Button\n\n\ncheckboxGroupInput\nA group of check boxes\n\n\ncheckboxInput\nA single check box\n\n\ndateInput\nA calendar to aid date selection\n\n\ndateRangeInput\nA pair of calendars for selecting a date range\n\n\nfileInput\nA file upload control wizard\n\n\nhelpText\nHelp text that can be added to an input form\n\n\nnumericInput\nA field to enter numbers\n\n\nradioButtons\nA set of radio buttons\n\n\nselectInput\nA box with choices to select from\n\n\nsliderInput\nA slider bar\n\n\nsubmitButton\nA submit button\n\n\ntextInput\nA field to enter text\n\n\n\nSome of these widgets are built using the Twitter Bootstrap project, a popular open source framework for building user interfaces.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Add control widgets"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson3/index.html#adding-widgets",
    "href": "r/getstarted/shiny-basics/lesson3/index.html#adding-widgets",
    "title": "Add control widgets",
    "section": "Adding widgets",
    "text": "Adding widgets\nYou can add widgets to your web page in the same way that you added other types of HTML content in Lesson 2.\nEach widget function requires several arguments. The first two arguments for each widget are\n\na name for the widget: The user will not see this name, but you can use it to access the widget‚Äôs value. The name should be a character string.\na label: This label will appear with the widget in your app. It should be a character string, but it can be an empty string \"\".\n\nIn this example, the name is ‚Äúaction‚Äù and the label is ‚ÄúAction‚Äù: actionButton(\"action\", label = \"Action\")\nThe remaining arguments vary from widget to widget, depending on what the widget needs to do its job. They include things like initial values, ranges, and increments. You can find the exact arguments needed by a widget on the widget function‚Äôs help page, (e.g., ?selectInput).\nThe app.R script below makes the app pictured above. Change your own App-1/app.R script to match it, and then launch the app (runApp(\"App-1\"), select Run App, or use shortcuts).\nPlay with each widget to get a feel for what it does. Experiment with changing the values of the widget functions and observe the effects. If you are interested in the layout scheme for this Shiny app, read the description in the application layout guide. This lesson will not cover this slightly more complicated layout scheme, but it is interesting to note what it does.\nlibrary(shiny)\n\n# Define UI ----\nui &lt;- page_fluid(\n  titlePanel(\"Basic widgets\"),\n  layout_columns(\n    col_width = 3,\n    card(\n      card_header(\"Buttons\"),\n      actionButton(\"action\", \"Action\"),\n      submitButton(\"Submit\")\n    ),\n    card(\n      card_header(\"Single checkbox\"),\n      checkboxInput(\"checkbox\", \"Choice A\", value = TRUE)\n    ),\n    card(\n      card_header(\"Checkbox group\"),\n      checkboxGroupInput(\n        \"checkGroup\",\n        \"Select all that apply\",\n        choices = list(\"Choice 1\" = 1, \"Choice 2\" = 2, \"Choice 3\" = 3),\n        selected = 1\n      )\n    ),\n    card(\n      card_header(\"Date input\"),\n      dateInput(\"date\", \"Select date\", value = \"2014-01-01\")\n    ),\n    card(\n      card_header(\"Date range input\"),\n      dateRangeInput(\"dates\", \"Select dates\")\n    ),\n    card(\n      card_header(\"File input\"),\n      fileInput(\"file\", label = NULL)\n    ),\n    card(\n      card_header(\"Help text\"),\n      helpText(\n        \"Note: help text isn't a true widget,\",\n        \"but it provides an easy way to add text to\",\n        \"accompany other widgets.\"\n      )\n    ),\n    card(\n      card_header(\"Numeric input\"),\n      numericInput(\"num\", \"Input number\", value = 1)\n    ),\n    card(\n      card_header(\"Radio buttons\"),\n      radioButtons(\n        \"radio\",\n        \"Select option\",\n        choices = list(\"Choice 1\" = 1, \"Choice 2\" = 2, \"Choice 3\" = 3),\n        selected = 1\n      )\n    ),\n    card(\n      card_header(\"Select box\"),\n      selectInput(\n        \"select\",\n        \"Select option\",\n        choices = list(\"Choice 1\" = 1, \"Choice 2\" = 2, \"Choice 3\" = 3),\n        selected = 1\n      )\n    ),\n    card(\n      card_header(\"Sliders\"),\n      sliderInput(\n        \"slider1\",\n        \"Set value\",\n        min = 0,\n        max = 100,\n        value = 50\n      ),\n      sliderInput(\n        \"slider2\",\n        \"Set value range\",\n        min = 0,\n        max = 100,\n        value = c(25, 75)\n      )\n    ),\n    card(\n      card_header(\"Text input\"),\n      textInput(\"text\", label = NULL, value = \"Enter text...\")\n    )\n  )\n)\n\n# Define server logic ----\nserver &lt;- function(input, output) {\n\n}\n\n# Run the app ----\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Add control widgets"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson3/index.html#your-turn",
    "href": "r/getstarted/shiny-basics/lesson3/index.html#your-turn",
    "title": "Add control widgets",
    "section": "Your turn",
    "text": "Your turn\nRewrite your ui to create the user interface displayed below. Notice that this Shiny app uses a basic Shiny layout (no columns) and contains three of the widgets pictured above. The other values of the select box are shown below the image of the app.\n\n\n\n\n\n\n\nModel Answer\n\n\n\n\n\n\nView Answer\n\n\n\n\n\nBe sure your ui is identical to the one displayed below before you move on. You will use the script in Lesson 4 and Lesson 5, as part of an app that visualizes census data.\nIn particular, make sure that your select box widget is named ‚Äúvar‚Äù, and your slider widget is named ‚Äúrange‚Äù.\nAlso notice that the slider widget has two values, not one.\nui &lt;- page_sidebar(\n  title = \"censusVis\",\n  sidebar = sidebar(\n    helpText(\n      \"Create demographic maps with information from the 2010 US Census.\"\n    ),\n    selectInput(\n      \"var\",\n      label = \"Choose a variable to display\",\n      choices = \n        list(\n          \"Percent White\", \n          \"Percent Black\", \n          \"Percent Hispanic\", \n          \"Percent Asian\"\n        ),\n      selected = \"Percent White\"\n    ),\n    sliderInput(\"range\",\n                label = \"Range of interest:\",\n                min = 0, max = 100, value = c(0, 100))\n  )\n)",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Add control widgets"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson3/index.html#recap",
    "href": "r/getstarted/shiny-basics/lesson3/index.html#recap",
    "title": "Add control widgets",
    "section": "Recap",
    "text": "Recap\nIt is easy to add fully functional widgets to your Shiny app.\n\nShiny provides a family of functions to create these widgets.\nEach function requires a name and a label.\nSome widgets need specific instructions to do their jobs.\nYou add widgets to your Shiny app just like you added other types of HTML content (see Lesson 2)",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Add control widgets"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson3/index.html#go-further",
    "href": "r/getstarted/shiny-basics/lesson3/index.html#go-further",
    "title": "Add control widgets",
    "section": "Go Further",
    "text": "Go Further\nThe Shiny Widgets Gallery provides templates that you can use to quickly add widgets to your Shiny apps.\nTo use a template, visit the gallery. The gallery displays each of Shiny‚Äôs widgets, and demonstrates how the widgets‚Äô values change in response to your input.\n\n\n\nSelect the widget that you want and click the ‚ÄúSee Code‚Äù button below the widget. The gallery will take you to an example app that describes the widget. To use the widget, copy and paste the code in the example‚Äôs app.R file to your app.R file.\n\n\n\nIn Lesson 4, you will learn how to connect widgets to reactive output, objects that update themselves whenever your user changes a widget.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Add control widgets"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson1/index.html#installation",
    "href": "r/getstarted/shiny-basics/lesson1/index.html#installation",
    "title": "Welcome to Shiny",
    "section": "Installation",
    "text": "Installation\nShiny is an R package that makes it easy to build interactive web applications (apps) straight from R. This lesson will get you started building Shiny apps right away.\nIf you still haven‚Äôt installed the Shiny package, open an R session, connect to the internet, and run\ninstall.packages(\"shiny\")\nShiny comes with another package, bslib, which we‚Äôll also use to build great looking user interfaces.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Welcome to Shiny"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson1/index.html#example-shiny-apps",
    "href": "r/getstarted/shiny-basics/lesson1/index.html#example-shiny-apps",
    "title": "Welcome to Shiny",
    "section": "Example Shiny Apps",
    "text": "Example Shiny Apps\n\n\n\nThe Shiny package has eleven built-in examples that each demonstrate how Shiny works. Each example is a self-contained Shiny app.\nThe Hello Shiny example plots a histogram of R‚Äôs faithful dataset with a configurable number of bins. Users can change the number of bins with a slider bar, and the app will immediately respond to their input. You‚Äôll use Hello Shiny to explore the structure of a Shiny app and to create your first app.\nTo run Hello Shiny, type:\nlibrary(shiny)\nrunExample(\"01_hello\")",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Welcome to Shiny"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson1/index.html#structure-of-a-shiny-app",
    "href": "r/getstarted/shiny-basics/lesson1/index.html#structure-of-a-shiny-app",
    "title": "Welcome to Shiny",
    "section": "Structure of a Shiny App",
    "text": "Structure of a Shiny App\nShiny apps are contained in a single script called app.R. The script app.R lives in a directory (for example, newdir/) and the app can be run with runApp(\"newdir\").\napp.R has three components:\n\na user interface object\na server function\na call to the shinyApp function\n\nThe user interface (ui) object controls the layout and appearance of your app. The server function contains the instructions that your computer needs to build your app. Finally the shinyApp function creates Shiny app objects from an explicit UI/server pair.\n\nui\nHere is the ui object for the Hello Shiny example.\nlibrary(shiny)\nlibrary(bslib)\n\n# Define UI for app that draws a histogram ----\nui &lt;- page_sidebar(\n  # App title ----\n  title = \"Hello Shiny!\",\n  # Sidebar panel for inputs ----\n  sidebar = sidebar(\n    # Input: Slider for the number of bins ----\n    sliderInput(\n      inputId = \"bins\",\n      label = \"Number of bins:\",\n      min = 1,\n      max = 50,\n      value = 30\n    )\n  ),\n  # Output: Histogram ----\n  plotOutput(outputId = \"distPlot\")\n)\n\n\nserver\nHere is the server function for the Hello Shiny example.\n# Define server logic required to draw a histogram ----\nserver &lt;- function(input, output) {\n\n  # Histogram of the Old Faithful Geyser Data ----\n  # with requested number of bins\n  # This expression that generates a histogram is wrapped in a call\n  # to renderPlot to indicate that:\n  #\n  # 1. It is \"reactive\" and therefore should be automatically\n  #    re-executed when inputs (input$bins) change\n  # 2. Its output type is a plot\n  output$distPlot &lt;- renderPlot({\n\n    x    &lt;- faithful$waiting\n    bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n\n    hist(x, breaks = bins, col = \"#007bc2\", border = \"white\",\n         xlab = \"Waiting time to next eruption (in mins)\",\n         main = \"Histogram of waiting times\")\n\n    })\n\n}\nAt one level, the Hello Shiny server function is very simple. The script does some calculations and then plots a histogram with the requested number of bins.\nHowever, you‚Äôll also notice that most of the script is wrapped in a call to renderPlot. The comment above the function explains a bit about this, but if you find it confusing, don‚Äôt worry. We‚Äôll cover this concept in much more detail soon.\nPlay with the Hello Shiny app and review the source code. Try to develop a feel for how the app works. But before you do so, note that in your app.R file you will need to start with loading the Shiny package and end with a call to shinyApp:\nlibrary(shiny)\n\n# See above for the definitions of ui and server\nui &lt;- ...\n\nserver &lt;- ...\n\nshinyApp(ui = ui, server = server)\nYour R session will be busy while the Hello Shiny app is active, so you will not be able to run any R commands. R is monitoring the app and executing the app‚Äôs reactions. To get your R session back, hit escape or click the stop sign icon (found in the upper right corner of the RStudio console panel).",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Welcome to Shiny"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson1/index.html#running-an-app",
    "href": "r/getstarted/shiny-basics/lesson1/index.html#running-an-app",
    "title": "Welcome to Shiny",
    "section": "Running an App",
    "text": "Running an App\nEvery Shiny app has the same structure: an app.R file that contains ui and server. You can create a Shiny app by making a new directory and saving an app.R file inside it. It is recommended that each app will live in its own unique directory.\nYou can run a Shiny app by giving the name of its directory to the function runApp. For example if your Shiny app is in a directory called my_app, run it with the following code:\nlibrary(shiny)\nrunApp(\"my_app\")\nNote: runApp is similar to read.csv, read.table, and many other functions in R. The first argument of runApp is the filepath from your working directory to the app‚Äôs directory. The code above assumes that the app directory is in your working directory. In this case, the filepath is just the name of the directory.\n(In case you are wondering, the Hello Shiny app‚Äôs files are saved in a special system directory called \"01_hello\". This directory is designed to work with the runExample (\"01_hello\") call.)",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Welcome to Shiny"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson1/index.html#your-turn",
    "href": "r/getstarted/shiny-basics/lesson1/index.html#your-turn",
    "title": "Welcome to Shiny",
    "section": "Your Turn",
    "text": "Your Turn\nCreate a new directory named App-1 in your working directory. Then copy and paste the app.R script above into your directory (the scripts from Hello Shiny). When you are finished the directory should look like this:\n\n\n\nLaunch your app by running runApp(\"App-1\"). Then click escape and make some changes to your app:\n\nChange the title from ‚ÄúHello Shiny!‚Äù to ‚ÄúHello World!‚Äù.\nSet the minimum value of the slider bar to 5.\nChange the histogram border color from \"white\" to \"orange\".\n\nWhen you are ready, launch your app again. Your new app should match the image below. If it doesn‚Äôt, or if you want to check your code, press the model answers button to reveal how we did these tasks.\n\n\n\nBy default, Shiny apps display in ‚Äúnormal‚Äù mode, like the app pictured above. Hello Shiny and the other built in examples display in ‚Äúshowcase mode‚Äù, a different mode that displays the app.R script alongside the app.\nIf you would like your app to display in showcase mode, you can run runApp(\"App-1\", display.mode = \"showcase\").\n\nModel Answers\n\n\n\n\n\n\nView UI Answers\n\n\n\n\n\nChange the title of your app and the slider bar values in the ui object.\n\nui\n# Define UI for app that draws a histogram ----\nui &lt;- page_sidebar(\n  # App title ----\n  title = \"Hello World!\",\n  # Sidebar panel for inputs ----\n  sidebar = sidebar(\n    # Input: Slider for the number of bins ----\n    sliderInput(\n      inputId = \"bins\",\n      label = \"Number of bins:\",\n      min = 1,\n      max = 50,\n      value = 30\n    )\n  ),\n  # Output: Histogram ----\n  plotOutput(outputId = \"distPlot\")\n)\nUse the server function to change how your computer builds the histogram.\n# Define server logic required to draw a histogram ----\nserver &lt;- function(input, output) {\n\n  # Histogram of the Old Faithful Geyser Data ----\n  # with requested number of bins\n  # This expression that generates a histogram is wrapped in a call\n  # to renderPlot to indicate that:\n  #\n  # 1. It is \"reactive\" and therefore should be automatically\n  #    re-executed when inputs (input$bins) change\n  # 2. Its output type is a plot\n  output$distPlot &lt;- renderPlot({\n\n    x    &lt;- faithful$waiting\n    bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n\n    hist(x, breaks = bins, col = \"#007bc2\", border = \"orange\",\n         xlab = \"Waiting time to next eruption (in mins)\",\n         main = \"Histogram of waiting times\")\n\n    })\n\n}",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Welcome to Shiny"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson1/index.html#relaunching-apps",
    "href": "r/getstarted/shiny-basics/lesson1/index.html#relaunching-apps",
    "title": "Welcome to Shiny",
    "section": "Relaunching Apps",
    "text": "Relaunching Apps\nTo relaunch your Shiny app:\n\nRun runApp(\"App-1\"), or\nOpen the app.R script in your RStudio editor. RStudio will recognize the Shiny script and provide a Run App button (at the top of the editor). Either click this button to launch your app or use the keyboard shortcut: Command+Shift+Enter (Control+Shift+Enter on Windows).\n\n\n\n\nRStudio will launch the app in a new window by default, but you can also choose to have the app launch in a dedicated viewer pane, or in your external web browser. Make your selection by clicking the icon next to Run App.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Welcome to Shiny"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson1/index.html#recap",
    "href": "r/getstarted/shiny-basics/lesson1/index.html#recap",
    "title": "Welcome to Shiny",
    "section": "Recap",
    "text": "Recap\nTo create your own Shiny app:\n\nMake a directory named myapp/ for your app.\nSave your app.R script inside that directory.\nLaunch the app with runApp or RStudio‚Äôs keyboard shortcuts.\nExit the Shiny app by clicking escape.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Welcome to Shiny"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson1/index.html#go-further",
    "href": "r/getstarted/shiny-basics/lesson1/index.html#go-further",
    "title": "Welcome to Shiny",
    "section": "Go Further",
    "text": "Go Further\nYou can create Shiny apps by copying and modifying existing Shiny apps. The Shiny gallery provides some good examples, or use the eleven pre-built Shiny examples listed below.\nrunExample(\"01_hello\")      # a histogram\nrunExample(\"02_text\")       # tables and data frames\nrunExample(\"03_reactivity\") # a reactive expression\nrunExample(\"04_mpg\")        # global variables\nrunExample(\"05_sliders\")    # slider bars\nrunExample(\"06_tabsets\")    # tabbed panels\nrunExample(\"07_widgets\")    # help text and submit buttons\nrunExample(\"08_html\")       # Shiny app built from HTML\nrunExample(\"09_upload\")     # file upload wizard\nrunExample(\"10_download\")   # file download wizard\nrunExample(\"11_timer\")      # an automated timer\nEach demonstrates a feature of Shiny apps. All Shiny example apps open in ‚Äúshowcase‚Äù mode (with the app.R script in the display).\nBut why limit yourself to copying other apps? The next few lessons will show you how to build your own Shiny apps from scratch. You‚Äôll learn about each part of a Shiny app, and finish by deploying your own Shiny app online.\nWhen you are ready, continue to Lesson 2, where you will learn how to build the layout and appearance of your Shiny apps.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Welcome to Shiny"
    ]
  },
  {
    "objectID": "r/getstarted/index-old.html",
    "href": "r/getstarted/index-old.html",
    "title": "Shiny",
    "section": "",
    "text": "Step 1\n\n\nInstall Shiny\n\n\n\nOpen an R session, connect to the internet, and run:\ninstall.packages(\"shiny\")\n\n\n\n\n\nStep 2\n\n\nCreate your first app\n\n\n\nCTA to the first tutorial"
  },
  {
    "objectID": "r/getstarted/build-an-app/reactivity-essentials/stop-trigger-delay.html",
    "href": "r/getstarted/build-an-app/reactivity-essentials/stop-trigger-delay.html",
    "title": "Stop-trigger-delay",
    "section": "",
    "text": "In this section we present how to stop, trigger, and delay Shiny actions.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactivity Essentials",
      "Stop-trigger-delay"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactivity-essentials/stop-trigger-delay.html#practice---stop-with-isolate",
    "href": "r/getstarted/build-an-app/reactivity-essentials/stop-trigger-delay.html#practice---stop-with-isolate",
    "title": "Stop-trigger-delay",
    "section": "Practice - Stop with isolate()",
    "text": "Practice - Stop with isolate()\nIn the following app, the user, in addition to controlling which variables are plotted, can adjust the size and transparency of points and define the plot title.\n\nYour turn\n\nRun the code and test out the functionality of the plot title input. Is the plot title updated immediately after you‚Äôre done typing the title?\nModify the app so that the plot title only gets updated when one of the other inputs is changed.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the Posit Cloud Project titled 3-4a Stop with isolate() in your Posit Cloud Workspace\n Go to Posit Cloud Project\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(tools)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    sidebar = sidebar(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.5\n      ),\n\n      sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 2\n      ),\n\n      textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      )\n    ),\n\n    card(\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y, color = input$z)) +\n      geom_point(alpha = input$alpha, size = input$size) +\n      labs(title = toTitleCase(input$plot_title))\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(tools)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    sidebar = sidebar(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.5\n      ),\n\n      sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 2\n      ),\n\n      textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      )\n    ),\n\n    card(\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y, color = input$z)) +\n      geom_point(alpha = input$alpha, size = input$size) +\n      labs(title = isolate({\n        toTitleCase(input$plot_title)\n      }))\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactivity Essentials",
      "Stop-trigger-delay"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactivity-essentials/stop-trigger-delay.html#practice---delay-with-eventreactive",
    "href": "r/getstarted/build-an-app/reactivity-essentials/stop-trigger-delay.html#practice---delay-with-eventreactive",
    "title": "Stop-trigger-delay",
    "section": "Practice - Delay with eventReactive()",
    "text": "Practice - Delay with eventReactive()\nThe following app has the same starter code as the previous exercise.\n\nYour turn\n\nModify the app such that the title is updated only when a button titled ‚ÄúUpdate plot title‚Äù is clicked.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the Posit Cloud Project titled 3-4b Delay with eventReactive() in your Posit Cloud Workspace\n Go to Posit Cloud Project\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(tools)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    sidebar = sidebar(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.5\n      ),\n\n      sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 2\n      ),\n\n      textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      )\n    ),\n\n    card(\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y, color = input$z)) +\n      geom_point(alpha = input$alpha, size = input$size) +\n      labs(title = toTitleCase(input$plot_title))\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(tools)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    sidebar = sidebar(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.5\n      ),\n\n      sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 2\n      ),\n\n      textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      ),\n\n      actionButton(\n        inputId = \"update_plot_title\",\n        label = \"Update plot title\"\n      )\n    ),\n\n    card(\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  new_plot_title &lt;- eventReactive(\n    eventExpr = input$update_plot_title,\n    valueExpr = {\n      toTitleCase(input$plot_title)\n    }\n  )\n\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y, color = input$z)) +\n      geom_point(alpha = input$alpha, size = input$size) +\n      labs(title = new_plot_title())\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactivity Essentials",
      "Stop-trigger-delay"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactivity-essentials/stop-trigger-delay.html#practice---trigger-with-observeevent",
    "href": "r/getstarted/build-an-app/reactivity-essentials/stop-trigger-delay.html#practice---trigger-with-observeevent",
    "title": "Stop-trigger-delay",
    "section": "Practice - Trigger with observeEvent()",
    "text": "Practice - Trigger with observeEvent()\nIn this app we want two things to happen when an action button is clicked:\n\nA message printed to the console stating how many records are shown and\nA table output of those records.\n\n\nYour turn\n\nFill in the necessary function and input ID for printing a message to the console when the action button is clicked.\nSet up a table output that will print only when action button is clicked, but not when other inputs that go into the creation of that output changes.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the Posit Cloud Project titled 3-4c Trigger with observeEvent() in your Posit Cloud Workspace\n Go to Posit Cloud Project\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    sidebar = sidebar(\n      numericInput(\n        inputId = \"n_rows\",\n        label = \"How many rows do you want to see?\",\n        value = 10\n      ),\n\n      actionButton(\n        inputId = \"button\",\n        label = \"Show\"\n      )\n    ),\n\n    card(\n      tableOutput(outputId = \"datatable\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  # Print a message to the console every time button is pressed;\n  ___(input$___, {\n    cat(\"Showing\", input$n_rows, \"rows\\n\")\n  })\n\n  # Take a reactive dependency on input$button, but not on any other inputs\n  df &lt;- ___(input$___, {\n    head(movies, input$n_rows)\n  })\n  output$___ &lt;- ___({\n    df()\n  })\n\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    sidebar = sidebar(\n      numericInput(\n        inputId = \"n_rows\",\n        label = \"How many rows do you want to see?\",\n        value = 10\n      ),\n\n      actionButton(\n        inputId = \"button\",\n        label = \"Show\"\n      )\n    ),\n\n    card(\n      tableOutput(outputId = \"datatable\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  # Pring a message to the console every time button is pressed;\n  observeEvent(input$button, {\n    cat(\"Showing\", input$n_rows, \"rows\\n\")\n  })\n\n  # Take a reactive dependency on input$button,\n  # but not on any of the stuff inside the function\n  df &lt;- eventReactive(input$button, {\n    head(movies, input$n_rows)\n  })\n  output$datatable &lt;- renderTable({\n    df()\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactivity Essentials",
      "Stop-trigger-delay"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactivity-essentials/stop-trigger-delay.html#practice---difference-between-eventreactive-and-observeevent",
    "href": "r/getstarted/build-an-app/reactivity-essentials/stop-trigger-delay.html#practice---difference-between-eventreactive-and-observeevent",
    "title": "Stop-trigger-delay",
    "section": "Practice - Difference between eventReactive() and observeEvent()",
    "text": "Practice - Difference between eventReactive() and observeEvent()\n\n\n\n\n\n\nNoticing the differences\n\n\n\nWhich of the following is false?\n\nobserveEvent() is used to perform an action in response to an event\nisolate() is used to trigger a reaction\neventReactive() is used to create a calculated value that only updates in response to an event\nRecalculating a value does not generally count as performing an action\n\n\n\n\n\n\n\nClick to View the Answer\n\n\n\n\n\nThe correct answer is ‚Äúisolate() is used to trigger a reaction‚Äù",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactivity Essentials",
      "Stop-trigger-delay"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactivity-essentials/reactives-observers.html",
    "href": "r/getstarted/build-an-app/reactivity-essentials/reactives-observers.html",
    "title": "Reactives and Observers",
    "section": "",
    "text": "In this section we discuss implementations of the three different types of reactive objects.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactivity Essentials",
      "Reactives and Observers"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactivity-essentials/reactives-observers.html#practice---reactives-vs.-observers",
    "href": "r/getstarted/build-an-app/reactivity-essentials/reactives-observers.html#practice---reactives-vs.-observers",
    "title": "Reactives and Observers",
    "section": "Practice - Reactives vs.¬†observers",
    "text": "Practice - Reactives vs.¬†observers\nNext you get to assess your understanding of reactives vs.¬†observers.\nYou‚Äôll add a reactiveValues() element to the app. Define observers and their side effects, and how these compare to reactives.\n\nYour turn\n\nUsing the code from the app you worked on in the last exercise, add another reactiveValues() and reactiveVal() element to the app.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by building off of the code you completed in the last Posit Cloud Project titled 3-2b Find inconsistencies in what the app is reporting in your Posit Cloud Workspace\n Go to Posit Cloud Project",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactivity Essentials",
      "Reactives and Observers"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactive-flow/ui-outputs.html#practice---hovering",
    "href": "r/getstarted/build-an-app/reactive-flow/ui-outputs.html#practice---hovering",
    "title": "UI Outputs",
    "section": "Practice - Hovering",
    "text": "Practice - Hovering\nIn addition to brushing, users can also interact with plots via hovering over them.\n\nYour turn\n\nChange the brush argument to hover in the plotOutput().\nRead the article on Selecting rows of data to determine what change needs to be made in the renderDataTable() function to list the data points that the user hovers on.\nImplement this change.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-4a Hovering in your Posit Cloud Workspace.\n Go to RStudio Cloud Project\n\n\n\n\n\n\n\n\n\nWork locally in your RStudio IDE\n\n\n\n\n\n\nCopy the code below into an R script\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n\n    sidebar = sidebar(\n      selectInput(\n        inputId = \"y\", label = \"Y-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\", label = \"X-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"critics_score\"\n      )\n    ),\n\n    card(\n      plotOutput(outputId = \"scatterplot\", brush = \"plot_brush\"),\n      DT::dataTableOutput(outputId = \"moviestable\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n\n  output$moviestable &lt;- renderDataTable({\n    brushedPoints(movies, brush = input$plot_brush) %&gt;%\n      select(title, audience_score, critics_score)\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n\n    sidebar = sidebar(\n      selectInput(\n        inputId = \"y\", label = \"Y-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"audience_score\"\n      ),\n      selectInput(\n        inputId = \"x\", label = \"X-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"critics_score\"\n      )\n    ),\n\n    card(\n      plotOutput(outputId = \"scatterplot\", hover = \"plot_hover\"),\n      dataTableOutput(outputId = \"moviestable\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n\n  output$moviestable &lt;- renderDataTable({\n    nearPoints(movies, input$plot_hover) %&gt;%\n      select(title, audience_score, critics_score)\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactive Flow",
      "UI Outputs"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactive-flow/ui-outputs.html#practice---displaying-text-outputs",
    "href": "r/getstarted/build-an-app/reactive-flow/ui-outputs.html#practice---displaying-text-outputs",
    "title": "UI Outputs",
    "section": "Practice - Displaying text outputs",
    "text": "Practice - Displaying text outputs\nThe goal in this exercise is to develop an app where the user selects two variables and their relationship is visualized with a scatterplot, and averages of both variables are reported as well as the output of the linear regression predicting the variable on the y-axis from the variable in the x-axis. The code on the right only does some of these things.\n\nYour turn\n\nAdd the appropriate output UI functions and output IDs to print the elements noted in the comments in the main content area of the UI and run the app. Also add commas as needed.\nIn the server function averages are calculated first and then the regression model is fit, but in the app the regression output comes before the averages. Make the necessary changes to the app so that averages are displayed above the regression output.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-4b Displaying text outputs in your Posit Cloud Workspace.\n Go to RStudio Cloud Project\n\n\n\n\n\n\n\n\n\nWork locally in your RStudio IDE\n\n\n\n\n\n\nCopy the code below into an R script\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    \n    sidebar = sidebar(\n      \n      selectInput(inputId = \"y\",\n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"audience_score\"),\n\n      selectInput(inputId = \"x\",\n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"critics_score\")\n\n    ),\n    \n    card(\n      plotOutput(outputId = \"scatterplot\"),\n      ___(outputId = ___) # regression output\n      ___(outputId = ___) # avg of x\n      ___(outputId = ___) # avg of y\n\n    )\n)\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n\n  output$avg_x &lt;- renderText({\n    avg_x &lt;- movies %&gt;% pull(input$x) %&gt;% mean() %&gt;% round(2)\n    paste(\"Average\", input$x, \"=\", avg_x)\n  })\n\n  output$avg_y &lt;- renderText({\n    avg_y &lt;- movies %&gt;% pull(input$y) %&gt;% mean() %&gt;% round(2)\n    paste(\"Average\", input$y, \"=\", avg_y)\n  })\n\n  output$lmoutput &lt;- renderPrint({\n    x &lt;- movies %&gt;% pull(input$x)\n    y &lt;- movies %&gt;% pull(input$y)\n    summ &lt;- summary(lm(y ~ x, data = movies))\n    print(summ, digits = 3, signif.stars = FALSE)\n  })\n\n  }\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    \n    sidebar = sidebar(\n      selectInput(inputId = \"y\",\n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"audience_score\"),\n\n      selectInput(inputId = \"x\",\n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"critics_score\")\n\n    ),\n\n    # Output(s)\n    card(\n      plotOutput(outputId = \"scatterplot\"),\n      textOutput(outputId = \"avg_x\"), # avg of x\n      textOutput(outputId = \"avg_y\"), # avg of y\n      verbatimTextOutput(outputId = \"lmoutput\") # regression output\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n\n  output$avg_x &lt;- renderText({\n    avg_x &lt;- movies %&gt;% pull(input$x) %&gt;% mean() %&gt;% round(2)\n    paste(\"Average\", input$x, \"=\", avg_x)\n  })\n\n  output$avg_y &lt;- renderText({\n    avg_y &lt;- movies %&gt;% pull(input$y) %&gt;% mean() %&gt;% round(2)\n    paste(\"Average\", input$y, \"=\", avg_y)\n  })\n\n  output$lmoutput &lt;- renderPrint({\n    x &lt;- movies %&gt;% pull(input$x)\n    y &lt;- movies %&gt;% pull(input$y)\n    print(summary(lm(y ~ x, data = movies)), digits = 3, signif.stars = FALSE)\n  })\n\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactive Flow",
      "UI Outputs"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactive-flow/ui-outputs.html#practice---creating-and-formatting-html-output",
    "href": "r/getstarted/build-an-app/reactive-flow/ui-outputs.html#practice---creating-and-formatting-html-output",
    "title": "UI Outputs",
    "section": "Practice - Creating and formatting HTML output",
    "text": "Practice - Creating and formatting HTML output\nIn the previous exercise you developed an app that reported averages of selected x and y variables as two separate outputs. An alternative approach would be to combine them into a single, multi-line output.\nCombine the values calculated in the previous exercise as described below to create a customized HTML output.\n\nYour turn\n\nIn the server, create a new output, named output$avgs, that replaces output$avg_x and output$avg_y. For this output, calculate avg_x and avg_y like you did before, save the output text strings as str_x and str_y, and finally combine these two text strings with HTML(paste(str_x, str_y, sep = '&lt;br/&gt;')).\nIn the UI, replace the textOutput()s with a call to htmlOutput(), calling the new HTML text string you created in the server.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-4c Creating and formatting HTML output in your Posit Cloud Workspace.\n Go to RStudio Cloud Project\n\n\n\n\n\n\n\n\n\nWork locally in your RStudio IDE\n\n\n\n\n\n\nCopy the code below into an R script\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    \n    sidebar = sidebar(\n      selectInput(inputId = \"y\",\n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"audience_score\"),\n\n      selectInput(inputId = \"x\",\n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"critics_score\")\n\n    ),\n    \n    card(\n      plotOutput(outputId = \"scatterplot\"),\n      textOutput(outputId = \"avg_x\"), # avg of x\n      textOutput(outputId = \"avg_y\"), # avg of y\n      verbatimTextOutput(outputId = \"lmoutput\") # regression output\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n\n  output$avg_x &lt;- renderText({\n    avg_x &lt;- movies %&gt;% pull(input$x) %&gt;% mean() %&gt;% round(2)\n    paste(\"Average\", input$x, \"=\", avg_x)\n  })\n\n  output$avg_y &lt;- renderText({\n    avg_y &lt;- movies %&gt;% pull(input$y) %&gt;% mean() %&gt;% round(2)\n    paste(\"Average\", input$y, \"=\", avg_y)\n  })\n\n  output$lmoutput &lt;- renderPrint({\n    x &lt;- movies %&gt;% pull(input$x)\n    y &lt;- movies %&gt;% pull(input$y)\n    print(summary(lm(y ~ x, data = movies)), digits = 3, signif.stars = FALSE)\n  })\n\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    \n    sidebar = sidebar(\n      selectInput(inputId = \"y\",\n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"audience_score\"),\n\n      selectInput(inputId = \"x\",\n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"critics_score\")\n\n    ),\n    \n    card(\n      plotOutput(outputId = \"scatterplot\"),\n      htmlOutput(outputId = \"avgs\"),\n      verbatimTextOutput(outputId = \"lmoutput\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n\n  output$avgs &lt;- renderUI({\n    avg_x &lt;- movies %&gt;% pull(input$x) %&gt;% mean() %&gt;% round(2)\n    avg_y &lt;- movies %&gt;% pull(input$y) %&gt;% mean() %&gt;% round(2)\n    str_x &lt;- paste(\"Average\", input$x, \"=\", avg_x)\n    str_y &lt;- paste(\"Average\", input$y, \"=\", avg_y)\n    HTML(paste(str_x, str_y, sep = '&lt;br/&gt;'))\n  })\n\n  output$lmoutput &lt;- renderPrint({\n    x &lt;- movies %&gt;% pull(input$x)\n    y &lt;- movies %&gt;% pull(input$y)\n    print(summary(lm(y ~ x, data = movies)), digits = 3, signif.stars = FALSE)\n  })\n\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactive Flow",
      "UI Outputs"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactive-flow/ui-outputs.html#practice---download-data-with-downloadbutton",
    "href": "r/getstarted/build-an-app/reactive-flow/ui-outputs.html#practice---download-data-with-downloadbutton",
    "title": "UI Outputs",
    "section": "Practice - Download data with downloadButton()",
    "text": "Practice - Download data with downloadButton()\nIn this app you get to specify the filetype and the variables included in the file you will download. For downloading from a Shiny app we use the downloadHandler() function in the server and downloadButton() or downloadLink() function in the UI.\nDownload the selected data with downloadButton() using instructions help files to figure out exactly how it works\n\nYour turn\n\nIn the server function, add the name of the output for file download, the function for setting up a file download, and fill in other blanks. Looking in the help file for the function may be useful.\nIn the UI, add the name of the function for displaying a link or button for downloading.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-4d Download data with downloadButton() in your Posit Cloud Workspace.\n Go to RStudio Cloud Project\n\n\n\n\n\n\n\n\n\nWork locally in your RStudio IDE\n\n\n\n\n\n\nCopy the code below into an R script\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(readr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    \n    sidebar = sidebar(\n      radioButtons(inputId = \"filetype\",\n                   label = \"Select filetype:\",\n                   choices = c(\"csv\", \"tsv\"),\n                   selected = \"csv\"),\n\n      checkboxGroupInput(inputId = \"selected_var\",\n                         label = \"Select variables:\",\n                         choices = names(movies),\n                         selected = c(\"title\"))\n\n    ),\n    \n    card(\n      HTML(\"Select filetype and variables, then hit 'Download data'.\"),\n      ___(\"download_data\", \"Download data\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  # Download file\n  output$___ &lt;- ___(\n    filename = function() {\n      paste0(\"movies.\", ___)\n    },\n    content = function(file) {\n      if(___ == \"csv\"){\n        write_csv(movies %&gt;% select(input$selected_var), file)\n      }\n      if(___ == \"tsv\"){\n        write_tsv(movies %&gt;% select(input$selected_var), file)\n      }\n    }\n  )\n\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(readr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    \n    sidebar = sidebar(\n      radioButtons(inputId = \"filetype\",\n                   label = \"Select filetype:\",\n                   choices = c(\"csv\", \"tsv\"),\n                   selected = \"csv\"),\n\n      checkboxGroupInput(inputId = \"selected_var\",\n                         label = \"Select variables:\",\n                         choices = names(movies),\n                         selected = c(\"title\"))\n\n    ),\n    \n    card(\n      HTML(\"Select filetype and variables, then hit 'Download data'.\"),\n      downloadButton(\"download_data\", \"Download data\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  # Download file\n  output$download_data &lt;- downloadHandler(\n    filename = function() {\n      paste0(\"movies.\", input$filetype)\n      },\n    content = function(file) {\n      if(input$filetype == \"csv\"){\n        write_csv(movies %&gt;% select(input$selected_var), file)\n        }\n      if(input$filetype == \"tsv\"){\n        write_tsv(movies %&gt;% select(input$selected_var), file)\n        }\n    }\n  )\n\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactive Flow",
      "UI Outputs"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactive-flow/render-functions.html#render-functions",
    "href": "r/getstarted/build-an-app/reactive-flow/render-functions.html#render-functions",
    "title": "Rendering functions",
    "section": "render*() functions",
    "text": "render*() functions\n\n\nThe goal of this section is to build familiarity with a few rendering functions.\n\n\n\nAs we mentioned earlier in the course, Shiny provides a wide selection of output types, each of which works with a render function. We looked at the renderPlot() function before.\n\n\n\n\n\n\nNow let‚Äôs take a look at the renderTable() function.\n\n\n\n\nThis is the app you‚Äôve seen numerous times so far that we will use as our starting point.\n\n\n\n\nAnd this is the final app that we want to achieve, with a summary table beneath the plot.\n\n\n\nrenderTable\nSo we want to add a summary table beneath the plot displaying summary statistics for a new variable we‚Äôll create: score_ratio, the ratio of audience scores to critics scores.\nWe need to make four modifications to our app to accomplish this.\n\nCalculate the new variable\nIn the ui: Add an input widget that the user can interact with to check boxes for selected title types.\nIn the ui: Add an output defining where the summary tables should appear.\nIn the server function: Add a reactive expression that creates the summary table.\n\nWe‚Äôll go through these steps one by one.\n\n\n1. Calculate the new variable.\n# Create new variable:\n# ratio of critics and audience scores\nmovies &lt;- movies %&gt;%\n  mutate(score_ratio = audience_score / critics_score)\nFirst is creating the new variable, which we can do outside of the ui and the server so it‚Äôs calculated once when our app launches.\nThere are many ways one can create the new variable in R. We do so here using the mutate() function from the dplyr package.\n\n\n2. ui: Add an input widget that the user can interact with to check boxes for selected title types.\n# Subset for title types\ncheckboxGroupInput(inputId = \"selected_title_type\", \n                   label = \"Select title type:\", \n                   choices = levels(movies$title_type),\n                   selected = levels(movies$title_type))\n\nThe first argument is the inputId.\nNext is the user facing label.\nThird, we define the choices. Previously we manually entered the choices. We present an alternative approach here, directly using information from the dataset. Specifically, the choices we want are the levels of the title_type variable. And by default we select all of them.\n\n\n\n3. ui: Add an output defining where the summary tables should appear.\ncard(\n  # Show scatterplot\n  plotOutput(outputId = \"scatterplot\"),\n  # Show data table\n  tableOutput(outputId = \"summarytable\")\n)\nWe use the tableOutput() function for this. This function takes one argument, the outputId.\n\n\n4. server: Add a reactive expression that creates the summary table.\nLastly, in the server, we describe how this table should be calculated with the renderTable() function.\noutput$summarytable &lt;- renderTable(\n  {\n    movies %&gt;%\n      filter(title_type %in% input$selected_title_type) %&gt;%\n      group_by(mpaa_rating) %&gt;%\n      summarise(mean_score_ratio = mean(score_ratio), SD = sd(score_ratio), n = n())\n  },\n  striped = TRUE,\n  spacing = \"l\",\n  align = \"lccr\",\n  digits = 4,\n  width = \"90%\",\n  caption = \"Score ratio (audience / critics' scores) summary statistics by MPAA rating.\"\n)\nNote that the name of the output created by the render function should match the name we used for the output in the ui (summarytable).\nThe first argument is the expression that returns an R object in tabular form.\n  {\n    movies %&gt;%\n      filter(title_type %in% input$selected_title_type) %&gt;%\n      group_by(mpaa_rating) %&gt;%\n      summarise(mean_score_ratio = mean(score_ratio), SD = sd(score_ratio), n = n())\n  }\nNote that we wrap the expression with curly braces. The expression first filters for the selected title types. Since this is a user selection, the information is in the input list generated in the ui.\nThen, the expression groups the data by MPAA rating, and then calculates summary statistics like means, standard deviations, and sample sizes for each level of MPAA ratings.\n\n\n\nIf we stopped here and didn‚Äôt include any of the following arguments, the app would look something like this:\n\nBut we want our table to look like this:\n\n\n\n\nIn order to achieve this look, we add additional arguments to our render* function.\nstriped = TRUE, spacing = \"l\", align = \"lccr\", digits = 4, width = \"90%\",\ncaption = \"Score ratio (audience / critics' scores) summary statistics by MPAA rating.\"\n\nstriped = TRUE for alternating color rows\nspacing = \"l\" for larger row heights\nthe align argument for left, right, or center alignment of columns\ndigits for number of decimal places to display\nwidth for, well, width of the table output\nand lastly a caption.\n\n\n\nRecap\n\nShiny has a variety of render*() functions with corresponding *Output() functions to create and display outputs.\nrender*() functions can take on multiple arguments, the first being the expression for the desired output.\nThe expression in the render*() function should be wrapped in curly braces.\n\nAlright, it‚Äôs time for you to practice render*() functions!",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactive Flow",
      "Rendering functions"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactive-flow/render-functions.html#practice-missing-renderplot",
    "href": "r/getstarted/build-an-app/reactive-flow/render-functions.html#practice-missing-renderplot",
    "title": "Rendering functions",
    "section": "Practice: Missing renderPlot()",
    "text": "Practice: Missing renderPlot()\nThe following app is one you‚Äôve seen before ‚Äì it creates a scatterplot of two variables selected by the user. However it‚Äôs missing a crucial component, and hence the plot is not rendered.\n\nYour turn\n\nFix the app code by adding the missing component, and run to confirm that it works.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-3a Missing renderPlot in your Posit Cloud Workspace\n Go to RStudio Cloud Project\n\n\n\n\n\n\n\n\n\nWork locally in your RStudio IDE\n\n\n\n\n\n\nCopy the code below into an R script\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    \n    sidebar = sidebar(\n      \n      selectInput(inputId = \"y\", \n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"audience_score\"),\n\n      selectInput(inputId = \"x\",\n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"critics_score\")\n    ),\n    \n    card(\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  output$scatterplot &lt;- ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n    geom_point()\n\n  }\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n\n    sidebar = sidebar(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"critics_score\"\n      )\n    ),\n\n    card(\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactive Flow",
      "Rendering functions"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactive-flow/render-functions.html#practice-add-rendertext",
    "href": "r/getstarted/build-an-app/reactive-flow/render-functions.html#practice-add-rendertext",
    "title": "Rendering functions",
    "section": "Practice: Add renderText()",
    "text": "Practice: Add renderText()\nIn this app, the user selects x and y variables for the scatterplot. We will extend the app to also include a textOutput which prints the correlation between the two selected variables as well some informational text.\n\nYour turn\n\nCreate the text to be printed using the paste() function: ‚ÄúCorrelation = ____. Note: If the relationship between the two variables is not linear, the correlation coefficient will not be meaningful.‚Äù\nPlace the text within the renderText() function, and assign to output$text$.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-3b Add renderText in your Posit Cloud Workspace.\n Go to RStudio Cloud Project\n\n\n\n\n\n\n\n\n\nWork locally in your RStudio IDE\n\n\n\n\n\n\nCopy the code below into an R script\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    \n    sidebar = sidebar(\n      \n      selectInput(inputId = \"y\", \n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"audience_score\"),\n\n      selectInput(inputId = \"x\",\n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"critics_score\")\n    ),\n    \n    card(\n      plotOutput(outputId = \"scatterplot\"),\n      textOutput(outputId = \"correlation\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n\n  # Create text output stating the correlation between the two ploted\n  output$correlation &lt;- ___\n\n  s}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n\n    sidebar = sidebar(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"critics_score\"\n      )\n    ),\n\n    card(\n      plotOutput(outputId = \"scatterplot\"),\n      textOutput(outputId = \"correlation\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n\n  # Create text output stating the correlation between the two ploted\n  output$correlation &lt;- renderText({\n    r &lt;- round(cor(movies[, input$x], movies[, input$y], use = \"pairwise\"), 3)\n    paste0(\n      \"Correlation = \", r,\n      \". Note: If the relationship between the two variables is not linear, the correlation coefficient will not be meaningful.\"\n    )\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactive Flow",
      "Rendering functions"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/hello-shiny/user-interface.html",
    "href": "r/getstarted/build-an-app/hello-shiny/user-interface.html",
    "title": "User interface (UI)",
    "section": "",
    "text": "In this section we‚Äôll build the user interface of a simple app.\nHowever, before we get into the weeds of building a user interface, let‚Äôs revisit the anatomy of a Shiny app.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Hello Shiny!",
      "User interface (UI)"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/hello-shiny/user-interface.html#practice-extend-the-ui",
    "href": "r/getstarted/build-an-app/hello-shiny/user-interface.html#practice-extend-the-ui",
    "title": "User interface (UI)",
    "section": "Practice: Extend the UI",
    "text": "Practice: Extend the UI\nWe‚Äôll start with a simplified version of the app you saw in the previous exercise. In this app a selectInput() widget is used to allow the user to select which variables should be plotted on the x and y axes of the scatterplot.\nThe selectInput() function has the following arguments:\n\nan inputId that is used to refer to the input parameter when building the scatterplot,\na list of choices to pick from (which must match variable names in the data frame),\nand a selected choice for when the app first launches.\n\n\nYour turn\nModify the Shiny app code in app.R / shown below:\nIn the ui:\n\nAdd a new selectInput widget to color the points by a choice of the following variables: \"title_type\", \"genre\", \"mpaa_rating\", \"critics_rating\", \"audience_rating\".\nMake the default selection \"mpaa_rating\".\nUse \"z\" as the inputId.\nlabel can be whatever you like.\n\nIn the server:\n\nSet the color argument in ggplot() aesthetic mappings to input$z.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete this exercise by opening up the RStudio Project titled 1-2a Extend the UI within your RStudio Cloud Workspace\n Go to Posit Cloud Workspace\n\n\n\n\n\n\n\n\n\nWork locally in your RStudio IDE\n\n\n\n\n\nContinue editing the file you started in the Getting Started section\nOR\n\nDownload the data if you haven‚Äôt already\n\n```{r}\n# Get the data\n\nfile &lt;- \"https://github.com/rstudio-education/shiny-course/raw/main/movies.RData\"\ndestfile &lt;- \"movies.RData\"\n\ndownload.file(file, destfile)\n```\n\nCopy the code below into an R script\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    \n    # Inputs: Select variables to plot\n    sidebar = sidebar(\n      \n      # Select variable for y-axis\n      selectInput(inputId = \"y\",\n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"audience_score\"),\n\n      # Select variable for x-axis\n      selectInput(inputId = \"x\",\n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"critics_score\"),\n\n      # Select variable for color\n      selectInput(inputId = \"___\",\n                  label = \"____\",\n                  choices = c(___),\n                  selected = \"___\"),\n      ),\n    \n    # Output: Show scatterplot\n    card(\n      plotOutput(outputId = \"scatterplot\")\n    )  \n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y,\n                                     color = ___)) +\n      geom_point()\n  })\n\n  }\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n  \n    \n    # Inputs: Select variables to plot\n    sidebar = sidebar(\n      \n      # Select variable for y-axis\n      selectInput(inputId = \"y\",\n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"audience_score\"),\n\n      # Select variable for x-axis\n      selectInput(inputId = \"x\",\n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"critics_score\"),\n\n      # Select variable for color\n      selectInput(inputId = \"z\",\n                  label = \"Color by:\",\n                  choices = c(\"title_type\", \"genre\", \"mpaa_rating\", \"critics_rating\", \"audience_rating\"),\n                  selected = \"mpaa_rating\")\n\n    ),\n\n    # Output: Show scatterplot\n    card(\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y,\n                                     color = input$z)) +\n      geom_point()\n  })\n  \n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Hello Shiny!",
      "User interface (UI)"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/hello-shiny/user-interface.html#practice-extend-the-ui-further",
    "href": "r/getstarted/build-an-app/hello-shiny/user-interface.html#practice-extend-the-ui-further",
    "title": "User interface (UI)",
    "section": "Practice: Extend the UI further",
    "text": "Practice: Extend the UI further\nThe potential variables the user can select for the x and y axes and color currently appear in the UI of the app the same way that they are spelled in the data frame header. However we might want to label them in a way that is more human readable. We can achieve this using named vectors for the choices argument, in the format of \"Human readable label\" = \"variable_name\".\n\nYour turn\n\nFill in the blanks in the code below with human readable labels for x and y inputs.\nRe-create the selectInput widget for color, z, with options \"title_type\", \"genre\", \"mpaa_rating\", \"critics_rating\", and \"audience_rating\", default selection \"mpaa_rating\" just like in the previous exercise, but this time use human readable labels as well.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete this exercise by opening up the RStudio Project titled 1-2b Extend the UI further within your Posit Cloud Workspace\n Go to Posit Cloud Workspace\n\n\n\n\n\n\n\n\n\nWork locally in your RStudio IDE\n\n\n\n\n\n\nContinue editing the code you‚Äôve created with the code below\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n  \n    \n    # Inputs: Select variables to plot\n    sidebar = sidebar(\n      \n      # Select variable for y-axis\n      selectInput(inputId = \"y\",\n                  label = \"Y-axis:\",\n                  choices = c(___ = \"imdb_rating\",\n                              ___ = \"imdb_num_votes\",\n                              ___ = \"critics_score\",\n                              ___ = \"audience_score\",\n                              ___ = \"runtime\"),\n                  selected = \"audience_score\"),\n\n      # Select variable for x-axis\n      selectInput(inputId = \"x\",\n                  label = \"X-axis:\",\n                  choices = c(___ = \"imdb_rating\",\n                              ___ = \"imdb_num_votes\",\n                              ___ = \"critics_score\",\n                              ___ = \"audience_score\",\n                              ___ = \"runtime\"),\n                  selected = \"critics_score\"),\n\n      # Select variable for color\n      selectInput(inputId = \"z\",\n                  label = \"Color:\",\n                  choices = ___,\n                  selected = ___)\n    ),\n\n    # Output: Show scatterplot\n    card(\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y,\n                                     color = input$z)) +\n      geom_point()\n  })\n\n  }\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n  \n    \n    # Inputs: Select variables to plot\n    sidebar = sidebar(\n      \n      # Select variable for y-axis\n      selectInput(inputId = \"y\",\n                  label = \"Y-axis:\",\n                  choices = c(\"IMDB rating\"          = \"imdb_rating\",\n                              \"IMDB number of votes\" = \"imdb_num_votes\",\n                              \"Critics score\"        = \"critics_score\",\n                              \"Audience score\"       = \"audience_score\",\n                              \"Runtime\"              = \"runtime\"),\n                  selected = \"audience_score\"),\n\n      # Select variable for x-axis\n      selectInput(inputId = \"x\",\n                  label = \"X-axis:\",\n                  choices = c(\n                    \"IMDB rating\"          = \"imdb_rating\",\n                    \"IMDB number of votes\" = \"imdb_num_votes\",\n                    \"Critics score\"        = \"critics_score\",\n                    \"Audience score\"       = \"audience_score\",\n                    \"Runtime\"              = \"runtime\"),\n                  selected = \"critics_score\"),\n\n      # Select variable for color\n      # Select variable for color\n      selectInput(inputId = \"z\",\n                  label = \"Color by:\",\n                  choices = c(\n                    \"Title type\" = \"title_type\",\n                    \"Genre\" = \"genre\",\n                    \"MPAA rating\" = \"mpaa_rating\",\n                    \"Critics rating\" = \"critics_rating\",\n                    \"Audience rating\" = \"audience_rating\"),\n                  selected = \"mpaa_rating\")\n\n    ),\n\n    # Output: Show scatterplot\n    card(\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y,\n                                     color = input$z)) +\n      geom_point()\n  })\n\n  }\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Hello Shiny!",
      "User interface (UI)"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/hello-shiny/recap.html",
    "href": "r/getstarted/build-an-app/hello-shiny/recap.html",
    "title": "Recap",
    "section": "",
    "text": "Let‚Äôs quickly recap what we have learned in this tutorial.\nEvery Shiny app has a webpage that the user visits, and behind this webpage there is a computer that serves this webpage by running R.\n\n\n\n\nWhen running your app locally, the computer serving your app is your computer.\n\n\n\n\nWhen your app is deployed, the computer serving your app is a web server.\n\n\n\n\nEach app is comprised of two components, a UI and a server.\n\n\nThe UI is ultimately built with HTML, CSS, and JavaScript. However, you as the Shiny developer do not need to know these languages. Shiny lets R users write user interfaces using a simple, familiar-looking API. However there are no limits to customization for advanced users who are familiar with these languages.\nThe server function contains the instructions to map user inputs to outputs.\n\nI often think of the UI as containing syntax specific to Shiny, and the server as containing R code you might already be familiar with ‚Äì with some Shiny functions added to achieve reactivity.\n\n\nTip: Change display\nIn this tutorial you will be developing your apps in Posit Cloud projects, but once you‚Äôre done with the tutorial you might consider developing your apps in the RStudio IDE, which has some some handy-dandy functionality for running and viewing your apps.\nRStudio will automatically recognize R scripts that contain ui and server components and that end with a call to the shinyApp() function and will make available the Run App button. You can choose to run your app in a new window, or in the viewer pane of your RStudio window.\n\n\n\nTip: Close an app\nWhen you are done with an app, you can terminate the session by clicking the red stop button in your viewer pane.\n\n\n\n\nThat‚Äôs all for this module! In the next module we discuss inputs, outputs, and rendering functions in further detail.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Hello Shiny!",
      "Recap"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/customizing-ui/theming.html#practice---theming",
    "href": "r/getstarted/build-an-app/customizing-ui/theming.html#practice---theming",
    "title": "Theming",
    "section": "Practice - Theming",
    "text": "Practice - Theming\n\nYour turn\n\nPick a Bootstrap theme and apply to the existing app.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the Posit Cloud Project titled 4-4 Customize the appearance of your app in your Posit Cloud Workspace\n Go to Posit Cloud Project\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(tools)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    sidebar = sidebar(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.5\n      ),\n\n      sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 2\n      ),\n\n      textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      ),\n\n      actionButton(\n        inputId = \"update_plot_title\",\n        label = \"Update plot title\"\n      )\n    ),\n\n    card(\n      markdown(\n        \"These data were obtained from [IMBD](http://www.imbd.com/) and [Rotten Tomatoes](https://www.rottentomatoes.com/).\n  \n        The data represent 651 randomly sampled movies released between 1972 to 2014 in the United States.\"\n      ),\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  new_plot_title &lt;- eventReactive(\n    eventExpr = input$update_plot_title,\n    valueExpr = {\n      toTitleCase(input$plot_title)\n    }\n  )\n\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y, color = input$z)) +\n      geom_point(alpha = input$alpha, size = input$size) +\n      labs(title = new_plot_title())\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(tools)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(theme = bs_theme(preset = \"vapor\"),\n    sidebar = sidebar(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.5\n      ),\n\n      sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 2\n      ),\n\n      textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      ),\n\n      actionButton(\n        inputId = \"update_plot_title\",\n        label = \"Update plot title\"\n      )\n    ),\n\n    card(\n      markdown(\n        \"These data were obtained from [IMBD](http://www.imbd.com/) and [Rotten Tomatoes](https://www.rottentomatoes.com/).\n  \n        The data represent 651 randomly sampled movies released between 1972 to 2014 in the United States.\"\n      ),\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  new_plot_title &lt;- eventReactive(\n    eventExpr = input$update_plot_title,\n    valueExpr = {\n      toTitleCase(input$plot_title)\n    }\n  )\n\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y, color = input$z)) +\n      geom_point(alpha = input$alpha, size = input$size) +\n      labs(title = new_plot_title())\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Customizing UI",
      "Theming"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/customizing-ui/layout.html",
    "href": "r/getstarted/build-an-app/customizing-ui/layout.html",
    "title": "Layout Components",
    "section": "",
    "text": "In this section we discuss how to layout a Shiny app. Shiny apps are built upon Bootstrap, an extremely popular CSS/HTML framework. As a result, we recommend that you use the {bslib} package to build your layout. {bslib} makes the most modern Bootstrap features available to Shiny developers, without assuming that you know how to use Bootsrap.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Customizing UI",
      "Layout Components"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/customizing-ui/layout.html#movie-browser-1970-to-2014",
    "href": "r/getstarted/build-an-app/customizing-ui/layout.html#movie-browser-1970-to-2014",
    "title": "Layout Components",
    "section": "Movie browser, 1970 to 2014",
    "text": "Movie browser, 1970 to 2014\n\n\n\nSome inputs\n\n\n\n\nSome outputs\n\n\n\n\n\nconditionalPanel()\nThe last layout element we will consider is conditionalPanel(), which comes from the {shiny} package. conditionalPanel() creates a panel that is visible conditional upon the value of an input or an output.\nFirst, let‚Äôs see it in action in the app below. Click the check box next to ‚ÄúClick to select number of digits‚Äù to see how the sidebar panel changes.\n\n\n\n\n\n\n\n\n\nAnd here is the code that creates the app with the conditional panel.\nUnder the hood this function evaluates a JavaScript expression once at start up and then whenever Shiny detects a relevant change or input/output.\nBeing able to display panels conditional on previous user selections is a powerful feature of Shiny.\nlibrary(shiny)\nlibrary(bslib)\n\n# Define UI with conditionalPanel\nui &lt;- page_sidebar(\n  title =\"Random number generator\",\n  sidebar = sidebar(\n      width = 325,\n      checkboxInput(\n        \"select_digits\", \"Click to select number of digits\",\n        value = FALSE\n      ),\n      conditionalPanel(\n        condition = \"input.select_digits == true\",\n        sliderInput(\"digit_count\", \"How many digits?\",\n                    min = 1, max = 10, value = 4\n        )\n      ),\n      actionButton(\"go\", \"Generate new random number\")\n    ),\n\n    \"Your random number is\",\n    h4(textOutput(\"random_number\"))\n)\n\n# Define server logic that generates a random number based on user input\nserver &lt;- function(input, output, session) {\n  output$random_number &lt;- renderText({\n    input$go\n    raw &lt;- runif(1)\n    digits &lt;- if (input$select_digits == FALSE) {\n      sample(1:10, size = 1)\n    } else {\n      input$digit_count\n    }\n    round(raw * 10^digits)\n  })\n}\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Customizing UI",
      "Layout Components"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/customizing-ui/congratulations.html",
    "href": "r/getstarted/build-an-app/customizing-ui/congratulations.html",
    "title": "Congratulations!",
    "section": "",
    "text": "You now know how to get started with building web apps in R with Shiny!\n\nWhat did you learn?\nIn this course you have learned:\n\nHow to design a Shiny app from scratch\nThe essentials of reactive programming\nYou also got practice with customizing your app‚Äôs UI\nEmploying reactivity best practices\n\nWe hope you enjoyed the course and that the topics we discussed in this course motivated you to build your first, and second, and third Shiny app!\nOnce you build your first app, you have a variety of deployment options.\n\n\nshinyapps.io\nThe first is shinyapps.io. This is a server maintained by Posit, that is easy to use, secure, and scalable. It comes with built in metrics and has a free tier available.\n\n\nShiny Server\nIf you prefer to build your own server you can use Shiny Server, which is free and open source. It runs on premises, moving your computation closer to your data.\n\n\nPro options\nPosit also offers a professional option for deploying your apps: Posit Connect. You can find out more about all of these options at https://shyr-test-center.netlify.appm/deploy.\n\n\nCongratulations!\nWhat we covered in this course is just the tip of the Shiny iceberg, so we hope you decide to dive deeper to learn more.\nWe can‚Äôt wait to see the apps you create online!",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Customizing UI",
      "Congratulations!"
    ]
  },
  {
    "objectID": "r/gallery/widgets/widget-gallery/index.html",
    "href": "r/gallery/widgets/widget-gallery/index.html",
    "title": "Widget Gallery",
    "section": "",
    "text": "Back to Gallery\n      Widget Gallery\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/widgets/selectize-vs-select/index.html",
    "href": "r/gallery/widgets/selectize-vs-select/index.html",
    "title": "Selectize vs.¬†Select",
    "section": "",
    "text": "Back to Gallery\n      Selectize vs.¬†Select\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/widgets/option-groups-for-selectize-input/index.html",
    "href": "r/gallery/widgets/option-groups-for-selectize-input/index.html",
    "title": "Option groups for selectize input",
    "section": "",
    "text": "Back to Gallery\n      Option groups for selectize input\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/widgets/file-upload/index.html",
    "href": "r/gallery/widgets/file-upload/index.html",
    "title": "File Upload",
    "section": "",
    "text": "Back to Gallery\n      File Upload\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/widgets/dynamic-clustering/index.html",
    "href": "r/gallery/widgets/dynamic-clustering/index.html",
    "title": "Dynamic Clustering",
    "section": "",
    "text": "Back to Gallery\n      Dynamic Clustering\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/widgets/datatables-options/index.html",
    "href": "r/gallery/widgets/datatables-options/index.html",
    "title": "DataTables Options",
    "section": "",
    "text": "Back to Gallery\n      DataTables Options\n            \n                         View App"
  },
  {
    "objectID": "r/gallery/widgets/custom-input-control/index.html",
    "href": "r/gallery/widgets/custom-input-control/index.html",
    "title": "Custom input control",
    "section": "",
    "text": "Back to Gallery\n      Custom input control\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/widgets/basic-datatable/index.html",
    "href": "r/gallery/widgets/basic-datatable/index.html",
    "title": "Basic DataTable",
    "section": "",
    "text": "Back to Gallery\n      Basic DataTable\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/technology/dynamic-repot/index.html",
    "href": "r/gallery/technology/dynamic-repot/index.html",
    "title": "Advanced D3 interactive charts with dynamic reports",
    "section": "",
    "text": "Back to Gallery\n      Advanced D3 interactive charts with dynamic reports\n            Jiena Gu McLellan\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            Advanced interactive charts with dynamic reports!"
  },
  {
    "objectID": "r/gallery/technology/chirp/index.html",
    "href": "r/gallery/technology/chirp/index.html",
    "title": "Chirp",
    "section": "",
    "text": "Back to Gallery\n      Chirp\n            John Coene\n            \n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            Visualise Twitter interactions in the form networks. Enter a search or a single keyword and explore how users conversed around the topic with the help of numerous filters and network views.\n            You can also freely download the app and deploy on your premises."
  },
  {
    "objectID": "r/gallery/start-simple/telephones-by-region/index.html",
    "href": "r/gallery/start-simple/telephones-by-region/index.html",
    "title": "Telephones by region",
    "section": "",
    "text": "Back to Gallery\n      Telephones by region\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/start-simple/kmeans-example/index.html",
    "href": "r/gallery/start-simple/kmeans-example/index.html",
    "title": "Kmeans example",
    "section": "",
    "text": "Back to Gallery\n      Kmeans example\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/sports/soccer-player-similarity/index.html",
    "href": "r/gallery/sports/soccer-player-similarity/index.html",
    "title": "The ten most similar players - Pro Evolution Soccer 2019",
    "section": "",
    "text": "Back to Gallery\n      The ten most similar players - Pro Evolution Soccer 2019\n            Thiago\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            This app is an interactive tool that allows any user to choose a soccer player from the game and find the ten players most similar whith him."
  },
  {
    "objectID": "r/gallery/sports/impact-replay-cfl/index.html",
    "href": "r/gallery/sports/impact-replay-cfl/index.html",
    "title": "Impact Replays: Relive the Best Moments of the CFL",
    "section": "",
    "text": "Back to Gallery\n      Impact Replays: Relive the Best Moments of the CFL\n            Dean Attali\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            Using play-by-play data, visualize the progression of Canadian Football League matches by showing the passes, rushes, and touchdowns. This shiny app (which doesn‚Äôt look like one!) was the winner of the 2015 Canada Sports Hackathon.\n            This app was recognized with an honorable mention on the 2019 Shiny Contest."
  },
  {
    "objectID": "r/gallery/reactive-programming/timer/index.html",
    "href": "r/gallery/reactive-programming/timer/index.html",
    "title": "Timer",
    "section": "",
    "text": "Back to Gallery\n      Timer\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/reactive-programming/reactivity/index.html",
    "href": "r/gallery/reactive-programming/reactivity/index.html",
    "title": "Reactivity",
    "section": "",
    "text": "Back to Gallery\n      Reactivity\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/reactive-programming/observer-demo/index.html",
    "href": "r/gallery/reactive-programming/observer-demo/index.html",
    "title": "Observer demo",
    "section": "",
    "text": "Back to Gallery\n      Observer demo\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/reactive-programming/actionbutton-demo/index.html",
    "href": "r/gallery/reactive-programming/actionbutton-demo/index.html",
    "title": "actionButton demo",
    "section": "",
    "text": "Back to Gallery\n      actionButton demo\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/miscellaneous/pokemon-questions/index.html",
    "href": "r/gallery/miscellaneous/pokemon-questions/index.html",
    "title": "Pok√©mon 20 Questions",
    "section": "",
    "text": "Back to Gallery\n      Pok√©mon 20 Questions\n            Ashley Baldry\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            This is a fun, simple app around 20 Questions, but instead of random objects, it is Pokemon. Select any one up until generation 6 and go through the questions 1 by 1 until it tries to guess the Pokemon you are thinking of. For certain details that are relevant to the quiz that might not be aware of, there is a reference table included."
  },
  {
    "objectID": "r/gallery/miscellaneous/magnetic-fields/index.html",
    "href": "r/gallery/miscellaneous/magnetic-fields/index.html",
    "title": "A lyrical analysis of ‚Äò69 Love Songs‚Äô by Magnetic Fields",
    "section": "",
    "text": "Back to Gallery\n      A lyrical analysis of ‚Äò69 Love Songs‚Äô by Magnetic Fields\n            David Smale\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            Exploring the lyrics to the three-volume album, ‚Äò69 Love Songs‚Äô, by The Magnetic Fields. The album was conceived and written by frontman, Stephin Merritt, but what does Stephin sing about when he sings about love (songs)? You can find out more about the app on this blog post.\n            69 Love Songs is the winner of the Best Design award of the 2019 Shiny Contest. We fell in love with the look of this app, and really appreciated that the font and colours used in the app have been chosen to match the album artwork. You don‚Äôt have to be a fan of the Magnetic Fields to appreciate the care and attention to detail that went into each panel!"
  },
  {
    "objectID": "r/gallery/miscellaneous/lego-mosaic/index.html",
    "href": "r/gallery/miscellaneous/lego-mosaic/index.html",
    "title": "The Shiny LEGO mosaic creator",
    "section": "",
    "text": "Back to Gallery\n      The Shiny LEGO mosaic creator\n            Eric Nantz\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            ShinyLEGO is a Shiny app that creates a mosaic composed of LEGO bricks from any image file! Customize various settings for your mosaic such as dimensions, brightness, and colors. Best of all, you can download instructions so that you can build the mosaic yourself IRL!\n            This app is one of the runers up of the 2019 Shiny Contest. Upload any (relatively small) image and within seconds this app will design a LEGO mosaic for you, complete with a list of required bricks and build instructions!"
  },
  {
    "objectID": "r/gallery/miscellaneous/hex-memory/index.html",
    "href": "r/gallery/miscellaneous/hex-memory/index.html",
    "title": "Hex Memory Game",
    "section": "",
    "text": "Back to Gallery\n      Hex Memory Game\n            Victor Perrier\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            A memory game in Shiny to find matching Hex!\n            Hex Memory Game is the winner of the Most Fun award of the 2019 Shiny Contest. A brave handful of people have built small games in Shiny. It‚Äôs always impressive to us when people pull that off at all, but we haven‚Äôt seen one that works as well as this one. Not only that, but the code is super clean and easy to reason about."
  },
  {
    "objectID": "r/gallery/miscellaneous/conference-tweet-dashboard/index.html",
    "href": "r/gallery/miscellaneous/conference-tweet-dashboard/index.html",
    "title": "A Dashboard for Conference Tweets",
    "section": "",
    "text": "Back to Gallery\n      A Dashboard for Conference Tweets\n            Garrick Aden-Buie\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            A Shiny app for tracking tweets around conferences and events. With a leader board and tools for exploring tweets sent with a conference hashtag, users can stay up to date with the online conversation, or explore the action after the fact.\n            This app is one of the runners up of the 2019 Shiny Contest. We have fond memories of rstudio::conf 2019, but nostalgia isn‚Äôt the only thing going for this dashboard by Garrick Aden-Buie. There are a lot of great tweets we missed the first time around, and we added some new follows. We also loved the Top Emoji plot."
  },
  {
    "objectID": "r/gallery/life-sciences/visual-abstracts/index.html",
    "href": "r/gallery/life-sciences/visual-abstracts/index.html",
    "title": "Visual Abstracts for Original Research",
    "section": "",
    "text": "Back to Gallery\n      Visual Abstracts for Original Research\n            Matthew Kumar\n            \n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            An R-Shiny application to create visual abstracts for original research studies.\n            This app was recognized with an honorable mention on the 2019 Shiny Contest."
  },
  {
    "objectID": "r/gallery/life-sciences/shinyab-sample-size/index.html",
    "href": "r/gallery/life-sciences/shinyab-sample-size/index.html",
    "title": "Shiny Contest Submission : ShinyAB - Shiny Apps Calculator of Sample Size for AB test",
    "section": "",
    "text": "Back to Gallery\n      Shiny Contest Submission : ShinyAB - Shiny Apps Calculator of Sample Size for AB test\n            Motoyuki Oki\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            The application is a calculator of sample size for AB test including the following functions : 1. informative tables for supporting understanding of statistical Type I and II error 2. various visualization of control and treatment groups regarding AB Test"
  },
  {
    "objectID": "r/gallery/life-sciences/phylo-tree-view-subset/index.html",
    "href": "r/gallery/life-sciences/phylo-tree-view-subset/index.html",
    "title": "Interactively view and subset phylogenetic trees",
    "section": "",
    "text": "Back to Gallery\n      Interactively view and subset phylogenetic trees\n            Tyler Bradley\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            This app allows for users to upload a .tree file (or other common phylogenetic tree file types) and visually explore it. You can leave the tree its full size, or you can subset it by looking at specific branches to easily zoom in on related species."
  },
  {
    "objectID": "r/gallery/life-sciences/mri-images/index.html",
    "href": "r/gallery/life-sciences/mri-images/index.html",
    "title": "ShinyMRI - View MRI images in Shiny",
    "section": "",
    "text": "Back to Gallery\n      ShinyMRI - View MRI images in Shiny\n            Hao Zhuname\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            This app visualizes 3D MRI images interactively using pure R shiny mechanism.\n            This app was recognized with an honorable mention on the 2019 Shiny Contest."
  },
  {
    "objectID": "r/gallery/life-sciences/isee/index.html",
    "href": "r/gallery/life-sciences/isee/index.html",
    "title": "iSEE",
    "section": "",
    "text": "Back to Gallery\n      iSEE\n            Kevin Rue\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            iSEE (interactive SummarizedExperiment Explorer) is designed for interactive exploration of high-throughput biological data sets.\n            iSEE is winner of the Most Technically Impressive award of the 2019 Shiny Contest. The deeper we dove into this app, the more impressed we were at its feature set. The data-visual-selection controls in each panel were well presented, and the dynamic, directional crosslinking feature is something we haven‚Äôt seen before. And it can even generate a reproducible R script!"
  },
  {
    "objectID": "r/gallery/life-sciences/genome-browser/index.html",
    "href": "r/gallery/life-sciences/genome-browser/index.html",
    "title": "Genome browser",
    "section": "",
    "text": "Back to Gallery\n      Genome browser\n            ICGC Data Portal\n            \n                 About the Author\n                         View App\n                         View Code\n                      \n                \n            This visualisation is based on Circos, a way of visualising whole genomes. Here we are using data taken from the ICGC, specifically pancreatic adenocarcinoma tumour samples from various donors. The Circos-style plot shows a number of layers, starting from the outer layer representing colour and size distinguished chromosomes, moving clockwise from chromosome 1 to 22, then X and Y. Inside the chromosomes ring, you can see a line representation of copy number mutations. When expanded (by clicking a chromosome), more details on the precise copy number at specific locations is revealed. Hover the bars for further details."
  },
  {
    "objectID": "r/gallery/life-sciences/covid19-tracker/index.html",
    "href": "r/gallery/life-sciences/covid19-tracker/index.html",
    "title": "COVID-19 tracker",
    "section": "",
    "text": "Back to Gallery\n      COVID-19 tracker\n            Edward Parker\n            \n                 About the Author\n                         View App\n                         View Code\n                      \n                \n            In December 2019, cases of severe respiratory illness began to be reported across the city of Wuhan in China. These were caused by a new type of coronavirus, and the disease is now commonly referred to as COVID-19. The number of COVID-19 cases started to escalate more quickly in mid-January and the virus soon spread beyond China‚Äôs borders. This story has been rapidly evolving ever since, and each day we are faced by worrying headlines regarding the current state of the outbreak.\n            In isolation, these headlines can be hard to interpret. How fast is the virus spreading? Are efforts to control the disease working? How does the situation compare with previous epidemics? This site is updated daily based on data published by Johns Hopkins University. By looking beyond the headlines, we hope it is possible to get a deeper understanding of this unfolding pandemic.\n            An article discussing this app was published in The Conversation. The map was also featured on the BBC World Service program Science in Action.\n            This app is updated once daily. For more regular updates, see the JHU COVID-19 dashboard."
  },
  {
    "objectID": "r/gallery/life-sciences/animal-tracking/index.html",
    "href": "r/gallery/life-sciences/animal-tracking/index.html",
    "title": "ctmmweb, a web app to analysis Animal tracking data",
    "section": "",
    "text": "Back to Gallery\n      ctmmweb, a web app to analysis Animal tracking data\n            Xianghui Dong\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            ctmmweb is built on ctmm, an R package for analyzing animal tracking data as a continuous-time stochastic processes. The web app provided a streamlined workflow so general users can upload their own data and get sophisticated analyses result in an interactive interface.\n            This app was recognized with an honorable mention on the 2019 Shiny Contest."
  },
  {
    "objectID": "r/gallery/internationalization/unicode-characters/index.html",
    "href": "r/gallery/internationalization/unicode-characters/index.html",
    "title": "Unicode characters",
    "section": "",
    "text": "Back to Gallery\n      Unicode characters\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/interactive-visualizations/movie-explorer/index.html",
    "href": "r/gallery/interactive-visualizations/movie-explorer/index.html",
    "title": "Movie explorer",
    "section": "",
    "text": "Back to Gallery\n      Movie explorer\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/interactive-visualizations/bus-dashboard/index.html",
    "href": "r/gallery/interactive-visualizations/bus-dashboard/index.html",
    "title": "Bus dashboard",
    "section": "",
    "text": "Back to Gallery\n      Bus dashboard\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/interactive-plots/plot-interaction-selecting-points/index.html",
    "href": "r/gallery/interactive-plots/plot-interaction-selecting-points/index.html",
    "title": "Plot interaction - selecting points",
    "section": "",
    "text": "Back to Gallery\n      Plot interaction - selecting points\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/interactive-plots/plot-interaction-advanced/index.html",
    "href": "r/gallery/interactive-plots/plot-interaction-advanced/index.html",
    "title": "Plot interaction - advanced",
    "section": "",
    "text": "Back to Gallery\n      Plot interaction - advanced\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/government-public-sector/viscover/index.html",
    "href": "r/gallery/government-public-sector/viscover/index.html",
    "title": "VISCOVER",
    "section": "",
    "text": "Back to Gallery\n      VISCOVER\n            Xiaodan Lyu\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            This is a shiny app tool designed for interacting with Cropland Data Layer (CDL) and Soil Data Layer (SDL). CDL is geo-referenced crop-specific land cover data, created annually for the contiguous United States since 2008. SDL contains tabular and spatial soil information available for the United States and the Territories. Unlike the official tools on the USDA website, this app provides a user-friendly interface to interact with public Federal data from different sources and allows users to make cross-reference through the overlay operation. Besides leaflet and plotly, this app mainly relies on my tiny R package viscover on GitHub to query these two public databases with Web Map Service and Web Geo-processing Service. This app can be adapted to visualize other various Federal data where web services are supported and nicely documented, such as Normalized Difference Vegetation Index (NDVI), Vegetation Condition Index (VCI), National Land Cover Data (NLCD), etc."
  },
  {
    "objectID": "r/gallery/government-public-sector/scotpho-profiles/index.html",
    "href": "r/gallery/government-public-sector/scotpho-profiles/index.html",
    "title": "ScotPHO Profiles Tool",
    "section": "",
    "text": "Back to Gallery\n      ScotPHO Profiles Tool\n            Vicky Elliott, Jaime Villacampa, Zsanett Bahor\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            An interactive local area health and wellbeing profiling tool for Scotland. The app provides users with an assortment of custom interactive visualisations, allowing exploration of temporal and geographical comparisons across a range of indicators of health and wider determinants of health.\n            This app is one of the runners up of the 2019 Shiny Contest. The app was created to help people living and working in Scotland explore how geographical areas have changed over time or how they compare to other areas, across a range of indicators of health and wider determinants of health. The app is pretty complicated, but no more than it has to be with such a sprawling dataset behind it. Each part of the app has a carefully curated set of options that expose lots of power without being totally overwhelming. The context-sensitive Definition button and pervasive Download data/Save chart options are nice touches as well."
  },
  {
    "objectID": "r/gallery/government-public-sector/nyc-metro/index.html",
    "href": "r/gallery/government-public-sector/nyc-metro/index.html",
    "title": "Animated NYC metro traffic",
    "section": "",
    "text": "Back to Gallery\n      Animated NYC metro traffic\n            Tiger Tang\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            Wonder what one week of metro traffic would look like? Wanna see the heaviest/lightest traffic times for your NYC metro stops? Check out this app below.\n            This app was recognized with an honorable mention on the 2019 Shiny Contest."
  },
  {
    "objectID": "r/gallery/government-public-sector/india-blood-banks/index.html",
    "href": "r/gallery/government-public-sector/india-blood-banks/index.html",
    "title": "Locating Blood Banks in India",
    "section": "",
    "text": "Back to Gallery\n      Locating Blood Banks in India\n            Atmajitsinh\n            \n                 About the Author\n                         View App\n                         View Code\n                      \n                \n            The main motivation behind this simple shiny application is to make it easier to locate blood banks in India. The app provides additional details on pincodes, addresses, contact person name and number."
  },
  {
    "objectID": "r/gallery/government-public-sector/dublin-transport/index.html",
    "href": "r/gallery/government-public-sector/dublin-transport/index.html",
    "title": "Dublin Transport Info",
    "section": "",
    "text": "Back to Gallery\n      Dublin Transport Info\n            Aidan Boland\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            The current Dublin Bus (Ireland) website and app will only allow you to view information for a single bus stop. This frustrated me into creating this Shiny app.\n            I can commute home using a number of different bus stops. This Shiny app will collate the information on a number of different bus stops and filter out the relevant buses for the user. The search query string in the URL can be used to pre-populate the bus stop numbers and buses selected."
  },
  {
    "objectID": "r/gallery/government-public-sector/crime-watch/index.html",
    "href": "r/gallery/government-public-sector/crime-watch/index.html",
    "title": "Crime Watch",
    "section": "",
    "text": "Back to Gallery\n      Crime Watch\n            Paul Campbell\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            This is an example of how shiny can be used to democratise a data source by connected users to an API via a simple, effective user interface.\n            This application uses geocoding and GPS to allow users to retrieve and map data from the UK Police data base at a location of their choice within England, Wales or Northern Ireland.\n            Currently the app will return data for the most recent month available in the data base. Functionality could be added to allow users to request data from previous months.\n            Criminal incidents within a 1 mile radius of the users chosen location are retrieved and mapped at the latitude + longitude recorded by the police. A summary count of all incidents, grouped by category, is also visualised in a bar chart."
  },
  {
    "objectID": "r/gallery/government-public-sector/brazil-voter-profile/index.html",
    "href": "r/gallery/government-public-sector/brazil-voter-profile/index.html",
    "title": "Voronoys - Understanding voters‚Äô profile in Brazilian elections",
    "section": "",
    "text": "Back to Gallery\n      Voronoys - Understanding voters‚Äô profile in Brazilian elections\n            Douglas Mesquita\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            This tool provides access to usual charts, maps and an innovative way to investigate voters‚Äô profile in Brazilian elections.\n            This app was recognized with an honorable mention on the 2019 Shiny Contest."
  },
  {
    "objectID": "r/gallery/finance-banking/career-pathfinder/index.html",
    "href": "r/gallery/finance-banking/career-pathfinder/index.html",
    "title": "Career PathFinder",
    "section": "",
    "text": "Back to Gallery\n      Career PathFinder\n            George\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            Explore historical career choices at LA County and build your own path towards your goals.\n            This app was recognized with an honorable mention on the 2019 Shiny Contest."
  },
  {
    "objectID": "r/gallery/extending-shiny/drag-drop-map-maker/index.html",
    "href": "r/gallery/extending-shiny/drag-drop-map-maker/index.html",
    "title": "Drag-and-drop U.S. mapmaker",
    "section": "",
    "text": "Back to Gallery\n      Drag-and-drop U.S. mapmaker\n            Aleszu Bajak\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            A Shiny app allowing users to upload a CSV file with latitude and longitude coordinates to create and customize a U.S. map of point data. Users can modify points shape, size and color, as well as font type and size."
  },
  {
    "objectID": "r/gallery/education/rd-business-game/index.html",
    "href": "r/gallery/education/rd-business-game/index.html",
    "title": "R&D Business Game",
    "section": "",
    "text": "Back to Gallery\n      R&D Business Game\n            Paul Simmering\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            A business game where the player is the CEO of a tech company. Two companies use innovation & imitation strategies to compete, impress consumers and maximize profit."
  },
  {
    "objectID": "r/gallery/education/ncaa-swim-team-finder/index.html",
    "href": "r/gallery/education/ncaa-swim-team-finder/index.html",
    "title": "NCAA Swimming Team Finder for Incoming College Athletes",
    "section": "",
    "text": "Back to Gallery\n      NCAA Swimming Team Finder for Incoming College Athletes\n            Greg Pilgrimname\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            A look at college swimming programs to help incoming student athletes in selecting schools and programs that would fit them athletically, academically, locationally and financially. Provides interactive maps and charts to display programs sorted by swimming times/events, US News college rankings, etc."
  },
  {
    "objectID": "r/gallery/dynamic-user-interface/update-input-demo/index.html",
    "href": "r/gallery/dynamic-user-interface/update-input-demo/index.html",
    "title": "Update input demo",
    "section": "",
    "text": "Back to Gallery\n      Update input demo\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/dynamic-user-interface/conditionalpanel-demo/index.html",
    "href": "r/gallery/dynamic-user-interface/conditionalpanel-demo/index.html",
    "title": "conditionalPanel demo",
    "section": "",
    "text": "Back to Gallery\n      conditionalPanel demo\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/application-layout/tabsets/index.html",
    "href": "r/gallery/application-layout/tabsets/index.html",
    "title": "Tabsets",
    "section": "",
    "text": "Back to Gallery\n      Tabsets\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/application-layout/retirement-simulation/index.html",
    "href": "r/gallery/application-layout/retirement-simulation/index.html",
    "title": "Retirement simulation",
    "section": "",
    "text": "Back to Gallery\n      Retirement simulation\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/application-layout/navlistpanel-example/index.html",
    "href": "r/gallery/application-layout/navlistpanel-example/index.html",
    "title": "navlistPanel example",
    "section": "",
    "text": "Back to Gallery\n      navlistPanel example\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/application-layout/inline-output/index.html",
    "href": "r/gallery/application-layout/inline-output/index.html",
    "title": "Inline Output",
    "section": "",
    "text": "Back to Gallery\n      Inline Output\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/application-layout/absolutely-positioned-panels/index.html",
    "href": "r/gallery/application-layout/absolutely-positioned-panels/index.html",
    "title": "Absolutely-positioned panels",
    "section": "",
    "text": "Back to Gallery\n      Absolutely-positioned panels\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/advanced-shiny/selectize-rendering-methods/index.html",
    "href": "r/gallery/advanced-shiny/selectize-rendering-methods/index.html",
    "title": "Selectize rendering methods",
    "section": "",
    "text": "Back to Gallery\n      Selectize rendering methods\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/advanced-shiny/option-groups-for-server-side-selectize/index.html",
    "href": "r/gallery/advanced-shiny/option-groups-for-server-side-selectize/index.html",
    "title": "Option groups for server-side selectize",
    "section": "",
    "text": "Back to Gallery\n      Option groups for server-side selectize\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/advanced-shiny/image-output/index.html",
    "href": "r/gallery/advanced-shiny/image-output/index.html",
    "title": "Image output",
    "section": "",
    "text": "Back to Gallery\n      Image output\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/advanced-shiny/download-knitr-reports/index.html",
    "href": "r/gallery/advanced-shiny/download-knitr-reports/index.html",
    "title": "Download knitr Reports",
    "section": "",
    "text": "Back to Gallery\n      Download knitr Reports\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/advanced-shiny/client-data-and-query-string/index.html",
    "href": "r/gallery/advanced-shiny/client-data-and-query-string/index.html",
    "title": "Client data and query string",
    "section": "",
    "text": "Back to Gallery\n      Client data and query string\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/advanced-shiny/bookmarking-url/index.html",
    "href": "r/gallery/advanced-shiny/bookmarking-url/index.html",
    "title": "Bookmarking - URL",
    "section": "",
    "text": "Back to Gallery\n      Bookmarking - URL\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/contribute.html#answer-questions",
    "href": "r/contribute.html#answer-questions",
    "title": "Contribute to Shiny",
    "section": "Answer questions",
    "text": "Answer questions\nThe easiest way to help out is to answer questions. You won‚Äôt know the answer to everything, but that‚Äôs ok! Even just the acknowledgement that someone cares enough to try can be tremendously encouraging.\nMany people asking for help, don‚Äôt know about reprexes. A little education, and some help crafting a reprex can go a long way. You might not answer the question, but you‚Äôll help someone answer it more easily.\nIf you‚Äôre interested in answering questions, good places to start are the Posit Community site, Stack Overflow, and Twitter. Just remember that while you might have seen the problem a hundred times before, it‚Äôs new to the person asking it. Be patient, polite, and empathic."
  },
  {
    "objectID": "r/contribute.html#file-issues",
    "href": "r/contribute.html#file-issues",
    "title": "Contribute to Shiny",
    "section": "File issues",
    "text": "File issues\nIf you‚Äôve found a bug, first create a minimal reprex. Spend some time trying to make it as minimal as possible: the more time you spend doing this, the easier it will be for the Shiny team to fix it. Then file it on the GitHub repo."
  },
  {
    "objectID": "r/contribute.html#contribute-documentation-or-code",
    "href": "r/contribute.html#contribute-documentation-or-code",
    "title": "Contribute to Shiny",
    "section": "Contribute documentation or code",
    "text": "Contribute documentation or code\nIf you‚Äôre a bit more experienced with Shiny and are looking to improve your open source development skills, the next step up is to contribute a pull request to the shiny package. The most important thing to know is that Shiny uses roxygen2: this means that documentation is found in the R code close to the source of each function.\nBefore you do a pull request, you should always file an issue and make sure someone from the Shiny team agrees that it‚Äôs a problem, and is happy with your basic proposal for fixing it. We don‚Äôt want you to spend a bunch of time on something that we don‚Äôt think is a good idea.\nBefore contributing to the package in any way, please review the contributing guidelines."
  },
  {
    "objectID": "r/articles/start/help/index.html",
    "href": "r/articles/start/help/index.html",
    "title": "How to get help",
    "section": "",
    "text": "Writing code can be tricky. Sometimes you will want more advice than you can find in R‚Äôs help pages.\nThis article will show you where to seek help, how to get it.\nSupport for R and Shiny has developed like the languages themselves, organically and through the excellent work of volunteers. You can be a part of this process. Simply ask your questions in the right places and in a clear manner. Not only will your question help you, it will create a record that will benefit everyone who has the same question later."
  },
  {
    "objectID": "r/articles/start/help/index.html#where-to-seek-help",
    "href": "r/articles/start/help/index.html#where-to-seek-help",
    "title": "How to get help",
    "section": "Where to seek help",
    "text": "Where to seek help\nYou will get the quickest response if you submit your question to a place that people already visit to ask and answer similar questions. We recommend these resources for questions on the following topics:\n\nR:\n\nRStudio Community\nStackOverflow\n\nShiny:\n\nRStudio Community\nshiny-dicuss Google group\nStackOverflow\n\nShiny Server: The Shiny Server support forum\nPosit Connect and Shiny Server Pro: email the RStudio customer support team1\nShinyApps.io: The ShinyApps.io discussion group\nRStudio IDE: The RStudio IDE support forum\n\n1Since Posit Connect and Shiny Server Pro are paid products, they have a dedicated customer support team.\nThese sites all have archives that you can search to see if your question has already been answered. If answered, you can get an immediate solution!\nOnce answered your question will go into these archives and expand the knowledge base in the Shiny community."
  },
  {
    "objectID": "r/articles/start/help/index.html#how-to-get-help",
    "href": "r/articles/start/help/index.html#how-to-get-help",
    "title": "How to get help",
    "section": "How to get help",
    "text": "How to get help\nYou will get the most useful help if you do these simple things:\n\nSearch the archives and check if your question has an answer already.\nWrite a minimal reproducible example that illustrates your problem.\nBe precise. Include the exact error messages that you see.\nRun sessionInfo() in R and include the output with your question (sessionInfo() displays the versions of R and its packages that you are using, as well as your OS. This is important information for debugging).\nBe friendly and appreciative.\n\nThese steps will make it easier for a mentor to help you.\n\nHow to write a good reproducible example\nA reproducible example is a snippet of R code that someone can run and recreate your problem. Many bugs cannot be diagnosed unless you include the code that causes them.\nA good reproducible example is:\n\nMinimal - It should contain just enough code to recreate the bug. This will help both you and your mentors zero in on the problem.\nComplete - It should contain everything a person needs to recreate the bug. In other words, a person should be able to copy and paste the code into R and see the bug.\n\nYou do not need to share your own code and data (if you do not want to). Often you can create an example that reproduces your bug with toy code and a dummy data set.\nIf you need to create a reproducible example of a Shiny app, we recommend you save your app as a gist. When you write your question, include the runGist command that will launch your app. A runGist command looks like this:\nshiny::runGist(\"eb3470beb1c0252bd0289cbc89bcf36f\")\nDon‚Äôt forget to explain how to create the error in your app. You may need to provide instructions such as ‚ÄúClick this checkbox‚Äù or ‚ÄúSelect this value.‚Äù\nIf you need to create a reproducible example of Rcpp code, we recommend you supply a .cpp file that can be executed through Rcpp::sourceCpp. It is the easiest way of testing or debugging C++ / Rcpp code.\nIf you want more details on writing a good example, Hadley gives some advice here."
  },
  {
    "objectID": "r/articles/start/help/index.html#what-about-the-shiny-dev-center",
    "href": "r/articles/start/help/index.html#what-about-the-shiny-dev-center",
    "title": "How to get help",
    "section": "What about the Shiny Dev Center?",
    "text": "What about the Shiny Dev Center?\nRStudio wants to make the Shiny Dev Center as useful as possible. We hope it can be a one stop shop for advice, wisdom, and inspiration. However the Shiny Dev Center is not designed to be an interactive resource.\nIf you ask a question about an article or tutorial in its comments section, we will try our best to answer it there. However, the comments section is not a good place to ask for specific help with your code. Why not?\n\nPracticality - Volunteers do not hang out in the comments sections waiting to answer your questions.\nEfficiency - The resources listed above are searchable and well known, which makes it easy for others to benefit from your questions and answers. Not so for the comments.\nRedundancy - There is a good chance someone already answered your question at one of the help sites. Why not find out?"
  },
  {
    "objectID": "r/articles/start/help/index.html#recap",
    "href": "r/articles/start/help/index.html#recap",
    "title": "How to get help",
    "section": "Recap",
    "text": "Recap\nYou can get the help you need and make Shiny better in the process by visiting a help site specific to your question. Do not forget to make your question clear with a reproducible example, an error message, and the output of sessionInfo()."
  },
  {
    "objectID": "r/articles/start/build/index.html",
    "href": "r/articles/start/build/index.html",
    "title": "How to build a Shiny app",
    "section": "",
    "text": "Let‚Äôs walk through the steps of building a simple Shiny application. A Shiny application is simply a directory containing an R script called app.R which is made up of a user interface object and a server function. This folder can also contain any any additional data, scripts, or other resources required to support the application."
  },
  {
    "objectID": "r/articles/start/build/index.html#ui-server",
    "href": "r/articles/start/build/index.html#ui-server",
    "title": "How to build a Shiny app",
    "section": "UI & Server",
    "text": "UI & Server\nTo get started building the application, create a new empty directory wherever you‚Äôd like, then create an empty app.R file within it. For purposes of illustration we‚Äôll assume you‚Äôve chosen to create the application at ~/shinyapp:\n~/shinyapp\n|-- app.R\nNow we‚Äôll add the minimal code required in the source file called app.R.\nFirst, we load the shiny package:\nlibrary(shiny)\n\nui\nThen, we define the user interface by calling the function pageWithSidebar:\n# Define UI for miles per gallon app ----\nui &lt;- pageWithSidebar(\n\n  # App title ----\n  headerPanel(\"Miles Per Gallon\"),\n\n  # Sidebar panel for inputs ----\n  sidebarPanel(),\n\n  # Main panel for displaying outputs ----\n  mainPanel()\n)\nThe three functions headerPanel, sidebarPanel, and mainPanel define the various regions of the user-interface. The application will be called ‚ÄúMiles Per Gallon‚Äù so we specify that as the title when we create the header panel. The other panels are empty for now.\nNow let‚Äôs define a skeletal server implementation. To do this we call shinyServer and pass it a function that accepts two parameters, input and output:\n\n\nserver\n# Define server logic to plot various variables against mpg ----\nserver &lt;- function(input, output) {\n\n}\nOur server function is empty for now but later we‚Äôll use it to define the relationship between our inputs and outputs.\n\n\napp.R\nFinally, we need the shinyApp function that uses the ui object and the server function we defined to build a Shiny app object.\nPutting it altogether, our app.R script looks like this:\nlibrary(shiny)\n\n# Define UI for miles per gallon app ----\nui &lt;- pageWithSidebar(\n  \n  # App title ----\n  headerPanel(\"Miles Per Gallon\"),\n  \n  # Sidebar panel for inputs ----\n  sidebarPanel(),\n  \n  # Main panel for displaying outputs ----\n  mainPanel()\n)\n\n# Define server logic to plot various variables against mpg ----\nserver &lt;- function(input, output) {\n  \n}\n\nshinyApp(ui, server)\nWe‚Äôve now created the most minimal possible Shiny application. You can run the application by calling the runApp function as follows:\n&gt; library(shiny)\n&gt; runApp(\"~/shinyapp\")\nAlternatively, if you are working on you can click the Run App button on your RStudio Editor.\nIf everything is working correctly you‚Äôll see the application appear in your browser looking something like this:\n\n\n\nWe now have a running Shiny application however it doesn‚Äôt do much yet. In the next section we‚Äôll complete the application by specifying the user interface object and implementing the server function"
  },
  {
    "objectID": "r/articles/start/build/index.html#inputs-outputs",
    "href": "r/articles/start/build/index.html#inputs-outputs",
    "title": "How to build a Shiny app",
    "section": "Inputs & Outputs",
    "text": "Inputs & Outputs\n\nAdding Inputs to the Sidebar\nThe application we‚Äôll be building uses the mtcars data from the R datasets package, and allows users to see a box-plot that explores the relationship between miles-per-gallon (MPG) and three other variables (Cylinders, Transmission, and Gears).\nWe want to provide a way to select which variable to plot MPG against as well as provide an option to include or exclude outliers from the plot. To do this we‚Äôll add two elements to the sidebar, a selectInput to specify the variable and a checkboxInput to control display of outliers. Our user-interface definition looks like this after adding these elements:\n\nui\n# Define UI for miles per gallon app ----\nui &lt;- pageWithSidebar(\n  \n  # App title ----\n  headerPanel(\"Miles Per Gallon\"),\n  \n  # Sidebar panel for inputs ----\n  sidebarPanel(\n  \n        # Input: Selector for variable to plot against mpg ----\n      selectInput(\"variable\", \"Variable:\", \n                c(\"Cylinders\" = \"cyl\",\n                  \"Transmission\" = \"am\",\n                  \"Gears\" = \"gear\")),\n\n      # Input: Checkbox for whether outliers should be included ----\n      checkboxInput(\"outliers\", \"Show outliers\", TRUE)\n  \n  ),\n  \n  # Main panel for displaying outputs ----\n  mainPanel()\n)\nIf you run the application again after making these changes you‚Äôll see the two user-inputs we defined displayed within the sidebar:\n\n\n\n\n\n\nCreating the server function\nNext we need to define the server-side of the application which will accept inputs and compute outputs. Our server function is shown below, and illustrates some important concepts:\n\nAccessing input using slots on the input object and generating output by assigning to slots on the output object.\nInitializing data at startup that can be accessed throughout the lifetime of the application.\nUsing a reactive expression to compute a value shared by more than one output.\n\nThe basic task of a Shiny server function is to define the relationship between inputs and outputs. Our function does this by accessing inputs to perform computations and by assigning reactive expressions to output slots.\nHere is the source code for the full server function (the inline comments explain the implementation technqiues in more detail):\n\nserver\n# Data pre-processing ----\n# Tweak the \"am\" variable to have nicer factor labels -- since this\n# doesn't rely on any user inputs, we can do this once at startup\n# and then use the value throughout the lifetime of the app\nmpgData &lt;- mtcars\nmpgData$am &lt;- factor(mpgData$am, labels = c(\"Automatic\", \"Manual\"))\n\n# Define server logic to plot various variables against mpg ----\nserver &lt;- function(input, output) {\n\n  # Compute the formula text ----\n  # This is in a reactive expression since it is shared by the\n  # output$caption and output$mpgPlot functions\n  formulaText &lt;- reactive({\n    paste(\"mpg ~\", input$variable)\n  })\n\n  # Return the formula text for printing as a caption ----\n  output$caption &lt;- renderText({\n    formulaText()\n  })\n\n  # Generate a plot of the requested variable against mpg ----\n  # and only exclude outliers if requested\n  output$mpgPlot &lt;- renderPlot({\n    boxplot(as.formula(formulaText()),\n            data = mpgData,\n            outline = input$outliers,\n            col = \"#007bc2\", pch = 19)\n  })\n\n}\nThe use of renderText and renderPlot to generate output (rather than just assigning values directly) is what makes the application reactive. These reactive wrappers return special expressions that are only re-executed when their dependencies change. This behavior is what enables Shiny to automatically update output whenever input changes.\n\n\n\nDisplaying Outputs\nThe server function assigned two output values: output$caption and output$mpgPlot. To update our user interface to display the output we need to add some elements to the main UI panel.\nIn the updated user-interface definition below you can see that we‚Äôve added the caption as an h3 element and filled in its value using the textOutput function, and also rendered the plot by calling the plotOutput function:\n\nui\n# Define UI for miles per gallon app ----\nui &lt;- fluidPage(\n\n  # App title ----\n  titlePanel(\"Miles Per Gallon\"),\n\n  # Sidebar layout with input and output definitions ----\n  sidebarLayout(\n\n    # Sidebar panel for inputs ----\n    sidebarPanel(\n\n      # Input: Selector for variable to plot against mpg ----\n      selectInput(\"variable\", \"Variable:\",\n                  c(\"Cylinders\" = \"cyl\",\n                    \"Transmission\" = \"am\",\n                    \"Gears\" = \"gear\")),\n\n      # Input: Checkbox for whether outliers should be included ----\n      checkboxInput(\"outliers\", \"Show outliers\", TRUE)\n\n    ),\n\n    # Main panel for displaying outputs ----\n    mainPanel(\n\n      # Output: Formatted text for caption ----\n      h3(textOutput(\"caption\")),\n\n      # Output: Plot of the requested variable against mpg ----\n      plotOutput(\"mpgPlot\")\n\n    )\n  )\n)\nRunning the application now shows it in its final form including inputs and dynamically updating outputs:"
  },
  {
    "objectID": "r/articles/start/build/index.html#details",
    "href": "r/articles/start/build/index.html#details",
    "title": "How to build a Shiny app",
    "section": "Details",
    "text": "Details\nThe shinyApp() function returns an object of class shiny.appobj. When this is returned to the console, it is printed using the print.shiny.appobj() function, which launches a Shiny app from that object.\nYou can also use a similar technique to create and run files that aren‚Äôt named app.R and don‚Äôt reside in their own directory. If, for example, you create a file called test.R and have it call shinyApp() at the end, you could then run it from the console with:\nprint(source(\"test.R\"))\nWhen the file is sourced, it returns a shiny.appobj‚Äîbut by default, the return value from source() isn‚Äôt printed. Wrapping it in print() causes Shiny to launch it.\nThis method is handy for quick experiments, but it lacks some advantages that you get from having an app.R in its own directory. When you do runApp(\"newdir\"), Shiny will monitor the file for changes and reload the app if you reload your browser, which is useful for development. This doesn‚Äôt happen when you simply source the file. Also, Shiny Server and shinyapps.io expect an app to be in its own directory. So if you want to deploy your app, it should go in its own directory.\nNow that we‚Äôve got a simple application running we‚Äôll probably want to make some changes. The next article covers the basic cycle of editing, running, and debugging Shiny applications."
  },
  {
    "objectID": "r/articles/share/shinyapps/index.html",
    "href": "r/articles/share/shinyapps/index.html",
    "title": "Getting started with shinyapps.io",
    "section": "",
    "text": "Shinyapps.io is a platform as a service (PaaS) for hosting Shiny web apps (applications). This article will show you how to create a shinyapps.io account and deploy your first application to the cloud.\nBefore you get started with shinyapps.io, you will need:",
    "crumbs": [
      "Share",
      "Deployment",
      "Getting started with shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/share/shinyapps/index.html#create-a-shinyapps.io-account",
    "href": "r/articles/share/shinyapps/index.html#create-a-shinyapps.io-account",
    "title": "Getting started with shinyapps.io",
    "section": "Create a shinyapps.io account",
    "text": "Create a shinyapps.io account\nGo to shinyapps.io and click ‚ÄúDashboard.‚Äù The site will ask you to sign in using your email and password, your Google account, or your GitHub account.\nThe first time you sign in, shinyapps.io prompts you to set up your account. Shinyapps.io uses the account name as the domain name for all your apps. Account names must be between four and 63 characters and can contain only letters, numbers, and dashes (-). Account names may not begin with a number or a dash, and they can not end with a dash (see RFC 952). Some account names may be reserved.\n\nConfigure rsconnect\nOnce you set up your account in shinyapps.io, you can configure the rsconnect package to use your account. Shinyapps.io automatically generates a token and secret for you, which the rsconnect package can use to access your account. Retrieve your token from the shinyapps.io dashboard. Tokens are listed under Tokens in the menu at the top right of the shinyapps dashboard (under your avatar).\n\nYou can configure the rsconnect package to use your account with two methods:\n\nMethod 1\nClick the show button on the token page. A window will pop up that shows the full command to configure your account using the appropriate parameters for the rsconnect::setAccountInfo function. Copy this command to your clip board, and then paste it into the command line of RStudio and click enter.\n\n\n\nMethod 2\nRun the ‚ÄòsetAccountInfo‚Äô function from the rsconnect package passing in the token and secret from the Profile / Tokens page.\nrsconnect::setAccountInfo(name=\"&lt;ACCOUNT&gt;\", token=\"&lt;TOKEN&gt;\", secret=\"&lt;SECRET&gt;\")\nOnce you have configured your rsconnect installation, you can use it to upload applications to shinyapps.io. In the second part of this guide, we will build a demo application, upload it to shinyapps.io, and create a password for the application.\nIf you‚Äôre using the RStudio IDE, you can manage your shinyapps.io accounts by going to Tools -&gt; Global Options -&gt; Publishing.",
    "crumbs": [
      "Share",
      "Deployment",
      "Getting started with shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/share/shinyapps/index.html#a-demo-app",
    "href": "r/articles/share/shinyapps/index.html#a-demo-app",
    "title": "Getting started with shinyapps.io",
    "section": "A Demo app",
    "text": "A Demo app\nFor this guide, we created an RStudio project named ‚Äúdemo‚Äù that contains a Shiny application to upload to shinyapps.io. Follow these steps to create your own Shiny app.\n\nInstall application dependencies\nThe demo application we will deploy requires the ggplot2 package and the shiny package. Ensure that any package required by your application is installed locally before you deploy your application:\ninstall.packages(c('ggplot2', 'shiny'))\n\n\nui.R and server.R\nWe placed two Shiny source files, ui.R and server.R, in our demo application. You can cut and paste the code below to make your own Shiny application:\nserver.R\nlibrary(shiny)\nlibrary(ggplot2)\n\nfunction(input, output) {\n\n  dataset &lt;- reactive({\n    diamonds[sample(nrow(diamonds), input$sampleSize),]\n  })\n\n  output$plot &lt;- renderPlot({\n\n    p &lt;- ggplot(dataset(), aes_string(x=input$x, y=input$y)) + geom_point()\n\n    if (input$color != 'None')\n      p &lt;- p + aes_string(color=input$color)\n\n    facets &lt;- paste(input$facet_row, '~', input$facet_col)\n    if (facets != '. ~ .')\n      p &lt;- p + facet_grid(facets)\n\n    if (input$jitter)\n      p &lt;- p + geom_jitter()\n    if (input$smooth)\n      p &lt;- p + geom_smooth()\n\n    print(p)\n\n  }, height=700)\n\n}\nui.R\nlibrary(shiny)\nlibrary(ggplot2)\n\ndataset &lt;- diamonds\n\nfluidPage(\n\n  titlePanel(\"Diamonds Explorer\"),\n\n  sidebarPanel(\n\n    sliderInput('sampleSize', 'Sample Size', min=1, max=nrow(dataset),\n                value=min(1000, nrow(dataset)), step=500, round=0),\n\n    selectInput('x', 'X', names(dataset)),\n    selectInput('y', 'Y', names(dataset), names(dataset)[[2]]),\n    selectInput('color', 'Color', c('None', names(dataset))),\n\n    checkboxInput('jitter', 'Jitter'),\n    checkboxInput('smooth', 'Smooth'),\n\n    selectInput('facet_row', 'Facet Row', c(None='.', names(dataset))),\n    selectInput('facet_col', 'Facet Column', c(None='.', names(dataset)))\n  ),\n\n  mainPanel(\n    plotOutput('plot')\n  )\n)\n\n\nTest your application\nTest that your application works by running it locally. Set your working directory to your app directory, and then run:\nlibrary(shiny)\nrunApp()\nIf you‚Äôre using the RStudio IDE, you can also run your application by clicking the Run App button on the editor toolbar.\n\nNow that the application works, let‚Äôs upload it to shinyapps.io.",
    "crumbs": [
      "Share",
      "Deployment",
      "Getting started with shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/share/shinyapps/index.html#deploying-apps",
    "href": "r/articles/share/shinyapps/index.html#deploying-apps",
    "title": "Getting started with shinyapps.io",
    "section": "Deploying apps",
    "text": "Deploying apps\nTo deploy your application, use the deployApp command from the rsconnect packages.\nlibrary(rsconnect)\ndeployApp()\n\nIf you‚Äôre using the RStudio IDE, you can also deploy your application by clicking the Publish button while viewing the application.\n\n\n\nPublish from RStudio\n\n\nOnce the deployment finishes, your browser should open automatically to your newly deployed application.\nCongratulations! You‚Äôve deployed your first application. :-)\nFeel free to make changes to your code and run deployApp again. rsconnect can deploy an app much more quickly after the first deployment.\n\nPackage dependencies\nWhen you deploy your application, the rsconnect package attempts to detect the packages that your application uses. rsconnect sends this list of packages and their dependencies along with your application to the shinyapps.io service. Then shinyapps.io builds and installs the packages into the R library for your application. The first time you deploy your application, it may take some time to build these packages (depending on how many packages are used). However, you will not wait for these packages to build during future deployments (unless you upgrade or downgrade a package).\n\n\n\nPackage sources\nCurrently the shinyapps.io service supports deploying packages installed from CRAN, GitHub, and BioConductor. We will look to add support for R-Forge packages in the future.\n\nImportant note on GitHub packages\nOnly packages installed from GitHub with devtools::install_github in version 1.4 (or later) of devtools are supported. Packages installed with an earlier version of devtools must be reinstalled before you can deploy your application. If you get an error such as ‚ÄúPackageSourceError‚Äù when you attempt to deploy, check that you have installed any package from Github with devtools 1.4 or later.\n\n\n\nApplication instances\nShinyapps.io hosts each app on its own virtualized server, called an instance. Each instance runs an identical copy of the code and packages that you deployed (called the image).\nWhen you deploy an app, shinyapps.io creates a new image with the updated code and packages, and starts one or more instances with the new image. If the app was previously deployed, shinyapps.io shuts down and destroys the old instances. Consider a few implications of this arrangement:\n\nData written by an application to the local filesystem of an instance will be lost when you re-deploy the app. Additionally, the distributed nature of the shinyapps.io platform means that instances may be shut down and re-created at any time for maintenance or to recover from server failures.\nIt is possible to have more than one instance of an application. This situation means that multiple instances of an application do not share a local filesystem. A file written to one instance will not be available to another instance.\n\nShinyapps.io limits the amount of system resources an instance can consume. The amount of resources available to an instance will depend on its type. The table below outlines the various instance types and how much memory is allowed. By default, shinyapps.io deploys all applications on ‚Äòmedium‚Äô instances, which are allowed to use 512 MB of memory.\n\n\n\nInstance Type\nMemory\n\n\n\n\nsmall\n256 MB\n\n\nmedium (default)\n512 MB\n\n\nlarge\n1024 MB\n\n\nxlarge\n2048 MB\n\n\nxxlarge\n4096 MB\n\n\n\nNote: Instance types and limits are not finalized; RStudio may change them in the future.\n\n\nApplication logging\nIf you‚Äôre having problems with your application, it may be helpful to be able to see the log messages it‚Äôs producing. You can use the rsconnect::showLogs() function to show the log messages of a deployed application. This log will include both stdout (log lines producted via print or cat) and stderr (log lines produced by message, warning, stop). You can even use the streaming=TRUE option to specify that you want to continuously monitor the file for changes; this will listen for log messages until you interrupt R (typically by pressing Escape). If you deployed your application using an older version of the rsconnect package, you will need to redeploy it (deployApp(upload=FALSE)) before you can use logging.\n\n\nConfiguring applications\nYou can change the instance type used by an application with the configureApp function from the rsconnect package. To change the instance type of your application (here from medium to small), run:\nrsconnect::configureApp(\"APPNAME\", size=\"small\")\nThis change will redeploy your application using the small instance type.\nYou can also change the instance type used by an application from the shinyapps.io dashboard. To do this, log in to shinyapps.io, select the application that you wish to configure, and then open the Settings tab.\nTo learn more about instances and other details of the shinyapps.io architecture, read Scaling and Performance Tuning. The guide will also show you several advanced options for fine tuning the performance of your apps on shinyapps.io.",
    "crumbs": [
      "Share",
      "Deployment",
      "Getting started with shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/share/shinyapps/index.html#application-authentication",
    "href": "r/articles/share/shinyapps/index.html#application-authentication",
    "title": "Getting started with shinyapps.io",
    "section": "Application authentication",
    "text": "Application authentication\nWith shinyapps.io, you can limit the access to your application by enabling authentication. Only users who log-in with valid credentials will be able to view or use the app.\nTo enable authentication in the administrative UI, select the application to modify and click on the Users tab.\nHere is a sample application with the default visibility settings:\n\n\n\nvisibility settings\n\n\nChange the Application Visibility to Private and click on Save Settings. Changing the visibility of your application will require a restart of the application. The Owner of the account and other members of the account will automatically be included in the list of authorized users.\n\n\n\nvisibility settings\n\n\nAfter the application is restarted you can add authorized users by entering their email addresses and clicking on Add User.\n\n\n\nvisibility settings\n\n\nEach user will receive an email from shinyapps.io with an invite to view your application. If a user does not already have an authenticated account on shinyapps.io, they will be able to create one by authenticating through one of the following three methods:\n\nGoogle Authorization\nGitHub authorization\nShinyapps.io authentication\n\nShinyapps.io will prompt each visitor to your app for a username and password if they have not been authenticated. Only users who log-in with valid credentials will be able to view or use the app.\nIf you currently use the pre-beta authentication scheme, please upgrade to the new system by January 28, 2015 as we will be deprecating support for the old authentication system during the beta. For instructions on how to upgrade, please read the guide here.",
    "crumbs": [
      "Share",
      "Deployment",
      "Getting started with shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/share/shinyapps/index.html#terminate-an-app",
    "href": "r/articles/share/shinyapps/index.html#terminate-an-app",
    "title": "Getting started with shinyapps.io",
    "section": "Terminate an app",
    "text": "Terminate an app\nYou can remove an app on shinyapps.io from the web with the terminateApp command. To use it, run\nterminateApp(\"&lt;your app's name&gt;\")\nterminateApp requires one argument, the name of the app that you would like to terminate (as a character string). This name should correspond with one of the apps in your shinyapps.io account.\nWhen you run terminateApp shinyapps.io will close your app, but the app will remain archived in your shinyapps.io account. This creates efficiencies if you later decide to redeploy your app with deployApp.\nYou can also terminate an app from your shinyapps.io dashboard. To do this, log in to shinyapps.io, select the app that you wish to terminate and then click ‚ÄúArchive.‚Äù",
    "crumbs": [
      "Share",
      "Deployment",
      "Getting started with shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/share/shinyapps/index.html#getting-help",
    "href": "r/articles/share/shinyapps/index.html#getting-help",
    "title": "Getting started with shinyapps.io",
    "section": "Getting help",
    "text": "Getting help\nTo seek and share advice about shinyapps.io, please visit the Shinyapps.io google group.",
    "crumbs": [
      "Share",
      "Deployment",
      "Getting started with shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/share/shinyapps/index.html#recap",
    "href": "r/articles/share/shinyapps/index.html#recap",
    "title": "Getting started with shinyapps.io",
    "section": "Recap",
    "text": "Recap\nShinyapps.io is an online service for hosting Shiny apps in the cloud. RStudio takes care of all of the details of hosting the app and maintaining the server, which lets you focus on writing great apps!\nTo use shinyApps.io\n\nInstall the rsconnect R package from github\nCreate an account at shinyapps.io\nUse the tokens generated by shinyapps.io to configure your rsconnect package.\nDeploy apps with rsconnect::deployApp\nTerminate apps with rsconnect::terminateApp\n\nYou can also use shinyapps.io to create secure apps, and manage your authorized users.",
    "crumbs": [
      "Share",
      "Deployment",
      "Getting started with shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/share/shinyapps/index.html#learn-more",
    "href": "r/articles/share/shinyapps/index.html#learn-more",
    "title": "Getting started with shinyapps.io",
    "section": "Learn more",
    "text": "Learn more\nFor more on this topic, see the following resources:\n\nShinyapps.io Overview & Tour",
    "crumbs": [
      "Share",
      "Deployment",
      "Getting started with shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/share/share-data/index.html",
    "href": "r/articles/share/share-data/index.html",
    "title": "Sharing data across sessions on shinyapps.io",
    "section": "",
    "text": "shinyapps.io expects your applications to be portable across servers. It uses this feature to maintain a smooth user experience. For example, shinyapps.io will scale up your application by adding more running instances, or shinyapps.io will keep your application available by starting your application on a server that has sufficient resources to host it. Both of these features will fail if your app is not portable.\nOne of the consequences of this design is that files written to the file system will be deleted when your application shuts down or moves to another server. These transitions shouldn‚Äôt happen while a user‚Äôs session is active, so you can safely write temporary files associated with a particular session to the filesystem and expect to read these files back in during the same session. However, local files created by your application will not persist beyond the session in which they are created. If you want to access files after the session has closed, you will need to design your application so that it saves its temporary files to an external service.\nThis article will introduce three ways to save‚Äîand use‚Äîdata over multiple sessions. You can:\nWe will not trace out each step required to set up these storage services, but we will provide enough context to help you determine which options would be most appropriate for your application. We will then point you to the appropriate resources that will help you store your data.\nRegardless of which option you choose, we recommend using a ‚Äúhosted‚Äù solution to store your data if you don‚Äôt already have a server capable of the appropriate option. Amazon Web Services products can support the first and last options. AWS provides S3 object storage and RDS for a relational database. R has packages to support NoSQL servers like MongoDB. One hosted provider for MongoDB is MongoLab.\nWe‚Äôll walk through an example application that collects names and comments from users. We want to accrue all comments across user sessions. We‚Äôll begin with a functioning app that relies on local file storage, available here\nhttps://gist.github.com/trestletech/3679b34c5a83f521387b\nNote that this code is not compatible with ShinyApps, since the modified copy of log.txt would be overwritten with the original version of log.txt every time the application is stopped or moved. The next three sections will present three ways to make the application portable for work on ShinyApps.",
    "crumbs": [
      "Share",
      "Deployment",
      "Sharing data across sessions on shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/share/share-data/index.html#object-storage-amazon-s3",
    "href": "r/articles/share/share-data/index.html#object-storage-amazon-s3",
    "title": "Sharing data across sessions on shinyapps.io",
    "section": "1. Object Storage (Amazon S3)",
    "text": "1. Object Storage (Amazon S3)\nObject storage is the simplest of the three alternatives and works the most like a traditional filesystem. You can put an ‚Äúobject‚Äù (file) into the store at a particular location, update it as often as you‚Äôd like, and then retrieve it from that same location.\nThis option allows users to continue to use a local file in their code assuming they\n\nretrieve the most updated file when the application starts, and\nwrite the updates to the file back to their object storage system before the application closes and the changes are lost.\n\nYou can do this every time the data changes, or every time a session exits (session$onEnded).\nWe‚Äôll update our comment example from above using the RAmazonS3 package which can be installed using the following command:\ninstall.packages(\"RAmazonS3\", repos = \"http://www.omegahat.net/R\")\nYou can view the updated demo here. In short, rather than reading in the log from a file when the application starts, we‚Äôll read in the object from S3. And rather than writing out to a file, we‚Äôll write to S3. That way we can be sure that, when the process closes, our updated log has been written somewhere where it will persist and can be retrieved later.\nOne important caveat is that this code is not safe to use in multiple processes simultaneously, so you should be sure to configure your application to have a maximum of 1 process if you‚Äôre using this approach. As an example, if you started two processes, both would read the up-to-date log file from S3 at startup. They would then write back to S3 any time a comment was posted without ever updating from S3 to capture each other‚Äôs updates‚Äîmeaning that they would just overwrite each other as long as they were both running.\nThis problem is solved in more formal database systems as will be discussed below using the concept of ‚Äútransactions‚Äù which can ensure that only one update occurs to a data set at a time.",
    "crumbs": [
      "Share",
      "Deployment",
      "Sharing data across sessions on shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/share/share-data/index.html#nosql-storage-mongodb-etc.",
    "href": "r/articles/share/share-data/index.html#nosql-storage-mongodb-etc.",
    "title": "Sharing data across sessions on shinyapps.io",
    "section": "2. NoSQL Storage (MongoDB, etc.)",
    "text": "2. NoSQL Storage (MongoDB, etc.)\nNoSQL databases offer a flexible storage system that offers a bit more control than object storage, but without the overhead of a formal relational database. NoSQL is an appropriate option if your data can easily be divided into individual ‚Äúentries‚Äù that can be created, updated, and deleted and there aren‚Äôt strong relationships between those entities.\nThere are a couple of R packages that will enable you to communicate with MongoDB, one of which is rmongodb, but you can choose the one that is right for your project.\nAdapting our example to use MongoDB storage would be fairly simple. Each comment could be treated as a separate record (or ‚Äúdocument,‚Äù in mongoDB parlance) with two fields:name and comment (and perhaps the date-time if it was posted). To add a comment, we might use mongo.insert. To query the list of comments initially we could use mongo.find.\nBecause we‚Äôre using a proper database, the information can be maintained more granularly which allows us to get around the problems we had previously with concurrency. If multiple processes call mongo.insert simultaneously, both records will get inserted into the data store without any data loss. One possible enhancement to our application would be to periodically query the MongoDB database to ensure that we‚Äôre showing any new comments that have been written into the database by other processes.",
    "crumbs": [
      "Share",
      "Deployment",
      "Sharing data across sessions on shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/share/share-data/index.html#relational-database-mysql-postgresql-etc.-with-amazon-rds",
    "href": "r/articles/share/share-data/index.html#relational-database-mysql-postgresql-etc.-with-amazon-rds",
    "title": "Sharing data across sessions on shinyapps.io",
    "section": "3. Relational Database (MySQL, PostgreSQL, etc. with Amazon RDS)",
    "text": "3. Relational Database (MySQL, PostgreSQL, etc. with Amazon RDS)\nThe final option for storage would be to use a formal relational database like MySQL or PostgreSQL. Most major databases have associated R packages to ease interaction from R (see RPostgreSQL or RMySQL.\nRelational databases excel when data is highly structured and there are well-defined relationships between entities. However, relational databases are often the most cumbersome of the above options and require the most know-how to setup and manage. If you do not have any prior experience with relational databases or know someone who does, you may be better served starting with one of the other options.\nThe architecture of our sample application using a relational database would be very similar to the solution described for a NoSQL server‚Äîrun an INSERT when a new comment is posted and a SELECT to retrieve the existing comments from the database. Most relational databases include a feature called ‚Äútransactions‚Äù which allow you to guarantee data accuracy when performing complex operations on your data (like querying a bank account balance, then updating it). If you find that you‚Äôre encountering such problems with NoSQL or an object store, it may be worth the learning curve to get acquainted with a relational database like PostgreSQL.",
    "crumbs": [
      "Share",
      "Deployment",
      "Sharing data across sessions on shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/share/share-data/index.html#recap",
    "href": "r/articles/share/share-data/index.html#recap",
    "title": "Sharing data across sessions on shinyapps.io",
    "section": "Recap",
    "text": "Recap\nTo summarize, shinyapps.io expects your apps to be portable, which means that your app cannot pass data from session to session with local files. Instead, your app should save data to an external source that future sessions can access. You can do this by saving different types of data to different storage services.\n\nSave arbitrary data of any size in an object storage system like Amazon S3\nSave semi-structured data in an easily scalable NoSQL database like MongoDB\nSave rigidly structured data in a formal relational database like MySQL, SQL Server, or PostgreSQL.",
    "crumbs": [
      "Share",
      "Deployment",
      "Sharing data across sessions on shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/share/migration/index.html",
    "href": "r/articles/share/migration/index.html",
    "title": "Migrating authentication on shinyapps.io",
    "section": "",
    "text": "The general release of shinyapps.io in 2015 introduced a new mechanism for authentication and authorization. This system replaced the existing rscrypt based approach and provides a more flexible and manageable flow.\nshinyapps.io authentication system allows the ability to:\n\nAdd or remove authorized users without restarting the application thereby preserving the sessions of logged in users.\nManage application access through the admin interface.\nLeverage Google or Github authentication to improve security for your users.\nSave your users the burden of managing and maintaining their own user authentication information.\n\nThe steps below were used to migrate applications from the old rscrypt based authentication system (prior to 2015) to the new one:\n\nSet the Application Visibility setting to Private in the Users tab for that application and click Save Settings. This will restart the application and apply the new setting. Note, once you do this, none of the existing users will be able to authenticate.\nOn your local system, rename the passwords.txt file in /shinyapps to old_passwords.txt.\nRe-deploy your application using shinyapps::deployApp()\nIn the Users tab, add the email addresses for the individuals that were in your old_passwords.txt file. If you were not using email addresses before, you will need to do so at this time. Don‚Äôt worry if your users don‚Äôt have Google or GitHub accounts, they can always use local authentication through shinyapps.io.\nYour users should now be able to authenticate and see your application.",
    "crumbs": [
      "Share",
      "Deployment",
      "Migrating authentication on shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/share/function/index.html",
    "href": "r/articles/share/function/index.html",
    "title": "Save your app as a function",
    "section": "",
    "text": "Shiny apps are a great way to build interactive data analysis tools, but they require a bit of set up to use. Or do they? This article will show you how to write R functions that launch Shiny apps.\nThe result is a quick tool that you can reuse on any data set (or with any set of arguments that you like). Moreover, you can use this method to share your Shiny apps as straightforward R functions.",
    "crumbs": [
      "Share",
      "Distribution",
      "Save your app as a function"
    ]
  },
  {
    "objectID": "r/articles/share/function/index.html#an-example",
    "href": "r/articles/share/function/index.html#an-example",
    "title": "Save your app as a function",
    "section": "An example",
    "text": "An example\nrmdexamples::kmeans_cluster is a function that launches a Shiny app. It takes one argument, a data frame, and launches a cluster analysis app that explores the data frame.\nYou can install the rmdexamples library from github. To do so, run\ndevtools::install_github(\"rmdexamples\", \"rstudio\")\n\nlibrary(rmdexamples)\nkmeans_cluster(iris)\n\nThe following sections will show you how to\n\nDefine a Shiny app in a single script with shinyApp\nSave your app as a parameterized function\nLaunch your app from the command line or inside an interactive document",
    "crumbs": [
      "Share",
      "Distribution",
      "Save your app as a function"
    ]
  },
  {
    "objectID": "r/articles/share/function/index.html#shinyapp",
    "href": "r/articles/share/function/index.html#shinyapp",
    "title": "Save your app as a function",
    "section": "shinyApp",
    "text": "shinyApp\nshinyApp is a function that builds Shiny apps. You can use shinyApp to define a complete app in a single R script, or even at the command line.\nshinyApp builds an app from two arguments that parallel the structure of a standard Shiny app. The ui argument takes code that builds the user interface for your app, and the server argument takes code that sets up the server for your Shiny app.\nWhen you build a standard Shiny app, you save two files in your working directory and then call runApp(). One file, named ui.R, contains a call to shinyUI. The second file, named server.R, contains a call to shinyServer.\n\nTo build an app with shinyApp, give ui the code that you would normally pass to shinyUI in a ui.R file. Then give server the code that you would normally pass to shinyServer in a server.R file.\nshinyApp(\n  ui = fluidPage(\n    sidebarLayout(\n      sidebarPanel(sliderInput(\"n\", \"Bins\", 5, 100, 20)),\n      mainPanel(plotOutput(\"hist\"))\n    )\n  ), \n  server = function(input, output) {\n    output$hist &lt;- renderPlot( \n      hist(faithful[[2]], breaks = input$n,\n        col = \"skyblue\", border = \"white\") \n    )\n  }\n)\nR will build and launch your app when you run the complete shinyApp call at the command line.\nFor example, the code above will build a minimal Shiny app. When you run the code, your app will look like this.\n\nshinyApp also uses an option argument, which takes a list of named options. You can use the option argument to set any options that you would normally set in a runApp call.\nIn addition, you can use the option argument to provide a hint to the browser environment about the ideal height and width of your Shiny app. This becomes very useful when you embed Shiny apps in R Markdown documents (described below). The code below will launch an app that has a suggested size of 600 by 500 pixels.\nshinyApp(\n  ui = fluidPage(\n    sidebarLayout(\n      sidebarPanel(sliderInput(\"n\", \"Bins\", 5, 100, 20)),\n      mainPanel(plotOutput(\"hist\"))\n    )\n  ), \n  server = function(input, output) {\n    output$hist &lt;- renderPlot( \n      hist(faithful[[2]], breaks = input$n,\n        col = \"skyblue\", border = \"white\") \n    )\n  },\n  options = list(height = 600, width = 500)\n)",
    "crumbs": [
      "Share",
      "Distribution",
      "Save your app as a function"
    ]
  },
  {
    "objectID": "r/articles/share/function/index.html#save-your-app-as-a-function",
    "href": "r/articles/share/function/index.html#save-your-app-as-a-function",
    "title": "Save your app as a function",
    "section": "Save your app as a function",
    "text": "Save your app as a function\nTo turn your app into a function, write a function that calls shinyApp. Parameterize your app by passing function arguments to shinyApp.\nThe code below saves the histogram app as a function named binner that takes a vector named var. The function passes its var argument to shinyApp, which then launches an app that visualizes var.\nbinner &lt;- function(var) {\n  require(shiny)\n  shinyApp(\n    ui = fluidPage(\n      sidebarLayout(\n        sidebarPanel(sliderInput(\"n\", \"Bins\", 5, 100, 20)),\n        mainPanel(plotOutput(\"hist\"))\n      )\n    ), \n    server = function(input, output) {\n      output$hist &lt;- renderPlot( \n        hist(var, breaks = input$n,\n          col = \"skyblue\", border = \"white\") \n      )\n    }\n  )\n}\nSince var is a function argument, you can supply it at runtime. This means you can reuse the app on many different data frames.",
    "crumbs": [
      "Share",
      "Distribution",
      "Save your app as a function"
    ]
  },
  {
    "objectID": "r/articles/share/function/index.html#call-your-app-as-a-function",
    "href": "r/articles/share/function/index.html#call-your-app-as-a-function",
    "title": "Save your app as a function",
    "section": "Call your app as a function",
    "text": "Call your app as a function\nYou can launch your app from the command line once you define your function. To do this, call the function and supply a value for each function argument.\nFor example, you can now use binner to explore various vectors.\nbinner(faithful$eruptions)\n\nbinner(iris$Sepal.Length)\n\nbinner(mtcars$mpg)\n\n\nEmbed your app in an interactive document\nYou can also embed your app in R Markdown reports. Define the function that launches your app in an R code chunk (by including the definition, or loading a package that has the function). Then call the function.\nThe R Markdown script below places binner in an interactive document.\n---\nruntime: shiny\noutput: html_document\n---\n\n```{r echo = FALSE}\nbinner &lt;- function(var) {\n  require(shiny)\n  shinyApp(\n    ui = fluidPage(\n      sidebarLayout(\n        sidebarPanel(sliderInput(\"n\", \"Bins\", 5, 100, 20)),\n        mainPanel(plotOutput(\"hist\"))\n      )\n    ), \n    server = function(input, output) {\n      output$hist &lt;- renderPlot( \n        hist(var, breaks = input$n,\n          col = \"skyblue\", border = \"white\") \n      )\n    }\n  )\n}\n```\n\n## Old Faithful\n\nOld faithful tends to erupt at regular intervals (hence its name). But how regular are these intervals?  \n\nI went to Yellowstone national park and monitored the old faithful geyser during fourteen days. During this time I wrote down the exact number of minutes that passed between each eruption.\n\nJust kidding, I used the `faithful` data set which comes with R. It contains the same information. Below is a histogram of the results. As you can see the times are bimodal. Old faithful is not entirely faithful; it appears to have a mistress on the side.\n\n```{r echo = FALSE}\nbinner(faithful$waiting)\n```\nThe document looks like this when you render the report. The binner app is interactive in the final document (try it!)",
    "crumbs": [
      "Share",
      "Distribution",
      "Save your app as a function"
    ]
  },
  {
    "objectID": "r/articles/share/function/index.html#recap",
    "href": "r/articles/share/function/index.html#recap",
    "title": "Save your app as a function",
    "section": "Recap",
    "text": "Recap\nYou can package your Shiny apps as parameterized R functions. To do this, define a function that builds your app with shinyApp.\nWhy would you save your Shiny apps this way? Saving your app as a function opens several opportunities\n\nEasy to share - you can share your apps with other R users just as you would share functions. For example, you can put your apps in an R package very easily.\nReusable - it is very easy to reuse your apps on new data sets, or with new conditions, by parameterizing your apps.\nA Chance to be a Hero - you can create and share apps that any R user can use. Your users do not need to know Shiny; they only need to call a function. You can use this method to make packages that contain interactive data exploration tools, teaching examples and quizzes, gui versions of R programs, and much more.",
    "crumbs": [
      "Share",
      "Distribution",
      "Save your app as a function"
    ]
  },
  {
    "objectID": "r/articles/share/deployment-local/index.html",
    "href": "r/articles/share/deployment-local/index.html",
    "title": "Sharing apps to run locally",
    "section": "",
    "text": "Once you‚Äôve written your Shiny app, you can distribute it for others to run on their own computers - they can download and run Shiny apps with a single R command. This requires that they have R and Shiny installed on their computers.\nIf you want your Shiny app to be accessible over the web, so that users only need a web browser, see\n\nIntroduction to Shiny Server (to host your own apps), or\nGetting started with shinyapps.io (to use RStudio‚Äôs hosting service)\n\nHere are some ways to deliver Shiny apps to run locally:\n\nGist\nOne easy way is to put your code on gist.github.com, a code pasteboard service from GitHub. Both server.R and ui.R must be included in the same gist, and you must use their proper filenames. See https://gist.github.com/jcheng5/3239667 for an example.\nYour recipient must have R and the Shiny package installed, and then running the app is as easy as entering the following command:\nshiny::runGist('3239667')\nIn place of '3239667' you will use your gist‚Äôs ID; or, you can use the entire URL of the gist (e.g.¬†'https://gist.github.com/jcheng5/3239667').\n\nPros\n\nSource code is easily visible by recipient (if desired)\nEasy to run (for R users)\nEasy to post and update\n\n\n\nCons\n\nCode is published to a third-party server\n\n\n\n\nGitHub repository\nIf your project is stored in a git repository on GitHub, then others can download and run your app directly. An example repository is at https://github.com/rstudio/shiny_example. The following command will download and run the application:\nshiny::runGitHub('shiny_example', 'rstudio')\nIn this example, the GitHub account is 'rstudio' and the repository is 'shiny_example'; you will need to replace them with your account and repository name.\n\nPros\n\nSource code is easily visible by recipient (if desired)\nEasy to run (for R users)\nVery easy to update if you already use GitHub for your project\nGit-savvy users can clone and fork your repository\n\n\n\nCons\n\nDeveloper must know how to use git and GitHub\nCode is hosted by a third-party server\n\n\n\n\nZip File, delivered over the web\nIf you store a zip or tar file of your project on a web or FTP server, users can download and run it with a command like this:\nrunUrl('https://github.com/rstudio/shiny_example/archive/master.zip')\nThe URL in this case is a zip file that happens to be stored on GitHub; replace it with the URL to your zip file.\n\nPros\n\nOnly requires a web server for delivery\n\n\n\nCons\n\nTo view the source, recipient must first download and unzip it\n\n\n\n\nZip File, copied to recipient‚Äôs computer\nAnother way is to simply zip up your project directory and send it to your recipient(s), where they can unzip the file and run it the same way you do (shiny::runApp).\n\nPros\n\nShare apps using e-mail, USB flash drive, or any other way you can transfer a file\n\n\n\nCons\n\nUpdates to app must be sent manually\n\n\n\n\nPackage\nIf your Shiny app is useful to a broader audience, it might be worth the effort to turn it into an R package. Put your Shiny application directory under the package‚Äôs inst directory, then create and export a function that contains something like this:\nshiny::runApp(system.file('&lt;em&gt;appdir&lt;/em&gt;', package='&lt;em&gt;packagename&lt;/em&gt;'))\nwhere appdir is the name of your app‚Äôs subdirectory in inst, and packagename is the name of your package.\n\nPros\n\nPublishable on CRAN\nEasy to run (for R users)\n\n\n\nCons\n\nMore work to set up\nSource code is visible by recipient (if not desired)",
    "crumbs": [
      "Share",
      "Distribution",
      "Sharing apps to run locally"
    ]
  },
  {
    "objectID": "r/articles/share/bookmarking-state/index.html",
    "href": "r/articles/share/bookmarking-state/index.html",
    "title": "Bookmarking state",
    "section": "",
    "text": "As of version 0.14, Shiny supports bookmarkable state: users can save the state of an application and get a URL which will restore the application with that state.\nThere are two types of bookmarking: encoding the state in a URL, and saving the state to the server. With an encoded state, the entire state of the application is contained in the URL‚Äôs query string. You can see this in action with this app: https://gallery.shinyapps.io/113-bookmarking-url/. An example of a bookmark URL for this app is https://gallery.shinyapps.io/113-bookmarking-url/?_inputs_&n=200.\nWhen the state is saved to the server, the URL might look like: https://gallery.shinyapps.io/bookmark-saved/?_state_id_=d80625dc681e913a.\nThe main differences between an encoded state and a saved-to-server state are:\nFor saving state to the server, the hosting environment must support bookmarkable state. As of version 1.4.7, Shiny Server Open Source and Shiny Server Pro support saving state to disk. Posit Connect added support in version 1.4.6. URL-encoded bookmarking currently works in all of these hosting environments.",
    "crumbs": [
      "Share",
      "Bookmarking",
      "Bookmarking state"
    ]
  },
  {
    "objectID": "r/articles/share/bookmarking-state/index.html#using-bookmarkable-state",
    "href": "r/articles/share/bookmarking-state/index.html#using-bookmarkable-state",
    "title": "Bookmarking state",
    "section": "Using bookmarkable state",
    "text": "Using bookmarkable state\nFor most Shiny apps, there are two changes that must be made to enable bookmarking:\n\nThe UI portion of an application must be a function that takes one argument.\nThere must be a call to enableBookmarking(). Or, if you‚Äôre calling shinyApp(), use the enableBookmarking argument.\n\nThe next few examples here show how to enable URL-encoded bookmarking with different file configurations.\n\nSingle-file applications\nHere is an example single-file app (with just app.R) with URL-encoded bookmarking enabled. You can also run this code from the console, if you want to test out bookmarking on your local development machine:\nui &lt;- function(request) {\n  fluidPage(\n    textInput(\"txt\", \"Enter text\"),\n    checkboxInput(\"caps\", \"Capitalize\"),\n    verbatimTextOutput(\"out\"),\n    bookmarkButton()\n  )\n}\nserver &lt;- function(input, output, session) {\n  output$out &lt;- renderText({\n    if (input$caps)\n      toupper(input$txt)\n    else\n      input$txt\n  })\n}\n\nshinyApp(ui, server, enableBookmarking = \"url\")\nNotice that the UI portion of app is not the fluidPage(...) content, but instead a function that returns the fluidPage(...) content. All of the input-generating functions (like textInput()) must be invoked from this function, either directly or indirectly (the UI function can call a function which calls textInput()). The input components cannot be saved in variables and then used inside the UI function ‚Äì if this is done, then they will not restore properly.\nThis application has some inputs, an output, and a bookmark button:\n\n\n\nBookmark app screenshot\n\n\nWhen the user clicks on the bookmark button, a modal dialog with the link will be displayed:\n\n\n\nBookmark modal screenshot\n\n\nThe user can then copy the URL and save it for later, or share it with others so they can visit the application in the bookmarked state.\nNote: An alternative is to call enableBookmarking() right before shinyApp(). This tells Shiny to enable bookmarking for the next Shiny app that is created.\nenableBookmarking(store = \"url\")\nshinyApp(ui, server)\n\n\nui.R/server.R\nFor applications that use ui.R and server.R, there should also be a global.R with a call to enableBookmarking(). For example:\n## global.R ##\nenableBookmarking(store = \"url\")\n## ui.R ##\nfunction(request) {\n  fluidPage(\n    textInput(\"txt\", \"Enter text\"),\n    checkboxInput(\"caps\", \"Capitalize\"),\n    verbatimTextOutput(\"out\"),\n    bookmarkButton()\n  )\n}\n## server.R ##\nfunction(input, output, session) {\n  output$out &lt;- renderText({\n    if (input$caps)\n      toupper(input$txt)\n    else\n      input$txt\n  })\n}\n\n\nApplications generated by functions\nIf your Shiny application is generated by a function, enabling bookmarking is done just the same as for a single file app. For example, this function returns a Shiny app:\nmyApp &lt;- function() {\n  ui &lt;- function(request) {\n    fluidPage(\n      textInput(\"txt\", \"Enter text\"),\n      checkboxInput(\"caps\", \"Capitalize\"),\n      verbatimTextOutput(\"out\"),\n      bookmarkButton()\n    )\n  }\n  server &lt;- function(input, output, session) {\n    output$out &lt;- renderText({\n      if (input$caps)\n        toupper(input$txt)\n      else\n        input$txt\n    })\n  }\n\n  shinyApp(ui, server, enableBookmarking = \"url\")\n}\nAs with single-file apps, another alternative is to call enableBookmarking() just before shinyApp(). So, for example, the myApp() function would call this:\nenableBookmarking(store = \"url\")\nshinyApp(ui, server)\n\n\nSaved-to-server bookmarking\nTo saved the bookmarked state to disk on the server, the only change is to use enableBookmarking = \"server\". Here is a basic single-file app with saved-to-server bookmarking enabled:\nui &lt;- function(request) {\n  fluidPage(\n    textInput(\"txt\", \"Enter text\"),\n    checkboxInput(\"caps\", \"Capitalize\"),\n    verbatimTextOutput(\"out\"),\n    bookmarkButton()\n  )\n}\nserver &lt;- function(input, output, session) {\n  output$out &lt;- renderText({\n    if (input$caps)\n      toupper(input$txt)\n    else\n      input$txt\n  })\n}\n\nshinyApp(ui, server, enableBookmarking = \"server\")",
    "crumbs": [
      "Share",
      "Bookmarking",
      "Bookmarking state"
    ]
  },
  {
    "objectID": "r/articles/share/bookmarking-state/index.html#saving-to-server",
    "href": "r/articles/share/bookmarking-state/index.html#saving-to-server",
    "title": "Bookmarking state",
    "section": "Saving to server",
    "text": "Saving to server\nFor saving state to the server, the hosting environment must support bookmarkable state. Currently, Shiny Server Open Source, Shiny Server Pro, and Posit Connect support saved-to-server bookmarkable state.\nWhen running a Shiny application in a hosting environment like Shiny Server, the hosting environment determines which directory is used for for storing bookmarked states. For Shiny Server, they will be stored in a subdirectory under /var/lib/shiny-server/bookmarks. For Posit Connect, the bookmarked states are stored in a subdirectory of the Posit Connect data directory, by default /var/lib/rstudio-connect/bookmarks.\nWhen running a Shiny application from R without a hosting environment (directly from the R console), the saved states will be stored in a subdirectory of the application directory named shiny_bookmarks/. This happens when the user calls runApp() and passes it a directory or file to run.\nIt is possible to start a Shiny application without a directory ‚Äì for example, by calling shinyApp() at the console, or by calling a function that returns a Shiny app object, or if was invoked with runApp(list(ui, server)). In these cases, the saved state will be stored in shiny_bookmarks/ under the current working directory.",
    "crumbs": [
      "Share",
      "Bookmarking",
      "Bookmarking state"
    ]
  },
  {
    "objectID": "r/articles/share/bookmarking-state/index.html#how-it-works",
    "href": "r/articles/share/bookmarking-state/index.html#how-it-works",
    "title": "Bookmarking state",
    "section": "How it works",
    "text": "How it works\nA bookmarked state automatically saves the values of all inputs (with some exceptions which are discussed below). When the application is restored using that state, the inputs are seeded with the saved values. If the application‚Äôs reactive graph structure has a straightforward flow, where the data flow goes from inputs to (optional) reactives to outputs, then the application will restore cleanly.\nIf, however, the application uses constructs that don‚Äôt have a straightforward reactive flow, then the application may not restore cleanly. In other words, if the state of the inputs at time t does not fully determine the state of the outputs at time t, then the application may not save and restore correctly unless you add additional logic. This is discussed in more detail in the advanced bookmarking article.\nIf the application uses randomly generated numbers somewhere between the inputs and outputs, then the restored state of the app may not exactly match the bookmarked state. However, it is possible to use the set.seed() or repeatable() functions to make the bookmarked state and restored state consistent.\n\nExcluding values\nAll input values in a Shiny application are automatically saved, except for passwordInputs. fileInputs are saved only when the state saved to server, not when it is encoded in a URL.\nTo exclude other inputs from being bookmarked, call setBookmarkExclude() in the server function, and pass in a vector containing the names of the inputs:\n# Server function\nfunction(input, output, session) {\n  setBookmarkExclude(c(\"x\", \"y\"))\n}\n\n\nBookmarking and restoring tabs\nIt is possible for an app to bookmark which tab it is on. For this to work, you will need to provide an id for tabsetPanel(), navbarPage(), or navlistPanel(). See the example in the next section.\n\n\nUsing multiple bookmark buttons\nIf you want to have more than one bookmark button, you‚Äôll need to provide a unique ID for each one.\nIn the example below, there are two tabs, so the tabsetPanel() has an id, and there is a bookmarkButton in each one.\nui &lt;- function(request) {\n  fluidPage(\n    tabsetPanel(id = \"tabs\",\n      tabPanel(\"One\",\n        checkboxInput(\"chk1\", \"Checkbox 1\"),\n        bookmarkButton(id = \"bookmark1\")\n      ),\n      tabPanel(\"Two\",\n        checkboxInput(\"chk2\", \"Checkbox 2\"),\n        bookmarkButton(id = \"bookmark2\")\n      )\n    )\n  )\n}\nserver &lt;- function(input, output, session) {\n  # Need to exclude the buttons from themselves being bookmarked\n  setBookmarkExclude(c(\"bookmark1\", \"bookmark2\"))\n\n  # Trigger bookmarking with either button\n  observeEvent(input$bookmark1, {\n    session$doBookmark()\n  })\n  observeEvent(input$bookmark2, {\n    session$doBookmark()\n  })\n}\nshinyApp(ui, server, enableBookmarking = \"url\")\nIn order to trigger bookmarking from each button, there is an observeEvent() for each button that calls session$doBookmark(). Also, the bookmark buttons themselves are excluded from bookmarking with setBookmarkExclude(); if we don‚Äôt do this, then as soon as a user restores the application, it will immediately trigger bookmarking again.\n\n\nUpdating location bar with each input change\nThe default way that the bookmark URL is be presented to the user is with a modal dialog that appears on top of the app, but it‚Äôs not the only way to do it. Another way is to update the browser‚Äôs location bar. The example below updates the location bar every time the user changes an input. See it in action here.\nui &lt;- function(req) {\n  fluidPage(\n    textInput(\"txt\", \"Text\"),\n    checkboxInput(\"chk\", \"Checkbox\")\n  )\n}\nserver &lt;- function(input, output, session) {\n  observe({\n    # Trigger this observer every time an input changes\n    reactiveValuesToList(input)\n    session$doBookmark()\n  })\n  onBookmarked(function(url) {\n    updateQueryString(url)\n  })\n}\n\nshinyApp(ui, server, enableBookmarking = \"url\")",
    "crumbs": [
      "Share",
      "Bookmarking",
      "Bookmarking state"
    ]
  },
  {
    "objectID": "r/articles/share/bookmarking-state/index.html#learn-more",
    "href": "r/articles/share/bookmarking-state/index.html#learn-more",
    "title": "Bookmarking state",
    "section": "Learn more",
    "text": "Learn more\nFor more on this topic, see the following resources:\n\nIntroducing bookmarkable state for shiny\nBookmarking Shiny State",
    "crumbs": [
      "Share",
      "Bookmarking",
      "Bookmarking state"
    ]
  },
  {
    "objectID": "r/articles/share/advanced-bookmarking/index.html#applications-with-complex-state",
    "href": "r/articles/share/advanced-bookmarking/index.html#applications-with-complex-state",
    "title": "Advanced bookmarking",
    "section": "Applications with complex state",
    "text": "Applications with complex state\nFor applications that don‚Äôt have a straightforward reactive flow ‚Äì where the state of the inputs at a given time doesn‚Äôt fully determine the state of the outputs ‚Äì it may be necessary to use additional tools to save and restore the desired state.\nSuppose your application uses a variable to record how many times an input has changed. A very basic version of the server function might contain something like this:\nfunction(input, output) {\n  count &lt;- 0\n\n  observe({\n    input$x   # Trigger this observer when input$x changes\n    count &lt;&lt;- count + 1\n  })\n}\nIn actual use, it‚Äôs likely that the value would be stored in a reactiveValues object so that it could trigger other reactives and observers. For example, this app displays the sum of all the previous slider values that the user explicitly adds to a running tally using an action button:\nui &lt;- fluidPage(\n  sidebarPanel(\n    sliderInput(\"n\", \"Value to add\", min = 0, max = 100, value = 50),\n    actionButton(\"add\", \"Add\"), \n    br(), br()\n  ),\n  mainPanel(\n    h4(\"Sum of all previous slider values:\", textOutput(\"sum\"))\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  vals &lt;- reactiveValues(sum = 0)\n  \n  observeEvent(input$add, {\n    vals$sum &lt;- vals$sum + input$n\n  })\n  output$sum &lt;- renderText({\n    vals$sum\n  })\n}\n\nshinyApp(ui, server, enableBookmarking = \"url\")\nIn this app, the state of the outputs is not fully determined by the state of the inputs at a given time point; previous input values matter as well. Bookmarking this application therefore requires more than simply saving the current input values. We need to also record vals$sum and restore it later.\n\nonBookmark and onRestore\nTo record vals$sum, we will tell Shiny to save extra values when bookmarking state, and restore those values when restoring state. This is done by adding callbacks, using onBookmark() and onRestore() in the application‚Äôs server function. The callback functions that you pass to onBookmark() and onRestore() must take one argument, typically named state. The state object has an environment object named values, to which you can write or read arbitrary values. For this app, it‚Äôs simple: we‚Äôll just save vals$sum when we bookmark, and copy it back when we restore. We‚Äôd call the functions like this (in the server function):\n  # Save extra values in state$values when we bookmark\n  onBookmark(function(state) {\n    state$values$currentSum &lt;- vals$sum\n  })\n\n  # Read values from state$values when we restore\n  onRestore(function(state) {\n    vals$sum &lt;- state$values$currentSum\n  })\nHere‚Äôs the full app:\nui &lt;- function(request) {\n  fluidPage(\n    sidebarPanel(\n      sliderInput(\"n\", \"Value to add\", min = 0, max = 100, value = 50),\n      actionButton(\"add\", \"Add\"), br(), br(),\n      bookmarkButton()\n    ),\n    mainPanel(\n      h4(\"Sum of all previous slider values:\", textOutput(\"sum\"))\n    )\n  )\n}\n\nserver &lt;- function(input, output, session) {\n  vals &lt;- reactiveValues(sum = 0)\n  \n  # Save extra values in state$values when we bookmark\n  onBookmark(function(state) {\n    state$values$currentSum &lt;- vals$sum\n  })\n\n  # Read values from state$values when we restore\n  onRestore(function(state) {\n    vals$sum &lt;- state$values$currentSum\n  })\n\n  # Exclude the add button from bookmarking\n  setBookmarkExclude(\"add\")\n\n  observeEvent(input$add, {\n    vals$sum &lt;- vals$sum + input$n\n  })\n  output$sum &lt;- renderText({\n    vals$sum\n  })\n}\n\nshinyApp(ui, server, enableBookmarking = \"url\")\nNote that we exclude the add button from bookmarking with setBookmarkExclude so that when the app is restored the last value of input$n is not added to vals$sum.\n\n\nonBookmarked and onRestored\nThe onBookmark and onRestore callbacks are triggered just before the bookmarking and restoring events happen. They have counterpart callbacks that are triggered after bookmarking and restoring: onBookmarked and onRestored.\nThe onBookmarked callback behaves differently from the others. Its purpose is to display a URL in a modal dialog on the client browser. The callback function should take one argument, url, which is a string that contains the URL to display in the browser. If no onBookmarked callback is supplied the default is to use showBookmarkUrlModal. In other words, the default is equivalent to:\nonBookmarked(showBookmarkUrlModal)\nIf you wish to display the URL another way, you can supply a different function for onBookmarked().\nThe onRestored callback is similar to onBookmark and onRestore in that the function should take one argument, state, which is an object with a values member. This callback is invoked after the the application has been restored and running in the client browser, so it can be used to do things that must occur only after the application is ready. One example is calling an input updater function, like updateTextInput.\nui &lt;- function(request) {\n  fluidPage(\n    sliderInput(\"slider\", \"Add a value:\", 0, 100, 0),\n    bookmarkButton(),\n    textInput(\"txt\", \"Application restored at:\")\n  )\n}\n\nserver &lt;- function(input, output, session) {\n  onRestored(function(state) {\n    # This works, because it doesn't use the inputMessageQueue. Should it use a\n    # queue that's flushed on flushOutput?\n    showNotification('xxxx')\n    \n    # This doesn't, because it uses the inputMessageQueue\n    updateTextInput(session, \"txt\", value = \"xxxx\")\n  })\n}\n\nshinyApp(ui, server, enableBookmarking = \"url\")",
    "crumbs": [
      "Share",
      "Bookmarking",
      "Advanced bookmarking"
    ]
  },
  {
    "objectID": "r/articles/index.html#start",
    "href": "r/articles/index.html#start",
    "title": "Articles",
    "section": "Start",
    "text": "Start"
  },
  {
    "objectID": "r/articles/index.html#mastering-shiny",
    "href": "r/articles/index.html#mastering-shiny",
    "title": "Articles",
    "section": "Mastering Shiny",
    "text": "Mastering Shiny\n\nBy Hadley Wickham\n\n\n\nA free, online book designed to take you from basic Shiny to creating your own customized apps.\nRead Now"
  },
  {
    "objectID": "r/articles/index.html#build",
    "href": "r/articles/index.html#build",
    "title": "Articles",
    "section": "Build",
    "text": "Build"
  },
  {
    "objectID": "r/articles/index.html#improve",
    "href": "r/articles/index.html#improve",
    "title": "Articles",
    "section": "Improve",
    "text": "Improve"
  },
  {
    "objectID": "r/articles/index.html#share",
    "href": "r/articles/index.html#share",
    "title": "Articles",
    "section": "Share",
    "text": "Share"
  },
  {
    "objectID": "r/articles/improve/upgrade-R/index.html",
    "href": "r/articles/improve/upgrade-R/index.html",
    "title": "Upgrading to a new version of R",
    "section": "",
    "text": "When you upgrade to a new version of R on your computer, it‚Äôs possible that everything will continue to work without any trouble, but it‚Äôs also possible that you‚Äôll run into problems. In some cases, the new version of R won‚Äôt find your existing R packages. In other cases, R will find the existing packages, but they might not work correctly. The article of this document is to explain these problems, and how to fix them.\nOn most single-user systems (Mac, Windows, and Linux), when you upgrade to a new minor version of R (like 3.3.0 to 3.4.0), R will not find the packages, you will need to reinstall your R packages. This is an inconvenience, but the problem is obvious and it is easy to fix. If you are using a system like this, you can just reinstall your packages after upgrading R. You probably don‚Äôt need to read the rest of this document unless you want to learn much more about package libraries.\nOn servers running Linux, it is possible that after an R version upgrade, your R packages will load without trouble, but they might not work correctly, or they might even crash R when used. Because the cause of these problems will not be obvious, upgrading R on a server should be done with care.\nIn a production environment, we strongly suggest testing new versions of R and packages on a staging server before deploying to a production server.\nR version numbers have the form major.minor.subminor. The current version as of the writing of this document, 3.4.0, has a major version 3, minor version 4, and subminor version 0. New minor versions are released about once per year. In general, there are no issues with subminor version upgrades, like going from 3.3.2 to 3.3.3, but there can be compatibility problems when there is a major or minor version upgrade.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Upgrading to a new version of R"
    ]
  },
  {
    "objectID": "r/articles/improve/upgrade-R/index.html#user-libraries-and-version-incompatibilities",
    "href": "r/articles/improve/upgrade-R/index.html#user-libraries-and-version-incompatibilities",
    "title": "Upgrading to a new version of R",
    "section": "User libraries and version incompatibilities",
    "text": "User libraries and version incompatibilities\nThere are two possible sources of problems with R version upgrades, both of which are related to package libraries. (A library is a directory where packages are stored.)\nOne problem is that, after upgrading to a new version of R, packages are no longer found because there is a new library. When this happens, the problem is obvious: when R code calls library(), it throws an error and reports that the package is missing.\nThe other problem that happens is more subtle. Sometimes packages installed with a previous version of R will not work correctly with the new version of R. Sometimes they can crash the R process. And even when there is a crash, it will not be obvious that this it is because the package was installed with an old version of R.\nIn both cases, the solution is to reinstall packages with the new version of R.\n\nDetecting which version of R a package was built with\nThe following code will show which packages are installed, their version numbers, and which version of R they were built with. The user is running R 3.4.0 and most of the installed packages were built with R 3.4.0, but others were built with R 3.2.0.\npkgs &lt;- as.data.frame(installed.packages(), stringsAsFactors = FALSE, row.names = FALSE)\npkgs[, c(\"Package\", \"Version\", \"Built\")]\n#&gt;       Package Version Built\n#&gt; 1        base   3.4.0 3.4.0\n#&gt; 2        boot  1.3-19 3.4.0\n#&gt; 3       class  7.3-14 3.4.0\n#&gt; 4     cluster   2.0.6 3.4.0\n#&gt; 5       Cairo   1.5-6 3.2.0\n#&gt; ...\nIn this particular case, the Cairo package was able to be loaded with library(Cairo), but when functions from the package were called, it caused a segfault, crashing the R process. This is because it was built with an older version of R.\nThis issue most frequently happens on Linux, when root has installed some packages, though it can happen in other cases as well, if a customized configuration is used.\n\n\nReinstalling packages with the new version of R\nAfter upgrading R, if you have any packages that were built with an older version of R, you should reinstall those packages to avoid compatibility issues. There are two methods described below: one upgrades all packages to the latest available version of that package, and the other reinstalls packages with the currently-installed version. For example, if you have Shiny version 1.0.1 installed, and the latest available version is 1.0.3, the first method will install Shiny 1.0.3, while the second method will reinstall 1.0.1 (built with the current version of R).\nThe following code should be run as root after upgrading R on Linux. It can also be run as a regular user, but in that case it will store the packages in the user‚Äôs personal library, and won‚Äôt help other users. If this code is run as root after an R version upgrade, then users should not need to run this code (unless they have their own copies of the same packages in their personal library).\nThe first way is to use the base R function update.packages(), with checkBuilt=TRUE. Normally, the update.package() function will only reinstall packages for which a newer version available, but the checkBuilt=TRUE option tells it to also reinstall packages if they were built with an older version of R, even if the version of the package will remain the same.\nupdate.packages(ask = FALSE, checkBuilt = TRUE)\nIn many cases, it is useful to update all packages to the latest available version, but it‚Äôs possible that some changes in the packages could cause your code to behave differently.\nThe pkgsnap package provides a way to reinstall packages without changing their version. pkgsnap is not yet on CRAN, but you can currently install it from GitHub.\n# Install the pkgsnap package from GitHub\nsource(\"https://install-github.me/MangoTheCat/pkgsnap\")\n\nsnap()\nrestore()\nfile.remove(\"packages.csv\") # Remove the package list created by save()",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Upgrading to a new version of R"
    ]
  },
  {
    "objectID": "r/articles/improve/upgrade-R/index.html#technical-details",
    "href": "r/articles/improve/upgrade-R/index.html#technical-details",
    "title": "Upgrading to a new version of R",
    "section": "Technical details",
    "text": "Technical details\nThe information above should be enough to help diagnose and solve the problem, but if you‚Äôd like a more comprehensive understanding of the problem, read on. Each platform (Mac, Windows, and various flavors of Linux) has a different default configuration, and therefore has different default behavior. This document will also explain the default settings for each platform, and what that means for dealing with R upgrade issues.\n\nUser and site libraries\nIn all R installations, there is a site library: packages installed there are available to all users. (In some installations, there is more than one site library.) Some R installations are also configured to have a user library: packages installed in a user library are available only to that user.\nWhen a regular user starts R, it will recognize both the user library (if configured for it) and the site library. If present, the user library is where packages will be installed to. If there is no user library, then packages will be installed to the site library, assuming the user has the correct permissions to do so.\nWhen a system‚Äôs superuser (root) starts R, it uses only the site library (or libraries), and that is where packages will be installed to. This is not how packages are usually installed, but it is sometimes done this way on servers.\nTo find the libraries for your user, you can run .libPaths() from the R prompt. For example, this is what shows on Ubuntu Linux:\n&gt; .libPaths()\n[1] \"/home/username/R/x86_64-pc-linux-gnu-library/3.4\"\n[2] \"/usr/local/lib/R/site-library\"              \n[3] \"/usr/lib/R/site-library\"                    \n[4] \"/usr/lib/R/library\"                         \nUsers can configure their library path by setting the R_LIBS_USER variable in a file called .Renviron in their home directory. At a system level, the library path(s) can be set with an Renviron.site file. See the R startup documentation page for more information.\n\n\nVersioned and unversioned libraries\nIn some installations (typically on Linux), R is configured to keep the same site library across R version upgrades. The problem here is that packages that built and installed with one version of R may be incompatible with a newer version of R, at least when the major or minor version changes. (Note that Subminor version upgrades of R generally do not introduce incompatibilities.)\nIn other installations (typically on Mac and Windows), R is configured to use a new library when R has a major or minor version upgrade. The advantage of this is that you won‚Äôt experience package incompatibilities. The drawback is that you must reinstall your packages after upgrading R.\n\n\nCustomized library paths\nThe user and site library paths can be customized. At the user level, this is done with a file named ~/.Renviron, and at the system level, this is usually done with a file named /etc/R/Renviron.site. See the R startup documentation for more information.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Upgrading to a new version of R"
    ]
  },
  {
    "objectID": "r/articles/improve/upgrade-R/index.html#platform-specific-notes",
    "href": "r/articles/improve/upgrade-R/index.html#platform-specific-notes",
    "title": "Upgrading to a new version of R",
    "section": "Platform-specific notes",
    "text": "Platform-specific notes\nThe default library configuration differs across platforms, and so the behavior after an R version upgrade also differs across platforms.\n\nWindows\nOn Windows, the default user library has the major.minor version in the path. The default site library has the major.minor.subminor version.\n&gt; .libPaths()\n[1] \"C:/Users/username/Documents/R/win-library/3.4\"\n[2] \"C:/Program Files/R/R-3.4.0/library\"         \nWith this configuration, user-installed packages get installed in the user library. (The site library will just contain ‚Äúbase‚Äù R packages that are installed along with R itself.) Only R version upgrades that involve a minor version change will result in the user library changing. When this happens, you will need to reinstall all your packages.\nOn Windows, upgrading R is something that is usually done by the user of the machine, so it shouldn‚Äôt be much of a surprise when R cannot find old installed packages.\nSummary:\n\nUpgrade is usually done explicitly by user.\nUser library is versioned to minor.\nSite library is versioned to subminor.\nUnlike on Mac and Linux, when R is run as an administrator on Windows, it will still install packages to the user‚Äôs personal library by default, but it can also install to the site library if specified.\n\n\n\nmacOS\nOn macOS, the default configuration does not have a user library. The site library has the major.minor version in the path.\n&gt; .libPaths()\n[1] \"/Library/Frameworks/R.framework/Versions/3.4/Resources/library\"\nWith this configuration, user-installed packages get installed into the site library. (Users on macOS usually have permission to write to the site library.) R version upgrades that involve a minor version change will require the user to reinstall all packages.\nOn a Mac, upgrading R is usually done by the user of the machine, so it shouldn‚Äôt be a surprise when the new version of R cannot find old installed packages.\nSummary:\n\nUpgrade is usually done explicitly by user.\nDoes not have user library, so packages install to site library.\nSite library is versioned to subminor.\n\n\n\nLinux\nOn Linux, the default user library has the major.minor version in the path. The site library is not versioned. There can be multiple site libraries, though this should not cause any differences in most use cases.\nDebian / Ubuntu:\n&gt; .libPaths()\n[1] \"/home/username/R/x86_64-pc-linux-gnu-library/3.4\"\n[2] \"/usr/local/lib/R/site-library\"              \n[3] \"/usr/lib/R/site-library\"                    \n[4] \"/usr/lib/R/library\"                         \nRed Hat / Centos:\n&gt; .libPaths()\n[1] \"/home/username/R/x86_64-redhat-linux-gnu-library/3.3\"\n[2] \"/usr/lib64/R/library\"                              \n[3] \"/usr/share/R/library\"                              \nSUSE / openSUSE:\n&gt; .libPaths()\n[1] \"/home/username/R/x86_64-suse-linux-gnu-library/3.3\"\n[2] \"/usr/lib64/R/library\"                            \nThe process of upgrading R on Linux is different from upgrading it Mac and Windows. On Mac and Windows, the user usually needs to go download the new version of R and install it, so it is obvious when R is upgraded. On Linux, R is usually upgraded in the process of a system software update, such as when you run apt-get upgrade on Debian or Ubuntu. Additionally, Linux systems often have different people administering them and using them. For these two reasons, the installed version of R can change without the user being aware of it.\nUser-installed packages go into the user library. The site library by default will contain only ‚Äúbase‚Äù packages included with R itself. After R gets a minor version upgrade, the user will find that their user-installed packages are no longer available, and will need to reinstall all of them. This may come as a surprise to users, but the solution is straightforward.\nWhen Linux is being used on a server, there is another, more difficult scenario: the system administrator may install some packages as root, so that they‚Äôre available for all users. When R is upgraded, those packages will continue to be available even after a major or minor version upgrade, but they potentially could be incompatible with the new version of R. If this happens, users will experience problems like the ones described previously.\nIn these cases, a user or system administrator should check which version of R each package was built with, and reinstall those packages that were built with an old version of R, as described above. One risk of doing this is that this will not only reinstall those R packages, but also upgrade the versions of those packages, which could cause problems if the newer version of the package has different behavior.\nBecause of these potential problems, administrators of Linux servers should be exercise caution when upgrading R. On most Linux distributions, it is possible to freeze system packages (like R) to a specific version, and only upgrade after testing.\nSummary:\n\nUpgrade is usually something that happens with apt-get upgrade or yum update, and user might not be aware when it occurs.\nUser library is versioned to minor.\nSite library is not versioned.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Upgrading to a new version of R"
    ]
  },
  {
    "objectID": "r/articles/improve/testing-overview/index.html",
    "href": "r/articles/improve/testing-overview/index.html",
    "title": "Shiny testing overview",
    "section": "",
    "text": "Automated testing is essential for making sure that code works the way that you intend it to, and keeps working even after you make changes to the code.\nBefore Shiny 1.5.0, the shinytest package provided the main way of testing apps. Shinytest records a script of actions, takes snapshots of the application‚Äôs state, and uses those snapshots for comparison in future test runs.\nShiny 1.5.0 introduced the runTests() function, which can run shinytest snapshot-based tests, as well as other kinds of tests that don‚Äôt use snapshots. Broadly speaking, there are three categories of tests:\nFor unit tests and server function tests, no web browser is involved, and the tests and test expectations are expressed in R code. This means that the tests run quickly, and that changing code in one part of an application will generally not affect tests of another part of the application.\nThe snapshot-based tests require a headless web browser, and, as the name suggests, use snapshots. The recordTest() function makes it easy to record a test script by interacting with your application; running the test script replays your interactions with the application and takes snapshots of the application‚Äôs state. Each snapshot can also include a screenshot of the web browser. These snapshots are saved to disk as baseline, or expected, results. Later on, when you run the test script again, it compares the snapshots to the expected results from before. If they are identical, the test is considered successful; if not, then you will be prompted to view what changed in the snapshots, and you can either accept the new snapshots as the new expected results, or you can reject them.\nHere are some practical differences between the various types of tests.\nThey differ in scope:\nThe components that can be tested with each type of test:\nCreating tests:\nSensitivity to changes:\nIn this article, we‚Äôll demonstrate these three approaches to testing with a basic Shiny application. As you‚Äôll see throughout, any of these tests can be run locally via shiny::runTest() (see the continuous integration section to run them on a remote machine). Finally, these testing strategies are primarily focused on testing the correctness of an application, but they don‚Äôt tell you anything about its performance under load. Shiny load testing is most easily done via the shinyloadtest package (see the Load testing section).\nNote: If you used shinytest before version 1.4.0, it put its tests in your application‚Äôs tests/ subdirectory. As of shinytest 1.4.0, they go in tests/shinytest/, because shiny 1.5.0 puts all kinds tests in tests/. The function shinytest::migrateShinytestDir() will migrate your tests to the new location and set it up to be used with shiny::runTests().",
    "crumbs": [
      "Improve",
      "Refactor",
      "Testing",
      "Shiny testing overview"
    ]
  },
  {
    "objectID": "r/articles/improve/testing-overview/index.html#creating-an-example",
    "href": "r/articles/improve/testing-overview/index.html#creating-an-example",
    "title": "Shiny testing overview",
    "section": "Creating an example",
    "text": "Creating an example\nYou can create a basic application with the shinyAppTemplate() function. This application will contain a module and various kinds of tests. To create an application in a directory called myapp:\nshinyAppTemplate(\"myapp\")\nIt will ask you what components you want to use:\nSelect which of the following to add at myapp/ :\n\n1: All\n2: app.R              : Main application file\n3: R/example.R        : Helper file with R code\n4: R/example-module.R : Example module\n5: tests/shinytest/   : Tests using the shinytest package\n6: tests/testthat/    : Tests using the testthat package\n\nEnter one or more numbers (with spaces), or an empty line to exit:\nSelect 1 to add all of these components, and press Enter. This will create a directory myapp with a Shiny application, a subdirectory R/ which contains a function that containing the following:\nmyapp/\n|- app.R\n|- R\n|   |- example-module.R\n|   `- example.R\n`- tests\n    |- shinytest.R\n    |- shinytest\n    |   `- mytest.R\n    |- testthat.R\n    `- testthat\n        |- test-examplemodule.R\n        |- test-server.R\n        `- test-sort.R\nThe R/ subdirectory contains code that is used in the application. example.R contains a function, lexical_sort, which can be unit-tested. example-module.R contains a module with two parts, exampleModuleUI and exampleModuleServer. The server part of the module can be tested using the server testing framework.\nWhen the runTests() function is called, it looks in the application‚Äôs tests/ directory and sources the .R files it finds there. The output looks like this:\n&gt; shiny::runTests(\"myapp\")\nRunning mytest.R\n==== Comparing mytest...\n  No existing snapshots at mytest-expected/. This is a first run of tests.\n\nUpdating baseline results at ..//tests/shinytest/mytest-expected...\nRenaming shinytest/mytest-current\n      =&gt; ..//tests/shinytest/mytest-expected.\n‚úì |  OK F W S | Context\n‚úì |   2       | sort\n\n‚ïê‚ïê Results ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\nDuration: 0.3 s\n\nOK:       8\nFailed:   0\nWarnings: 0\nSkipped:  0\nShiny App Test Results\n* Success\n  - myapp/tests/shinytest.R\n  - myapp/tests/testthat.R",
    "crumbs": [
      "Improve",
      "Refactor",
      "Testing",
      "Shiny testing overview"
    ]
  },
  {
    "objectID": "r/articles/improve/testing-overview/index.html#code-tests-with-testthat",
    "href": "r/articles/improve/testing-overview/index.html#code-tests-with-testthat",
    "title": "Shiny testing overview",
    "section": "Code tests with testthat",
    "text": "Code tests with testthat\nIn the application created by shinyAppTemplate(), the file tests/testthat.R is the test runner for code tests. It runs all the .R files in the tests/testthat/ subdirectory. It contains the following:\nlibrary(testthat)\ntest_dir(\n  \"./testthat\",\n  env = shiny::loadSupport(),\n  reporter = c(\"progress\", \"fail\")\n)\nNotably, when it calls the test_dir() function, it specifies a special value for env, which is the R environment in which to run the test scripts. This is done by calling shiny::loadSupport(), which sources the files in the R/ subdirectory in a new environment (which is a child of the global environment), so that any functions or other R objects from those scripts will be created in that environment. If global.R is present, it will also be sourced into R‚Äôs global environment (it uses the global environment for legacy reasons).\nAll of the code tests are contained with the directory tests/testthat/, so to run just the code tests, you can call:\nrunTests(\"myapp\", filter = \"testthat\")\nIf you just call runTests(\"myapp\"), it will run the all tests, which include the code tests and snapshot-based tests.\nNote: The code tests in this document use the testthat package. However, you don‚Äôt have to use testthat. You could use a different testing system if you prefer.\n\nUnit tests\nIn a Shiny application, unit tests can be used to test functions contained in the R/ directory. In our example, the file R/example.R contains a function named lexical_sort().\nOur application includes a test in testthat/test-sort.R, with the following:\ntest_that(\"Lexical sorting works\", {\n  expect_equal(lexical_sort(c(1, 2, 3)), c(1, 2, 3))\n  expect_equal(lexical_sort(c(1, 2, 3, 13, 11, 21)), c(1, 11, 13, 2, 21, 3))\n})\nThese tests ensure that lexical_sort() does what it claims to do: sort a vector lexically, intead of numerically, so that, for example, 11 and 13 come before 2. This kind of tests not only ensures that function does the right thing; it also ensures that it continues to do so in the future, even changes are made to it.\nFor more information on using testthat, see https://testthat.r-lib.org/.\n\n\nServer code tests\nShiny 1.5.0 also adds the ability to test code inside an application‚Äôs server function or a module‚Äôs server function. For a more in-depth exploration of this, see the Server function testing article.\nHere‚Äôs a portion of the application server function, from app.R:\nserver &lt;- function(input, output, session) {\n  data &lt;- reactive({\n    lexical_sort(seq_len(input$size))\n  })\n  output$sequence &lt;- renderText({\n    paste(data(), collapse = \" \")\n  })\n}\nHere are some server function tests, from tests/testthat/test-server.R:\ntestServer(expr = {\n  session$setInputs(size = 6)\n  expect_equal(output$sequence, \"1 2 3 4 5 6\")\n\n  session$setInputs(size = 12)\n  expect_equal(output$sequence, \"1 10 11 12 2 3 4 5 6 7 8 9\")\n})\nNotice that testServer() is called and given an expression. When invoked via runTests(), it automatically has access to the contents of the application‚Äôs server function. It works by executing the server function, and then making all of the objects from the server function available when it evaluates the test expression.\nThe first step inside of the test expression is to set input values. Normally, when an application is run the starting values of the inputs come from the web browser, which in turn gets the starting input values from the application‚Äôs UI definition. However, when testServer() is used, the UI isn‚Äôt available, so for the tests, the inputs don‚Äôt have any starting values, and so must be set explicitly with session$setInputs(). In the example, it sets size, but if you have multiple inputs you‚Äôd like to set, they can also be passed in, as in session$setInputs(x=1, y=2).\nEach time that setInputs is called, a reactive flush happens at the end. This is what causes reactive expressions, observers, and outputs to run. (A flush can also be triggered explicitly with session$flush().)\nInside of the test expression, output values and reactive expressions can be accessed. In the example above, it checks that the value output$sequence matches an expected value.\nThe reactive expression data() can also be tested. For example, the following test checks the value of data():\n  expect_equal(data(), 1:6)",
    "crumbs": [
      "Improve",
      "Refactor",
      "Testing",
      "Shiny testing overview"
    ]
  },
  {
    "objectID": "r/articles/improve/testing-overview/index.html#snapshot-based-tests",
    "href": "r/articles/improve/testing-overview/index.html#snapshot-based-tests",
    "title": "Shiny testing overview",
    "section": "Snapshot-based tests",
    "text": "Snapshot-based tests\nThe snapshot approach to testing differs significantly from the code tests above. In the code tests, the expectations for the tests are expressed in code, and written by hand. In the snapshot-based tests, the test expectations are recorded from the state of the application. The snapshots are used to detect changes to the application‚Äôs behavior. For Shiny, the shinytest package is used to create snapshot-based tests.\nBecause the snapshots typically capture a large amount of the application‚Äôs state as well as a screenshot, they are very sensitive to changes. This is helpful for detecting unexpected changes in behavior, but it can also result in false positives ‚Äì any change to the application‚Äôs behavior causes a test failure which then requires a person to view and potentially approve the changes. Because these changes can happen easily, viewTestDiff() provides a graphical interface for easily visualizing the changes and either accepting them or rejecting them.\nHere is a brief overview of how testing works with shinytest:\n\nGet your Shiny application to a state that looks good.\nCreate a test recording:\n\nCall shinytests‚Äôs recordTest() function. This will open a web browser with your application running in an iframe, and a set of shinytest controls on the side.\nInteract with your application as normal. These interactions will be recorded to a test script. Along the way, click the Take snapshot button to tell the test script to record snapshots of the application‚Äôs state.\nOnce you finish the recording, it will play back the test script using a headless web browser and take snapshots where specified. These snapshots will be stored as the expected results.\n\nWhen you run the test script again in the future, it will take new snapshots. If new the snapshots are the same as the expected (old) ones, then the test passes. If the new snapshots differ from the expected ones, then you will be prompted with a web interface whether to accept the new snapshots (and use them in the future as the expected snapshots), or to reject them.\n\nFor more information about using shinytest, see the shinytest web site.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Testing",
      "Shiny testing overview"
    ]
  },
  {
    "objectID": "r/articles/improve/testing-overview/index.html#automated-testing-with-continuous-integration",
    "href": "r/articles/improve/testing-overview/index.html#automated-testing-with-continuous-integration",
    "title": "Shiny testing overview",
    "section": "Automated testing with continuous integration",
    "text": "Automated testing with continuous integration\nYou can use continuous integration (CI) for testing your Shiny application ‚Äì that is, automatically run tests each time any changes are committed. You can also run the tests on a schedule, for example, once per day or week. This can be useful for detecting if any changes to the packages used by your application cause changes in behavior.\nUsing CI is relatively simple for unit and server function tests, but is more difficult for snapshot-based testing, since any software differences (e.g., the operating system, R version, package versions, etc) can lead to snapshot differences.\nWe recommend using GitHub Actions (GHA) for CI and have several templates to help you get started:\n\nA minimal setup for just unit and server function testing.\nA more advanced setup for snapshot testing.\nEven more advanced setup for snapshot testing on multiple platforms.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Testing",
      "Shiny testing overview"
    ]
  },
  {
    "objectID": "r/articles/improve/testing-overview/index.html#load-testing",
    "href": "r/articles/improve/testing-overview/index.html#load-testing",
    "title": "Shiny testing overview",
    "section": "Load testing",
    "text": "Load testing\nAll the testing we‚Äôve discussed thus far relate to validating the correctness of the app. If you anticipate a lot of traffic or if you deem that downtime is very expensive for this app, you may wish to validate that the application will be able to handle the anticipated ‚Äúload‚Äù before you deploy a new version.\nThankfully, shinyloadtest makes it easy to evaluate the performance of a Shiny app and even identify bottlenecks. Much like shinytest, the first step is to record a session that represents how a user might interact with your application. Once you have this recorded session, you can replay this session in parallel, simulating many dozens, hundreds, or thousands of concurrent users on your application to confirm that it continues to behave within acceptable ranges.\n\n\n\nScreenshot of shinyloadtest\n\n\nAgain, because shinyloadtest involves interactively recording a session, you‚Äôre best served by reading through the shinyloadtest website to learn how to leverage shinyloadtest with your application.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Testing",
      "Shiny testing overview"
    ]
  },
  {
    "objectID": "r/articles/improve/server-function-testing/index.html",
    "href": "r/articles/improve/server-function-testing/index.html",
    "title": "Server function testing",
    "section": "",
    "text": "The testServer() function (introduced in Shiny 1.5.0) makes it possible to test code in server functions and modules, without needing to run the full Shiny application. This means that these tests will run more quickly and reliably than ones with shinytest, which simulate the entire session, including a headless web browser. The testServer() function can be used with a unit testing framework like testthat.\nHere is a server function for a simple Shiny application:\nThis server function\nIt would be nice to write tests that confirm that the module behaves the way we expect. We can do that using testServer():\nThere are a few things to notice in this example.\nFirst, the test expression provided here assumes the existence of some variables ‚Äì specifically, input, output, and myreactive. The objects from inside the server function environment will be made available in the environment of the test expression.\nSecond, you‚Äôll need to set the values to any inputs that you want to be defined; by default, they‚Äôre all NULL. We do that using the session$setInputs() method. The real session object that you‚Äôd see when running a Shiny app does not have session$setInputs(); the input values are set by the client‚Äôs web browser. The session object used in testServer() differs from the real session object Shiny uses. This allows us to tailor it to be more suitable for testing purposes by modifying or creating new methods such as setInputs().\nLast, you‚Äôre likely used to assigning to output, but here we‚Äôre reading from output$txt in order to check its value. When running inside testServer(), you can simply reference an output and it will give the value produced by the render function.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Testing",
      "Server function testing"
    ]
  },
  {
    "objectID": "r/articles/improve/server-function-testing/index.html#automated-tests",
    "href": "r/articles/improve/server-function-testing/index.html#automated-tests",
    "title": "Server function testing",
    "section": "Automated tests",
    "text": "Automated tests\nIn real tests, we don‚Äôt want to just print the values for manual inspection; we‚Äôll want to use them in automated tests. That way, we‚Äôll be able to build up a collection of tests that we can run against our module in the future to confirm that it always behaves correctly. You can use whatever testing framework you‚Äôd like (or none at all!), but we‚Äôll use the expect_* functions from the testthat package in this example.\n# Bring in testthat for its expectations\nlibrary(testthat)\ntestServer(server, {\n  session$setInputs(x = 1)\n  expect_equal(myreactive(), 2)\n  expect_equal(output$txt, \"I am 2\")\n  session$setInputs(x = 2)\n  expect_equal(myreactive(), 4)\n  expect_equal(output$txt, \"I am 4\")\n})\nIf there‚Äôs no error, then we know our tests ran successfully. If there were a bug, we‚Äôd see an error printed. For example:\ntestServer(server, {\n  session$setInputs(x = 1)\n\n  expect_equal(myreactive(), 99)\n})\n#&gt; Error: myreactive() (`actual`) not equal to 99 (`expected`).\n#&gt;\n#&gt;   `actual`:  2\n#&gt; `expected`: 99",
    "crumbs": [
      "Improve",
      "Refactor",
      "Testing",
      "Server function testing"
    ]
  },
  {
    "objectID": "r/articles/improve/server-function-testing/index.html#shiny-app-objects",
    "href": "r/articles/improve/server-function-testing/index.html#shiny-app-objects",
    "title": "Server function testing",
    "section": "Shiny app objects",
    "text": "Shiny app objects\nIn the examples above, we‚Äôve just used the server part of a Shiny application. In many cases, that‚Äôs a readily accessible object. It‚Äôs also possible to pass an entire shinyApp() object to testServer(), as in:\napp &lt;- shinyApp(\n  ui = fluidPage(\n    numericInput(\"x\", \"X\", value = 5),\n    textOutput(\"txt\")\n  ),\n  server = function(input, output, session) {\n    myreactive &lt;- reactive({\n      input$x * 2\n    })\n    output$txt &lt;- renderText({\n      paste0(\"I am \", myreactive())\n    })\n  }\n)\n\n\ntestServer(server, {\n  session$setInputs(x = 1)\n  expect_equal(myreactive(), 2)\n})\nNotice that, even though the numericInput() sets a starting value for input$x, running tests with testServer() doesn‚Äôt know that. This is because it runs the tests without the UI portion entirely ‚Äì it only knows about the server portion of the application.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Testing",
      "Server function testing"
    ]
  },
  {
    "objectID": "r/articles/improve/server-function-testing/index.html#test-file-layout",
    "href": "r/articles/improve/server-function-testing/index.html#test-file-layout",
    "title": "Server function testing",
    "section": "Test file layout",
    "text": "Test file layout\nAt this point you may be wondering how to use testServer() in a real application. In most cases, an app.R simply returns shinyApp(). How do we pass that object to testServer()? Where should the tests go?\nThe shinyAppTemplate() takes care of the details about how the files are laid out. (For more information, see this section from the Testing Overview article.) In most cases, you can shiny::runTests() function to run all tests for an application.\nTo create an example application in a directory called myapp:\nshinyAppTemplate(\"myapp\", \"all\")\nIt will create the following files:\nmyapp/\n|- app.R\n|- R\n|   |- example-module.R\n|   `- example.R\n`- tests\n    |- shinytest.R\n    |- shinytest\n    |   `- mytest.R\n    |- testthat.R\n    `- testthat\n        |- test-examplemodule.R\n        |- test-server.R\n        `- test-sort.R\nThe tests/testthat/test-server.R function has the following contents):\ntestServer(expr = {\n  session$setInputs(size = 6)\n  expect_equal(output$sequence, \"1 2 3 4 5 6\")\n})\nNotice that no server or app object is passed into this function. This is because the code that invokes this file (from tests/testthat.R) sets up the environment so that the server function is accessible to testServer().",
    "crumbs": [
      "Improve",
      "Refactor",
      "Testing",
      "Server function testing"
    ]
  },
  {
    "objectID": "r/articles/improve/server-function-testing/index.html#testing-shiny-modules",
    "href": "r/articles/improve/server-function-testing/index.html#testing-shiny-modules",
    "title": "Server function testing",
    "section": "Testing Shiny modules",
    "text": "Testing Shiny modules\nIn addition to testing server functions for Shiny applications, you can also test the server functions for Shiny modules.\nHere is the server code for a module that‚Äôs very similar to the full application above:\nmyModule &lt;- function(id) {\n  moduleServer(id, function(input, output, session) {\n    myreactive &lt;- reactive({\n      input$x * 2\n    })\n    output$txt &lt;- renderText({\n      paste0(\"I am \", myreactive())\n    })\n  })\n}\nIt can be tested in exactly the same way:\ntestServer(myModule, {\n  session$setInputs(x = 1)\n  expect_equal(myreactive(), 2)\n})\n\nModules with additional parameters\nSome modules take additional parameters. Here‚Äôs a version that takes multiplier:\nmyModule2 &lt;- function(id, multiplier) {\n  moduleServer(id, function(input, output, session) {\n    myreactive &lt;- reactive({\n      input$x * multiplier\n    })\n    output$txt &lt;- renderText({\n      paste0(\"I am \", myreactive())\n    })\n  })\n}\nTo pass in parameter values, use args:\ntestServer(myModule2, args = list(multiplier = 3), {\n  session$setInputs(x = 1)\n  expect_equal(myreactive(), 3)\n})\n\n\nModules with return values\nSome modules return reactive objects. For such modules, it can be helpful to test the returned value as well. The returned value from the module is made available as a property on the mock session object as demonstrated in this example.\nmyModule3 &lt;- function(id, multiplier) {\n  moduleServer(id, function(input, output, session) {\n    reactive({\n      input$a + input$b\n    })\n  })\n}\n\ntestServer(myModule3, {\n  session$setInputs(a = 1, b = 2)\n  expect_equal(session$returned(), 3)\n  # And retains reactivity\n  session$setInputs(a = 2)\n  expect_equal(session$returned(), 4)\n})",
    "crumbs": [
      "Improve",
      "Refactor",
      "Testing",
      "Server function testing"
    ]
  },
  {
    "objectID": "r/articles/improve/server-function-testing/index.html#timers-and-polling",
    "href": "r/articles/improve/server-function-testing/index.html#timers-and-polling",
    "title": "Server function testing",
    "section": "Timers and polling",
    "text": "Timers and polling\nTesting behavior that relies on timing is notoriously difficult. Modules will behave differently on different machines and under different conditions. In order to make testing with time more deterministic, testServer uses simulated time that you control, rather than the actual computer time. Let‚Äôs look at what happens when you try to use ‚Äúreal‚Äù time in your testing.\nserver &lt;- function(input, output, session){\n  rv &lt;- reactiveValues(x = 0)\n\n  observe({\n    # Cause the observer to invalidate every 0.1 second\n    invalidateLater(100)\n    isolate(rv$x &lt;- rv$x + 1)\n  })\n}\n\ntestServer(server, {\n  expect_equal(rv$x, 0)\n  Sys.sleep(0.1)\n  expect_equal(rv$x, 1)\n})\n#&gt; Error: rv$x (`actual`) not equal to 1 (`expected`).\n#&gt;\n#&gt;   `actual`: 0\n#&gt; `expected`: 1\nThis behavior may be surprising. It seems like rv$x should have been incremented 10 times (or perhaps 9, due to computational overhead). But in truth, it hasn‚Äôt changed at all. This is because testServer() doesn‚Äôt consider the actual time on your computer, but instead it uses simulated time.\nIn order to cause testServer() to progress through time, instead of Sys.sleep(), we‚Äôll use session$elapse() ‚Äì another method that exists only on our mocked session object. Using the same server function as above:\ntestServer(server, {\n  expect_equal(rv$x, 0)\n  session$elapse(100)   # Simulate the passing of 100ms\n  expect_equal(rv$x, 1) # The observer was invalidated and the value updated!\n\n  # You can even simulate multiple events in a single elapse\n  session$elapse(300)\n  expect_equal(rv$x, 4)\n})\nAs you can see, using session$elapse() caused testServer() to recognize that (simulated) time had passed which triggered the reactivity as we‚Äôd expect. This approach allows you to deterministically control time in your tests while avoiding expensive pauses that would slow down your tests. Using this approach, this test can complete in only a fraction of the 100ms that it simulates.\nYou should note that only certain time-based functions are aware of this mocked time that can be managed via elapse(). Shiny functions like reactivePoll(), invalidateLater(), and reactiveTimer() will all abide by this simulated time, but time-based functions in other packages (such as later::later() are not aware of mocked time and will not behave according to these rules.)",
    "crumbs": [
      "Improve",
      "Refactor",
      "Testing",
      "Server function testing"
    ]
  },
  {
    "objectID": "r/articles/improve/server-function-testing/index.html#complex-outputs-plots-htmlwidgets",
    "href": "r/articles/improve/server-function-testing/index.html#complex-outputs-plots-htmlwidgets",
    "title": "Server function testing",
    "section": "Complex outputs (plots, htmlwidgets)",
    "text": "Complex outputs (plots, htmlwidgets)\nThus far, we‚Äôve seen how to validate simple outputs like numeric or text values. Real Shiny applications and modules often use more complex outputs such as plots or htmlwidgets. Validating the correctness of these is not as simple, but is doable.\nYou can access the data for even complex outputs in testServer, but the structure of the output may initially be foreign to you.\nserver &lt;- function(input, output, session){\n  output$plot &lt;- renderPlot({\n    df &lt;- data.frame(length = iris$Petal.Length, width = iris$Petal.Width)\n    plot(df)\n  })\n}\ntestServer(server, {\n  print(str(output$plot))\n})\n\n## List of 4\n##  $ src     : chr \"data:image/png;base64,iVBORw0KGgoAAAANSUhEU\"| __truncated__\n##  $ width   : num 600\n##  $ height  : num 400\n##  $ coordmap:List of 2\n##   ..$ panels:List of 1\n##   .. ..$ :List of 4\n##   .. .. ..$ domain :List of 4\n##   .. .. .. ..$ left  : num 0.764\n##   .. .. .. ..$ right : num 7.14\n##   .. .. .. ..$ bottom: num 0.004\n##   .. .. .. ..$ top   : num 2.6\n##   .. .. ..$ range  :List of 4\n##   .. .. .. ..$ left  : num 59\n##   .. .. .. ..$ right : num 570\n##   .. .. .. ..$ bottom: num 326\n##   .. .. .. ..$ top   : num 58\n##   .. .. ..$ log    :List of 2\n##   .. .. .. ..$ x: NULL\n##   .. .. .. ..$ y: NULL\n##   .. .. ..$ mapping: Named list()\n##   ..$ dims  :List of 2\n##   .. ..$ width : num 600\n##   .. ..$ height: num 400\n## NULL\nAs you can see, there are a lot of internal details that go into a plot. Behind the scenes, these are all the details that Shiny will use to correctly display a plot in a user‚Äôs browser. You don‚Äôt need to learn about all of these properties, and they‚Äôre all subject to change.\nIn terms of your testing strategy, you shouldn‚Äôt bother yourself with ‚Äúis Shiny generating the correct structure so that the plot will render in the browser?‚Äù That‚Äôs a question that the Shiny package itself needs to answer (and one for which we have our own tests). The goal for your tests should be to ask ‚Äúis the code that I wrote producing the plot I want?‚Äù There are two components to that question:\n\nDoes the plot generate without producing an error?\nIs the plot visually correct?\n\ntestServer is great for assessing the first component here. By merely referencing output$plot in your test, you‚Äôll confirm that the plot was generated without an error. The second component is better suited for a shinytest test which actually loads the Shiny app in a headless browser and confirms that the content visually appears the same as it did previously. Doing this kind of test in testServer would be complex and may not be reliable as graphics devices differ slightly from platform to platform; i.e.¬†the exact bits in the src field of your plot will not necessarily be reproducible between different versions of R or different operating systems.\nFor htmlwidgets, you can adopt a similar strategy. The goal is not to confirm that the htmlwidget‚Äôs render function is behaving properly, but rather that the data that you intend to render is indeed getting passed through.\nWe could modify the above example to better represent this approach.\nserver &lt;- function(input, output, session){\n  # Move any complex logic into a separate reactive which can be tested comprehensively\n  plotData &lt;- reactive({\n    data.frame(length = iris$Petal.Length, width = iris$Petal.Width)\n  })\n\n  # And leave the `render` function to be as simple as possible to lessen the\n  # need for integration tests.\n  output$plot &lt;- renderPlot({\n    plot(plotData())\n  })\n}\n\ntestServer(server, {\n  # Confirm that the data reactive is behaving as expected\n  expect_equal(nrow(plotData()), 150)\n  expect_equal(ncol(plotData()), 2)\n  expect_equal(colnames(plotData()), c(\"length\", \"width\"))\n\n  # And now the plot function is so simple that there's not much need for\n  # automated testing. If we did wish to evaluate the plot visually, we could\n  # do so using the shinytest package.\n  output$plot # Just confirming that the plot can be accessed without an error\n})\nYou could adopt a similar strategy with other plots or htmlwidgets: move the complexity into reactives that can be tested, and leave the render functions as simple as possible.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Testing",
      "Server function testing"
    ]
  },
  {
    "objectID": "r/articles/improve/server-function-testing/index.html#flushing-reactives",
    "href": "r/articles/improve/server-function-testing/index.html#flushing-reactives",
    "title": "Server function testing",
    "section": "Flushing Reactives",
    "text": "Flushing Reactives\nReactive programming differs from imperative programming in that the processing required to update reactives can be deferred and batched together. While this is a boon for the computational speed of a reactive system, it does create some ambiguity about when the reactives should be processed or ‚Äúflushed‚Äù.\ntestServer will do its best to automatically flush the reactives at the right time. There are two triggers that will cause a reactive flush:\n\nCalling session$setInputs() - After setting the updated inputs, the reactives will be flushed.\nCalling session$elapse() - After the scheduled callbacks are executed, reactives will be flushed.\n\nHowever, there may be other times that you might want to trigger a reactive flush. For instance, you might want to flush the reactives after updating an element in a reactiveValues like this one:\nserver &lt;- function(input, output, session){\n  rv &lt;- reactiveValues(a = 1)\n  output$txt &lt;- renderText({\n    rv$a\n  })\n}\n\ntestServer(server, {\n  expect_equal(output$txt, \"1\")\n\n  rv$a &lt;- 2\n\n  # testServer has no innate knowledge of our `rv` variable;\n  # therefore, it hasn't been updated\n  expect_equal(output$txt, \"1\")\n\n  # We'll need to manually force a flush of the reactives\n  session$flushReact()\n\n  expect_equal(output$txt, \"2\")\n})\nAs you can see, we can use session$flushReact() to trigger a reactive flush at any point we‚Äôd like. In this example, testServer knows nothing about our rv variable. Therefore if we want to observe reactive changes that occur after manually updating this variable, we‚Äôd need to explicitly flush the reactives.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Testing",
      "Server function testing"
    ]
  },
  {
    "objectID": "r/articles/improve/scaling-and-tuning/index.html",
    "href": "r/articles/improve/scaling-and-tuning/index.html",
    "title": "Scaling and Performance Tuning with shinyapps.io",
    "section": "",
    "text": "R is a single threaded application which means that a Shiny application cannot serve two different users at precisely the same time. This is not an issue in most cases because most computations only take tens or hundreds of milliseconds. As a result, a single R process can usually serve 5 to 30 requests/second. However, as your applications get more complex, requiring more time to service a single request, and as more users interact with the application simultaneously, you may find that the user experience for your applications does not meet your expectations.",
    "crumbs": [
      "Improve",
      "Scale",
      "Tuning",
      "Scaling and Performance Tuning with shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/improve/scaling-and-tuning/index.html#fine-tuning-your-shiny-apps-performance",
    "href": "r/articles/improve/scaling-and-tuning/index.html#fine-tuning-your-shiny-apps-performance",
    "title": "Scaling and Performance Tuning with shinyapps.io",
    "section": "Fine-Tuning Your Shiny apps Performance",
    "text": "Fine-Tuning Your Shiny apps Performance\nShinyapps.io lets you optimize the performance of your apps with several tuning parameters. To see your current settings go to the Settings page for any application. The default settings have been chosen to address the needs of most applications.",
    "crumbs": [
      "Improve",
      "Scale",
      "Tuning",
      "Scaling and Performance Tuning with shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/improve/scaling-and-tuning/index.html#key-concepts-and-terms",
    "href": "r/articles/improve/scaling-and-tuning/index.html#key-concepts-and-terms",
    "title": "Scaling and Performance Tuning with shinyapps.io",
    "section": "Key concepts and terms",
    "text": "Key concepts and terms\nThere are several ideas that are important when considering the various tuning options that are available.\n\nApplication\nApplication Instance\nWorker\nBrowser Connection\n\nThe diagram below shows how these ideas relate to each other.\n\n\nApplication\nAn application is a combination of files that you upload to shinyapps.io. These files must include a ui.R file and a server.R file, and can also include data files.\nA running application will have at least one Application Instance. You can add additional instances if the application is hosted on a paid tier.\n\n\nApplication Instance\nAn Application Instance is a single server that responds to requests from end users. Shinyapps.io will start at least one Application Instance when a user first visits your application, and shinyapps.io will shut down this instance (or these instances) when the application is idle.\nEach Application Instance will run one or more R Workers to fulfill user requests.\n\n\nWorker\nA worker is a special type of R process that an Application Instance runs to service requests to an application. Each Application Instance can run multiple workers. Each worker process is capable of servicing multiple end users depending on the configuration and performance requirements of the application. If there are no processes available to handle a new request, the Application Instance will start a new worker process.\n\n\nBrowser Connection\nA browser connection is a connection between a user‚Äôs web browser and a worker serving your application.\nA user creates a browser connection when they first send a request to your application through their web browser, or when they refresh their browser after it has gone idle. Shinyapps.io assigns each new browser connection to a worker. The worker responds by creating a session for the browser connection to use.",
    "crumbs": [
      "Improve",
      "Scale",
      "Tuning",
      "Scaling and Performance Tuning with shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/improve/scaling-and-tuning/index.html#tuning-parameters",
    "href": "r/articles/improve/scaling-and-tuning/index.html#tuning-parameters",
    "title": "Scaling and Performance Tuning with shinyapps.io",
    "section": "Tuning parameters",
    "text": "Tuning parameters\nThe architecture described above uses two load factors to fine tune the performance of your applications.\n\nWorker Load Factor - The threshold percentage after which a new browser connection will trigger the addition of a new worker.\nInstance Load Factor - The threshold percentage after which a new connection will trigger the addition of a new Application Instance (limited to the maximum instance limit, free tier is 1)\n\nEach load factor is based on the idea of a threshold percentage, which is the percentage of available connections or processes that are allowed to open before shinyapps.io launches another worker or Application Instance. Both settings are configurable in the Advanced tab within the Settings page for a given application.\nYou can also use the Settings page to change:\n\nthe size of your Application Instances\nthe maximum number of workers per Application Instance\nthe maximum number of connections per worker\nthe amount of time at which an instance or connection goes idle.\n\nEach of these changes will further fine tune the performance of your application.",
    "crumbs": [
      "Improve",
      "Scale",
      "Tuning",
      "Scaling and Performance Tuning with shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/improve/scaling-and-tuning/index.html#lifecycle-of-an-application",
    "href": "r/articles/improve/scaling-and-tuning/index.html#lifecycle-of-an-application",
    "title": "Scaling and Performance Tuning with shinyapps.io",
    "section": "Lifecycle of an Application",
    "text": "Lifecycle of an Application\nThe diagram below shows how shinyapps.io handles user requests throughout the life cycle of an application.\n\n\nPublisher creates a new application and deploys it to shinyapps.io at https://www.shinyapps.io/\nA request from an end user triggers the start of an Application Instance\nApplication Instance will start with at least one worker\nThe number of connections to the worker increases as additional end users visit the application. When the Worker Load Factor threshold is exceeded, shinyapps.io adds another worker, so long as the max number of workers per Application Instance has not been reached. New connections are now assigned to the new worker.\nNew workers are added when needed as new users continue to visit the application. When the Instance Load factor is exceeded, shinyapps.io will trigger the addition of another Application Instance, so long as the max number of Application Instances has not been reached (the max number may be one).\n\nShinyapps.io closes connections as end users close their browsers or are idle for longer than the Idle Timeout.\nShinyapps.io shuts down each worker once it has no further connections open.\n\nShinyapps.io turns off each Application Instance once it has no running workers, or once its workers are idle for longer than the Instance Idle Timeout. This threshold timeout should be increased if you would like to avoid restarting the application. Note: Increasing the timeout will use up more active hours.\nA new request from an end user causes shinyapps.io to turn on an Application Instance, and stages 2-9 repeat.",
    "crumbs": [
      "Improve",
      "Scale",
      "Tuning",
      "Scaling and Performance Tuning with shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/improve/scaling-and-tuning/index.html#examples",
    "href": "r/articles/improve/scaling-and-tuning/index.html#examples",
    "title": "Scaling and Performance Tuning with shinyapps.io",
    "section": "Examples:",
    "text": "Examples:\nAssuming the following settings:\nInstance Load Factor (default is 50%)\nWorker Load Factor (default is 5%)\nMax worker processes (default is 3)\nMax # of concurrent connections supported per worker (default is 50)\nDetermining when another worker would be started:\nMax # of Concurrent connections per worker * Worker Load Factor\n50 * 5% = 2.5 (meaning the 3rd Browser Connection would add another worker up to the Max worker processes)\nDetermining when another Application Instance would be started:\nMax # of connections per worker * Max worker processes * Instance Load Factor\n50 * 3 * 50% = 75 (meaning the 76th connection would cause an additional instance to be started)",
    "crumbs": [
      "Improve",
      "Scale",
      "Tuning",
      "Scaling and Performance Tuning with shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/improve/scaling-and-tuning/index.html#troubleshooting",
    "href": "r/articles/improve/scaling-and-tuning/index.html#troubleshooting",
    "title": "Scaling and Performance Tuning with shinyapps.io",
    "section": "Troubleshooting",
    "text": "Troubleshooting\nWhen should you worry about tuning your applications? You should consider tuning your applications if:\n\nYour application has several requests that are slow and you have enough concurrent usage that people‚Äôs expectations for responsiveness aren‚Äôt being met. For example, If your response time for some key calculations takes one second and you would like to make sure that the average response time for your application is less than two seconds, you will not want more than two concurrent requests per worker.\n\nPossible Diagnosis: The application performance might be due to R‚Äôs single threaded nature. Spreading the load across additional workers should alleviate the issue.\n\nRemedy: Consider lowering the maximum number of connections per worker, and possibly increasing the maximum number of workers. Also consider adding additional Application Instances and aggressively scaling them by tweaking the Instance Load Factor to a lower percentage.\n\nSudden large spikes of traffic have poor performance even though you have configured multiple Application Instances. However, additional new users have good performance.\n\nPossible Diagnosis: The number of workers within the first container are insufficient for the initial spike of traffic. When the additional containers are started, new users are routed to the new Application Instance.\n\nRemedy: Decrease the Instance Load Factor which will aggressively start up additional Application Instances and spread the load.\n\nYour application suddenly goes grey and you see in your logs that the application was ‚Äúkilled‚Äù.\n\nPossible Diagnosis: Each Application Instance has a size which corresponds to the amount of RAM (memory) that is allocated to it. If the amount of memory allocated to this application is exceeded, then the Application Instance could be shut down by shinyapps.\n\nRemedy: There are two possible solutions:\n\nIncrease the size of the Application Instance.\n\nDecrease the number of workers per Application Instance. Since each worker takes up additional RAM, you may find that lowering the ‚ÄúMax worker processes‚Äù to two or one would help keep each Application Instance‚Äôs memory usage down.\n\n\nAn application isn‚Äôt fitting in memory even for the largest Application Instance size\n\nPossible Diagnosis: If the application loads correctly with one or two users interacting with it, then it is possible that your data set sizes on a per worker basis are too big.\n\nRemedy: Decrease the number of workers per Application Instance.\n\nYour application stops accepting additional users beyond 150 connections.\n\nPossible Diagnosis: It is likely that you have reached the limit on the number of connections that can be served by the default settings in an Application Instance.\n\nRemedy: A few things to try would be:\n\nIncrease the allowed connections per worker by changing Connections setting for the application.\nIncrease the number of workers per Application Instance.\nAdd additional Application Instances.\n\n\nAn application that has a significant initialization time (loading lots of data, or talking to 3rd party web services) sometimes doesn‚Äôt load.\n\nPossible diagnosis: Shinyapps.io has an ‚ÄúInstance Startup Timeout‚Äù which will stop an application if it is not responsive within that period of time at startup.\n\nRemedy: Increase the timeout on the Application Settings page.",
    "crumbs": [
      "Improve",
      "Scale",
      "Tuning",
      "Scaling and Performance Tuning with shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/improve/sanitize-errors/index.html",
    "href": "r/articles/improve/sanitize-errors/index.html",
    "title": "Sanitizing error messages",
    "section": "",
    "text": "Basic Usage\nWith the release of Shiny 0.14, you now have the option to sanitize error messages. This can be important if there is information in the original error message that you don‚Äôt want the user to see (usually because it may be sensitive information). To sanitize errors everywhere in your app, just add options(shiny.sanitize.errors = TRUE) somewhere in your app. Then, all error messages will be replaced with the following generic error message (the only exception are errors wrapped in the new safeError() function ‚Äì see details in the next section):\n\nError: An error has occurred. Check your logs or contact the app author for clarification.\n\nBy default, this option is FALSE, which means that errors won‚Äôt be sanitized and the user will see the original message. If you‚Äôre not worried about security, this has the advantage of potentially making debugging a lot easier for your users.\nThe next section goes over safeError() and how to exert finer control over your error messages. It may be easier, however, to check out this demo app, which covers the same material in an interactive way.\n\n\nA finer level of control\nError sanitization applies to all errors generated within your app: both the ones you yourself produce using stop(), and the ones produced by code you rely on (although, ultimately, some code somewhere will have had to use a stop() or a similar function for an error to occur). In the latter case, error sanitization may prove to be particularly useful because errors are sanitized even in instances for which you did not foresee any problems. If something weird happens (like your user entering a strange input or some bug from an update), you can rest assured that no sensitive information will ever be leaked through error messages.\nBut this raises the question: what if there are some errors that you don‚Äôt want to sanitize? In general, you might want to suppress error messages because of security concerns, but for a couple of cases, you might not be worried about that and might actually want to let the user know what went wrong. In that situation, still have options(shiny.sanitize.errors = TRUE), and, in the few cases when you want the user to see the error message use stop(safeError(e)) instead of stop(e). In here, e can either be an object with the ‚Äúerror‚Äù class or a string (in which case it will become the resulting error‚Äôs message). The safeError() function basically lets Shiny know that this is a safe error for the user to see and that it doesn‚Äôt need to be sanitized.\nYou can also use safeError() to show an error that does not originate in your own code, but in code you rely on. However, unlike the reverse situation (in which you want to sanitize these types of errors), you do need to have an idea of where an error might occur. This has to be so because you‚Äôll first need to catch the error using tryCatch() (or something to the same effect). Inside this function, you can then wrap the error in safeError() and rethrow it.\n\n\nOther errors\nThis error suppression mechanism also applies to less common errors. For example, if you have a syntax error in your ui.R; or if your downloadHandler() function has a bug. Because these errors do not go through the websockets set up by Shiny, they are handled differently (they open up a new window that just displays the error message). Still, for our purposes, you can sanitize them in the exact same way as before. You can also use safeError().",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Sanitizing error messages"
    ]
  },
  {
    "objectID": "r/articles/improve/reconnecting/index.html",
    "href": "r/articles/improve/reconnecting/index.html",
    "title": "Reconnecting to Shiny apps",
    "section": "",
    "text": "In the past, users of Shiny applications would get disconnected from the server and see the browser window ‚Äúgray out‚Äù if the network connection was interrupted, even if it was just briefly. This could frustrate and confuse users, and it could lead to the impression that the application was unstable, when in fact the problem was the network connection.\nTo improve the user experience, we‚Äôve made changes in Shiny Server (Pro and Open Source) 1.4.7, Posit Connect 1.5.10, and in Shiny 0.14 to allow a Shiny client to seamlessly reconnect to the server even when there is disruption of network service.\nIn the normal course of running a Shiny application, the user‚Äôs client web browser maintains a connection to the server running R. In prior versions of Shiny and Shiny Server, if the connection between the client and server is lost, then the client browser will ‚Äúgray out‚Äù and the server will close the server session.\nThere are now two ways that the client browser can reconnect to a session on the server: it can reconnect to the existing session, or it can reconnect to a new session. To understand how these two kinds of reconnections differ from each other and from simply reloading the page in the browser, keep in mind that a running application has two parts that contain some state: the client web browser, and the server running R.\nIf you reload a shiny application by clicking on your browser‚Äôs Reload button, it will start a new session on both the client and the server, losing the state on both sides. With an existing-session reconnection, it will keep the existing session on both the client and server. With a new-session reconnection, it will keep the existing session on the client, and start a new session on the server.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Reconnecting to Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/improve/reconnecting/index.html#reconnecting-to-existing-sessions",
    "href": "r/articles/improve/reconnecting/index.html#reconnecting-to-existing-sessions",
    "title": "Reconnecting to Shiny apps",
    "section": "Reconnecting to existing sessions",
    "text": "Reconnecting to existing sessions\nTo reconnect to an existing session, Shiny Server (Pro or Open Source) 1.4.7+ or Posit Connect 1.4.6+ must be used. This kind of reconnection is enabled by default ‚Äì all you need to do is update Shiny Server or Posit Connect. No modification of the application is needed. When an existing-session reconnection happens, it will be as though nothing happened except for a temporary pause in communication.\n\nTechnical details\nHere‚Äôs how existing-session reconnections work:\n\nWhen the server detects that the connection has been lost, it keeps the session running for 15 more seconds.\nWhen the client detects that the connection has been lost, it will try to reconnect to the server for 15 seconds.\nIf the client successfully reconnects in those 15 seconds that the server keeps the session alive, then the application will continue running as though nothing happened. Any updates that still need to be sent to the server will be sent sequentially; if you update a slider twice while they are disconnected, then after the reconnect, both of the slider values will be sent to the server, one after another.\nIf the client fails to reconnect within 15 seconds, then the server will close the session, and, on the client side, the application will gray out and display a box with a button labeled ‚ÄúReload‚Äù.\nIf the ‚ÄúReload‚Äù button is clicked, the browser will try to reload the page.\n\nThis kind of reconnection smooths over occasional connectivity problems, and users may not even notice that it is occurring.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Reconnecting to Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/improve/reconnecting/index.html#reconnecting-to-new-sessions",
    "href": "r/articles/improve/reconnecting/index.html#reconnecting-to-new-sessions",
    "title": "Reconnecting to Shiny apps",
    "section": "Reconnecting to new sessions",
    "text": "Reconnecting to new sessions\nTo reconnect to a new session, it requires Shiny 0.14 (or higher), as well as Shiny Server 1.4.7+ or Posit Connect 1.5.10+. This behavior is opt-in on a per-application basis, because it is suitable for some applications, but not all. After the client has disconnected from the server (and has reached a gray-out state), it will try to reconnect to the server. If it successfully reaches the server, a new session will be started on the server, and the client will send the current state of the inputs to the server.\nAn example use case is a dashboard: imagine that you have a dashboard that you want to keep open on a laptop computer, even after that laptop is put to sleep. Every time the laptop wakes up, it will reconnect to server and display updated data for the dashboard.\nFor your application to work with this kind of reconnection, the state of the inputs must fully determine the state of the outputs. This kind of reconnection will not work for applications that store intermediate state on the server and require, for example, inputs to occur in a particular sequence in order to reach the desired output state. Here are some things that will cause problems for this type of reconnection:\n\nThe server function stores some values in a reactiveValues object, or in other variables that are not part of a standard reactive flow. An example: a variable that counts the number of times an actionButton is pressed.\nThe user uploads a file to a fileInput().\nThe application generates random values (with rnorm(), runif(), or similar).\n\nTo enable new-session reconnections, put session$allowReconnect(TRUE) somewhere in the server function. For example:\nshinyApp(\n  ui = fluidPage(sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"bins\", \"Number of bins:\", min = 1, max = 75, value = 30)\n    ),\n    mainPanel(\n      plotOutput(\"distPlot\")\n    )\n  )),\n  server = function(input, output, session) {\n    output$distPlot &lt;- renderPlot({\n      hist(faithful$eruptions, breaks = input$bins)\n    })\n\n    # Set this to \"force\" instead of TRUE for testing locally (without Shiny Server)\n    session$allowReconnect(TRUE)\n  }\n)\nIf you‚Äôd like to try this out in a local development environment (without Shiny Server or Connect), you can use session$allowReconnect(\"force\") in the server function. If you are running inside of RStudio, you will also need to use options(shiny.launch.browser=FALSE), and use a separate web browser to visit the app. Start up your app, visit it with the web browser, and then stop the app in R, and the client should gray out. If you restart the app in R, then the client should automatically reconnect.\n\nTechnical details\nHere‚Äôs how new-session reconnections work:\n\nThe client detects that it has disconnected from the server and ‚Äúgrays out‚Äù. (If the server supports existing-session reconnections, this is what happens after it tries and fails to make that type of reconnection.)\nAt this point the server will have closed the session on its side.\nThe client displays a box that says ‚ÄúAttempting to reconnect‚Ä¶‚Äù and attempts to connect to a new session on the server.\nIf the connection is successful, the client sends all of its current input values to the server, and then the server sends the output values to the client.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Reconnecting to Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/improve/plot-caching/index.html",
    "href": "r/articles/improve/plot-caching/index.html",
    "title": "Plot Caching",
    "section": "",
    "text": "Creating plots in a Shiny application can take anywhere from a fraction of a second to multiple seconds. If there are multiple plots in an application they can be a significant source of perceived slowness. Improving the responsiveness of plots can greatly improve users‚Äô experience of your application.\nThere are multiple ways you can improve the performance of your plots. For example, you could consider using R‚Äôs base graphics instead of a plotting package, using JavaScript graphics that render on the client instead of static plots that render on the server, or you could change the type of plot, e.g.¬†switching from ggplot2::geom_point to ggplot2::geom_hex. However, there are cases where you might want to keep using the plotting code you already have.\nAs of Shiny 1.2.0, it is possible to cache plots with renderCachedPlot(). Plot caching can significantly improve the performance of your Shiny application with minimal code changes. Plot caching works by storing rendered plots in a cache so that, if the same plot is requested again, it can be drawn from the cache almost instantly. By default, the cache is shared among multiple users of an application. The more users your application has, the more performance benefits you‚Äôll see from caching!",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Plot Caching"
    ]
  },
  {
    "objectID": "r/articles/improve/plot-caching/index.html#using-cached-plots",
    "href": "r/articles/improve/plot-caching/index.html#using-cached-plots",
    "title": "Plot Caching",
    "section": "Using cached plots",
    "text": "Using cached plots\nUsage is simple: in the most basic form, simply replace your renderPlot() with renderCachedPlot(), and add a cache key expression argument. For example, your server function might look like this:\nfunction(input, output) {\n  renderCachedPlot(\n    {\n      rownums &lt;- seq_len(input$n)\n      plot(cars$speed[rownums], cars$dist[rownums])\n    },\n    cacheKeyExpr = { input$n }\n  )\n}\nIn this case, the first time a particular of value input$n is seen, Shiny will render the plot and store it in the cache. If it changes to another value and then back again, instead of re-executing the plotting code, it will simply get the saved plot from the cache.\n\n\nClick here to see full app code\n\nlibrary(shiny)\nshinyApp(\n  fluidPage(\n    sidebarLayout(\n      sidebarPanel(\n        sliderInput(\"n\", \"Number of points\", 4, 32, value = 8, step = 4)\n      ),\n      mainPanel(plotOutput(\"plot\"))\n    )\n  ),\n  function(input, output, session) {\n    output$plot &lt;- renderCachedPlot(\n      {\n        Sys.sleep(2)  # Add an artificial delay\n        rownums &lt;- seq_len(input$n)\n        plot(cars$speed[rownums], cars$dist[rownums],\n            xlim = range(cars$speed), ylim = range(cars$dist))\n      },\n      cacheKeyExpr = {input$n }\n    )\n  }\n)\n\nYou can see the application in action below (or here).\n\n\nIn this example, there are two expressions given to renderCachedPlot(). The first expression contains the code that generates a plot. Unlike the plotting expression that‚Äôs used in a regular renderPlot(), this expression does not take any reactive dependencies ‚Äì it will not, by itself, automatically re-execute. That‚Äôs where the second expression comes in. You can, of course, reference user inputs in this expression, it is only the affect on the reactive dependency graph that is different.\nThe second expression, cacheKeyExpr, serves two purposes. The first is that it sets up reactive dependencies: whenever any reactive expressions or reactive values in that expression change, it causes the plotting expression to re-execute ‚Äì with a big exception, which we‚Äôll see soon. (If you‚Äôve used eventReactive() or observeEvent(), this is similar the eventExpr that they have.) In technical terms, when cacheKeyExpr is invalidated, it causes the plotting expression to re-execute.\nThe other use of cacheKeyExpr is, not surprisingly, for caching. When the plot expression is executed, the resulting plot is stored in a cache, using the result from cacheKeyExpr as the cache key. (Techincal note: the value from cacheKeyExpr is actually serialized and then hashed, and the resulting hash value is used as the key.) Whenever the cacheKeyExpr is invalidated and re-executed, Shiny looks first looks in the cache to see if there‚Äôs a previously-saved plot. If there is, then the saved plot is sent to the client web browser, and the plotting expression does not need to re-execute. If there is not, then it re-executes the plotting expression, caches the resulting plot, and sends it to the browser.\n\nThe cache key expression\nIn the example above, the cache key expression only contains one thing, input$n. It can, however, contain multiple values, if you simply combine them in a list. For example, in addition to user input values that can change, you may have a data set that can change. The cacheKeyExpr might look like this:\n  output$plot &lt;- renderCachedPlot(\n    {\n      # Plotting code here...\n    },\n    cacheKeyExpr = { list(input$n, dataset()) }\n  )\n\n\nClick here to see full app\n\nlibrary(shiny)\ndataset &lt;- reactiveVal(data.frame(x = rnorm(400), y = rnorm(400)))\n\nui &lt;- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"n\", \"Number of points to display\", 50, 400, 100, step = 50),\n      actionButton(\"newdata\", \"Generate new data\")\n    ),\n    mainPanel(\n      plotOutput(\"plot\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  # When the newdata button is clicked, change the data set to new random data\n  observeEvent(input$newdata, {\n    dataset(data.frame(x = rnorm(400), y = rnorm(400)))\n  })\n\n  output$plot &lt;- renderCachedPlot(\n    {\n      Sys.sleep(2)     # Add an artificial delay\n      d &lt;- dataset()\n      rownums &lt;- seq_len(input$n)\n      plot(d$x[rownums], d$y[rownums], xlim = range(d$x), ylim = range(d$y))\n    },\n    cacheKeyExpr = {\n      list(input$n, dataset())\n    }\n  )\n}\n\nshinyApp(ui, server)\n\nYou can see the application in action below (or here).\n\n\n\n\nPlot sizing\nSizing for cached plots works a bit differently from regular plots: with regular plots, the plot is rendered to exactly fit the div on the web page; with cached plots, the plot is rendered to a close-fitting size, and scaled to fit the div on the web page.\nWith renderPlot(), the plot is rendered at exactly the dimensions of the div containing the image in the browser. If the div is 500 pixels wide and 400 pixels tall, then it will create a plot that is exactly 500√ó400 pixels. If you resize the window, and the div then becomes 550x400 pixels (typically the width is variable, but the height is fixed), then Shiny will render another plot that is 550x400, which can take some time.\nWith renderCachedPlot(), the plot is not rendered to be an exact fit. There are a number of possible sizes, and Shiny will render the plot to be the closest size that is larger than the div on the web page, and cache it. For example, possible widths include 400, 480, 576, 691, and so on, both smaller and larger; each width is 20% larger than the previous one. Heights work the same way.\nIf the width of the div is 450 pixels, then Shiny will render a plot that is 480 pixels wide and scale it down to fit the 450 pixel wide div. If the div is then resized to 500 pixels, then Shiny will render a plot that is 576 pixels wide.\nThe reason that renderCachedPlot() works this way is so that it doesn‚Äôt have to cache a plot of every possible size; doing that would greatly reduce the usefuless of caching, since each browser would likely have a slightly different width, and so there would be very few cache hits.\nThis behavior is controlled by the sizePolicy parameter ‚Äì it is a function that takes two numbers (the actual dimensions of the div) and returns two numbers (the dimensions of the plot that will be rendered). If you want to use a different strategy, you can pass in a different function.",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Plot Caching"
    ]
  },
  {
    "objectID": "r/articles/improve/modules/index.html",
    "href": "r/articles/improve/modules/index.html",
    "title": "Modularizing Shiny app code",
    "section": "",
    "text": "As Shiny applications grow larger and more complicated, we use modules to manage the growing complexity of Shiny application code.\nFunctions are the fundamental unit of abstraction in R, and we designed Shiny to work with them. You can write UI-generating functions and call them from your app, and you can write functions to be used in the server function that define outputs and create reactive expressions.\nIn practice, though, functions alone don‚Äôt address the problem of organising and managing large and complex app code completely. Input and output IDs in Shiny apps share a global namespace, meaning, each ID must be unique across the entire app. If you‚Äôre using functions to generate UI, and those functions generate inputs and outputs, then you need to ensure that none of the IDs collide.\nIn computer science, the traditional solution to the problem of name collisions is namespaces. As long as names are unique within a namespace, and no two namespaces have the same name, then each namespace/name combination is guaranteed to be unique. Many systems will let you nest namespaces, so a namespace doesn‚Äôt need a name that‚Äôs globally unique, just unique within its parent namespace.\nShiny modules address the namespacing problem in Shiny UI and server logic, adding a level of abstraction beyond functions.\nNote: Prior to Shiny 1.5.0, we recommended using callModule() to invoke modules. From 1.5.0 onward, we recommend using moduleServer() instead, because it has simpler syntax for using the module. Additionally, new-style modules can be tested with the testServer() function, also introduced in Shiny 1.5.0. If you would like to see how to migrate from old to new-style modules and see how they compare, see the Migrating from callModule to moduleServer section, below.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Modules",
      "Modularizing Shiny app code"
    ]
  },
  {
    "objectID": "r/articles/improve/modules/index.html#a-simple-module",
    "href": "r/articles/improve/modules/index.html#a-simple-module",
    "title": "Modularizing Shiny app code",
    "section": "A Simple Module",
    "text": "A Simple Module\nHere‚Äôs a small application demonstrating a simple ‚Äúcounter‚Äù module:\nlibrary(shiny)\n\ncounterButton &lt;- function(id, label = \"Counter\") {\n  ns &lt;- NS(id)\n  tagList(\n    actionButton(ns(\"button\"), label = label),\n    verbatimTextOutput(ns(\"out\"))\n  )\n}\n\ncounterServer &lt;- function(id) {\n  moduleServer(\n    id,\n    function(input, output, session) {\n      count &lt;- reactiveVal(0)\n      observeEvent(input$button, {\n        count(count() + 1)\n      })\n      output$out &lt;- renderText({\n        count()\n      })\n      count\n    }\n  )\n}\n\nui &lt;- fluidPage(\n  counterButton(\"counter1\", \"Counter #1\")\n)\n\nserver &lt;- function(input, output, session) {\n  counterServer(\"counter1\")\n}\n\nshinyApp(ui, server)\n\nNS() is used within counterButton() to encapsulate the module‚Äôs UI.\ncounterServer() is a function which calls moduleServer().\nThe call to moduleServer() is passed the id, as well as a module function.\nIn this particular example, the module function returns a reactive value, but it could return any value.\nInside of the applications server function, counterServer() is called to initialize the module.\n\nIf that all makes sense to you, great! Otherwise, read on for more details.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Modules",
      "Modularizing Shiny app code"
    ]
  },
  {
    "objectID": "r/articles/improve/modules/index.html#introducing-shiny-modules",
    "href": "r/articles/improve/modules/index.html#introducing-shiny-modules",
    "title": "Modularizing Shiny app code",
    "section": "Introducing Shiny Modules",
    "text": "Introducing Shiny Modules\nA Shiny module is a piece of a Shiny app. It can‚Äôt be directly run, as a Shiny app can. Instead, it is included as part of a larger app (or as part of a larger Shiny module ‚Äì they are composable).\nModules can represent input, output, or both. They can be as simple as a single output, or as complicated as a multi-tabbed interface festooned with controls/outputs driven by multiple reactive expressions and observers.\nOnce created, a Shiny module can be easily reused ‚Äì whether across different apps, or multiple times in a single app (like a set of controls that needs to appear on multiple tabs of a complex app). One possible motivation for building modules is to bundle them into R packages to be used by other Shiny authors. Another possible motivation is to break up a complicated Shiny app into separate modules that can each be reasoned about independently; such modules likely have no potential for reuse but they serve an important purpose within an app.\n\nCreating Shiny Modules\nA module is composed of two functions that represent 1) a piece of UI, and 2) a fragment of server logic that uses that UI ‚Äì similar to the way that Shiny apps are split into UI and server logic.\nIndeed, the contents of your UI and server functions will look a lot like normal Shiny UI/server logic. But the packaging needs to differ in a few important ways.\n\n\nCreating UI\nA module‚Äôs UI function should be given a name that is suffixed with Input, Output, or UI; for example, csvFileUI, zoomableChoroplethOutput, or tabOneUI.\nThe first argument to a UI function should always be id. This is the namespace for the module. (Note that the namespace for the module is decided by the caller at the time the module is used. This will make more sense later, when we talk about how modules are invoked.)\nHere‚Äôs an example for a CSV file input module:\n# Module UI function\ncsvFileUI &lt;- function(id, label = \"CSV file\") {\n  # `NS(id)` returns a namespace function, which was save as `ns` and will\n  # invoke later.\n  ns &lt;- NS(id)\n\n  tagList(\n    fileInput(ns(\"file\"), label),\n    checkboxInput(ns(\"heading\"), \"Has heading\"),\n    selectInput(ns(\"quote\"), \"Quote\", c(\n      \"None\" = \"\",\n      \"Double quote\" = \"\\\"\",\n      \"Single quote\" = \"'\"\n    ))\n  )\n}\nThe body of this function looks quite similar to the UI code for a Shiny app. The main differences are:\n\nThe function body starts with the statement ns &lt;- NS(id). All UI function bodies should start with this line. It takes the string id and creates a namespace function.\nAll input and output IDs that appear in the function body needs to be wrapped in a call to ns(). This example shows inputId arguments being wrapped in ns(), e.g.¬†ns(\"file\")). If we happened to have a plotOutput in our UI, we would also want to use ns() when declaring its outputId or brush ID, for example.\nThe results are wrapped in tagList, instead of fluidPage, pageWithSidebar, etc. You only need to use tagList if you want to return a UI fragment that consists of multiple UI objects; if you were just returning a div or a single input, you could skip tagList.\n\nAdmittedly, the ns() mechanism isn‚Äôt very elegant, but what it buys us makes it worth it. Thanks to the namespacing, we only need to make sure that the IDs \"file\", \"heading\", and \"quote\" are unique within this function, rather than unique across the entire app.\n\n\nWriting server functions\nNow that we‚Äôve got some UI, we can turn our attention to the server logic. The server logic is encapsulated in a single function that we‚Äôll call the module server function.\nModule server functions should be named like their corresponding module UI functions, but with a server suffix instead of a Input/Output/UI suffix. Since our UI function was called csvFileUI, we‚Äôll call our server function csvFileServer.\nInside of csvFileServer, there is a call to moduleServer(), to which two things are passed. One is the id, and the second is the module function:\n# Module server function\ncsvFileServer &lt;- function(id, stringsAsFactors) {\n  moduleServer(\n    id,\n    ## Below is the module function\n    function(input, output, session) {\n      # The selected file, if any\n      userFile &lt;- reactive({\n        # If no file is selected, don't do anything\n        validate(need(input$file, message = FALSE))\n        input$file\n      })\n\n      # The user's data, parsed into a data frame\n      dataframe &lt;- reactive({\n        read.csv(userFile()$datapath,\n          header = input$heading,\n          quote = input$quote,\n          stringsAsFactors = stringsAsFactors)\n      })\n\n      # We can run observers in here if we want to\n      observe({\n        msg &lt;- sprintf(\"File %s was uploaded\", userFile()$name)\n        cat(msg, \"\\n\")\n      })\n\n      # Return the reactive that yields the data frame\n      return(dataframe)\n    }\n  )    \n}\nThe outer function, csvFileServer(), takes id as its first parameter. You can define the function so that it takes any number of additional parameters, including ..., so that whoever uses the module can customize what the module does. In this case, there‚Äôs one extra parameter, stringsAsFactors, so the application that uses this module can decide whether or not to convert strings to factors when reading in the data.\nInside of csvFileServer() is a call to the moduleServer() function. This function is passed the id variable, as well as the module function. You may notice a lot of similarities between the module function and a regular Shiny server function. Its three parameters ‚Äì input, output, and session ‚Äì should be familiar: every module function must take those three parameters. The moduleServer() function invokes the module function in a special way that creates special input, output, and session objects that are aware of the id.\nInside of the module function, it can use parameters from the outside function. In this example, this outside function is csvFileServer(), and its stringsAsFactors parameter is used inside the module function. You can have as many or as few additional parameters as you want, including ... if it makes sense, and you can use them for whatever you want inside the function body.\nInside the module function, we can use input$file to refer to the ns(\"file\") component in the UI function. If this example had outputs, we could similarly match up ns(\"plot\") with output$plot, for example. The input, output, and session objects we‚Äôre provided with are special, in that they use the id to scope them to the specific namespace that matches up with our UI function.\nOn the flip side, the input, output, and session cannot be used to access inputs/outputs that are outside of the namespace, nor can they directly access reactive expressions and reactive values from elsewhere in the application.\nThese restrictions are by design, and they are important. The goal is not to prevent modules from interacting with their containing apps, but rather, to make these interactions explicit. If a module needs to use a reactive expression, the outer function should take the reactive expression as a parameter. If a module wants to return reactive expressions to the calling app, then return a list of reactive expressions from the function.\nIf a module needs to access an input that isn‚Äôt part of the module, the containing app should pass the input value wrapped in a reactive expression (i.e.¬†reactive(...)):\n  myModule(\"myModule1\", reactive(input$checkbox1))\n\n\nUsing modules\nAssuming the above csvFileUI and csvFileServer functions are loaded (more on that in a moment), this is how you‚Äôd use them in a Shiny app:\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      csvFileUI(\"datafile\", \"User data (.csv format)\")\n    ),\n    mainPanel(\n      dataTableOutput(\"table\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  datafile &lt;- csvFileServer(\"datafile\", stringsAsFactors = FALSE)\n\n  output$table &lt;- renderDataTable({\n    datafile()\n  })\n}\n\nshinyApp(ui, server)\nThe UI function csvFileUI is called directly, using \"datafile\" as the id. In this case, we‚Äôre inserting the generated UI into the sidebar.\nThe module server function is called with csvFileServer(), with the id that we will use as the namespace; this must be exactly the same as the id argument we passed to csvFileUI. The call to the module server function also is passed the parameter stringsAsFactors = FALSE.\nLike all Shiny modules, csvFileUI can be embedded in a single app more than once. Each call must be passed a unique id, and each call must have a corresponding call to csvFileServer() on the server side with that same id.\n\n\nOutput example\nHere‚Äôs an example of a module that consists of two linked scatterplots (selecting an area on one plot will highlight observations on both plots).\nlibrary(shiny)\nlibrary(ggplot2)\nFirst we‚Äôll make the module UI function. We want two plots, plot1 and plot2, side-by-side with a common brush ID of brush. (Notice that the brush ID needs to be wrapped in ns(), just like the plotOutput IDs.)\nlinkedScatterUI &lt;- function(id) {\n  ns &lt;- NS(id)\n\n  fluidRow(\n    column(6, plotOutput(ns(\"plot1\"), brush = ns(\"brush\"))),\n    column(6, plotOutput(ns(\"plot2\"), brush = ns(\"brush\")))\n  )\n}\nThe module server function comes next. Besides the mandatory input, output, and session parameters, we need to know the data frame to plot (data), and the column names that should be used as x and y for each plot (left and right).\nTo allow the data frame and columns to change in response to user actions, the data, left, and right must all be reactive expressions. These parameters are passed to linkedScatterServer, and they can be used in the module function defined inside.\nlinkedScatterServer &lt;- function(id, data, left, right) {\n  moduleServer(\n    id,\n    function(input, output, session) {\n      # Yields the data frame with an additional column \"selected_\"\n      # that indicates whether that observation is brushed\n      dataWithSelection &lt;- reactive({\n        brushedPoints(data(), input$brush, allRows = TRUE)\n      })\n\n      output$plot1 &lt;- renderPlot({\n        scatterPlot(dataWithSelection(), left())\n      })\n\n      output$plot2 &lt;- renderPlot({\n        scatterPlot(dataWithSelection(), right())\n      })\n\n      return(dataWithSelection)\n    }\n  )\n}\nNotice that the module function inside of linkedScatterServer() returns the dataWithSelection reactive. This means that the caller of this module can make use of the brushed data as well, such as showing it in a table below the plots, for example.\nFor clarity and ease of testing, let‚Äôs put the plotting code in a standalone function. The scale_color_manual call sets the colors of unselected vs.¬†selected points, and guide = FALSE hides the legend.\nscatterPlot &lt;- function(data, cols) {\n  ggplot(data, aes_string(x = cols[1], y = cols[2])) +\n    geom_point(aes(color = selected_)) +\n    scale_color_manual(values = c(\"black\", \"#66D65C\"), guide = FALSE)\n}\n\n\nNesting modules\nModules can use other modules. When doing so, when the outer module‚Äôs UI function calls the inner module‚Äôs UI function, ensure that the id is wrapped in ns(). In the following example, when outerUI calls innerUI, notice that the id argument is ns(\"inner1\"):\ninnerUI &lt;- function(id) {\n  ns &lt;- NS(id)\n  \"This is the inner UI\"\n}\n\nouterUI &lt;- function(id) {\n  ns &lt;- NS(id)\n  wellPanel(\n    innerUI(ns(\"inner1\"))\n  )\n}\nAs for the module server functions, just ensure that the call to callModule for the inner module happens inside the outer module‚Äôs server function. There‚Äôs generally no need to use ns().\ninnerServer &lt;- function(id) {\n  moduleServer(\n    id,\n    function(input, output, session) {\n      # inner logic here\n    }\n  )\n}\n\nouterServer &lt;- function(id) {\n  moduleServer(\n    id,\n    function(input, output, session) {\n      innerResult &lt;- innerServer(\"inner1\")\n      # outer logic here\n    }\n  )\n}\n\n\nUsing renderUI within modules\nInside of a module, you may want to use uiOutput/renderUI. If your renderUI block itself contains inputs/outputs, you need to use ns() to wrap your ID arguments, just like in the examples above. But those ns instances were created using NS(id), and in this case, there‚Äôs no id parameter to use. What to do?\nThe session parameter can provide the ns for you; just call ns &lt;- session$ns. This will put the ID in the same namespace as the session.\ncolumnChooserUI &lt;- function(id) {\n  ns &lt;- NS(id)\n  uiOutput(ns(\"controls\"))\n}\n\ncolumnChooserServer &lt;- function(id, data) {\n  moduleServer(\n    id,\n    function(input, output, session) {\n      output$controls &lt;- renderUI({\n        ns &lt;- session$ns\n        selectInput(ns(\"col\"), \"Columns\", names(data), multiple = TRUE)\n      })\n\n      return(reactive({\n        validate(need(input$col, FALSE))\n        data[,input$col]\n      }))\n    }\n  )\n}\n\n\nPackaging modules\nThe previous examples of using a module assume that the module‚Äôs UI and server functions are defined and available. But logistically, where should these functions actually be defined, and how should they be loaded into R?\nThere are several options.\n\nInline code\nMost simply, you can put the UI and server function code directly in your app.\nIf you‚Äôre using an app.R style file layout (both app UI and server logic in the same file), then you can just include the code for your module functions right in that file, before the app‚Äôs UI and server logic.\nIf you‚Äôre using a ui.R/server.R style file layout, add a global.R file to your app directory (if you don‚Äôt already have one) and put the UI and server functions there. The global.R file will be loaded before either ui.R or server.R.\nIf you have many modules to define, or modules that contain a lot of code, this may result in a bloated global.R/app.R file.\n\n\nIn an R script in the R/ subdirectory\nYou can create a separate R script (.R file) for the module in the R/ subdirectory of your application. It will automatically be sourced (as of Shiny 1.5.0) when the application is loaded.\nThis is the recommended method for modules that won‚Äôt be reused across applications.\n\n\nIn an R script elsewhere in the app directory\nYou can create a separate R script (.R file) for the module, either directly in the app directory or in a subdirectory. Then call source(\"path-to-module.R\") from global.R (if using ui.R/server.R) or app.R. This will add your module functions to the global environment.\nIn versions of Shiny prior to 1.5.0, this was the recommended method, but with 1.5.0 and later, we recommend the previous method, where the standalone R script is in the R/ subdirectory.\n\n\nR package\nFor modules that are intended for reuse across applications, consider building an R package. If you‚Äôve never done this before, a good resource is Hadley Wickham‚Äôs book R Packages, which is freely available online.\nYour R package needs to export and document your module‚Äôs UI and server functions. You can include more than one module in a package, if you like.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Modules",
      "Modularizing Shiny app code"
    ]
  },
  {
    "objectID": "r/articles/improve/modules/index.html#migrating-from-callmodule-to-moduleserver",
    "href": "r/articles/improve/modules/index.html#migrating-from-callmodule-to-moduleserver",
    "title": "Modularizing Shiny app code",
    "section": "Migrating from callModule to moduleServer",
    "text": "Migrating from callModule to moduleServer\nPrior to Shiny 1.5.0, the only way to use the module function was with callModule; as of Shiny 1.5.0, we added the moduleServer function and recommend using it instead of callModule, because the syntax for the user of the module is more consistent with the UI portion, and somewhat easier to understand. (Note that the UI portion of modules was unchanged.) New-style modules also can be tested with the testServer function, also introduced in Shiny 1.5.0.\nHere is an example of the older-style module. The part to pay attention to is the definition of myModule, and its corresponding use in the server function, with callModule:\n# Module definition, old method\nmyModuleUI &lt;- function(id, label = \"Input text: \") {\n  ns &lt;- NS(id)\n  tagList(\n    textInput(ns(\"txt\"), label),\n    textOutput(ns(\"result\"))\n  )\n}\n\nmyModule &lt;- function(input, output, session, prefix = \"\") {\n  output$result &lt;- renderText({\n    paste0(prefix, toupper(input$txt))\n  })\n}\n\n\n# Use the module in an application\nui &lt;- fluidPage(\n  myModuleUI(\"myModule1\")\n)\nserver &lt;- function(input, output, session) {\n  callModule(myModule, \"myModule1\", prefix = \"Converted to uppercase: \")\n}\nshinyApp(ui, server)\nHere is the same application, with the new method using moduleServer(). This time, we are creating a function called myModuleServer, and in the application‚Äôs server function, we call that function directly (instead of using callModule().\n# Module definition, new method\nmyModuleUI &lt;- function(id, label = \"Input text: \") {\n  ns &lt;- NS(id)\n  tagList(\n    textInput(ns(\"txt\"), label),\n    textOutput(ns(\"result\"))\n  )\n}\n\nmyModuleServer &lt;- function(id, prefix = \"\") {\n  moduleServer(\n    id,\n    function(input, output, session) {\n      output$result &lt;- renderText({\n        paste0(prefix, toupper(input$txt))\n      })\n    }\n  )\n}\n\n\n# Use the module in an application\nui &lt;- fluidPage(\n  myModuleUI(\"myModule1\")\n)\nserver &lt;- function(input, output, session) {\n  myModuleServer(\"myModule1\", prefix = \"Converted to uppercase: \")\n}\nshinyApp(ui, server)\nThe old and new versions of the application have the exact same behavior. Notice, however, that with the new version, the usage of the module in the application is more consistent, with myModuleUI(\"myModule1\") and myModuleServer(\"myModule1\", prefix = \"Converted to uppercase: \").\nWhen creating the module server function, here is the old method:\n# Old-style modules\nmyModule &lt;- function(input, output, session, prefix = \"\") {\n  output$result &lt;- renderText({\n    paste0(prefix, toupper(input$txt))\n  })\n}\nAnd here is the new method:\n# New-style modules\nmyModuleServer &lt;- function(id, prefix = \"\") {\n  moduleServer(\n    id,\n    function(input, output, session) {\n      output$result &lt;- renderText({\n        paste0(prefix, toupper(input$txt))\n      })\n    }\n  )\n}\nIn the old version, the myModule function takes input, output, and session, as parameters, along with any additional user parameters ‚Äì in this case, prefix. In the new version, the function just takes id and additional user parameters (prefix).\nIn the new version, there is an inner module function that takes input, output, and session, and no other parameters. The code from the old-style module is simply moved into this inner module function. Any extra user parameters, like prefix (or even ...) can be accessed inside that function because they are available in the parent environment.\nWhen it comes to using the module in the application‚Äôs server function, here is the old method, which uses Shiny‚Äôs callModule function:\n# Old-style modules\nserver &lt;- function(input, output, session) {\n  callModule(myModule, \"myModule1\", prefix = \"Converted to uppercase: \")\n}\nThe new method is more straightforward: it simply calls the myModuleServer function.\n# New-style modules\nserver &lt;- function(input, output, session) {\n  myModuleServer(\"myModule1\", prefix = \"Converted to uppercase: \")\n}",
    "crumbs": [
      "Improve",
      "Refactor",
      "Modules",
      "Modularizing Shiny app code"
    ]
  },
  {
    "objectID": "r/articles/improve/communicate-bet-modules/index.html",
    "href": "r/articles/improve/communicate-bet-modules/index.html",
    "title": "Communication between modules",
    "section": "",
    "text": "The introductory article on modules describes that Shiny modules have more than a few similarities with general R functions, albeit with some specific components related to Shiny. In addition, modules can range in complexity and often need to communicate with each other in large-scale applications. While a basic use of modules already helps manage complexity greatly, there are some useful techniques you can employ to ensure a smooth and clear model for communication between modules themselves and with your overall Shiny application. Following these best practices with modules enables your application‚Äôs code base to be more organized, easier to understand, and facilitate concurrent development workstreams on different components. In the remainder of this article, we will illustrate how these techniques are applied to a specific application utilizing modules.\n\nMotivating Example\nTo illustrate these techniques, suppose we have a Shiny application that allows the user to visualize key variables within the Ames, Iowa housing data set (available via the AmesHousing R package).\n\n\n\nApp Screenshot\n\n\nThis application lets the user create two side-by-side scatterplots, each with potentially different variables selected for the X and Y axes. The app uses two modules, one handling the variable selection and the other producing the side-by-side scatterplots.\n\n\nModule Documentation\nHere is the variable selection module user interface:\n#' Variable selection for plot user interface\n#'\n#' @param id, character used to specify namespace, see \\code{shiny::\\link[shiny]{NS}}\n#'\n#' @return a \\code{shiny::\\link[shiny]{tagList}} containing UI elements\nvarselect_mod_ui &lt;- function(id) {\n  ns &lt;- NS(id)\n  \n  # define choices for X and Y variable selection\n  var_choices &lt;- list(\n    `Sale price` = \"Sale_Price\",\n    `Total basement square feet` = \"Total_Bsmt_SF\",\n    `First floor square feet` = \"First_Flr_SF\",\n    ...\n  )\n  \n  # assemble UI elements\n  tagList(\n    selectInput(\n      ns(\"xvar\"),\n      \"Select X variable\",\n      choices = var_choices,\n      selected = \"Lot_Area\"\n    ),\n    selectInput(\n      ns(\"yvar\"),\n      \"Select Y variable\",\n      choices = var_choices,\n      selected = \"Sale_Price\"\n    )\n  )\n}\nNotice the use of roxygen comments before the varselect_mod_ui module definition. Writing documentation of a module‚Äôs inputs and return values is a powerful way to make clear the purpose of the module. Even if you use a different format for documenting the module parameters, the key point is to document when possible!\n\n\nReturn Values\nNow let‚Äôs examine the server logic of this module:\n#' Variable selection module server-side processing\n#'\n#' @param input, output, session standard \\code{shiny} boilerplate\n#'\n#' @return list with following components\n#' \\describe{\n#'   \\item{xvar}{reactive character string indicating x variable selection}\n#'   \\item{yvar}{reactive character string indicating y variable selection}\n#' }\nvarselect_mod_server &lt;- function(input, output, session) {\n\n  return(\n    list(\n      xvar = reactive({ input$xvar }),\n      yvar = reactive({ input$yvar })\n    )\n  )\n}\nThe purpose of the server-side component is to assemble the variable choices made by the user, and the return object is a named list with slots corresponding to the different variable selections. While the processing of this module is trivial (i.e.¬†nothing more than obtaining the input values), constructing the return value in this manner is a straight-forward approach to articulating the intent. In this case, the module acts like an accessor to capture the inputs explicitely. Lastly, this module reinforces the idea that reactive expressions are typically the most portable format for passing reactive information between modules.\n\n\nCommunication between modules\nBelow is the server logic of the visualization module. This module makes use of a simple function, scatter_sales(), to create the scatterplot. Details on this function as well as the module that builds the user interface for the visualization (scatterplot_mod_ui) are shown in the app code, but omitted here.\n#' Scatterplot module server-side processings\n#'\n#' This module produces a scatterplot with the sales price against a variable selected by the user.\n#' \n#' @param input,output,session standard \\code{shiny} boilerplate\n#' @param dataset data frame (non-reactive) with variables necessary for scatterplot\n#' @param plot1_vars list containing reactive x-variable name (called `xvar`) and y-variable name (called `yvar`) for plot 1\n#' @param plot2_vars list containing reactive x-variable name (called `xvar`) and y-variable name (called `yvar`) for plot 2\nscatterplot_server_mod &lt;- function(input, \n                            output, \n                            session, \n                            dataset, \n                            plot1vars, \n                            plot2vars) {\n  \n  \n  plot1_obj &lt;- reactive({\n    p &lt;- scatter_sales(dataset, xvar = plot1vars$xvar(), yvar = plot1vars$yvar())\n    return(p)\n  })\n  \n  plot2_obj &lt;- reactive({\n    p &lt;- scatter_sales(dataset, xvar = plot2vars$xvar(), yvar = plot2vars$yvar())\n    return(p)\n  })\n  \n  output$plot1 &lt;- renderPlot({\n    plot1_obj()\n  })\n  \n  output$plot2 &lt;- renderPlot({\n    plot2_obj()\n  })\n}\nWe can now see the benefits of documenting the variable module‚Äôs parameters and clear specification of the return object. The documentation for the plot1vars and plot2vars parameters indicates the object type and more importantly the reactive components of the x and y variable names. Within the module code, it is important to reference the variable names correctly by using plot1vars$yvar() instead of plot1vars()$yvar, which is a common error in these situations.\n\n\nApplication structure\nBelow is the user interface and server code for the application overall. Complete code including module definitions and helper functions can be found alongside the deployed app here.\n# user interface\nui &lt;- fluidPage(\n  \n  titlePanel(\"Ames Housing Data Explorer\"),\n  \n  fluidRow(\n    column(\n      width = 2,\n      wellPanel(\n        varselect_mod_ui(\"plot1_vars\")\n      )\n    ),\n    column(\n      width = 8,\n      scatterplot_mod_ui(\"plots\")\n    ),\n    column(\n      width = 2,\n      wellPanel(\n        varselect_mod_ui(\"plot2_vars\")\n      )\n    )\n  )\n)\n\n# server logic\nserver &lt;- function(input, output, session) {\n  \n  # prepare dataset\n  ames &lt;- make_ames()\n  \n  # execute plot variable selection modules\n  plot1vars &lt;- callModule(varselect_mod_server, \"plot1_vars\")\n  plot2vars &lt;- callModule(varselect_mod_server, \"plot2_vars\")\n  \n  # execute scatterplot module\n  res &lt;- callModule(scatterplot_mod_server,\n                    \"plots\",\n                    dataset = ames,\n                    plot1vars = plot1vars,\n                    plot2vars = plot2vars)\n  \n}\n\n# Run the application \nshinyApp(ui = ui, server = server)\nBy utilizing the techniques illustrated above, the application wrapper code is well-organized and easy to manage. The module for selecting variables could easily be called multiple times, and any enhancements made to that module could be performed in parallel to other development workstreams. For instance, if a team of developers was authoring this application, a subset of the team may improve the plot aesthetics in the scatterplot module while another group tweaks the variable selection module appearance. In addition, the documentation of the module inputs and return values ensures clear communication of the purpose of the module and can even be incorporated in new applications or packages.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Modules",
      "Communication between modules"
    ]
  },
  {
    "objectID": "r/articles/improve/async/index.html",
    "href": "r/articles/improve/async/index.html",
    "title": "Improving scalability with async programming",
    "section": "",
    "text": "Asynchronous programming is a powerful but advanced technique for increasing the scalability of your Shiny apps (starting with the Shiny 1.1.0 release). On its own, async programming doesn‚Äôt increase the performance or responsiveness for a single user of your app, but can improve responsiveness‚Äìdramatically, in some cases‚Äìwhen multiple users are active at the same time.\nAsync programming is mainly effective when your app has one, or two, or a few spots where a lot of time is spent. This might be where you download a large amount of data from a web API, or run a slow query against a remote database, or ferret through a directory full of thousands of log files. You can use async to offload this kind of work to a background R process, leaving Shiny free to service other users while it waits for those calculations to complete.\nShiny integrates with the promises package, which you‚Äôll need to become intimately familiar with if you want to take advantage of async programming."
  },
  {
    "objectID": "r/articles/improve/async/index.html#optimize-first",
    "href": "r/articles/improve/async/index.html#optimize-first",
    "title": "Improving scalability with async programming",
    "section": "Optimize first!",
    "text": "Optimize first!\nIf your app doesn‚Äôt scale well and you don‚Äôt yet know why, stop and figure that out first! Async programming should be your last resort in fixing performance and scalability problems. If you haven‚Äôt tried profiling and removing common bottlenecks, definitely do that first, and only turn to async programming if you‚Äôre sure the long-running tasks you‚Äôre trying to offload are already run as quickly and as seldom as possible."
  },
  {
    "objectID": "r/articles/improve/async/index.html#watch-the-talk",
    "href": "r/articles/improve/async/index.html#watch-the-talk",
    "title": "Improving scalability with async programming",
    "section": "Watch the talk",
    "text": "Watch the talk\nFor a quick introduction to async programming with Shiny, check out this video introducing the feature at rstudio::conf 2018:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis video‚Äôs page at Posit.co"
  },
  {
    "objectID": "r/articles/improve/async/index.html#get-started",
    "href": "r/articles/improve/async/index.html#get-started",
    "title": "Improving scalability with async programming",
    "section": "Get started",
    "text": "Get started\nIf you‚Äôre ready to get started learning about async programming in earnest, you‚Äôll find all the documentation you need at the promises site. Async programming is an advanced technique, so we highly recommend you read through the entire six-part article series there!"
  },
  {
    "objectID": "r/articles/build/understanding-reactivity/index.html",
    "href": "r/articles/build/understanding-reactivity/index.html",
    "title": "How to understand reactivity in R",
    "section": "",
    "text": "Reactivity is what makes your Shiny apps responsive. It lets the app instantly update itself whenever the user makes a change. You don‚Äôt need to know how reactivity occurs to use it (just follow the steps laid out in Lesson 4, but understanding reactivity will make you a better Shiny programmer. You‚Äôll be able to\nLet‚Äôs take a look at reactivity by building a very simple Shiny app:\nThe app sets up a very basic reactive system: it has a single input value that can change (input$a); it has a single output value that can respond (print(input$a)); and it has a server that can oversee the process. Every Shiny app will have these same components, although most apps will have multiple input values and multiple output expressions.\nWhen you move the slider, you can see reactivity in action: the number to the left of the slider automatically updates to show the current slider value. This may seem simple, but it is very special. Let‚Äôs look at why.",
    "crumbs": [
      "Build",
      "Backend",
      "Reactivity",
      "How to understand reactivity in R"
    ]
  },
  {
    "objectID": "r/articles/build/understanding-reactivity/index.html#reactivity-is-unexpected",
    "href": "r/articles/build/understanding-reactivity/index.html#reactivity-is-unexpected",
    "title": "How to understand reactivity in R",
    "section": "Reactivity is unexpected",
    "text": "Reactivity is unexpected\nReactivity creates the illusion that changes in input values automatically flow to the plots, text, and tables that use the input‚Äîand cause them to update. You can think of this flow as a current of electricity, or a stream of water that pushes information from input to output. You saw this illusion in action when you moved the slider bar. Changes in the slider bar seemed to automatically propagate to the number beside the bar.\n\nThis illusion is amazing, because information in R only travels through pull mechanisms, not push mechanisms. In other words, if you have a simple R expression like {a + 1}, R will retrieve information from a to evaluate the expression, but R won‚Äôt modify the result of {a + 1} if you later change the value of a.\na &lt;- 1\na + 1\n## 2\n\na &lt;- 2\n## (nothing happens)\nPictorially, the system looks like this. Notice that the arrow in the diagram goes from right to left. This is to imply that the expression on the right is doing the work. It is telling R to look up the value of a. a is just sitting passively in memory.\n\nFor our app, this suggests that R should look up the value of input$a once, print the value, and then not notice when input$a changes.\n\nIncredibly, this isn‚Äôt what happens, as you saw above. Reactivity appears to reverse the flow of information in R. How does it do that?",
    "crumbs": [
      "Build",
      "Backend",
      "Reactivity",
      "How to understand reactivity in R"
    ]
  },
  {
    "objectID": "r/articles/build/understanding-reactivity/index.html#what-is-reactivity",
    "href": "r/articles/build/understanding-reactivity/index.html#what-is-reactivity",
    "title": "How to understand reactivity in R",
    "section": "What is reactivity?",
    "text": "What is reactivity?\nThink of reactivity as a magic trick: reactivity creates the illusion that one thing is happening, when in fact something else is going on. The illusion is that information is being pushed from inputs to outputs (or at least that inputs and outputs are linked in an inseperable way). The reality is that Shiny is re-running your R expressions in a carefully scheduled way.\nI‚Äôve prepared four maxims to help you understand this process. We‚Äôll look at each of them (and the process itself), with a simple thought experiment: how could we recreate our basic app without breaking the rules of R?\nHere are our maxims\n\nR expressions update themselves, if you ask\nNothing needs to happen instantly\nThe app must do as little as possible\nThink carrier pigeons, not electricity\n\n\n1. R expressions update themselves, if you ask\nReactivity ensures that the output of print(input$a) is always up to date, but what does it mean for output to be out of date? Let‚Äôs consider output ‚Äì and the expression that made it ‚Äì to be out of date if one of the objects in the expression has been given a new value since the expression was called. For example, at the end of this code, the expression print(a) is out of date. The last time print(a) ran, a was 1.\na &lt;- 1\nprint(a)\n## 1\n\na &lt;- 2\nUpdating an out of date expression is not hard: you just need to re-run the expression. Everything in R updates itself each time it is run. This isn‚Äôt reactivity; it‚Äôs just standard R behavior.\na &lt;- 1\nprint(a)\n## 1\n\na &lt;- 2\nprint(a)\n## 2\nThink of it like this: every time you run an expression, the expression updates itself. It looks up the current value of each object that it uses and computes new ouput. However, you must tell R to run the expresssion for this to happen because R uses a style of execution known as lazy evaluation. In other words, R will not execute an expression until you force it to.\nYou could use this behavior ‚Äì and nothing else ‚Äì to create a reactive web app. All you need to do is manually re-run the expressions in the app whenever the user makes a change.\n\n\n2. Nothing needs to happen instantly\nHow quickly do you need to re-run an expression after a user makes a change? If the update appears instantaneous, the user will feel like they caused it. In other words, the update will create the illusion of reactivity. However, humans aren‚Äôt very good at noticing small windows of time. You could actually let a few microseconds pass between change and update and your user wouldn‚Äôt notice. This suggests a new feature for our plan.\nInstead of watching the user (which would require logistics we haven‚Äôt thought through), you could just have your server re-run each expression in the app every few microseconds. That way whenever the user makes a change, an update will follow within a few microseconds. If you re-run every expression in the app, you don‚Äôt even need to worry about which part of the app the user is changing.\nWhat if the user doesn‚Äôt make a change? Then the expressions will re-compute their previous results and the app will appear to be in the same state it was before.\nThis plan creates the illusion of reactivity without violating the rules of R. Information still travels from input to output in a pull fashion. For example, print(input$a) only learns the new value of input$a because the server re-executes print(input$a). Since print(input$a) is re-executed so often, it seems to learn of the change very fast, as if it were connected to input$a or as if input$a pushed its new value to print(input$a).\nShiny uses this approach to create reactivity. That is why your R session becomes busy when you launch a Shiny app. Your server is using the R session to monitor the app and re-run expressions. However, Shiny takes this approach one step further. It creates an alert system that lets Shiny know exactly which expressions need to be re-run.\n\n\n3. The app must do as little as possible\nIt takes a very powerful computer to re-run every expression in an app every few microseconds without bogging down. If you used our approach in reality, your app would quickly become slow and unresponsive, which would destroy the illusion of reactivity.\nIf you want your updates to run so fast that they appear instantaneous, you‚Äôll need to save your computer power for just the expressions that are out of date. However, your app may use hundreds of expressions. How will you know which ones are out of date?\nShiny solves this problem by creating a system of alerts that lets the server know when an expression becomes out of date. The server still checks in on your app every few microseconds, but instead of re-running each expression each time, it only runs the expressions that the alert system has flagged as out of date. If no alerts have appeared, the server does not have to run anything at all. It can rest until the next check. If alerts have appeared, the server runs all of the expressions that are out of date at that moment, an event known as a flush.\nThis alert system is the key to reactivity. It allows your server to update your app as fast as possible, so fast that changes seem to travel instantly from inputs to outputs. Let‚Äôs not try to brainstorm our own alert system. Instead let‚Äôs examine the system that Shiny uses.\n\n\n4. Think carrier pigeons, not electricity\nThe details of the alert system are fairly complicated. If they sound confusing in this next paragraph, don‚Äôt worry. We‚Äôre going to break them down step by step with an analogy that will make them more transparent.\nShiny implements reactivity with two special object classes, reactivevalues and observers. In our example input$a is a reactive values object and print(input$a) is an observer. These two classes behave like regular R values and R expressions with a few exceptions. Whenever an observer uses a reactive value, it registers a reactive context with the value. This context contains an expression to be run if the value ever changes. The expression is called a callback and it is always a command to re-run the observer. A single reactive value can hold many contexts if multiple observers use that value.\n\nWhen the value of a reactive values object changes, the object will send any callbacks that it has collected to the server. Lets look at how this happens.\nA reactive values object is a type of list. In R, you change the value of a list by calling a settor function, either $&lt;- or [[&lt;-. These are the functions that R calls in the background whenever you combine the assignment arrow, &lt;-, with the subsetting symbols $ or [[ ]]. For example, R will call $&lt;- when you run the second line of code below.\nmyList &lt;- list(a = 1, b = 2)\nmyList$b &lt;- 3\nSince reactive values objects are a special class of object, they have their own settor methods. The settor methods of reactive values objects ($&lt;- and [[&lt;-) include instructions to send any callbacks that the reactive value has received to the server. If the reactive values object is set to a new value, it executes these instructions and the server receives the callbacks.\n\nThe server saves the callbacks in a queue which acts as a list of observers that have become out of date. On the next flush, the server runs each callback in the queue which re-runs each out of date observer, which restarts the cycle.\n\nIf this seems complicated, think of reactivity as a carrier pigeon system between three objects. If you don‚Äôt know what carrier pigeons are, check out this link ‚Äì it‚Äôs pretty fascinating. Basically, you can take a carrier pigeon anywhere and when you release it, it will always fly back to the same location. Soldiers on the move used carrier pigeons to deliver messages to their headquarters. We‚Äôre going to use them to deliver messages to the server.\nA context is like a virtual carrier pigeon that an observer leaves with a reactive value. The context contains a message (its callback) that it will deliver to the server when released. The observer writes this message for the context, and it is a simple instruction to re-run the observer. An observer leaves behind a context each time it looks up a reactive values object. In fact, a reactive values object will return an error if an expression tries to access its value without leaving behind a context.\n{fig-alt=‚ÄúImage of Reactive value, Observer and Server. Arrow goes from Observer to Reactive value. Observer says‚ÄùI see that you are 50. Let us know if you change. Use this pigeon. A pigeon next to the Reactive value holds a card that says Re-run print(a).‚Äù}\nWhen a reactive values object receives a context, it simply holds onto it. It will collect multiple contexts if other observers look up the object as well. If the reactive value object ever changes, it will release all of the contexts it has collected (a process known as invalidating the contexts). This behavior is like releasing carrier pigeons, the pigeons are free to fly back to the server and deliver the callbacks that they have been holding onto. When a context is invalidated, it places its callback in the server‚Äôs queue to be run on the next flush. Then the context ceases to be relevant, just like a pigeon that has delivered its message.\n\nThe callback of a context is an R command that when run, will re-execute the observer that created the context. This will cause the observer to update itself with the new value of the reactive values object. When the server checks in on the app, all it needs to do is run any callbacks that have arrived. This will automatically update the app.\nRunning the callbacks also sets up a new reactive cycle. When an observer is re-run, it looks up the reactive value objects that it uses, which causes it to register new contexts with each value. In short, the observer leaves a new homing pigeon behind and the cycle is ready to repeat itself.\n\nThis system enables reactivity because it lets your server work fast enough to create the illusion of instant responses. Instead of re-running every expression in your app every few seconds, the server only needs to check its queue for new callbacks. The result is the quick, responsive updates you see in your Shiny app.\nNow you know how reactivity works in Shiny. Notice that this system doesn‚Äôt ask R to behave in a new way. Your observers are still looking up information from the reactive values. The values are not being pushed to the observer like a flow of electricity, or a stream‚Äîthey only appear to be doing that. The key to this system is speed. Shiny enacts the pull mechanisms of R so fast that they look like push mechanisms.",
    "crumbs": [
      "Build",
      "Backend",
      "Reactivity",
      "How to understand reactivity in R"
    ]
  },
  {
    "objectID": "r/articles/build/themes/index.html",
    "href": "r/articles/build/themes/index.html",
    "title": "Themes",
    "section": "",
    "text": "Shiny v1.6 and higher integrates with the {bslib} package providing easy access to modern versions of Bootstrap, Bootswatch themes, as well as custom themes that can even be modified in real time!",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Themes"
    ]
  },
  {
    "objectID": "r/articles/build/themes/index.html#using-bslib-in-shiny",
    "href": "r/articles/build/themes/index.html#using-bslib-in-shiny",
    "title": "Themes",
    "section": "Using bslib in Shiny",
    "text": "Using bslib in Shiny\nTo use {bslib} in your own Shiny app, pass a bs_theme() object to the theme argument of the relevant page layout function, such as page_navbar() or page_fillable(). Inside bs_theme(), you can specify a version of Bootstrap and (optionally) a Bootswatch theme (e.g.¬†minty)\nlibrary(shiny)\nlibrary(bslib)\n\nui &lt;- page_navbar(\n  theme = bs_theme(version = 5, bootswatch = \"minty\"),\n  ...\n)\n\nWhile Bootswatch themes make it very easy to change the default look of an application, you may want to design your own custom theme. In this case, {bslib}‚Äôs custom theming options make this much easier than writing custom CSS.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Themes"
    ]
  },
  {
    "objectID": "r/articles/build/themes/index.html#custom-themes",
    "href": "r/articles/build/themes/index.html#custom-themes",
    "title": "Themes",
    "section": "Custom themes",
    "text": "Custom themes\nThe bs_theme() function provides direct access to Bootstrap‚Äôs main colors & fonts as well as any of the 100s of more specific theming options. Also, when it comes to custom font(s) that may not be available on the end users machine, make sure to leverage {bslib}‚Äôs helper functions like font_google(), font_link(), and font_face(), which assist in including font file(s) in an convenient, efficient, and responsible way.\nlibrary(bslib)\ntheme &lt;- bs_theme(\n  bg = \"#0b3d91\", fg = \"white\", primary = \"#FCC780\",\n  base_font = font_google(\"Space Mono\"),\n  code_font = font_google(\"Space Mono\")\n)\nbs_theme_preview(theme)\n\nThe main reason why {bslib} makes it so much easier to implement custom themes is that bs_theme() leverages Bootstrap Sass variables, allowing you to change only a few color(s) and font(s) to impact potentially hundreds of Bootstrap‚Äôs CSS rules. Also, thanks to CSS Utility Classes, you can now more easily tackle complicated UI issues that Sass variables alone can‚Äôt solve such as adjustments to spacing, alignment, borders, background colors, and more. To learn more about leveraging {bslib} to tackle more custom theming tasks, see the article on custom theming.\nAnd while a lot of custom theming can be done via bs_theme() (i.e., CSS), it fundamentally can‚Äôt effect renderPlot(), because the image is rendered by R, not by the web browser. To help solve this problem, we‚Äôve also created the {thematic} package which can effectively translate CSS to new R plotting defaults by just calling thematic::thematic_shiny() before running an app.\n\n \n\nThis ‚Äòauto theming‚Äô behavior that {thematic} provides works great in Shiny with any CSS framework (not just {bslib}). Also, more generally, {thematic} can help simplify plot theming inside any R environment, using any graphics device, and also makes it super easy to use Google Fonts inside your R plots.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Themes"
    ]
  },
  {
    "objectID": "r/articles/build/themes/index.html#real-time",
    "href": "r/articles/build/themes/index.html#real-time",
    "title": "Themes",
    "section": "Real-time theming",
    "text": "Real-time theming\nThe {bslib} package also provides an interactive theming widget that you can use to theme any Shiny app in real-time, or any rmarkdown::html_document that uses runtime: shiny. To use it in your own Shiny app, call bs_themer() inside your server function with a UI that uses Bootstrap 4 (or higher).\nlibrary(shiny)\nlibrary(bslib)\nthematic::thematic_shiny(font = \"auto\")\n\nui &lt;- fluidPage(\n  theme = bs_theme(),\n  ...\n)\n\nserver &lt;- function(input, output) {\n  bs_themer()\n  \n  ...\n}\n\nshinyApp(ui, server)\n\n\n\nIf you want the real-time theming changes to effect static R plots, make sure {thematic} auto-theming is enabled, and that plots are generated with renderPlot()\n---\nruntime: shiny\noutput:\n  html_document:\n    theme: !expr bslib::bs_theme()\n---\n\n```{r, echo = FALSE}\nbslib::bs_themer()\nthematic::thematic_shiny(font = \"auto\")\n```\n\n# Here's a plot\n\nMake sure to use `renderPlot()` if you want R plots to respond to real-time theming!\n\n```{r}\nrenderPlot({\n  plot(pressure)\n})\n```",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Themes"
    ]
  },
  {
    "objectID": "r/articles/build/themes/index.html#custom-real-time-theming",
    "href": "r/articles/build/themes/index.html#custom-real-time-theming",
    "title": "Themes",
    "section": "Custom real-time theming",
    "text": "Custom real-time theming\nShiny 1.6 introduced session$setCurrentTheme() and session$getCurrentTheme() session methods for dynamically updating the Bootstrap theme after initial load. These methods power bs_themer(), but they can also be used to implement custom real-time theming widgets like a dark mode switch.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Themes"
    ]
  },
  {
    "objectID": "r/articles/build/themes/index.html#learn-more",
    "href": "r/articles/build/themes/index.html#learn-more",
    "title": "Themes",
    "section": "Learn more",
    "text": "Learn more\nTo learn more about the {bslib} and {thematic} packages, see https://rstudio.github.io/bslib/articles/theming/index.html and https://rstudio.github.io/thematic",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Themes"
    ]
  },
  {
    "objectID": "r/articles/build/tag-glossary/index.html",
    "href": "r/articles/build/tag-glossary/index.html",
    "title": "Shiny HTML Tags Glossary",
    "section": "",
    "text": "In Customize your Shiny UI with HTML you saw that Shiny provides a list of functions named tags. Each function in the list creates an HTML tag that you can use to layout your Shiny App. But what if you are unfamiliar with HTML tags? The glossary below explains what the most popular tags in tags do.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Shiny HTML Tags Glossary"
    ]
  },
  {
    "objectID": "r/articles/build/tag-glossary/index.html#tags",
    "href": "r/articles/build/tag-glossary/index.html#tags",
    "title": "Shiny HTML Tags Glossary",
    "section": "tags",
    "text": "tags\nThe shiny::tags object contains R functions that recreate 110 HTML tags.\nnames(tags)\n##   [1] \"a\"           \"abbr\"        \"address\"     \"area\"        \"article\"\n##   [6] \"aside\"       \"audio\"       \"b\"           \"base\"        \"bdi\"\n##  [11] \"bdo\"         \"blockquote\"  \"body\"        \"br\"          \"button\"\n##  [16] \"canvas\"      \"caption\"     \"cite\"        \"code\"        \"col\"\n##  [21] \"colgroup\"    \"command\"     \"data\"        \"datalist\"    \"dd\"\n##  [26] \"del\"         \"details\"     \"dfn\"         \"div\"         \"dl\"\n##  [31] \"dt\"          \"em\"          \"embed\"       \"eventsource\" \"fieldset\"\n##  [36] \"figcaption\"  \"figure\"      \"footer\"      \"form\"        \"h1\"\n##  [41] \"h2\"          \"h3\"          \"h4\"          \"h5\"          \"h6\"\n##  [46] \"head\"        \"header\"      \"hgroup\"      \"hr\"          \"html\"\n##  [51] \"i\"           \"iframe\"      \"img\"         \"input\"       \"ins\"\n##  [56] \"kbd\"         \"keygen\"      \"label\"       \"legend\"      \"li\"\n##  [61] \"link\"        \"mark\"        \"map\"         \"menu\"        \"meta\"\n##  [66] \"meter\"       \"nav\"         \"noscript\"    \"object\"      \"ol\"\n##  [71] \"optgroup\"    \"option\"      \"output\"      \"p\"           \"param\"\n##  [76] \"pre\"         \"progress\"    \"q\"           \"ruby\"        \"rp\"\n##  [81] \"rt\"          \"s\"           \"samp\"        \"script\"      \"section\"\n##  [86] \"select\"      \"small\"       \"source\"      \"span\"        \"strong\"\n##  [91] \"style\"       \"sub\"         \"summary\"     \"sup\"         \"table\"\n##  [96] \"tbody\"       \"td\"          \"textarea\"    \"tfoot\"       \"th\"\n## [101] \"thead\"       \"time\"        \"title\"       \"tr\"          \"track\"\n## [106] \"u\"           \"ul\"          \"var\"         \"video\"       \"wbr\"\nYou can use any of these functions by subsetting the tags list. For example to create an h1 header in HTML, run:\ntags$h1(\"My header\")\n## &lt;h1&gt;My header&lt;/h1&gt; \nSome tags functions come with a helper function that makes accessing them easier. For example, the shiny::h1 function is a wrapper for tags$h1.\nHowever, you can access many of the functions in tags only through tags because they share a name with a common R function.\nThe glossary below explains what the most popular tag functions do. The tag functions that do not appear here are less popular, but still useful. You can look them up at an HTML documentation site such as w3schools.\n\nNote about non-standard attribute names\nLike in all R code, if you need to use a non-standard argument or variable name, you will also need to use backticks around it. This can come up for attribute names, since a few of these will include dashes. For example, the following code will not work:\ntags$div(data-value = \"test\")      # bad\n## Error: unexpected '=' in \"tags$div(data-value =\"\nHere‚Äôs the correct version:\ntags$div(`data-value` = \"test\")    # good\n## &lt;div data-value=\"test\"&gt;&lt;/div&gt;\n\n\na\nCreates a link to a web page. You can access the ‚Äúa‚Äù tag with the helper function a.\n\n\n\nCommon Attributes\nDescription\n\n\n\n\nhref\nthe address of the web page to link to\n\n\n\ntags$a(href=\"www.rstudio.com\", \"Click here!\")\n## &lt;a href=\"www.rstudio.com\"&gt;Click here!&lt;/a&gt; \n\n\naudio\nAdds an audio element (e.g., a sound to your app).\n\n\n\n\n\n\n\nCommon Attributes\nDescription\n\n\n\n\nautoplay\nA valueless attribute. If present, audio starts playing automatically when loaded\n\n\ncontrols\nA valueless attribute. If present, play controls are displayed\n\n\nsrc\nThe location of the audio file to play\n\n\ntype\nThe type of file to play\n\n\n\ntags$audio(src = \"sound.mp3\", type = \"audio/mp3\", autoplay = NA, controls = NA)\n## &lt;audio src=\"sound.mp3\" type=\"audio/mp3\" autoplay controls&gt;&lt;/audio&gt;\n\n\nb\nCreates bold text.\ntags$b(\"This text is bold.\")\n## &lt;b&gt;This text is bold.&lt;/b&gt;\n\n\nblockquote\nCreates a block of quoted text. Usually it is displayed in a special way.\n\n\n\nCommon Attributes\nDescription\n\n\n\n\ncite\nthe source of the quote\n\n\n\ntags$blockquote(\"Tidy data sets are all the same. Each messy data set is messy in its own way.\", cite = \"Hadley Wickham\")\n## &lt;blockquote cite=\"Hadley Wickham\"&gt;Tidy data sets are all the same. Each messy data set is messy in its own way.&lt;/blockquote&gt;\n\n\nbr\nCreates a line break. You can use the helper function br.\ntags$div(\n  \"Some text followed by a break\", \n  tags$br(),\n  \"Some text following a break\"\n)\n## &lt;div&gt;\n##   Some text followed by a break\n##   &lt;br/&gt;\n##   Some text following a break\n## &lt;/div&gt;\n\n\ncode\nCreates text formatted as computer code. You can use the helper function code.\ntags$code(\"This text will be displayed as computer code.\")\n## &lt;code&gt;This text will be displayed as computer code.&lt;/code&gt; \n\n\ndiv\nCreates a section (e.g., ‚Äúdivision‚Äù) of an HTML document. divs provide a useful hook for CSS styling. You can use the helper function div.\n\n\n\n\n\n\n\nCommon Attributes\nDescription\n\n\n\n\nclass\nThe class of the div, a useful way to style the div with CSS\n\n\nid\nThe ID of the div, a useful way to style the div with CSS\n\n\nstyle\nCSS styling to apply to the div\n\n\n\ntags$code(\"This text will be displayed as computer code.\")\n## &lt;code&gt;This text will be displayed as computer code.&lt;/code&gt; \n\n\nem\nCreates emphasized (e.g., italicized) text. You can use the helper function em.\ntags$em(\"This text is emphasized.\")\n## &lt;em&gt;This text is emphasized.&lt;/em&gt;\n\n\nembed\nEmbed a plug-in or third party application.\n\n\n\nCommon Attributes\nDescription\n\n\n\n\nsrc\nThe source of the file to embed\n\n\ntype\nThe MIME type of the embedded content\n\n\nheight\nThe height of the embedded content\n\n\nwidth\nThe width of the embedded content\n\n\n\ntags$embed(src = \"animation.swf\")\n## &lt;embed src=\"animation.swf\"/&gt; \n\n\nh1, h2, h3, h4, h5, h6\nAdds hierarchical headings. h1 creates a first level heading and h2 through h6 create a hierarchy of decreasing subheadings. You can use the helper functions h1, h2, h3, h4, h5, h6.\ntags$div(\n    tags$h1(\"Heading\"), \n    tags$h2(\"Subheading\"), \n    tags$h3(\"Subsubheading\"), \n    tags$h4(\"Subsubsubheading\"), \n    tags$h5(\"Subsubsubsubheading\"), \n    tags$h6(\"Subsubsubsubsubheading\") \n)\n## &lt;div&gt;\n##   &lt;h1&gt;Heading&lt;/h1&gt;\n##   &lt;h2&gt;Subheading&lt;/h2&gt;\n##   &lt;h3&gt;Subsubheading&lt;/h3&gt;\n##   &lt;h4&gt;Subsubsubheading&lt;/h4&gt;\n##   &lt;h5&gt;Subsubsubsubheading&lt;/h5&gt;\n##   &lt;h6&gt;Subsubsubsubsubheading&lt;/h6&gt;\n## &lt;/div&gt; \n\n\nhr\nAdds a horizontal line (e.g., horizontal rule). You can use the helper function hr.\ntags$hr()\n## &lt;hr/&gt; \n\n\ni\nCreates italicized text.\ntags$i(\"This text is italicized.\")\n## &lt;i&gt;This text is italicized.&lt;/i&gt;\n\n\niframe\nCreates an inline frame to embed an HTML document in.\n\n\n\n\n\n\n\nCommon Attributes\nDescription\n\n\n\n\nsrc\nThe URL of the HTML document to embed\n\n\nsrcdoc\nA raw HTML document to embed\n\n\nscrolling\nShould iframe display scrollbars (yes, no, auto)\n\n\nseamless\nA valueless attribute. Should the iframe seem like part of the web page?\n\n\nheight\nThe height of the iframe\n\n\nwidth\nThe width of the iframe\n\n\nname\nThe name of the iframe\n\n\n\ntags$iframe(src = \"www.rstudio.com\", seamless=NA)\n## &lt;iframe src=\"www.rstudio.com\" seamless&gt;&lt;/iframe&gt;\n\n\nimg\nCreates an image. You can use the helper function img.\n\n\n\nCommon Attributes\nDescription\n\n\n\n\nsrc\nThe source of the image to embed\n\n\nheight\nThe height of the image\n\n\nwidth\nThe width of the image\n\n\n\ntags$img(src = \"www.rstudio.com\", width = \"100px\", height = \"100px\")\n## &lt;img src=\"www.rstudio.com\" width=\"100px\" height=\"100px\"/&gt;\n\n\nlink\nCreates a link to a separate document. Normally used with CSS style sheets.\n\n\nol and li\nCreate an ordered list (i.e., a numbered list).\ntags$ol(\n    tags$li(\"First list item\"), \n    tags$li(\"Second list item\"), \n    tags$li(\"Third list item\")\n)\n## &lt;ol&gt;\n##   &lt;li&gt;First list item&lt;/li&gt;\n##   &lt;li&gt;Second list item&lt;/li&gt;\n##   &lt;li&gt;Third list item&lt;/li&gt;\n## &lt;/ol&gt; \n\n\np\nCreate a paragraph (a block of text that begins on its own line). You can access the p tag with the helper function p too.\ntags$div(\n    tags$p(\"First paragraph\"), \n    tags$p(\"Second paragraph\"), \n    tags$p(\"Third paragraph\")\n)\n## &lt;div&gt;\n##   &lt;p&gt;First paragraph&lt;/p&gt;\n##   &lt;p&gt;Second paragraph&lt;/p&gt;\n##   &lt;p&gt;Third paragraph&lt;/p&gt;\n## &lt;/div&gt; \n\n\npre\nCreate pre-formatted text, text that looks like computer code. You can use the helper function pre.\ntags$pre(\"This text is preformatted.\")\n## &lt;pre&gt;This text is preformatted.&lt;/pre&gt;\n\n\nscript\nAdd a client-side script such as javascript. You must wrap the actual script in HTML to prevent it from being passed as text.\ntags$script(HTML(\"if (window.innerHeight &lt; 400) alert('Screen too small');\"))\n\n\nspan\nCreate a group of inline elements. Normally used to style a string of text. You can use the helper function span.\ntags$div(\n    HTML(paste(\"This text is \", tags$span(style=\"color:red\", \"red\"), sep = \"\"))\n)\n## &lt;div&gt;This text is &lt;span style=\"color:red\"&gt;red&lt;/span&gt;&lt;/div&gt;\n\n\nstrong\nCreate bold text. You can use the helper function strong.\ntags$strong(\"This text is strongly emphasized.\")\n## &lt;strong&gt;This text is strongly emphasized.&lt;/strong&gt;\n\n\nstyle\nCreate style specifications. A way to add CSS styles directly to your Shiny App.\n\n\nsub, sup\nCreate subscript or super script.\ntags$div(\n    HTML(paste(\"E = mc\", tags$sup(2), sep = \"\")), \n    HTML(paste(\"H\", tags$sub(2), \"0\", sep = \"\"))\n)\n## &lt;div&gt;\n##   E = mc&lt;sup&gt;2&lt;/sup&gt;\n##   H&lt;sub&gt;2&lt;/sub&gt;0\n## &lt;/div&gt;\n\n\nul and li\nCreate an unordered list (i.e., a list of bullet points).\ntags$ul(\n    tags$li(\"First list item\"), \n    tags$li(\"Second list item\"), \n    tags$li(\"Third list item\")\n)\n## &lt;ul&gt;\n##   &lt;li&gt;First list item&lt;/li&gt;\n##   &lt;li&gt;Second list item&lt;/li&gt;\n##   &lt;li&gt;Third list item&lt;/li&gt;\n## &lt;/ul&gt; \n\n\nvideo\nAdd a video.\n\n\n\n\n\n\n\nCommon Attributes\nDescription\n\n\n\n\nautoplay\nA valueless attribute. If present, video starts playing automatically when loaded\n\n\ncontrols\nA valueless attribute. If present, Shiny will display play controls.\n\n\nsrc\nThe location of the video file to play\n\n\nheight\nThe height of the video\n\n\nwidth\nThe width of the video\n\n\n\ntags$video(src = \"video.mp4\", type = \"video/mp4\", autoplay = NA, controls = NA)\n## &lt;video src=\"video.mp4\" type=\"video/mp4\" autoplay controls&gt;&lt;/video&gt;",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Shiny HTML Tags Glossary"
    ]
  },
  {
    "objectID": "r/articles/build/sql-injections/index.html",
    "href": "r/articles/build/sql-injections/index.html",
    "title": "SQL injection prevention",
    "section": "",
    "text": "INSTALLATION NOTE: You can get both shiny and DBI from CRAN:",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "SQL injection prevention"
    ]
  },
  {
    "objectID": "r/articles/build/sql-injections/index.html#motivation",
    "href": "r/articles/build/sql-injections/index.html#motivation",
    "title": "SQL injection prevention",
    "section": "Motivation",
    "text": "Motivation\nSQL injections are attacks to apps, in which the attacker exploits a security vulnerability to send whatever SQL statements they wish to the database. This concept was popularized in one funny xkcd comic:\n\n\n\nbobby-tables\n\n\nIn the Shiny app at the end of the previous article, there‚Äôs a security vulnerability because we paste input$nrows right into a query:\ndbGetQuery(conn, paste0(\n  \"SELECT * FROM City LIMIT \", input$nrows, \";\"))\nIf a malicious user manages to modify the input to accept something other than a number (possibly a string containing more SQL commands), we‚Äôd have no way to catch that and prevent it. In this case, the solution is very simple: just coerce input$nrows into an integer and, to be extra safe, grab the first element only (in case the user passed in a vector with more than one element). The relevant command then becomes:\ndbGetQuery(conn, paste0(\n  \"SELECT * FROM City LIMIT \", as.integer(input$nrows)[1], \";\"))",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "SQL injection prevention"
    ]
  },
  {
    "objectID": "r/articles/build/sql-injections/index.html#a-more-challenging-example",
    "href": "r/articles/build/sql-injections/index.html#a-more-challenging-example",
    "title": "SQL injection prevention",
    "section": "A more challenging example",
    "text": "A more challenging example\nIn general, however, the solution won‚Äôt be so easy. As the comic above illustrates, most injection attacks are due to some clever manipulation of a string. To make this concrete, consider a slightly different app. Imagine that this contains highly sensitive information about each city. Each city knows its own ID (let‚Äôs assume these are complicated and encrypted IDs, not a simple sequence), but none of the other IDs. If you were a malicious user trying to access other cities‚Äô information, you could try a brute-force attack. This would imply systematically checking all possible IDs until the correct ones are found. This would be hard enough (and take long enough) if you were just trying to access one of the cities. But what if you are really extra evil and want all the records? Take a look at the app:\n\nlibrary(shiny)\nlibrary(DBI)\n\nui &lt;- fluidPage(\n  textInput(\"ID\", \"Enter your ID:\", \"5\"),\n  tableOutput(\"tbl\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$tbl &lt;- renderTable({\n    conn &lt;- dbConnect(\n      drv = RMySQL::MySQL(),\n      dbname = \"shinydemo\",\n      host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",\n      username = \"guest\",\n      password = \"guest\")\n    on.exit(dbDisconnect(conn), add = TRUE)\n    query &lt;- paste0(\"SELECT * FROM City WHERE ID = '\", input$ID, \"';\")\n    dbGetQuery(conn, query)\n  })\n}\n\nshinyApp(ui, server)\n\nThe expected use of this app is that you will provide your city‚Äôs ID (ex: 5). Then, the app forms the query using your input (ex: SELECT * FROM City WHERE ID = '5';). Finally, this query returns a single row of data corresponding to your city. But if you type ' OR 1 = 1 OR ' in the input box, the query that is formed is: SELECT * FROM City WHERE ID = '' OR 1 = 1 OR '';. This returns the entire table, all 3427 rows. Congratulations ‚Äì you‚Äôve just performed a successful SQL injection! Let‚Äôs examine exactly what this query asked the database for. It is requesting all rows from the City table, for which at least one of the following conditions apply:\n\nthe ID field is equal to the empty string;\n1 = 1;\nthe empty string.\n\nObviously, 1 = 1 is always true, so that condition applies to all rows in the table and the query returns them all. The first and third condition will always be false (there‚Äôs no city whose ID is the empty string, and the empty string by itself returns NULL), but that doesn‚Äôt matter because you only need one of these to be true. Those other conditions are only there to make the query semantically valid. The purpose of the first condition is simply to close the single quote, so that 1 = 1 is evaluated as SQL code (rather than being inside of the string literal, which would be useless for us). The purpose of the third condition is the reverse: to open the single quote, so that the final quote that is hardcoded in the app is matched.\nNote that the trick we used the first time (coercing the input to the expected class) won‚Äôt work here. In fact, this is a semantically correct string, and it is meant to be a string. What we really want to do is to prevent the user from adding single quotes at will. While we cannot actually prevent the user from entering whatever they wish, we can (and should!) always sanitize their inputs. In this case, this means making sure that any potential single quotes are double escaped (i.e.¬†add another single quote immediately after it).\n\nThe solution: sqlInterpolate()\nWith the latest release of DBI, we have a new function sqlInterpolate(), whose purpose is to safely interpolate values into an SQL string, therefore protecting you from injection attacks. If you substitute the query line in the app above by the following two lines, and enter the same input as before (' OR 1 = 1 OR '), you will get an empty table back (as you should):\nsql &lt;- \"SELECT * FROM City WHERE ID = ?id ;\"\nquery &lt;- sqlInterpolate(conn, sql, id = input$ID)\nThis is because the query that is generated has changed from SELECT * FROM City WHERE ID = '' OR 1 = 1 OR ''; to the SQL-injection safe SELECT * FROM City WHERE ID = ''' OR 1 = 1 OR ''' ;. If you just enter a valid ID, however, the query stays the same (since there‚Äôs nothing to escape). Ex: In you enter 5, the query is SELECT * FROM City WHERE ID = '5' ;.\nThe sqlInterpolate() function takes two mandatory arguments (the connection and the SQL string x number of variables to interpolate) and x number of named values to interpolate into the query. In order for this to work, the SQL string must include placeholders for all the values that you want to interpolate: these are the variables, and each must start with a question mark (in the example above, our SQL string only contains one variable, ?id). Then you must specify the value of each variable as a separate argument to sqlInterpolate() (in our example, id = input$ID). The function will sanitize all the values and then place them in the appropriate place in the original SQL string. The result of this operation becomes the actual SQL query used later on.\nImagine that you want to let the user select three cities ‚Äì you just just add more variables (and the corresponding values) to interpolate:\n\nlibrary(shiny)\nlibrary(DBI)\n\nui &lt;- fluidPage(\n  p(\"Enter up to three IDs:\"),\n  textInput(\"ID1\", \"First ID:\", \"5\"),\n  textInput(\"ID2\", \"Second ID:\", \"\"),\n  textInput(\"ID3\", \"Third ID:\", \"\"),\n  tableOutput(\"tbl\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$tbl &lt;- renderTable({\n    conn &lt;- dbConnect(\n      drv = RMySQL::MySQL(),\n      dbname = \"shinydemo\",\n      host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",\n      username = \"guest\",\n      password = \"guest\")\n    on.exit(dbDisconnect(conn), add = TRUE)\n    sql &lt;- \"SELECT * FROM City WHERE ID = ?id1 OR ID = ?id2 OR ID = ?id3;\"\n    query &lt;- sqlInterpolate(conn, sql, id1 = input$ID1,\n                            id2 = input$ID2, id3 = input$ID3)\n    dbGetQuery(conn, query)\n  })\n}\n\nshinyApp(ui, server)\n\nAs is, this app produces the query SELECT * FROM City WHERE ID = '5' OR ID = '' OR ID = '';, which returns just the row corresponding to ID = '5'. If you add, a second valid ID (ex, 10), then it will produce the query SELECT * FROM City WHERE ID = '5' OR ID = '10' OR ID = '';, and returns a table with those two rows.\nIn summary, you should always sanitize your user-provided inputs. If they‚Äôre numbers, coerce them to the integer or the numeric class. If they‚Äôre strings that go into a SQL query, use sqlInterpolate(). If it‚Äôs something more complicated, make sure you process it in a way such that a SQL injection is impossible.",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "SQL injection prevention"
    ]
  },
  {
    "objectID": "r/articles/build/shinyjs/index.html",
    "href": "r/articles/build/shinyjs/index.html",
    "title": "JavaScript actions packaged for Shiny apps",
    "section": "",
    "text": "The shinyjs package lets you perform common useful JavaScript operations in Shiny apps that will greatly improve your apps without having to know any JavaScript.\nExamples include: hiding an element, disabling an input, resetting an input back to its original value, delaying code execution by a few seconds, and many more useful functions for both the end user and the developer. shinyjs can also be used to easily call your own custom JavaScript functions from R.\nThis demo app lets you play around with some of the functionality in shinyjs.\nYou can find out more about shinyjs on the package website and in the package repo.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "JavaScript actions packaged for Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/build/selecting-rows-of-data/index.html",
    "href": "r/articles/build/selecting-rows-of-data/index.html",
    "title": "Selecting rows of data",
    "section": "",
    "text": "A common use of mouse interactions is to select rows of data from an input data frame. Although you could write code that uses the x and y (or the corresponding min and max) values to filter rows from the data frame, there is an easier way to do it. Shiny provides two convenience functions for selecting rows of data:\n\nnearPoints(): Uses the x and y value from the interaction data; to be used with click, dblclick, and hover.\nbrushedPoints(): Uses the xmin, xmax, ymin, and ymax values from the interaction data; to be used with brush.\n\nNote that these functions are only appropriate if the x and y variables are present in the data frame, without any transformation. If, for example, you have a plot where a the x position is calculated from a column of data, then these functions won‚Äôt work. In such a case, it may be useful to first calculate a new column and store it in the data frame.\n\nSelection with nearPoints()\nHere is a basic example of the nearPoints function. If you pass it the data frame with the plotted data, the mouse interaction object from input, and the names of the x and y variables, it will return a data frame with just selected rows (to see it in action, click near a point the plot area of the app rendered below the code):\nui &lt;- basicPage(\n  plotOutput(\"plot1\", click = \"plot_click\"),\n  verbatimTextOutput(\"info\")\n)\n\nserver &lt;- function(input, output) {\n  output$plot1 &lt;- renderPlot({\n    plot(mtcars$wt, mtcars$mpg)\n  })\n\n  output$info &lt;- renderPrint({\n    # With base graphics, need to tell it what the x and y variables are.\n    nearPoints(mtcars, input$plot_click, xvar = \"wt\", yvar = \"mpg\")\n    # nearPoints() also works with hover and dblclick events\n  })\n}\n\nshinyApp(ui, server)\n\n\nBy default, nearPoints will return all rows of data that are within 5 pixels of the mouse event, and they will be sorted by distance, with the nearest first. The radius can be customized with threshold, and the number of rows returned can be customized with maxpoints.\nIf you‚Äôre using plots created by ggplot2, it‚Äôs not necessary to specify xvar and yvar, since they can be autodetected. (Bear in mind that if the variables are calculated from the data ‚Äì for example with aes(x = wt/2) ‚Äì this won‚Äôt work.)\nThe version below uses a plot with ggplot2, and displays the one point that is closest to the click, and within 10 pixels:\nlibrary(ggplot2)\nui &lt;- basicPage(\n  plotOutput(\"plot1\", click = \"plot_click\"),\n  verbatimTextOutput(\"info\")\n)\n\nserver &lt;- function(input, output) {\n  output$plot1 &lt;- renderPlot({\n    ggplot(mtcars, aes(x=wt, y=mpg)) + geom_point()\n  })\n\n  output$info &lt;- renderPrint({\n    # With ggplot2, no need to tell it what the x and y variables are.\n    # threshold: set max distance, in pixels\n    # maxpoints: maximum number of rows to return\n    # addDist: add column with distance, in pixels\n    nearPoints(mtcars, input$plot_click, threshold = 10, maxpoints = 1,\n               addDist = TRUE)\n  })\n}\n\nshinyApp(ui, server)\n\n\n\n\nSelection with brushedPoints()\nTo select rows using a brush, use the brushedPoints() function. Basic usage is similar to nearPoints(): it returns the rows of data that are under the brush.\nui &lt;- basicPage(\n  plotOutput(\"plot1\", brush = \"plot_brush\"),\n  verbatimTextOutput(\"info\")\n)\n\nserver &lt;- function(input, output) {\n  output$plot1 &lt;- renderPlot({\n    plot(mtcars$wt, mtcars$mpg)\n  })\n\n  output$info &lt;- renderPrint({\n    # With base graphics, need to tell it what the x and y variables are.\n    brushedPoints(mtcars, input$plot_brush, xvar = \"wt\", yvar = \"mpg\")\n  })\n}\n\nshinyApp(ui, server)\n\n\nWith ggplot2 graphics, you don‚Äôt need to supply xvar and yvar because they can be inferred automatically. Also, brushedPoints() and nearPoints() both work with facets in ggplot2.\nlibrary(ggplot2)\nui &lt;- basicPage(\n  plotOutput(\"plot1\", brush = \"plot_brush\", height = 250),\n  verbatimTextOutput(\"info\")\n)\n\nserver &lt;- function(input, output) {\n  output$plot1 &lt;- renderPlot({\n    ggplot(mtcars, aes(x=wt, y=mpg)) + geom_point() +\n      facet_grid(. ~ cyl) +\n      theme_bw()\n  })\n\n  output$info &lt;- renderPrint({\n    brushedPoints(mtcars, input$plot_brush)\n  })\n}\n\nshinyApp(ui, server)\n\n\n\n\nGetting the position of selected rows\nInstead of getting just the selected rows, it‚Äôs sometimes useful to get all the rows, but with a column indicating which rows are selected. For both nearPoints() and brushedPoints(), you can do this with the allRows option.\nlibrary(ggplot2)\nui &lt;- basicPage(\n  plotOutput(\"plot1\", brush = \"plot_brush\"),\n  verbatimTextOutput(\"info\")\n)\n\nserver &lt;- function(input, output) {\n  options(width = 100) # Increase text width for printing table\n  output$plot1 &lt;- renderPlot({\n    ggplot(mtcars, aes(x=wt, y=mpg)) + geom_point()\n  })\n\n  output$info &lt;- renderPrint({\n    brushedPoints(mtcars, input$plot_brush, allRows = TRUE)\n  })\n}\n\nshinyApp(ui, server)\n\n\nThis can be useful if you need the row position of the selected points. For example, this can be used to allow clicking on points to exclude them from an analysis, as in this example where you can exclude points from a linear model.\n\n\nOptions\nMouse interactions have default settings that are suitable for most use cases, but these settings can also be customized.\nTo do this, for the click, dblclick, hover, and brush options, instead of passing them a string, you would pass them the value from clickOpts(), dblclickOpts(), hoverOpts(), or brushOpts().\nFor example, by default, a brush is a light transparent blue, and it can be controlled in both the vertical and horizontal directions. In the code below, using the brushOpts() function, we use the same input ID as before, \"plot_brush\", but now we can set the fill color to a light gray, and make the brush operate just in the horizontal direction.\nlibrary(ggplot2)\nui &lt;- basicPage(\n  plotOutput(\"plot1\",\n    brush = brushOpts(id = \"plot_brush\", fill = \"#ccc\", direction = \"x\"),\n    height = 250\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$plot1 &lt;- renderPlot({\n    ggplot(ChickWeight, aes(x=Time, y=weight, colour=factor(Chick))) +\n      geom_line() +\n      guides(colour=FALSE) +\n      theme_bw()\n  })\n}\n\nshinyApp(ui, server)\n\n\nFor more information about the available options, see ?clickOpts, ?dblclickOpts, ?hoverOpts, and ?brushOpts.\nNext: learn about advanced plot interaction features.",
    "crumbs": [
      "Build",
      "Frontend",
      "Graphics & visualization",
      "Selecting rows of data"
    ]
  },
  {
    "objectID": "r/articles/build/rmarkdown/index.html",
    "href": "r/articles/build/rmarkdown/index.html",
    "title": "Introduction to R Markdown",
    "section": "",
    "text": "Interactive documents are a new way to build Shiny apps. An interactive document is an R Markdown file that contains Shiny widgets and outputs. You write the report in markdown, and then launch it as an app with the click of a button.\nThis article will show you how to write an R Markdown report.\nThe companion article, Introduction to interactive documents, will show you how to turn an R Markdown report into an interactive document with Shiny components.\nThe file demonstrates how to use markdown to indicate:",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "Introduction to R Markdown"
    ]
  },
  {
    "objectID": "r/articles/build/rmarkdown/index.html#r-markdown",
    "href": "r/articles/build/rmarkdown/index.html#r-markdown",
    "title": "Introduction to R Markdown",
    "section": "R Markdown",
    "text": "R Markdown\nR Markdown is a file format for making dynamic documents with R. An R Markdown document is written in markdown (an easy-to-write plain text format) and contains chunks of embedded R code, like the document below.\n---\ntitle: R Markdown\noutput: html_document\n---\n\nThis is an R Markdown document. Markdown is a simple formatting syntax which allows you to author HTML, PDF, and MS Word documents. For more details on how to use R Markdown, see &lt;http://rmarkdown.rstudio.com&gt;.\n\nWhen you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:\n\n```{r}\nsummary(cars)\n```\n\nYou can also embed plots:\n\n```{r, echo=FALSE}\nplot(cars)\n```\n\nNote that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.\nR Markdown files are designed to be used with the rmarkdown package. rmarkdown comes installed with the RStudio IDE, but you can acquire your own copy of rmarkdown from github with the command\n```{r}\ndevtools:install_github(\"rmarkdown\", \"rstudio\")\n```\nR Markdown files are the source code for rich, reproducible documents. You can transform an R Markdown file in two ways.\n\nknit - You can knit the file. The rmarkdown package will call the knitr package. knitr will run each chunk of R code in the document and append the results of the code to the document next to the code chunk. This workflow saves time and facilitates reproducible reports.\nConsider how authors typically include graphs (or tables, or numbers) in a report. The author makes the graph, saves it as a file, and then copy and pastes it into the final report. This process relies on manual labor. If the data changes, the author must repeat the entire process to update the graph.\nIn the R Markdown paradigm, each report contains the code it needs to make its own graphs, tables, numbers, etc. The author can automatically update the report by re-knitting.\nconvert - You can convert the file. The rmarkdown package will use the pandoc program to transform the file into a new format. For example, you can convert your .Rmd file into an HTML, PDF, or Microsoft Word file. You can even turn the file into an HTML5 or PDF slideshow. rmarkdown will preserve the text, code results, and formatting contained in your original .Rmd file.\nConversion lets you do your original work in markdown, which is very easy to use. You can include R code to knit, and you can share your document in a variety of formats.\n\nIn practice, authors almost always knit and convert their documents at the same time. In this article, I will use the term render to refer to the two step process of knitting and converting an R Markdown file.\nYou can manually render an R Markdown file with rmarkdown::render(). This is what the above document looks like when rendered as a HTML file.\n\nIn practice, you do not need to call rmarkdown::render(). You can use a button in the RStudio IDE to render your reprt. R Markdown is heavily integrated into the RStudio IDE.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "Introduction to R Markdown"
    ]
  },
  {
    "objectID": "r/articles/build/rmarkdown/index.html#getting-started",
    "href": "r/articles/build/rmarkdown/index.html#getting-started",
    "title": "Introduction to R Markdown",
    "section": "Getting started",
    "text": "Getting started\nTo create an R Markdown report, open a plain text file and save it with the extension .Rmd. You can open a plain text file in your scripts editor by clicking File &gt; New File &gt; Text File in the RStudio toolbar.\n\nBe sure to save the file with the extension .Rmd. The RStudio IDE enables several helpful buttons when you save the file with the .Rmd extension. You can save your file by clicking File &gt; Save in the RStudio toolbar.\n\nR Markdown reports rely on three frameworks\n\nmarkdown for formatted text\nknitr for embedded R code\nYAML for render parameters\n\nThe sections below describe each framework.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "Introduction to R Markdown"
    ]
  },
  {
    "objectID": "r/articles/build/rmarkdown/index.html#markdown-for-formatted-text",
    "href": "r/articles/build/rmarkdown/index.html#markdown-for-formatted-text",
    "title": "Introduction to R Markdown",
    "section": "Markdown for formatted text",
    "text": "Markdown for formatted text\n.Rmd files are meant to contain text written in markdown. Markdown is a set of conventions for formatting plain text. You can use markdown to indicate\n\nbold and italic text\nlists\nheaders (e.g., section titles)\nhyperlinks\nand much more\n\nThe conventions of markdown are very unobtrusive, which make Markdown files easy to read. The file below uses several of the most useful markdown conventions.\n# Say Hello to markdown\n\nMarkdown is an **easy to use** format for writing reports. It resembles what you naturally write every time you compose an email. In fact, you may have already used markdown *without realizing it*. These websites all rely on markdown formatting\n\n* [Github](https://www.github.com)\n* [StackOverflow](https://stackoverflow.com/)\n* [Reddit](www.reddit.com)",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "Introduction to R Markdown"
    ]
  },
  {
    "objectID": "r/articles/build/rmarkdown/index.html#knitr-for-embedded-r-code",
    "href": "r/articles/build/rmarkdown/index.html#knitr-for-embedded-r-code",
    "title": "Introduction to R Markdown",
    "section": "knitr for embedded R code",
    "text": "knitr for embedded R code\nThe knitr package extends the basic markdown syntax to include chunks of executable R code.\nWhen you render the report, knitr will run the code and add the results to the output file. You can have the output display just the code, just the results, or both.\nTo embed a chunk of R code into your report, surround the code with two lines that each contain three backticks. After the first set of backticks, include {r}, which alerts knitr that you have included a chunk of R code. The result will look like this\nHere's some code\n```{r}\ndim(iris)\n```\nWhen you render your document, knitr will run the code and append the results to the code chunk. knitr will provide formatting and syntax highlighting to both the code and its results (where appropriate).\nAs a result, the markdown snippet above will look like this when rendered (to HTML).\n\nTo omit the results from your final report (and not run the code) add the argument eval = FALSE inside the brackets and after r. This will place a copy of your code into the report.\n\nTo omit the code from the final report (while including the results) add the argument echo = FALSE. This will place a copy of the results into your report.\n\necho = FALSE is very handy for adding plots to a report, since you usually do not want to see the code that generates the plot.\n\necho and eval are not the only arguments that you can use to customize code chunks. You can learn more about formatting the output of code chunks at the rmarkdown and knitr websites.\n\nInline code\nTo embed R code in a line of text, surround the code with a pair of backticks and the letter r, like this.\nTwo plus two equals `r 2 + 2`.\nknitr will replace the inline code with its result in your final document (inline code is always replaced by its result). The result will appear as if it were part of the original text. For example, the snippet above will appear like this:",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "Introduction to R Markdown"
    ]
  },
  {
    "objectID": "r/articles/build/rmarkdown/index.html#yaml-for-render-parameters",
    "href": "r/articles/build/rmarkdown/index.html#yaml-for-render-parameters",
    "title": "Introduction to R Markdown",
    "section": "YAML for render parameters",
    "text": "YAML for render parameters\nYou can use a YAML header to control how rmarkdown renders your .Rmd file. A YAML header is a section of key: value pairs surrounded by --- marks, like below\n---\ntitle: \"Untitled\"\nauthor: \"Garrett\"\ndate: \"July 10, 2014\"\noutput: html_document\n---\n\nSome inline R code, `r 2 + 2`.\nThe output: value determines what type of output to convert the file into when you call rmarkdown::render(). Note: you do not need to specify output: if you render your file with the RStudio IDE knit button.\noutput: recognizes the following values:\n\nhtml_document, which will create HTML output (default)\npdf_document, which will create PDF output\nword_document, which will create Word output\n\nIf you use the RStudio IDE knit button to render your file, the selection you make in the gui will override the output: setting.\n\nSlideshows\nYou can also use the output: value to render your document as a slideshow.\n\noutput: ioslides_presentation will create an ioslides (HTML5) slideshow\noutput: beamer_presentation will create a beamer (PDF) slideshow\n\nNote: The knit button in the RStudio IDE will update to show slideshow options when you include one of the above output values and save your .Rmd file.\nrmarkdown will convert your document into a slideshow by starting a new slide at each header or horizontal rule (e.g., ***).\nVisit rmakdown.rstudio.com to learn about more YAML options that control the render process.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "Introduction to R Markdown"
    ]
  },
  {
    "objectID": "r/articles/build/rmarkdown/index.html#recap",
    "href": "r/articles/build/rmarkdown/index.html#recap",
    "title": "Introduction to R Markdown",
    "section": "Recap",
    "text": "Recap\nR Markdown documents provide quick, reproducible reporting from R. You write your document in markdown and embed executable R code chunks with the knitr syntax.\nYou can update your document at any time by re-knitting the code chunks.\nYou can then convert your document into several common formats.\nR Markdown documents implement Donald‚Äôs Knuth‚Äôs idea of literate programming and take the manual labor out of writing and maintaining reports. Moreover, they are quick to learn. You already know ecnough about markdown, knitr, and YAML to begin writing your own R Markdown reports.\nIn the next article, Introduction to interactive documents, you will learn how to add interactive Shiny components to an R Markdown report. This creates a quick workflow for writing light-weight Shiny apps.\nTo learn more about R Markdown and interactive documents, please visit rmarkdown.rstudio.com.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "Introduction to R Markdown"
    ]
  },
  {
    "objectID": "r/articles/build/render-table/index.html",
    "href": "r/articles/build/render-table/index.html",
    "title": "Displaying and customizing static tables",
    "section": "",
    "text": "The renderTable app demonstrates how to use the improved renderTable() Shiny function.\n\n\n\nrenderTable Screenshot\n\n\nLike its predecessor, renderTable()should be used to render static tables in a Shiny app or a runtime: shiny document. However, the resulting table is now neater and more in line with Bootstrap table styles (you can see the differences between the two default implementations in the image above). In addition, you can also customize the table to a much greater extent than before.\nThe most basic use of renderTable() remains the same: renderTable({ yourData }). In addition, you might have passed some arguments to xtable() and print.xtable() through the ... argument. These will still work. But it is worth to note that many of the arguments you may have used (e.g.¬†align, digits, width) are now made explicit as direct arguments to renderTable(). Even if you didn‚Äôt use any extra aguments, however, the finished look of your table will be quite a bit different, as the image above shows. By default:\n\nthe table‚Äôs width is as small as possible, with only some padding between columns;\nthe row numbers are ommited;\nonly the cells‚Äô top border remains;\ncolumn headers‚Äô and column values‚Äô alignments match;\nNA values are shown in gray;\nthe height of each row is slightly smaller.\n\nBut if you don‚Äôt like these, fret not! All of these are customizable. Take a look at the documentation, or better yet, the interactive demo app, to experiment with all of the new renderTable() arguments.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Displaying and customizing static tables"
    ]
  },
  {
    "objectID": "r/articles/build/progress/index.html",
    "href": "r/articles/build/progress/index.html",
    "title": "Progress indicators",
    "section": "",
    "text": "If your Shiny app contains computations that take a long time to complete, a progress bar can improve the user experience by communicating how far along the computation is, and how much is left. Progress bars were added in Shiny 0.10.2. In Shiny 0.14, they were changed to use the notifications system, although the previous styling can be used (see the Old style progress bars section below).\nTo see progress bars in action, see this app in the gallery.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Progress indicators"
    ]
  },
  {
    "objectID": "r/articles/build/progress/index.html#adding-a-progress-indicator",
    "href": "r/articles/build/progress/index.html#adding-a-progress-indicator",
    "title": "Progress indicators",
    "section": "Adding a progress indicator",
    "text": "Adding a progress indicator\nThe simplest way to add a progress indicator is to put withProgress() inside of the reactive(), observer(), or renderXx() function that contains the long-running computation. In this example, we‚Äôll simulate a long computation by creating an empty data frame and then adding one row to it every 0.1 seconds. (Note that this example is written as a single-file app). To run this, you can copy and paste the code into the R console.)\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    input$goPlot # Re-run when button is clicked\n\n    # Create 0-row data frame which will be used to store data\n    dat &lt;- data.frame(x = numeric(0), y = numeric(0))\n\n    withProgress(message = 'Making plot', value = 0, {\n      # Number of times we'll go through the loop\n      n &lt;- 10\n\n      for (i in 1:n) {\n        # Each time through the loop, add another row of data. This is\n        # a stand-in for a long-running computation.\n        dat &lt;- rbind(dat, data.frame(x = rnorm(1), y = rnorm(1)))\n\n        # Increment the progress bar, and update the detail text.\n        incProgress(1/n, detail = paste(\"Doing part\", i))\n\n        # Pause for 0.1 seconds to simulate a long computation.\n        Sys.sleep(0.1)\n      }\n    })\n\n    plot(dat$x, dat$y)\n  })\n}\n\nui &lt;- shinyUI(basicPage(\n  plotOutput('plot', width = \"300px\", height = \"300px\"),\n  actionButton('goPlot', 'Go plot')\n))\n\nshinyApp(ui = ui, server = server)\nThis is what will happen:\nThe withProgress() function is used to start a progress bar, and then the value is incremented with incProgress(). By default, the range of values for the bar goes from 0 to 1, although this can be changed with the min and max arguments.\nThere are two levels of messages: message, and detail. The message is presented in bold, and the detail is presented in normal-weight text.\n\nIn the example above, withProgress() is used inside of renderPlot(), but it could also be used inside of any other render function, like renderTable(), or inside of a reactive().\nIt‚Äôs possible to nest calls to withProgress; if you do this, the second-level progress bar will appear directly under the top-level progress bar, and the second-level text will appear under the top-level text. Further levels of nesting will have a similar pattern.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Progress indicators"
    ]
  },
  {
    "objectID": "r/articles/build/progress/index.html#using-a-progress-object",
    "href": "r/articles/build/progress/index.html#using-a-progress-object",
    "title": "Progress indicators",
    "section": "Using a Progress object",
    "text": "Using a Progress object\nThe withProgress() function is a convenient interface around a Progress object. In most cases, it‚Äôs simpler and easier to use withProgress, but in some cases, you may need the greater level of control provided by the Progress object. Before we delve into a more complex example, we‚Äôll simply convert the example above from using withProgress to using a Progress object.\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    input$goPlot # Re-run when button is clicked\n\n    # Create 0-row data frame which will be used to store data\n    dat &lt;- data.frame(x = numeric(0), y = numeric(0))\n\n    # Create a Progress object\n    progress &lt;- shiny::Progress$new()\n    # Make sure it closes when we exit this reactive, even if there's an error\n    on.exit(progress$close())\n\n    progress$set(message = \"Making plot\", value = 0)\n\n    # Number of times we'll go through the loop\n    n &lt;- 10\n\n    for (i in 1:n) {\n      # Each time through the loop, add another row of data. This is\n      # a stand-in for a long-running computation.\n      dat &lt;- rbind(dat, data.frame(x = rnorm(1), y = rnorm(1)))\n\n      # Increment the progress bar, and update the detail text.\n      progress$inc(1/n, detail = paste(\"Doing part\", i))\n\n      # Pause for 0.1 seconds to simulate a long computation.\n      Sys.sleep(0.1)\n    }\n\n    plot(dat$x, dat$y)\n  })\n}\n\nui &lt;- shinyUI(basicPage(\n  plotOutput('plot', width = \"300px\", height = \"300px\"),\n  actionButton('goPlot', 'Go plot')\n))\n\nshinyApp(ui = ui, server = server)\nNotice that we need to explicitly create the progress object and make sure that it closes properly, using on.exit().",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Progress indicators"
    ]
  },
  {
    "objectID": "r/articles/build/progress/index.html#a-more-complex-progress-example",
    "href": "r/articles/build/progress/index.html#a-more-complex-progress-example",
    "title": "Progress indicators",
    "section": "A more complex Progress example",
    "text": "A more complex Progress example\nIn the example below, the renderTable() calls out to another function, compute_data(), to do the long-running computation. If we were to just update the progress indicator before and after compute_data() were called, then it would only be updated at the beginning, when nothing has been done yet, and at the end, when the computation is completed. In some cases, the best we can do may be to set it to a starting value of, say, 0.3, and then move it to 1 at completion. This may be true if, for example, the function is in an external package.\nHowever, if you do have control over the function doing the computation, you may want to modify it to accept either a Progress object which it will update directly, or to accept a function which it calls each time it does some part of the computation.\nIn the example below, we‚Äôll take the latter approach. The compute_data() function accepts an optional updateProgress function, which it calls periodically as it does the computation. The updateProgress function is a closure that captures the Progress object; each time it‚Äôs called, it updates the progress indicator.\nAgain, you can copy and paste this code in your R console to see it in action:\n# This function computes a new data set. It can optionally take a function,\n# updateProgress, which will be called as each row of data is added.\ncompute_data &lt;- function(updateProgress = NULL) {\n  # Create 0-row data frame which will be used to store data\n  dat &lt;- data.frame(x = numeric(0), y = numeric(0))\n\n  for (i in 1:10) {\n    Sys.sleep(0.25)\n  \n    # Compute new row of data\n    new_row &lt;- data.frame(x = rnorm(1), y = rnorm(1))\n\n    # If we were passed a progress update function, call it\n    if (is.function(updateProgress)) {\n      text &lt;- paste0(\"x:\", round(new_row$x, 2), \" y:\", round(new_row$y, 2))\n      updateProgress(detail = text)\n    }\n\n    # Add the new row of data\n    dat &lt;- rbind(dat, new_row)\n  }\n\n  dat\n}\n\n\nserver &lt;- function(input, output) {\n  output$table &lt;- renderTable({\n    input$goTable\n\n    # Create a Progress object\n    progress &lt;- shiny::Progress$new()\n    progress$set(message = \"Computing data\", value = 0)\n    # Close the progress when this reactive exits (even if there's an error)\n    on.exit(progress$close())\n    \n    # Create a callback function to update progress.\n    # Each time this is called:\n    # - If `value` is NULL, it will move the progress bar 1/5 of the remaining\n    #   distance. If non-NULL, it will set the progress to that value.\n    # - It also accepts optional detail text.\n    updateProgress &lt;- function(value = NULL, detail = NULL) {\n      if (is.null(value)) {\n        value &lt;- progress$getValue()\n        value &lt;- value + (progress$getMax() - value) / 5\n      }\n      progress$set(value = value, detail = detail)\n    }\n\n    # Compute the new data, and pass in the updateProgress function so\n    # that it can update the progress indicator.\n    compute_data(updateProgress)\n  })\n}\n\nui &lt;- shinyUI(basicPage(\n  tableOutput('table'),\n  actionButton('goTable', 'Go table')\n))\n\nshinyApp(ui = ui, server = server)\nIt‚Äôs possible to use other constructions for the updateProgress function that have different behavior. In the example above, each time updateProgress() is called, the progress bar moves 1/5 of the remaining distance. This tells the user that something is happening, and it‚Äôs simple because you don‚Äôt need to know ahead of time how many times it‚Äôs goingto run. However, it‚Äôs not the most accurate representation of progress, since it approaches the end asymptotically, whereas a linear approach would be more accurate.\nOne alternative is to have the external function call updateProgress() with a specific value. If, for example, the external function knows that it will iterate over the loop 100 times, it could call updateProgress() with value=0.01, then value=0.02, and so on.\nAnother alternative is to construct a different updateProgress callback, one which increments by a fixed amount each time. To do this, before you call compute_data(), you must know how many times it will call updateProgress() in the loop. Let‚Äôs assume that it will be called 20 times. Then updateProgress could be defined like so:\n    n &lt;- 20\n    updateProgress &lt;- function(detail = NULL) {\n      progress$inc(amount = 1/n, detail = detail)\n    }\nEach time this version of updateProgress() is called, it moves the bar 1/20th of the total distance.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Progress indicators"
    ]
  },
  {
    "objectID": "r/articles/build/progress/index.html#old-style-progress-bars",
    "href": "r/articles/build/progress/index.html#old-style-progress-bars",
    "title": "Progress indicators",
    "section": "Old style progress bars",
    "text": "Old style progress bars\nIn Shiny 0.14, the progress bars switched to Shiny‚Äôs notification API. However, if you created application that used the old progress bars and had custom styling with CSS, you will need to use the old style output to keep the custom styling. This can be done with by calling withProgress() or Progress$new() with the argument style=\"old\". For an example, see the example app.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Progress indicators"
    ]
  },
  {
    "objectID": "r/articles/build/progress/index.html#recap",
    "href": "r/articles/build/progress/index.html#recap",
    "title": "Progress indicators",
    "section": "Recap",
    "text": "Recap\nYou can add progress indicators to your app, using the simpler withProgress() interface, or the Progress object if you need more control. These progress indicators can provide feedback to the user that will make their experience more satisfying.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Progress indicators"
    ]
  },
  {
    "objectID": "r/articles/build/pool-basics/index.html#installation",
    "href": "r/articles/build/pool-basics/index.html#installation",
    "title": "Using the pool package (basics)",
    "section": "Installation",
    "text": "Installation\nYou can get both shiny and DBI from CRAN, but you must get pool from GitHub (since it‚Äôs not yet on CRAN):\ninstall.packages(\"shiny\")\ninstall.packages(\"DBI\")\n\n# get pool from GitHub, since it's not yet on CRAN\ndevtools::install_github(\"rstudio/pool\")",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Using the pool package (basics)"
    ]
  },
  {
    "objectID": "r/articles/build/pool-basics/index.html#motivation",
    "href": "r/articles/build/pool-basics/index.html#motivation",
    "title": "Using the pool package (basics)",
    "section": "Motivation",
    "text": "Motivation\nNow that you know how to use DBI, it‚Äôs time to talk about some possible problems ‚Äì in particular, connection management and performance. To make it as easy as possible for you not to run into problems (or even having to worry about their existence), there is a brand new package, pool, that takes care of this. This adds a new level of abstraction when connecting to a database: instead of directly fetching a connection from the database, you will create an object (called a pool) with a reference to that database. The pool holds a number of connections to the database. Some of these may be currently in-use and some of these may be idle, waiting for a query to request them. Each time you make a query, you are querying the pool, rather than the database. Under the hood, the pool will either give you an idle connection that it previously fetched from the database or, if it has no free connections, fetch one and give it to you. You never have to create or close connections directly: the pool knows when it should grow, shrink or keep steady. You only need to close the pool when you‚Äôre done.\nNote: While you don‚Äôt leak connections if you use a pool, if you forget to close it, you leak the pool itself. However, you will usually just have one pool open, so you‚Äôll have at most one leaked pool at any time ‚Äì which is generally not true if you‚Äôre dealing directly with connections. Once you lose a reference to the pool, it will get garbage collected, destroying all associated resources. Unfortunately, there is no built-in support for closing a pool in a Shiny app (once all sessions have ended). So, for the context of using pool in a Shiny app, just don‚Äôt worry about closing the pool. It will get garbage collected once all sessions end, so in practical terms, it displays the same behavior as if you closed it. However, if you‚Äôre using pool in the console, you will probably want to close it once you‚Äôre done with it.\nThe following sections illustrate how creating a connection pool helps alleviate the problems of connection manage and performance. We also show code examples that achieve the same thing with and without a pool, to hopefully demonstrate how using a pool makes your life a lot easier.\nNote: The pool package is actually general enough to allow you to construct a pool of any kind of object, not just database connections. For more information on the package and its general usage, check out its github page.",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Using the pool package (basics)"
    ]
  },
  {
    "objectID": "r/articles/build/pool-basics/index.html#connection-management-and-performance",
    "href": "r/articles/build/pool-basics/index.html#connection-management-and-performance",
    "title": "Using the pool package (basics)",
    "section": "Connection management and performance",
    "text": "Connection management and performance\nWhen you‚Äôre connecting to a database, it is important to manage your connections: when to open them, how to keep track of them, when to close them. Depending on your purpose, you might choose different connection management models. In any case, the most important thing is to not leak connections: i.e.¬†leave a connection open once you no longer need it. Over time, leaked connections could accumulate and substantially slow down your app, as well as overwhelming the database itself. However, the frequency with which you open connections may legitimately vary from the extreme of just having one connection per app (potentially serving several sessions of the app) to the extreme of opening one connection for each query you make. Using pool offers you the happy middle ground ‚Äì it is safer, more robust and offers better overall performance, independently of your connection management model. Here‚Äôs a simple example of using a pool within a Shiny app:\nlibrary(shiny)\nlibrary(DBI)\nlibrary(pool)\n\npool &lt;- dbPool(\n  drv = RMySQL::MySQL(),\n  dbname = \"shinydemo\",\n  host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",\n  username = \"guest\",\n  password = \"guest\"\n)\n\nui &lt;- fluidPage(\n  textInput(\"ID\", \"Enter your ID:\", \"5\"),\n  tableOutput(\"tbl\"),\n  numericInput(\"nrows\", \"How many cities to show?\", 10),\n  plotOutput(\"popPlot\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$tbl &lt;- renderTable({\n    sql &lt;- \"SELECT * FROM City WHERE ID = ?id;\"\n    query &lt;- sqlInterpolate(pool, sql, id = input$ID)\n    dbGetQuery(pool, query)\n  })\n  output$popPlot &lt;- renderPlot({\n    query &lt;- paste0(\"SELECT * FROM City LIMIT \",\n                    as.integer(input$nrows)[1], \";\")\n    df &lt;- dbGetQuery(pool, query)\n    pop &lt;- df$Population\n    names(pop) &lt;- df$Name\n    barplot(pop)\n  })\n}\n\nshinyApp(ui, server)\nWhat we‚Äôre doing here is creating a pool at the start of the app (if you‚Äôre not using a single-file app, you could put this at the top of server.R or in global.R). Then, we reference that pool each time we make a query. By default, on creation, the pool fetches and keeps around one idle connection. When you make a query to the pool, it will always use that connection, unless it happens to already be busy in another query (this becomes more likely if you have several sessions going on at the same time). If that‚Äôs the case, the pool will fetch a second connection for the current query; once that‚Äôs finished, the pool with hold on to it for a minute (by default). If that second connection is requested again in that period of time, the countdown resets. Otherwise, the pool disconnects it. (See the next article for information about how to customize these features.) So basically, the pool ‚Äúknows‚Äù when it should have more connections and how to manage them (including disconnecting them when necessary).\nTo understand exactly why this logic is advantageous and how it compares to pool-less code, let‚Äôs consider the same app using the two extreme connection management models mentioned before (i.e.¬†only one connection per app vs.¬†one connection per query).\n\nOnly one connection per app\nLet‚Äôs consider the case of opening only one connection (without using the pool package). You could do this at the top of your server.R file (before the actual server function) or in global.R. Then, each query made in any session of the app refers to this one connection:\n\nlibrary(shiny)\nlibrary(DBI)\n\nconn &lt;- DBI::dbConnect(\n  drv = RMySQL::MySQL(),\n  dbname = \"shinydemo\",\n  host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",\n  username = \"guest\",\n  password = \"guest\"\n)\n\nui &lt;- fluidPage(\n  textInput(\"ID\", \"Enter your ID:\", \"5\"),\n  tableOutput(\"tbl\"),\n  numericInput(\"nrows\", \"How many cities to show?\", 10),\n  plotOutput(\"popPlot\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$tbl &lt;- renderTable({\n    sql &lt;- \"SELECT * FROM City WHERE ID = ?id;\"\n    query &lt;- sqlInterpolate(conn, sql, id = input$ID)\n    dbGetQuery(conn, query)\n  })\n  output$popPlot &lt;- renderPlot({\n    query &lt;- paste0(\"SELECT * FROM City LIMIT \",\n                    as.integer(input$nrows)[1], \";\")\n    df &lt;- dbGetQuery(conn, query)\n    pop &lt;- df$Population\n    names(pop) &lt;- df$Name\n    barplot(pop)\n  })\n}\n\nshinyApp(ui, server)\n\nThe advantages to this approach are that it is fast (because, in the whole app, you only fetch one connection) and your code is kept as simple as possible. The drawbacks include:\n\nsince there is only one connection, it cannot handle simultaneous requests (this is especially an issue if you have a complicated app or if you have more than one session open at any time);\nif the connection breaks at some point (maybe the database server crashed), you won‚Äôt get a new connection (you have to exit the app and re-run it);\neven if you‚Äôre not making any queries at the moment (or if you leave your app running while your gone), you‚Äôre gonna have an idle connection sitting around for no reason;\nfinally, if you are not quite at this extreme, and you use use more than one connection per app (but fewer than one connection per query), it can be difficult to keep track of all your connections, since you‚Äôll be opening and closing them in potentially very different places.\n\n\n\nOne connection per query\nLet‚Äôs now turn our attention to the other extreme: opening (and closing) a connection for each query we make:\n\nlibrary(shiny)\nlibrary(DBI)\n\nargs &lt;- list(\n  drv = RMySQL::MySQL(),\n  dbname = \"shinydemo\",\n  host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",\n  username = \"guest\",\n  password = \"guest\"\n)\n\nui &lt;- fluidPage(\n  textInput(\"ID\", \"Enter your ID:\", \"5\"),\n  tableOutput(\"tbl\"),\n  numericInput(\"nrows\", \"How many cities to show?\", 10),\n  plotOutput(\"popPlot\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$tbl &lt;- renderTable({\n    conn &lt;- do.call(DBI::dbConnect, args)\n    on.exit(DBI::dbDisconnect(conn))\n\n    sql &lt;- \"SELECT * FROM City WHERE ID = ?id;\"\n    query &lt;- sqlInterpolate(conn, sql, id = input$ID)\n    dbGetQuery(conn, query)\n  })\n  output$popPlot &lt;- renderPlot({\n    conn &lt;- do.call(DBI::dbConnect, args)\n    on.exit(DBI::dbDisconnect(conn))\n\n    query &lt;- paste0(\"SELECT * FROM City LIMIT \",\n                    as.integer(input$nrows)[1], \";\")\n    df &lt;- dbGetQuery(conn, query)\n    pop &lt;- df$Population\n    names(pop) &lt;- df$Name\n    barplot(pop)\n  })\n}\n\nshinyApp(ui, server)\n\nThe advantages to this approach are the reverse of the disadvantages of the first approach:\n\nit can handle simultaneous requests, because these are always processed by different connections (it will easily handle complicated apps or multiple sessions);\nif a connection breaks, that‚Äôs no big deal for your app: it will just fetch a new one (no need to restart the app);\neach connection is only open for the duration of the query it‚Äôs making, so there‚Äôs no idle connections sitting around (good performance for the scenario in which the app is seldom interacted with, or left idle for long);\nin addition, it is very easy to keep track of connections (as you can see, each dbConnect is always paired with a dbDisconnect), so there‚Äôs virtually no danger of accidentally leaking them.\n\nSimilarly, it does less well on the things that the former approach excelled at:\n\nit is slow: each time we change an input, we have a fetch a connection to recalculate the reactive;\nyou need a lot more (boilerplate) code to connect and disconnect the connection within each reactive.\n\n\n\nThe best of both worlds: using a pool\nWouldn‚Äôt it be nice if you could combine the advantages of the two approaches? The goal of using a pool is to minimize all the disadvantages listed above as much as possible: the pool abstracts away the logic of connection management, so that, for the vast majority of cases, you never have to deal with connections directly. Since the pool ‚Äúknows‚Äù when it should have more connections and how to manage them, you have all the advantages of the second approach (one connection per query), without the disadvantages. You are still using one connection per query, but that connection is always fetched and returned to the pool, rather than getting it from the database directly. This is a whole lot faster and more efficient. Finally, the code is kept just as simple as the code in the first approach (only one connection for the entire app). In fact, if you look back at the pool Shiny app example, you will notice that the code structure is essentially the same as the one in the first approach.\nSpend some time experimenting with pool. Once you feel that you have the basic idea down, read on to the next article to learn how to customize your pool and to deal with transactions.",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Using the pool package (basics)"
    ]
  },
  {
    "objectID": "r/articles/build/plot-interaction/index.html",
    "href": "r/articles/build/plot-interaction/index.html",
    "title": "Interactive plots",
    "section": "",
    "text": "As of version 0.12.0, Shiny has built-in support for interacting with static plots generated by R‚Äôs base graphics functions, and those generated by ggplot2.\nThis makes it easy to add features like selecting points and regions, as well as zooming in and out of images.",
    "crumbs": [
      "Build",
      "Frontend",
      "Graphics & visualization",
      "Interactive plots"
    ]
  },
  {
    "objectID": "r/articles/build/plot-interaction/index.html#basics",
    "href": "r/articles/build/plot-interaction/index.html#basics",
    "title": "Interactive plots",
    "section": "Basics",
    "text": "Basics\nTo get the position of the mouse when a plot is clicked, you simply need to use the click option with the plotOutput(). For example, this will define a new input value, input$plot_click, which contains the location of the previous mouse click.\nplotOutput(\"plot1\", click = \"plot_click\")\nFor example, this app will print out the x and y coordinate position of the mouse cursor when a click occurs (to see it in action, click in the plot area of the app rendered below the code):\nlibrary(shiny)\n\nui &lt;- basicPage(\n  plotOutput(\"plot1\", click = \"plot_click\"),\n  verbatimTextOutput(\"info\")\n)\n\nserver &lt;- function(input, output) {\n  output$plot1 &lt;- renderPlot({\n    plot(mtcars$wt, mtcars$mpg)\n  })\n\n  output$info &lt;- renderText({\n    paste0(\"x=\", input$plot_click$x, \"\\ny=\", input$plot_click$y)\n  })\n}\n\nshinyApp(ui, server)\n\n\nNotice that the x and y coordinates are scaled to the data, as opposed to simply being the pixel coordinates. This makes it easy to use those values to select or filter data.\nThe other types of interactions are double-clicking, hovering, and brushing. (Brushing is clicking and dragging a selection box.) They can be enabled with the dblclick, hover, and brush options. In the example below, all of these are enabled, and the coordinates are displayed below\nui &lt;- basicPage(\n  plotOutput(\"plot1\",\n    click = \"plot_click\",\n    dblclick = \"plot_dblclick\",\n    hover = \"plot_hover\",\n    brush = \"plot_brush\"\n  ),\n  verbatimTextOutput(\"info\")\n)\n\nserver &lt;- function(input, output) {\n  output$plot1 &lt;- renderPlot({\n    plot(mtcars$wt, mtcars$mpg)\n  })\n\n  output$info &lt;- renderText({\n    xy_str &lt;- function(e) {\n      if(is.null(e)) return(\"NULL\\n\")\n      paste0(\"x=\", round(e$x, 1), \" y=\", round(e$y, 1), \"\\n\")\n    }\n    xy_range_str &lt;- function(e) {\n      if(is.null(e)) return(\"NULL\\n\")\n      paste0(\"xmin=\", round(e$xmin, 1), \" xmax=\", round(e$xmax, 1), \n             \" ymin=\", round(e$ymin, 1), \" ymax=\", round(e$ymax, 1))\n    }\n\n    paste0(\n      \"click: \", xy_str(input$plot_click),\n      \"dblclick: \", xy_str(input$plot_dblclick),\n      \"hover: \", xy_str(input$plot_hover),\n      \"brush: \", xy_range_str(input$plot_brush)\n    )\n  })\n}\n\nshinyApp(ui, server)\n\n\nWhile click, dblclick, and hover have x and y coordinates, brush is slightly different: because it‚Äôs a box, it has xmin, xmax, ymin, and ymax.\nNext: learn about how to easily select rows of data with interactive plots.",
    "crumbs": [
      "Build",
      "Frontend",
      "Graphics & visualization",
      "Interactive plots"
    ]
  },
  {
    "objectID": "r/articles/build/plot-interaction/index.html#learn-more",
    "href": "r/articles/build/plot-interaction/index.html#learn-more",
    "title": "Interactive plots",
    "section": "Learn more",
    "text": "Learn more\nFor more on this topic, see the following resources:\n Coordinated multiple views (linked brushing)",
    "crumbs": [
      "Build",
      "Frontend",
      "Graphics & visualization",
      "Interactive plots"
    ]
  },
  {
    "objectID": "r/articles/build/persistent-data-storage/index.html",
    "href": "r/articles/build/persistent-data-storage/index.html",
    "title": "Persistent data storage in Shiny apps",
    "section": "",
    "text": "Shiny apps often need to save data, either to load it back into a different session or to simply log some information. However, common methods of storing data from R may not work well with Shiny. Functions like write.csv() and saveRDS() save data locally, but consider how shinyapps.io works.\nShinyapps.io is a popular server for hosting Shiny apps. It is designed to distribute your Shiny app across different servers, which means that if a file is saved during one session on some server, then loading the app again later will probably direct you to a different server where the previously saved file doesn‚Äôt exist.\nOn other occasions, you may use data that is too big to store locally with R in an efficient manner.\nThis guide will explain seven methods for storing persistent data remotely with a Shiny app. You will learn how to store:\nThe article explains the theory behind each method, and augments the theory with working examples that will make it clear and easy for you to use these methods in your own apps.\nAs a complement to this article, you can see a live demo of a Shiny app that uses each of the seven storage methods to save and load data (source code on GitHub). This article expands on Jeff Allen‚Äôs article regarding sharing data across sessions.",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Persistent data storage in Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/build/persistent-data-storage/index.html#table-of-contents",
    "href": "r/articles/build/persistent-data-storage/index.html#table-of-contents",
    "title": "Persistent data storage in Shiny apps",
    "section": "Table of contents",
    "text": "Table of contents\n\nBasic Shiny app without data storage\nLocal vs remote storage\nPersistent data storage methods\n\nStore arbitrary data in a file\n\nLocal file system (local)\nDropbox (remote)\nAmazon S3 (remote)\n\nStore structured data in a table\n\nSQLite (local)\nMySQL (local or remote)\nGoogle Sheets (remote)\n\nStore semi-structured data in a NoSQL database\n\nMongoDB (local or remote)\n\n\nConclusion",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Persistent data storage in Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/build/persistent-data-storage/index.html#file",
    "href": "r/articles/build/persistent-data-storage/index.html#file",
    "title": "Persistent data storage in Shiny apps",
    "section": "Store arbitrary data in a file",
    "text": "Store arbitrary data in a file\nThis is the most flexible option to store data since files allow you to store any type of data, whether it is a single value, a big data.frame, or any arbitrary data. There are two common cases for using files to store data:\n\nyou have one file that gets repeatedly overwritten and used by all sessions (like the example in the sharing data article), or\nyou save a new file every time there is new data\n\nIn our case we‚Äôll use the latter because we want to save each response as its own file. We can use the former option, but then we would introduce the potential for race conditions which will overcomplicate the app. A race condition happens when two users submit a response at the exact same time, but since the file cannot deal with multiple edits simultaneously, one user will overwrite the response of the other user.\nWhen saving multiple files, it is important to save each file with a different file name to avoid overwriting files. There are many ways to do this. For example, you can simply use the current timestamp and an md5 hash of the data being saved as the file name to ensure that no two form submissions have the same file name.\nArbitrary data can be stored in a file either on the local file system or on remote services such as Dropbox or Amazon S3.\n\n1. Local file system (local)\nThe most trivial way to save data from Shiny is to simply save each response as its own file on the current server. To load the data, we simply load all the files in the output directory. In our specific example, we also want to concatenate all of the data files together into one data.frame.\nSetup: The only setup required is to create an output directory (responses in this case) and to ensure that the Shiny app has file permissions to read/write in that directory.\nCode:\noutputDir &lt;- \"responses\"\n\nsaveData &lt;- function(data) {\n  data &lt;- t(data)\n  # Create a unique file name\n  fileName &lt;- sprintf(\"%s_%s.csv\", as.integer(Sys.time()), digest::digest(data))\n  # Write the file to the local system\n  write.csv(\n    x = data,\n    file = file.path(outputDir, fileName), \n    row.names = FALSE, quote = TRUE\n  )\n}\n\nloadData &lt;- function() {\n  # Read all the files into a list\n  files &lt;- list.files(outputDir, full.names = TRUE)\n  data &lt;- lapply(files, read.csv, stringsAsFactors = FALSE) \n  # Concatenate all data together into one data.frame\n  data &lt;- do.call(rbind, data)\n  data\n}\n\n\n2. Dropbox (remote)\nIf you want to store arbitrary files with a remote hosted solution instead of the local file system, you can store files on Dropbox. Dropbox is a file storing service which allows you to host any file, up to a certain maximum usage. The free account provides plenty of storage space and should be enough to store most data from Shiny apps.\nThis approach is similar to the previous approach that used the local file system. The only difference is that now that files are being saved to and loaded from Dropbox. You can use the rdrop2 package to interact with Dropbox from R. Note that rdrop2 can only move existing files onto Dropbox, so we still need to create a local file before storing it on Dropbox.\nSetup: You need to have a Dropbox account and create a folder to store the responses. You will also need to add authentication to rdrop2 with any approach suggested in the package README. The authentication approach I chose was to authenticate manually once and to copy the resulting .httr-oauth file that gets created into the Shiny app‚Äôs folder.\nCode:\nlibrary(rdrop2)\noutputDir &lt;- \"responses\"\n\nsaveData &lt;- function(data) {\n  data &lt;- t(data)\n  # Create a unique file name\n  fileName &lt;- sprintf(\"%s_%s.csv\", as.integer(Sys.time()), digest::digest(data))\n  # Write the data to a temporary file locally\n  filePath &lt;- file.path(tempdir(), fileName)\n  write.csv(data, filePath, row.names = FALSE, quote = TRUE)\n  # Upload the file to Dropbox\n  drop_upload(filePath, path = outputDir)\n}\n\nloadData &lt;- function() {\n  # Read all the files into a list\n  filesInfo &lt;- drop_dir(outputDir)\n  filePaths &lt;- filesInfo$path_display\n  data &lt;- lapply(filePaths, drop_read_csv, stringsAsFactors = FALSE)\n  # Concatenate all data together into one data.frame\n  data &lt;- do.call(rbind, data)\n  data\n}\n\n\n3. Amazon S3 (remote)\nAnother popular alternative to Dropbox for hosting files online is Amazon S3, or S3 in short. Just like with Dropbox, you can host any type of file on S3, but instead of placing files inside directories, in S3 you place files inside of buckets. You can use the aws.s3 package to interact with S3 from R.\nSetup: You need to have an Amazon Web Services account and to create an S3 bucket to store the responses. As the package documentation explains, you will need to set a few environment variables in order to call the API.\nCode:\nlibrary(aws.s3)\n\ns3BucketName &lt;- \"my-unique-s3-bucket-name\"\nSys.setenv(\"AWS_ACCESS_KEY_ID\" = \"key\",\n           \"AWS_SECRET_ACCESS_KEY\" = \"secret\",\n           \"AWS_DEFAULT_REGION\" = \"region\")\n\nsaveData &lt;- function(data) {\n  # Create a plain-text representation of the data\n  data &lt;- paste0(\n    paste(names(data), collapse = \",\"), \"\\n\",\n    paste(unname(data), collapse = \",\")\n  )\n\n  file_name &lt;- paste0(\n    paste(\n      get_time_human(),\n      digest(data, algo = \"md5\"),\n      sep = \"_\"\n    ),\n    \".csv\"\n  )\n\n  # Upload the file to S3\n  put_object(file = charToRaw(data), object = file_name, bucket = s3_bucket_name)\n}\n\nloadData &lt;- function() {\n  # Get a list of all files\n  file_names &lt;- get_bucket_df(s3BucketName)[[\"Key\"]]\n  # Read all files into a list\n  data &lt;- lapply(file_names, function(x) {\n    object &lt;- get_object(x, s3BucketName)\n    object_data &lt;- readBin(object, \"character\")\n    read.csv(text = object_data, stringsAsFactors = FALSE)\n  })\n  # Concatenate all data together into one data.frame\n  data &lt;- do.call(rbind, data)\n  data  \n}",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Persistent data storage in Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/build/persistent-data-storage/index.html#table",
    "href": "r/articles/build/persistent-data-storage/index.html#table",
    "title": "Persistent data storage in Shiny apps",
    "section": "Store structured data in a table",
    "text": "Store structured data in a table\nIf the data you want to save is structured and rectangular, storing it in a table would be a good option. Loosely defined, structured data means that each observation has the same fixed fields, and rectangular data means that all observations contain the same number of fields and fit into a nice 2D matrix. A data.frame is a great example of such data, and thus data.frames are ideal candidates to be stored in tables such as relational databases.\nStructured data must have some schema that defines what the data fields are. In a data.frame, the number and names of the columns can be thought of as the schema. In tables with a header row, the header row can be thought of as the schema.\nStructured data can be stored in a table either in a relational database (such as SQLite or MySQL) or in any other table-hosting service such as Google Sheets. If you have experience with database interfaces in other languages, you should note that R does not currently have support for prepared statements, so any SQL statements have to be constructed manually. One advantage of using a relational database is that with most databases it is safe to have multiple users using the database concurrently without running into race conditions thanks to transaction support.\n\n4. SQLite (local)\nSQLite is a very simple and light-weight relational database that is very easy to set up. SQLite is serverless, which means it stores the database locally on the same machine that is running the shiny app. You can use the RSQLite package to interact with SQLite from R. To connect to a SQLite database in R, the only information you need to provide is the location of the database file.\nTo store data in a SQLite database, we loop over all the values we want to add and use a SQL INSERT statement to add the data to the database. It is essential that the schema of the database matches exactly the names of the columns in the Shiny data, otherwise the SQL statement will fail. To load all previous data, we use a plain SQL SELECT * statement to get all the data from the database table.\nSetup: First, you must have SQLite installed on your server. Installation is fairly easy; for example, on an Ubuntu machine you can install SQLite with sudo apt-get install sqlite3 libsqlite3-dev. If you use shinyapps.io, SQLite is already installed on the shinyapps.io server, which will be a handy feature in future versions of shinyapps.io, which will include persistent local storage.\nYou also need to create a database and a table that will store all the responses. When creating the table, you need to set up the schema of the table to match the columns of your data. For example, if you want to save data with columns ‚Äúname‚Äù and ‚Äúemail‚Äù then you can create the SQL table with CREATE TABLE responses(name TEXT, email TEXT);. Make sure the shiny app has write permissions on the database file and its parent directory.\nCode:\nlibrary(RSQLite)\nsqlitePath &lt;- \"/path/to/sqlite/database\"\ntable &lt;- \"responses\"\n\nsaveData &lt;- function(data) {\n  # Connect to the database\n  db &lt;- dbConnect(SQLite(), sqlitePath)\n  # Construct the update query by looping over the data fields\n  query &lt;- sprintf(\n    \"INSERT INTO %s (%s) VALUES ('%s')\",\n    table, \n    paste(names(data), collapse = \", \"),\n    paste(data, collapse = \"', '\")\n  )\n  # Submit the update query and disconnect\n  dbGetQuery(db, query)\n  dbDisconnect(db)\n}\n\nloadData &lt;- function() {\n  # Connect to the database\n  db &lt;- dbConnect(SQLite(), sqlitePath)\n  # Construct the fetching query\n  query &lt;- sprintf(\"SELECT * FROM %s\", table)\n  # Submit the fetch query and disconnect\n  data &lt;- dbGetQuery(db, query)\n  dbDisconnect(db)\n  data\n}\n\n\n5. MySQL (local or remote)\nMySQL is a very popular relational database that is similar to SQLite but is more powerful. MySQL databases can either be hosted locally (on the same machine as the Shiny app) or online using a hosting service.\nThis method is very similar to the previous SQLite method, with the main difference being where the database is hosted. You can use the RMySQL package to interact with MySQL from R. Since MySQL databases can be hosted on remote servers, the command to connect to the server involves more parameters, but the rest of the saving/loading code is identical to the SQLite approach. To connect to a MySQL database, you need to provide the following parameters: host, port, dbname, user, password.\nSetup: You need to create a MySQL database (either locally or using a web service that hosts MySQL databases) and a table that will store the responses. As with the setup for SQLite, you need to make sure the table schema is properly set up for your intended data.\nCode:\nlibrary(RMySQL)\n\noptions(mysql = list(\n  \"host\" = \"127.0.0.1\",\n  \"port\" = 3306,\n  \"user\" = \"myuser\",\n  \"password\" = \"mypassword\"\n))\ndatabaseName &lt;- \"myshinydatabase\"\ntable &lt;- \"responses\"\n\nsaveData &lt;- function(data) {\n  # Connect to the database\n  db &lt;- dbConnect(MySQL(), dbname = databaseName, host = options()$mysql$host, \n      port = options()$mysql$port, user = options()$mysql$user, \n      password = options()$mysql$password)\n  # Construct the update query by looping over the data fields\n  query &lt;- sprintf(\n    \"INSERT INTO %s (%s) VALUES ('%s')\",\n    table, \n    paste(names(data), collapse = \", \"),\n    paste(data, collapse = \"', '\")\n  )\n  # Submit the update query and disconnect\n  dbGetQuery(db, query)\n  dbDisconnect(db)\n}\n\nloadData &lt;- function() {\n  # Connect to the database\n  db &lt;- dbConnect(MySQL(), dbname = databaseName, host = options()$mysql$host, \n      port = options()$mysql$port, user = options()$mysql$user, \n      password = options()$mysql$password)\n  # Construct the fetching query\n  query &lt;- sprintf(\"SELECT * FROM %s\", table)\n  # Submit the fetch query and disconnect\n  data &lt;- dbGetQuery(db, query)\n  dbDisconnect(db)\n  data\n}\n\n\n6. Google Sheets (remote)\nIf you don‚Äôt want to deal with the formality and rigidity of a database, another option for storing tabular data is in a Google Sheet. One nice advantage of Google Sheets is that they are easy to access from anywhere; but unlike with databases, with Google Sheets data can be overwritten with multiple concurrent users.\nYou can use the googlesheets4 package to interact with Google Sheets from R.\nSetup: All you need to do is create a Google Sheet and set the top row with the names of the fields. You can do that either via a web browser or by using the googlesheets4 package. You also need to have a Google account. Now if you try to get R to write to a Google Sheet, R will ask for your permission explicitly every time. In a Shiny app, you probably want to be able to write to Google Sheets automatically without having to authorize it every time manually, so you need to set up {googlesheets4} with authentication. To learn how to add this authentication, refer to the package documentation.\nCode:\nlibrary(googlesheets4)\n\ntable &lt;- \"responses\"\n\nsaveData &lt;- function(data) {\n  # The data must be a dataframe rather than a named vector\n  data &lt;- data %&gt;% as.list() %&gt;% data.frame()\n  # Add the data as a new row\n  sheet_append(SHEET_ID, data)\n}\n\nloadData &lt;- function() {\n  # Read the data\n  read_sheet(SHEET_ID)\n}",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Persistent data storage in Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/build/persistent-data-storage/index.html#nosql",
    "href": "r/articles/build/persistent-data-storage/index.html#nosql",
    "title": "Persistent data storage in Shiny apps",
    "section": "Store semi-structured data in a NoSQL database",
    "text": "Store semi-structured data in a NoSQL database\nIf you have data that is not fully structured but is also not completely free-form, a good middle ground can be using a NoSQL database. NoSQL databases can also be referred to as schemaless databases because they do not use a formal schema. NoSQL databases still offer some of the benefits of a traditional relational database, but are more flexible because every entry can use different fields. If your Shiny app needs to store data that has several fields but there is no unifying schema for all of the data to use, then using a NoSQL database can be a good option.\nThere are many NoSQL databases available, but here we will only show how to use mongoDB.\n\n7. MongoDB (local or remote)\nMongoDB is one of the most popular NoSQL databases, and just like MySQL it can be hosted either locally or remotely. There are many web services that offer mongoDB hosting, including MongoDB Atlas which gives you free mongoDB databases. In mongoDB, entries (in our case, responses) are stored in a collection (the equivalent of an S3 bucket or a SQL table).\nYou can use the mongolite package to interact with mongoDB from R. As with the relational database methods, all we need to do in order to save/load data is connect to the database and submit the equivalent of an update or select query. To connect to the database you need to provide the following: db, host, username, password. When saving the data, mongolite requires the data to be in a data.frame format.\nSetup: All you need to do is create a mongoDB database‚Äîeither locally or using a web service such as MongoDB Atlas. Since there is no schema, it is not mandatory to create a collection before populating it.\nCode:\nlibrary(mongolite)\n\noptions(mongodb = list(\n  \"host\" = \"cluster0.1twdg.mongodb.net\",\n  \"username\" = \"myuser\",\n  \"password\" = \"mypassword\"\n))\ndatabaseName &lt;- \"myshinydatabase\"\ncollectionName &lt;- \"responses\"\n\nsaveData &lt;- function(data) {\n  # Connect to the database\n  db &lt;- mongo(collection = collectionName,\n              url = sprintf(\n                \"mongodb+srv://%s:%s@%s/%s\",\n                options()$mongodb$username,\n                options()$mongodb$password,\n                options()$mongodb$host,\n                databaseName\n              ),\n              options = ssl_options(weak_cert_validation = TRUE))\n  # Insert the data into the mongo collection as a data.frame\n  data &lt;- as.data.frame(t(data))\n  db$insert(data)\n}\n\nloadData &lt;- function() {\n  # Connect to the database\n  db &lt;- mongo(collection = collectionName,\n              url = sprintf(\n                \"mongodb+srv://%s:%s@%s/%s\",\n                options()$mongodb$username,\n                options()$mongodb$password,\n                options()$mongodb$host,\n                databaseName\n              ),\n              options = ssl_options(weak_cert_validation = TRUE))\n  # Read all the entries\n  data &lt;- db$find()\n  data\n}",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Persistent data storage in Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/build/overview/index.html",
    "href": "r/articles/build/overview/index.html",
    "title": "Database basics - dplyr and DBI",
    "section": "",
    "text": "Note (6/22/17): pool is now compatible with dplyr 0.7.0 and the brand new dbplyr. If you want to continue using pool with an older version of dplyr, please install pool@dplyr-pre-0.7.0-compat (devtools::install_github(\"rstudio/pool@dplyr-pre-0.7.0-compat).",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Database basics - dplyr and DBI"
    ]
  },
  {
    "objectID": "r/articles/build/overview/index.html#installation",
    "href": "r/articles/build/overview/index.html#installation",
    "title": "Database basics - dplyr and DBI",
    "section": "Installation",
    "text": "Installation\nThere are four packages that you need throughout this series of articles. Here are the installation instructions, so your code runs smoothly:\n# get shiny, DBI, dplyr and dbplyr from CRAN\ninstall.packages(\"shiny\")\ninstall.packages(\"DBI\")\ninstall.packages(\"dplyr\")\ninstall.packages(\"dbplyr\")\n\n# get pool from GitHub, since it's not yet on CRAN\ndevtools::install_github(\"rstudio/pool\")",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Database basics - dplyr and DBI"
    ]
  },
  {
    "objectID": "r/articles/build/overview/index.html#overview",
    "href": "r/articles/build/overview/index.html#overview",
    "title": "Database basics - dplyr and DBI",
    "section": "Overview",
    "text": "Overview\nAs Shiny apps grow and become more complex, a recurring issue has been that of integrating an external database into an app. While this is already possible, so far it‚Äôs been mostly up to the app authors to figure out the appropriate database driver for R and how to manage the database connections within the app itself. The goal of this series of articles is to demystify this process and to introduce some brand new features that should make it easier.\nIn particular, we will cover:\n\nhow to use the dplyr package to read data from an external database;\nhow to use the DBI package to hook up to an external database;\nhow to prevent SQL injections;\nhow to manage connections, prevent leaks and ensure the best performance using the pool package;\nhow to integrate the pool package with dplyr.\n\nNote that it isn‚Äôt always ideal to link up to an external database, as it may break and it is certainly more computationally expensive than dealing with local data. To quote Hadley on when to use dplyr with databases vs in-memory data:\n\nAs well as working with local in-memory data stored in data frames, dplyr also works with remote on-disk data stored in databases. This is particularly useful in two scenarios:\n\nYour data is already in a database.\nYou have so much data that it does not all fit into memory simultaneously and you need to use some external storage engine.\n\n(If your data fits in memory there is no advantage to putting it in a database: it will only be slower and more frustrating).\n\nIt is, however, outside of the scope of these articles to explain further when you do need to connect to a database; we will just assume that you‚Äôve thought through your options and concluded that this is the best way to go.\nFinally, this series will only cover relational databases ‚Äì in particular, relational databases whose drivers are DBI-compliant (which means that the R interface must have followed these steps these steps): SQLite, MySQL and PostgreSQL.",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Database basics - dplyr and DBI"
    ]
  },
  {
    "objectID": "r/articles/build/overview/index.html#dplyr-package",
    "href": "r/articles/build/overview/index.html#dplyr-package",
    "title": "Database basics - dplyr and DBI",
    "section": "dplyr package",
    "text": "dplyr package\nThe easiest way to hook up to an external database from within your Shiny app is to use dplyr. The dplyr package is a very popular data manipulation package that aims to provide a function for each basic verb of data manipulation:\n\nfilter() (and slice())\narrange()\nselect() (and rename())\ndistinct()\nmutate() (and transmute())\nsummarise()\nsample_n() (and sample_frac())\n\nIf you‚Äôre not familiar with the basics of dplyr (how to apply these verbs to data frames in local storage), you should take the time to do so through this introductory vignette). But in addition to in-memory data, dplyr also works with remote databases. And by translating your R code into the appropriate SQL, it allows you to work with both types of data using the same set of tools (which can be especially useful if you‚Äôre not familiar with SQL). Hadley has written a vignette that explains in detail how to use dplyr in relation to databases. You should really check that out if you want a more comprehensive overview of this subject (in here, we will just provide a brief example). Here‚Äôs an excerpt about the rationale to support databases in dplyr (from here):\n\nThe motivation for supporting databases in dplyr is that you never pull down the right subset or aggregate from the database the first time, and usually you have to iterate between R and SQL many times before you get the perfect dataset. Switching between languages is cognitively challenging (especially because R and SQL are so perilously similar), so dplyr allows you to write R code that is automatically translated to SQL. The goal of dplyr is not to replace every SQL function with an R function: that would be difficult and error prone. Instead, dplyr only generates SELECT statements, the SQL you write most often as an analyst.\n\n\nSample usage\nHere‚Äôs how to read the first five rows of a table from a remote database:\nlibrary(pool)\nlibrary(dplyr)\n\nmy_db &lt;- dbPool(\n  RMySQL::MySQL(), \n  dbname = \"shinydemo\",\n  host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",\n  username = \"guest\",\n  password = \"guest\"\n)\n\n# get the first 5 rows:\nmy_db %&gt;% tbl(\"City\") %&gt;% head(5)\n## # Source:   lazy query [?? x 5]\n## # Database: mysql 10.0.17-MariaDB [guest@shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com:/shinydemo]\n##      ID           Name CountryCode      District Population\n##   &lt;dbl&gt;          &lt;chr&gt;       &lt;chr&gt;         &lt;chr&gt;      &lt;dbl&gt;\n## 1     1          Kabul         AFG         Kabol    1780000\n## 2     2       Qandahar         AFG      Qandahar     237500\n## 3     3          Herat         AFG         Herat     186800\n## 4     4 Mazar-e-Sharif         AFG         Balkh     127800\n## 5     5      Amsterdam         NLD Noord-Holland     731200\nAs you can see, it‚Äôs pretty straightforward. With very few changes, you can make this more efficient, and behave a lot better within a Shiny app, if you combine it with the pool package (see this article on the subject). But to do so, you must understand the general idea behind pooling connections, so make sure you check this article about pool basics first.\n\nNote\nThroughout this series of articles, all the examples provided will use the ‚Äúshinydemo‚Äù toy database above (a MariaDB ‚Äì which is just a MySQL fork ‚Äì database, hosted on Amazon Web Services). This was created especially for learning purposes and you should feel free to play with it using the guest credentials above (these will allow you to read whatever you want from the table, but you obviously won‚Äôt be able to write into it or modify it in any way). The ‚Äúshinydemo‚Äù database is simply the well-known ‚Äúworld‚Äù database, available for download from here. Some general info:\n\nThe data set is available as a set of three tables:\n\nCountry: Information about countries of the world.\nCity: Information about some of the cities in those countries.\nCountryLanguage: Languages spoken in each country.\n\n\nNote: The Country table was modified to remove all rows that contained non-ASCII characters, so its total number of rows (3427) is smaller than the original (4079). This is to ensure that you can access the entire table without running into encoding problems, given that the default encoding is different depending on the platform you‚Äôre using (Unix or Windows), which can be an issue for non-ASCII characters. The other two tables were left unchanged.",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Database basics - dplyr and DBI"
    ]
  },
  {
    "objectID": "r/articles/build/overview/index.html#dbi-package",
    "href": "r/articles/build/overview/index.html#dbi-package",
    "title": "Database basics - dplyr and DBI",
    "section": "DBI package",
    "text": "DBI package\nIf you need to do anything more elaborate than fairly simple SELECT queries, dplyr won‚Äôt be able to help you. In that case, we heartily recommend that you use DBI to connect to your database if there is a suitable driver. Here‚Äôs a tidbit about DBI from its github page:\n\nThe DBI package defines a common interface between the R and database management systems (DBMS). The interface defines a small set of classes and methods similar in spirit to Perl‚Äôs DBI, Java‚Äôs JDBC, Python‚Äôs DB-API, and Microsoft‚Äôs ODBC. It defines a set of classes and methods defines what operations are possible and how they are performed:\n\nconnect/disconnect to the DBMS\ncreate and execute statements in the DBMS\nextract results/output from statements\nerror/exception handling\ninformation (meta-data) from database objects\ntransaction management (optional)\n\n\nHere‚Äôs a basic usage example that highlights some of the most common DBI capabilities ‚Äì we establish a connection to a database, query it, fetch the result set, close the result set and disconnect when we‚Äôre done:\nlibrary(DBI)\nconn &lt;- dbConnect(\n    drv = RMySQL::MySQL(),\n    dbname = \"shinydemo\",\n    host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",\n    username = \"guest\",\n    password = \"guest\")\nrs &lt;- dbSendQuery(conn, \"SELECT * FROM City LIMIT 5;\")\ndbFetch(rs)\n##   ID           Name CountryCode      District Population\n## 1  1          Kabul         AFG         Kabol    1780000\n## 2  2       Qandahar         AFG      Qandahar     237500\n## 3  3          Herat         AFG         Herat     186800\n## 4  4 Mazar-e-Sharif         AFG         Balkh     127800\n## 5  5      Amsterdam         NLD Noord-Holland     731200\ndbClearResult(rs)\ndbDisconnect(conn)\n\ndbGetQuery\nIn the example above, we use DBI to query the database and retrieve the first 5 rows from the City table. As you can see, there is some boilerplate required by DBI: every connection you create using dbConnect() must at some point be destroyed using dbDisconnect() (or you‚Äôll get a leaked connection, which will slow everything down unnecessarily). If you use dbSendQuery(), this will return a result set, here named rs, that stays open (so that you can gradually fetch data using dbFetch()) until you close it using dbClearResult(rs). In this particular case, since you‚Äôre fetching the data all at once (5 rows of data fit comfortably in R memory), you could actually achieve the same result in an easier way:\n\nlibrary(DBI)\nconn &lt;- dbConnect(\n    drv = RMySQL::MySQL(),\n    dbname = \"shinydemo\",\n    host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",\n    username = \"guest\",\n    password = \"guest\")\ndbGetQuery(conn, \"SELECT * FROM City LIMIT 5;\")\n##   ID           Name CountryCode      District Population\n## 1  1          Kabul         AFG         Kabol    1780000\n## 2  2       Qandahar         AFG      Qandahar     237500\n## 3  3          Herat         AFG         Herat     186800\n## 4  4 Mazar-e-Sharif         AFG         Balkh     127800\n## 5  5      Amsterdam         NLD Noord-Holland     731200\ndbDisconnect(conn)\n\nThe dbGetQuery() function basically calls dbSendQuery(), dbFetch() and dbClearResult() for you, so it makes your code a lot simpler. However, your query may be a lot bigger than 5 rows, so this is not always feasible. You may also have noticed that it can take a bit of time for the connection to be established (the second line of code). If you‚Äôre unfamiliar with DBI, it may be a good idea to explore some its additional functionality. That notwithstanding, just knowing the commands above (along with how to construct SQL queries) is enough to get you using DBI.\nHere‚Äôs a very simple Shiny app that does exactly what is demoed above, but allows the user to specify how many rows they want to fetch:\n\nlibrary(shiny)\nlibrary(DBI)\n\nui &lt;- fluidPage(\n  numericInput(\"nrows\", \"Enter the number of rows to display:\", 5),\n  tableOutput(\"tbl\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$tbl &lt;- renderTable({\n    conn &lt;- dbConnect(\n      drv = RMySQL::MySQL(),\n      dbname = \"shinydemo\",\n      host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",\n      username = \"guest\",\n      password = \"guest\")\n    on.exit(dbDisconnect(conn), add = TRUE)\n    dbGetQuery(conn, paste0(\n      \"SELECT * FROM City LIMIT \", input$nrows, \";\"))\n  })\n}\n\nshinyApp(ui, server)\n\nVERY IMPORTANT NOTE: The app above has a major security vulnerability because it allows app users to enter data that is directly used in the SQL query. For this particular case, this may not matter because guests have no write access to the database. But often this is not the case. And using the construct above, you‚Äôve just opened yourself up to nasty vulnerability of SQL injections. Thankfully DBI just added support for SQL injection prevention, so read on to the next article!",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Database basics - dplyr and DBI"
    ]
  },
  {
    "objectID": "r/articles/build/notifications/index.html",
    "href": "r/articles/build/notifications/index.html",
    "title": "Notifications",
    "section": "",
    "text": "As of version 0.14, Shiny can display notifications on the client browser by using the showNotification() function. You can see an example of them here.\nIn this example, we‚Äôll use an observeEvent() to display the notification when the Show button is pressed:\nshinyApp(\n  ui = fluidPage(\n    actionButton(\"show\", \"Show\")\n  ),\n  server = function(input, output) {\n    observeEvent(input$show, {\n      showNotification(\"This is a notification.\")\n    })\n  }\n)\nThe notification will appear in the bottom right corner of the browser, remain for 5 seconds, and then fade away.\n\n\n\nNotification screenshot\n\n\nThe are a number options that control the behavior and appearance of notifications\nThe default color of the notification is gray, but you can use other colors with the type argument. It can be \"default\", \"message\", \"warning\", or \"error\", which will display as shown below:\n\n\n\nNotification types\n\n\nBy default, a close button will be displayed on the right side of each notification, but it can be removed with closeButton=FALSE.\nThe action argument is an additional way of providing content in the notification. The action UI components will appear underneath the main text. The reason that it is separate is so that it can be custom-styled with CSS.\nThe showNotification() function returns an ID value which can be passed to removeNotification()to remove the notification from the server side. For example, this application has one button that will present a notification, and another that will remove it:\nshinyApp(\n  ui = fluidPage(\n    actionButton(\"show\", \"Show\"),\n    actionButton(\"remove\", \"Remove\")\n  ),\n  server = function(input, output) {\n    # A notification ID\n    id &lt;- NULL\n\n    observeEvent(input$show, {\n      # If there's currently a notification, don't add another\n      if (!is.null(id))\n        return()\n      # Save the ID for removal later\n      id &lt;&lt;- showNotification(paste(\"Notification message\"), duration = 0)\n    })\n\n    observeEvent(input$remove, {\n      if (!is.null(id))\n        removeNotification(id)\n      id &lt;&lt;- NULL\n    })\n  }\n)",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Notifications"
    ]
  },
  {
    "objectID": "r/articles/build/layout-guide/index.html",
    "href": "r/articles/build/layout-guide/index.html",
    "title": "Application layout guide",
    "section": "",
    "text": "Overview\nShiny apps use Bootstrap, an extremely popular HTML/CSS framework, (though no prior experience with Bootstrap is necessary). As a result, the best way to customize the layout of a Shiny app is with R‚Äôs bslib package. This guide will teach you how to use bslib to build:\n\nSidebars\nMulti-page apps that have a navigation bar\nMulti-page panels, like a tabset\nAccordions\nMulti-column apps that leverage a grid layout\n\nFor more information on any of these items, visit the bslib package site at the links above.\n\n\nSidebar Layout\nThe sidebar layout is a useful starting point for most applications. This layout provides a sidebar for inputs and a large main area for output:\n\n\n\nSidebar Layout\n\n\nHere‚Äôs the code used to create this layout:\nui &lt;- page_sidebar(\n\n  title = \"Hello Shiny!\",\n\n  sidebar = sidebar(\n    sliderInput(\n      \"bins\", label = \"Number of bins:\",\n      min = 1, value = 30, max = 50\n    )\n  ),\n\n  plotOutput(\"distPlot\")\n)\nNote that the sidebar can be positioned to the left (the default) or right of the main area. For example, to position the sidebar to the right you would use this code:\nui &lt;- page_sidebar(\n\n  title = \"Hello Shiny!\",\n\n  sidebar = sidebar(\n    position = \"right\",\n    # Inputs excluded for brevity\n  ),\n\n  # Outputs excluded for brevity \n)\npage_sidebar() described above makes use of bslib‚Äôs lower level layout_sidebar() function. layout_sidebar() provides a way to add a sidebar to individual bslib components, like nav_panel()s and card()s. For example, this app contains two cards, one of which has a sidebar.\n\n\n\nCard with sidebar\n\n\nHere‚Äôs the code used to create this layout:\nui &lt;- page_fillable(\n\n  card(\n    card_header(\"Card without sidebar\"),\n    \"No Sidebar\"\n  ),\n  \n  card(\n    card_header(\"Card with sidebar\"),\n    layout_sidebar(\n      sidebar = sidebar(\n        bg = \"lightgrey\",\n        \"Sidebar\"\n      ),\n      \"Main Content\"\n    )\n  )\n  \n)\nVisit the Sidebars article on the bslib site to learn more about bslib sidebars.\n\n\nMulti-page apps\nTo add multiple pages to an app, change page_sidebar() to page_navbar() and use nav_panel() to supply the title and content for each page. Here you can also take advantage of bslib‚Äôs:\n\nnav_spacer()\nnav_menu()\nnav_item()\n\nto add items or menus to the navbar, and to control their alignment.\n\n\n\nMulti-page app\n\n\nHere‚Äôs the code used to create this layout:\nui &lt;- page_navbar(\n  title = \"My App\",\n  bg = \"#2D89C8\",\n  inverse = TRUE,\n  nav_panel(title = \"One\", p(\"First page content.\")),\n  nav_panel(title = \"Two\", p(\"Second page content.\")),\n  nav_panel(title = \"Three\", p(\"Third page content.\")),\n  nav_spacer(),\n  nav_menu(\n    title = \"Links\",\n    align = \"right\",\n    nav_item(tags$a(\"Posit\", href = \"https://posit.co\")),\n    nav_item(tags$a(\"Shiny\", href = \"https://shyr-test-center.netlify.app\"))\n  )\n)\nBe wary that page_navbar()‚Äôs sidebar argument puts the same sidebar on every page, which may or may not be desirable. Sometimes it is better that only particular pages have such a sidebar layout. To achieve this, use layout_sidebar() within the nav_panel()s that should have a sidebar.\nSometimes it is useful for an app to know which page is active. To make this information available, pass an optional id argument to the page_navbar(), e.g.¬†page_navbar(id = \"page\", ...). The title of the active nav_panel() will be available in reactive contexts as input$&lt;id&gt;, e.g.¬†input$page.\n\nSecondary Navigation\nYou can add a second level of navigation to the page by using the nav_menu() function, as above. This adds a menu to the top level navbar which can in turn refer to additional nav_panel()s.\n\n\nAdditional Options\nSee the page_navbar() reference page for additional measures of customization.\n\n\n\nTabsets (Multi-page panels)\nMultiple nav_panel()s don‚Äôt necessarily need to go directly into page_navbar(). They can also be consumed by any navset_*() component, including navset_card_underline(), which makes a streamlined tabset.\n\n\n\nTabsets\n\n\nHere is the code that creates the above layout.\nui &lt;- page_sidebar(\n  title = \"Penguins dashboard\",\n  sidebar = sidebar(\n    varSelectInput(\n      \"color_by\",\n      \"Color by\",\n      penguins[c(\"species\", \"island\", \"sex\")],\n      selected = \"species\"\n    )\n  ),\n\n  navset_card_underline(\n    title = \"Histograms by species\",\n    nav_panel(\"Bill Length\", plotOutput(\"bill_length\")),\n    nav_panel(\"Bill Depth\", plotOutput(\"bill_depth\")),\n    nav_panel(\"Body Mass\", plotOutput(\"body_mass\"))\n  )\n)\nThe bslib package provides many styles of navset_*() containers for combining panels, including:\n\nnavset_underline() and navset_card_underline()\nnavset_tab() and navset_card_tab()\nnavset_pill_list()\nnavset_pill() and navset_card_pill()\nnavset_hidden()\nnavset_bar()\n\nEach allows the user to navigate the panels in a different way. Functions that contain card in their name place the navigation container within its own card. Learn more in the tabsets article.\n\n\nAccordions\nAn accordion() uses vertical collapsing to provide scalable navigation through many sections of content. Accordions can be placed anywhere on the page, including in a sidebar, which is convenient for grouping sections of input controls.\n\n\n\nAccordions\n\n\nHere is the code to make this app. Notice that it uses accordions in both the sidebar and the main content.\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\ndata(penguins, package = \"palmerpenguins\")\n\n# Define UI for random distribution app ----\n# Sidebar layout with input and output definitions ----\nui &lt;- page_sidebar(\n  title = \"Penguins dashboard\",\n\n  sidebar = sidebar(\n    bg = \"white\",\n    accordion(\n      accordion_panel(\n        \"Primary controls\",\n        varSelectInput(\n          \"color_by\", \"Color by\",\n          penguins[c(\"species\", \"island\", \"sex\")],\n          selected = \"species\"\n        )\n      ),\n      accordion_panel(\n        \"Other controls\",\n        \"Other controls go here\"\n      )\n    )\n  ),\n\n  accordion(\n    open = c(\"Bill Length\", \"About\"),\n    accordion_panel(\n      \"Bill Length\",\n      plotOutput(\"bill_length\")\n    ),\n    accordion_panel(\n      \"Bill Depth\",\n      plotOutput(\"bill_depth\")\n    ),\n    accordion_panel(\n      \"Body Mass\",\n      plotOutput(\"body_mass\")\n    )\n  )\n)\n\n\n# Define server logic required to draw a histogram ----\nserver &lt;- function(input, output) {\n  gg_plot &lt;- reactive({\n    ggplot(penguins) +\n      geom_density(aes(fill = !!input$color_by), alpha = 0.2) +\n      theme_bw(base_size = 16) +\n      theme(axis.title = element_blank())\n  })\n\n  output$bill_length &lt;- renderPlot(gg_plot() + aes(bill_length_mm))\n  output$bill_depth &lt;- renderPlot(gg_plot() + aes(bill_depth_mm))\n  output$body_mass &lt;- renderPlot(gg_plot() + aes(body_mass_g))\n}\n\n# Create Shiny app ----\nshinyApp(ui = ui, server = server)\nSimilar to page_navbar() and tabsets, the title of the currently active accordion panel can be accessed from reactive contexts as input$&lt;id&gt;, provided an id argument is passed to accordion().\nLearn more about accordions on their reference page.\n\n\nMulti-column apps\nA simple way to create an app without a sidebar is page_fillable(). Shiny will scale whatever components you place in page_fillable() to use the available vertical and horizontal space of the app.\nBy default, Shiny apps place each new component beneath the last, as if it placed each piece of content into a new row. For example, we can use this code to layout three cards:\nui &lt;- page_fillable(\n\n  card(card_header(\"Card 1\")),\n  card(card_header(\"Card 2\")),\n  card(card_header(\"Card 3\"))\n  \n)\n\n\n\nRowwise layout\n\n\nTo place components beside each other, as if each appeared in a new column, wrap the components with layout_columns(), like this:\nui &lt;- page_fillable(\n\n  layout_columns(\n     card(card_header(\"Card 1\")),\n     card(card_header(\"Card 2\")),\n     card(card_header(\"Card 3\"))\n  )\n  \n)\nThis creates the following layout:\n\n\n\nColumnwise layout\n\n\nYou can mix, match, and nest these methods to create bespoke, grid based layouts. For example, this app uses both row and column-based placement. It also nests rows within a column.\n\n\n\nMixed layout\n\n\nHere is the code that makes the layout. Notice that it calls layout_columns() in a nested fashion. It also uses a col_widths argument. Let‚Äôs look at col_widths next.\nui &lt;- page_fillable(\n\n  layout_columns(\n     card(card_header(\"Card 1\")),\n     layout_columns(\n       card(card_header(\"Card 2\")),\n       card(card_header(\"Card 3\")),\n       col_widths = c(12, 12)\n     )\n  ),\n     card(card_header(\"Card 4\"))\n\n)\n\nColumn widths\nIf no col_widths are specified, layout_columns divides space evenly among the UI elements in a row. A vector of column widths may also be supplied to allocate a given number of units (out of 12) to each element. Consider these units to be relative to the area that layout_columns() spans within the app. layout_columns() will divide the area into 12 and assign widths to columns accordingly.\n\n\n\nColumn widths\n\n\nHere is the code that makes the layout:\nui &lt;- page_fillable(\n\n  layout_columns(\n    card(card_header(\"Card 1\")),\n    card(card_header(\"Card 2\")),\n    card(card_header(\"Card 3\")),\n    col_widths = c(4, 6, 2)\n  )\n\n)\nAnd, if elements go beyond the 12 unit mark, they get wrapped onto a new row.\n\n\n\nColumn wrapping\n\n\nHere is the code that makes the layout:\nui &lt;- page_fillable(\n\n  layout_columns(\n    card(card_header(\"Card 1\")),\n    card(card_header(\"Card 2\")),\n    card(card_header(\"Card 3\")),\n    col_widths = c(6, 6, 8)\n  )\n\n)\n\n\nRow heights\nBy default, all row heights are equal, but this can be customized with the row_heights argument (numeric values are interpreted as fractional units, but fixed length units are also supported).\n\n\n\nRow heights\n\n\nHere is the code that makes the layout:\nui &lt;- page_fillable(\n\n  layout_columns(\n    card(card_header(\"Card 1\")),\n    card(card_header(\"Card 2\")),\n    card(card_header(\"Card 3\")),\n    col_widths = c(6, 6, 8),\n    row_heights = c(1, 2)\n  )\n\n)\n\n\nNegative Space\nNegative col_widths may also be provided to easily create negative/empty space:\n\n\n\nNegative space\n\n\nHere is the code that makes the layout:\nui &lt;- page_fillable(\n\n  layout_columns(\n    card(card_header(\"Card 1\")),\n    card(card_header(\"Card 2\")),\n    card(card_header(\"Card 3\")),\n    col_widths = c(4, 8, -2, 8, -2)\n  )\n\n)\n\nshinyApp(ui, server)\nAlthough we don‚Äôt show it here, layout_columns() also supports different col_widths and row_heights at different breakpoints(). This is useful for creating responsive layouts that adapt to different screen sizes. To learn more, visit layout_columns().\n\n\n\nFilling layout\nbslib provides three functions that allow you to layout elements on a sub-dividable 12-column grid, as with page_fillable(). Each resizes the components that you pass it dynamically (or not) as the size of the app changes, to make use of the available space.\n\npage_fixed() places components into a grid that occupies a fixed width of 940 pixels by default. It may assume other widths when Bootstrap‚Äôs responsive layout kicks in (e.g., when on a tablet).\npage_fluid() places components into a grid that always occupies the full width of the web page, and it re-sizes its components dynamically as the width of the page changes.\npage_fillable() places components into a grid that always occupies the full width and height of the web page, and it re-sizes its components dynamically as the width and height of the page changes.\n\n\n\n\n‚ÄúDifferences between the three functions‚Äù\n\n\n\n\nResponsive Layout\nThe Bootstrap grid system supports responsive CSS, which enables your application to automatically adapt its layout for viewing on different sized devices. Responsive layout includes the following:\n\nModifying the width of columns in the grid\nStacking elements instead of using float wherever necessary\nResizing headings and text to be more appropriate for devices\n\nResponsive layout is enabled by default for all Shiny page types.\n\nAvailable breakpoints\nBootstrap 5 includes six default breakpoints, which are customizable via Sass. By default, many column-wise layouts (e.g., layout_columns()) only apply at the sm breakpoint and larger.\n\n\n\nBreakpoint\nClass infix\nDimensions\n\n\n\n\nExtra small\nNone\n&lt; 576 px\n\n\nSmall\nsm\n&lt; 768 px\n\n\nMedium\nmd\n&lt; 992 px\n\n\nLarge\nlg\n&lt; 1200 px\n\n\nExtra large\nxl\n&lt; 1400 px\n\n\nExtra extra large\nxxl\n&gt;= 1400 px\n\n\n\nThat said, you can use breakpoints() with layout_columns() to customize column widths for different screen sizes:\nlayout_columns(\n    card(card_header(\"Card 1\"), \"foo\"),\n    card(card_header(\"Card 2\"), \"foo\"),\n    card(card_header(\"Card 3\"), \"foo\"),\n    col_widths = breakpoints(\n        sm = c(4, 4, 4), \n        md = c(3, 3, 6), \n        lg = c(-2, 8, -2)\n    )\n)\nSee the Bootsrap website for more details.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Application layout guide"
    ]
  },
  {
    "objectID": "r/articles/build/js-events/index.html",
    "href": "r/articles/build/js-events/index.html",
    "title": "JavaScript Events in Shiny",
    "section": "",
    "text": "A number of JavaScript events are supported in Shiny as of version 0.13.0. These events can be used to keep track of the app‚Äôs progress, or even manipulate the values of inputs/outputs. All event names have the prefix shiny:, e.g., shiny:connected. We can listen to these events using jQuery‚Äôs .on() method, e.g.,\nWhen an event is triggered in Shiny, the event object may have some additional properties that can be used to query or modify the information in Shiny, as we will see later in this document. Some events can cancel the process in Shiny, e.g., stop the propagation of an input or output change to the server. Such events include shiny:inputchanged, shiny:message, shiny:value, shiny:error, shiny:updateinput. To cancel the Shiny process, you can use event.preventDefault(), e.g.,\nAll events currently supported in Shiny are listed below. Here‚Äôs a live example (source).",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "JavaScript Events in Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/js-events/index.html#initial-connection-session-initialization-and-disconnection",
    "href": "r/articles/build/js-events/index.html#initial-connection-session-initialization-and-disconnection",
    "title": "JavaScript Events in Shiny",
    "section": "Initial Connection, Session Initialization and Disconnection",
    "text": "Initial Connection, Session Initialization and Disconnection\nThe events shiny:connected and shiny:disconnected are triggered when an initial connection to server is established, and when a session is ended or the connection is lost for some reason, respectively.\nYou can think of the shiny:connected event as firing the moment that you connect to Shiny. However, if you want to listen for an event that signals when you want to interact with the session object, you should use shiny:sessioninitialized. This event is only fired after the session object (the optional third argument in the Shiny server function) is fully initialized and queryable. These two events should happen almost immediately one after the other.\nFor shiny:connected and shiny:disconnected, the event object has a socket property, which is used to store the web socket that is used to communicate between R and JavaScript. For example, you may query the state of the web socket via event.socket.readyState. The shiny:sessioninitialized event doesn‚Äôt have any special Shiny properties.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "JavaScript Events in Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/js-events/index.html#server-status-busyidle",
    "href": "r/articles/build/js-events/index.html#server-status-busyidle",
    "title": "JavaScript Events in Shiny",
    "section": "Server Status: Busy/Idle",
    "text": "Server Status: Busy/Idle\nThe event shiny:busy is triggered when something is happening on the server (e.g.¬†an observer is running), and the event shiny:idle indicates when the server is idle. The event object does not carry any special properties related to Shiny.\nBy the first time that shiny:idle is triggered, both shiny:connected and shiny:sessioninitialized have already fired (by that order).",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "JavaScript Events in Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/js-events/index.html#messages",
    "href": "r/articles/build/js-events/index.html#messages",
    "title": "JavaScript Events in Shiny",
    "section": "Messages",
    "text": "Messages\nThe shiny:message is triggered when any messages are received from the server. The event has a property message, which is the message object (a JavaScript object).",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "JavaScript Events in Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/js-events/index.html#conditional-panels",
    "href": "r/articles/build/js-events/index.html#conditional-panels",
    "title": "JavaScript Events in Shiny",
    "section": "Conditional Panels",
    "text": "Conditional Panels\nWhen conditional panels (see ?shiny::conditionalPanel) are updated, the event shiny:conditional is triggered on the document.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "JavaScript Events in Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/js-events/index.html#bindingunbinding-inputsoutputs",
    "href": "r/articles/build/js-events/index.html#bindingunbinding-inputsoutputs",
    "title": "JavaScript Events in Shiny",
    "section": "Binding/Unbinding Inputs/Outputs",
    "text": "Binding/Unbinding Inputs/Outputs\nAll the events above are triggered on the whole document. There are a few events triggered on specific HTML elements, including the events in the following sections on input and output elements.\nWhen an input or output is bound to Shiny, the event shiny:bound is triggered. Similarly, there is a shiny:unbound event after an input/output is unbound. In these events, the event object has properties binding (the input/output binding object) and bindingType (may be 'input' or 'output' depending on whether the binding is for an input or an output).",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "JavaScript Events in Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/js-events/index.html#output-events",
    "href": "r/articles/build/js-events/index.html#output-events",
    "title": "JavaScript Events in Shiny",
    "section": "Output Events",
    "text": "Output Events\nThe shiny:value event is triggered when an output receives a value from the server. The event object has three properties: name (output id), value (output value), and binding (output binding).\nThe shiny:outputinvalidated event is triggered when an output‚Äôs value is invalidated on the server. The event object has two properties: name (output id), and binding (output binding).\nThe shiny:error event is triggered when an error is propagated to an output. The event also has three properties like the shiny:value event: name, error (the error message), and binding.\nThe shiny:recalculating and shiny:recalculated events are triggered before and after an output value is recalculated, respectively. Please note shiny:recalculated is triggered after the output value has been recalculated in R, but that does not imply the output value has been displayed on the page. Use shiny:value instead if you want to do something when the output value is rendered.\nTo recap, suppose you have an output x which takes a reactive dependency on y (this could be an input or another reactive object). When y changes, the first thing that happens is that x is invalidated (and the shiny:outputinvalidated event for x is fired). The shiny:recalculating event is the next one to be fired for x. This may happen either immediately after the previous event, or it can take a while, depending on whether or not there are other previously invalidated objects also waiting to be recalculated. Once the value of x has finished recalculating, its shiny:recalculated event is fired. The last event to be fired for x is shiny:value (or shiny:error if the recalculation resulted in an error).\nThe shiny:visualchange event is triggered when an output is resized, hidden, or shown. The event object has properties visible (true or false) and binding (the output binding).\nSince these events are triggered specifically on an output element, you may add the listener on the output element instead of on the document, although the latter also works, e.g.\n$('#foo').on('shiny:value', function(event) {\n  // append a character string to the output value\n  event.value += ' Oh that is nice!';\n});\n\n// use event.target to obtain the output element\n$(document).on('shiny:value', function(event) {\n  // cancel the output of the element with id 'foo'\n  if (event.target.id === 'foo') {\n    event.preventDefault();\n  }\n});",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "JavaScript Events in Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/js-events/index.html#input-events",
    "href": "r/articles/build/js-events/index.html#input-events",
    "title": "JavaScript Events in Shiny",
    "section": "Input Events",
    "text": "Input Events\nThe event shiny:inputchanged is triggered when an input possibly has a new value, e.g., when you click an action button, or type in a text input. The event object has properties name (the id of the input), value (the value of the input), inputType (the type of the input, e.g.¬†shiny.action), binding (the input binding object), and el (the DOM element for the input). The reason that it can be triggered when the input possibly has a new value is because, in some cases, keyboard or mouse events can trigger shiny:inputchanged even when the value has not actually changed.\nFor example, suppose you have a numeric input with id foo, you may double its value through this event:\n$(document).on('shiny:inputchanged', function(event) {\n  if (event.name === 'foo') {\n    event.value *= 2;\n  }\n});\nThe shiny:updateinput event is triggered when an input is updated from the server, e.g., when you call updateTextInput() in R to update the label or value of a text input. The event object has properties message (the update message sent from the server) and binding (the input binding).",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "JavaScript Events in Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/js-custom-input/index.html#introduction",
    "href": "r/articles/build/js-custom-input/index.html#introduction",
    "title": "How to create custom input bindings",
    "section": "Introduction",
    "text": "Introduction\nIn this tutorial we‚Äôll learn how we can create our own custom input bindings. In a Shiny context, input bindings are mainly used to send information from the client to R. In contrast, the HTMLWidgets we created previously are examples of output bindings. Their main task is to send data from R to the browser and to output e.g.¬†a chart or say a data table.\nThe simplest form of an input binding is an action button. The main purpose of an action button is to send a trigger from the client to R when we press the button.\nOut of the box, Shiny offers a number of other useful input bindings e.g.¬†a date picker or a selectize box. Please check out the UI Inputs section here for a more comprehensive overview of the available input bindings. Sometimes, however, you may want to use your own set of buttons with custom behavior. For instance, bootstrap alone already offers a vast amount of buttons, button groups, dropdown buttons etc. that you may want to use. This is typically the scenario in which you want to create an input binding such that you can easily use this functionality from R.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to create custom input bindings"
    ]
  },
  {
    "objectID": "r/articles/build/js-custom-input/index.html#creating-your-own-toggle-switch-input-binding",
    "href": "r/articles/build/js-custom-input/index.html#creating-your-own-toggle-switch-input-binding",
    "title": "How to create custom input bindings",
    "section": "Creating your own toggle switch input binding",
    "text": "Creating your own toggle switch input binding\nAs a first example, let‚Äôs create a toggle switch, based on bootstrap switch. With bootstrap switch you can easily turn checkboxes and radio buttons into iPhone style toggle switches. An overview of the various switches can be found here.\nHere‚Äôs an example of the switch we will be creating. Press the button and see what happens!\n\n\n\n\n\n\n\n\n\n\n\nAn example of a custom input binding in the form of a toggle switch\n\n\nLet‚Äôs start with an example without Shiny and slowly work towards creating the input binding.\nFrom the documentation of bootstrap switch it becomes clear that we need to:\n\ninclude a single CSS and JavaScript file,\ncreate a standard input control, and\ncall the bootstrapSwitch method on the input control in JavaScript.\n\nMore concretely, for this first step we need to include:\n&lt;link href=\"bootstrap-switch.css\" rel=\"stylesheet\"&gt;\n&lt;script src=\"bootstrap-switch.js\"&gt;&lt;/script&gt;\nNote that Bootstrap switch also requires jquery and bootstrap, however, these are automatically included by shiny.\nNext, we need to create an input tag of type checkbox and give it an id so we can easily grab the element later:\n&lt;input id=\"id1\" type=\"checkbox\"&gt;\nFinally, in JavaScript we select the input control via jQuery, based on the given id, and call the bootstrapSwitch method on the selection. The latter method is defined in bootstrap-switch.js.\n$(\"#id1\").bootstrapSwitch();\nBootstrap switch offers various options and methods you can use to initialize the component or to update the state after the switch has been rendered. For instance, using the options you can control the colors and the texts used in the switch. You can also listen for state change events if you need to.\nSimilar to creating an HTMLWidget, in order to create an input binding, we have to write some R code and some JavaScript code.\n\nBoilerplate code\nThere are a few things that are good to figure out before implementing a component. Before you start, make sure you understand:\n\nthe required HTML of your component and that you know which options you can set,\nhow to create HTML attributes for these options and extract their values from JavaScript,\nhow you can initialize your component in HTML or JavaScript based on these values,\nhow to listen for changes to the state of your component, and\nhow to extract a useful value out of your component to send to Shiny.\n\nNext we‚Äôll look into the actual R and JavaScript code required. At a first glance the required code below may appear a bit involved for only a single component. However, most of it is just boilerplate code that is the same for all input bindings you‚Äôll create. Filling in the details usually does not require too much original code. Especially if you master the five steps from above, creating a custom input binding is not that difficult.\n\nR boilerplate\nThe core boilerplate R code we need to implement is:\ncomponent &lt;- function(inputId, ...) {\n\n  tagList(\n\n    # add CSS and JavaScript files\n    ...\n\n    # create required tag and set options via HTML attributes\n    ...\n  )\n}\nBasically, we create a function, pass in some options, tell Shiny what and where the required CSS and JavaScript files are, create a taglist with some tags, and set some attributes in these tags.\nWe can then can use this function to use our binding. For instance, we may have component(\"comp1\", label = \"comp 1\", value = 10). Subsequently, we get the input back via input$comp1, which value initially will be 10.\n\n\nJavaScript boilerplate\nNext, the core boilerplate JavaScript code we need to implement is:\n// step i\nvar binding = new Shiny.InputBinding();\n\n// step ii\n$.extend(binding, {\n\n  find: function(scope) {\n    ...\n  },\n\n  initialize: function(el){\n    ...\n  },\n\n  getValue: function(el) {\n    ...\n  },\n\n  subscribe: function(el, callback) {\n    ...\n  }\n\n});\n\n// step iii\nShiny.inputBindings.register(binding);\nDon‚Äôt worry if you‚Äôre not familiar with this code yet, we‚Äôll explain it shortly! Essentially, we first create a new binding object, then add a few simple methods to it, and finally, we register the component so that Shiny knows it exists.\nThese methods allow Shiny to find instances of our component, to initialize them, to get information (values) out of them, to listen and react to changes to the state of our components, and to send information to Shiny, which in R we can capture with input$....\nWe‚Äôll discuss each of these methods and their implementation for our switch component in detail below. Let‚Äôs start with the R code!\n\n\n\nImplementing the R part\nIn order to use our switch component in other projects we create a BootstrapSwitch package. For convenience, you can find the example package here.\nIn our example, we want to create a toggle switch from R that we can use in Shiny. We‚Äôll allow the user to set an inputId and some options.\nMore specifically, we want to be able to set the inputId, label, initial state, width, size and to specify the on / off color scheme i.e.¬†onColor and offColor, using standard bootstrap colors i.e.¬†default, primary, success, info, warning, and danger.\nThe complete R code for our example looks like this:\nbootstrapSwitch &lt;- function(inputId, label, state = TRUE, width = \"auto\", size = \"mini\",\n                            onColor = \"success\", offColor = \"danger\") {\n\n  addResourcePath(\n    prefix = 'wwwFrissSwitch', directoryPath = system.file('www', package='BootstrapSwitch')\n  )\n\n  tagList(\n\n    singleton(tags$head(\n      tags$script(src=\"wwwFrissSwitch/bootstrap-switch.min.js\"),\n      tags$script(src=\"wwwFrissSwitch/BootstrapSwitchBinding.js\"),\n      tags$link(rel=\"stylesheet\", type=\"text/css\", href=\"wwwFrissSwitch/bootstrap-switch.min.css\")\n    )),\n\n    tags$input(type = \"checkbox\", id = inputId, class = \"FrissSwitch\",\n               \"data-state\" = tolower(state),\n               \"data-size\" = size,\n               \"data-label-width\" = width,\n               \"data-on-color\" = onColor,\n               \"data-off-color\" = offColor,\n               \"data-label-text\" = label)\n  )\n}\nAs we want to create an R package, Shiny needs to know where our CSS and JavaScript files live. The addResourcePath and the code block inside singleton make sure that happens. Of note, all these files need to be placed inside the www directory of our package.\nsystem.file tells Shiny where the directory of our package is after we have installed it, while BootstrapSwitchBinding.js contains the JavaScript part for our binding.\nNext, we create an input tag and set its type, id and class. The class attribute is used in JavaScript to find all instances of our component in a Shiny app (see below). Furthermore, we add a number of data- attributes to initialize our toggle switch. See here for an overview of the available options.\nFinally, note that the return type of our function is a tagList, that contains both the CSS and JavaScript files, as well as the required input tag. Shiny subsequently makes sure the files we need are included in the head of the HTML document of our app and generates the input tag. After this is done, we‚Äôll call some JavaScript on the tag, which we‚Äôll discuss next.\n\n\nImplementing the JavaScript part\nNext, let‚Äôs take a closer look at the boilerplate code for the required JavaScript:\n// this object that tells Shiny how to identify instances of our component and how to interact with them\nvar binding = new Shiny.InputBinding();\n\n// add some methods to our binding object\n$.extend(binding, {\n\n ...\n\n});\n\n// register the binding so Shiny knows it exists\nShiny.inputBindings.register(binding);\nFirst we indicate that we want to create a new custom input binding and store it in a variable called binding. Next, using jQuery‚Äôs extend we add various methods to this object (described below). Finally, we register our component.\n\nCore methods\nVarious methods can be added to the input binding object. The following are the most important:\n$.extend(binding, {\n\n  find: function(scope) {\n    ...\n  },\n\n  initialize: function(el){\n    ...\n  },\n\n  getValue: function(el) {\n    ...\n  },\n\n  subscribe: function(el, callback) {\n\n      $(el).on('...', function(event){\n\n        callback();\n      });\n  }\n\n});\nThe implementation details of these methods differ for each binding. Before discussing these, we first explain their purpose.\n\nfind\nThe find method finds any descendant elements that are an instance of your component and return them as an array-like object. Internally, the method often uses jQuery find method to locate these instances (see below). Note the argument scope is passed automatically by Shiny and here refers to the actual document object, the root node of our app.\n\n\ninitialize\nThe initialize method can be used to initialize a component, after we have rendered the required tags. el here is the element that was returned from find i.e.¬†the actual component. Furthermore, we can use jQuery‚Äôs data method to extract data attributes from our element (see below).\nFor instance, in the R code, we added attributes for data-state and data-on-color to our input element. In JavaScript, we can easily extract such attribute values from el e.g.¬†using $(el).data(\"state\") and $(el).data(\"onColor\"). Note that we need to omit the data- part and use camel casing. See here for additional information on jQuery‚Äôs data method.\n\n\ngetValue\nThe getValue method is used to extract the actual value out of our element el. The value we return here is the value that is made available in Shiny via input$....\n\n\nsubscribe\nThe subscribe method listens for specific events on our component. This is easiest to implement using jQuery‚Äôs on method. When jQuery detects the event, the method uses callback (an internal Shiny function), that subsequently calls getValue, and send the extracted value to shiny.\nThe complete JavaScript code for our switch example looks like this:\n// create a binding object\nvar binding = new Shiny.InputBinding();\n\n// add methods to it using jQuery's extend method\n$.extend(binding, {\n\n  find: function(scope) {\n\n    // find all instances of class FrissSwitch\n    return $(scope).find(\".FrissSwitch\");\n\n  },\n\n  // this method will be called on initialisation\n  initialize: function(el){\n\n     // extract the state from el\n     // note here our bootstrapSwitch does not yet exist\n     var state = $(el).data(\"state\");\n\n     // initialize our switch based on the extracted state\n     // note $(\"#\" + el.id) equals the input tag we generated\n     $(\"#\" + el.id).bootstrapSwitch(\"state\",state);\n\n     // now bootstrapSwitch does exist\n\n  },\n\n  // this method will also be called on initialisation (to pass the intial state to input$...)\n  // and each time when the callback is triggered via the event bound in subscribe\n  getValue: function(el) {\n\n    // get the value from bootstrapSwitch\n    var value = $(el).bootstrapSwitch('state');\n\n    return value;\n  },\n\n  // we want to subscribe to the switchChange event\n  // see http://bootstrapswitch.com/events.html\n  subscribe: function(el, callback) {\n\n    // only when the switchChange event is detected on instances of class bootstrapSwitch\n    // trigger the getValue method and send the value to shiny\n    $(document).on('switchChange.bootstrapSwitch', function(event){\n\n      // callback which will tell Shiny to retrieve the value via getValue\n      callback();\n    });\n  }\n});\n\n// register the binding so Shiny knows it exists\nShiny.inputBindings.register(binding);\nIn the code above, $(document).on('switchChange.bootstrapSwitch', ...) is an example of jQuery‚Äôs event-delegation. This type of behavior allows you to be efficient with event handlers.\nFor instance, suppose you generated a thousand buttons and you want to know the id of a button when you click on it. You could add a thousand click handlers, one for each button, but this is very inefficient. Using event-delegation you can use a single event handler instead, while still being able to tell which button was clicked.\nHere we ask jQuery to find all the elements of class bootstrapSwitch, and to use a single event handler for all switchChange events. The event object is automatically passed by JavaScript and can be used to find more information on the exact event. For example, see here.\nOf note, most changes of the JavaScript code between bindings will be for the getValue and subscribe methods. Fortunately, these methods often require only a few lines of code each. Note most lines in the code blocks above are code comments and indents.\n\n\n\nUsing console.log to learn more about your code\nYou can find out a lot about the code above by inserting console.log messages and checking your browser console (just hit F12 in the browser).\nFor instance, to know more about the event, scope, or el objects as used in the various methods, you can review their console.log.\nThe console.log will also tell you when and how often specific functions are called. For instance, the initialization method is called only once per component instance and so is the subscribe method. However, the callback inside the subscribe method is called many times, as is the getValue function.\n\n\n\nAdditional methods\nA more thorough description of the various methods above is provided here, while additional custom input binding examples by RStudio can be found here, and here.\nIn addition to the previously discussed methods, several other JavaScript methods can be added to your input binding object, notably; getId, getState, getRatePolicy, receiveMessage and unsubscribe. These are discussed in the various references provided and are not further discussed here.\n\n\nSecond example: A button group\nTo get some more exercise into creating your own custom input bindings, consider the source code for the binding for the button group used in the dashboard application, which can be found here.\n\n\nHTMLWidgets that send events to R\nHTMLWidgets send data from R to the browser, while input bindings do the reverse i.e.¬†they send data from the client to R. Even though this is a reasonable way to think about the difference between input and output bindings, it‚Äôs not the whole story.\nFor instance, RStudio‚Äôs leaflet widget is an example of an HTMLWidget i.e.¬†an output binding, that also sends events from the client to R. It does so when we change the map zoom level, pan the map to a different location, or click on a marker. Similar to input bindings, in R we can access these events using input$....\nNote that in JavaScript we can always send events back to Shiny using the Shiny.onInputChange method (see tutorial 3). In the next tutorial we see how we can use this method to send information from a brushable timeline widget (based on the C3LineBarChart developed tutorial 3), in order to create a filter system for our interactive dashboard application.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to create custom input bindings"
    ]
  },
  {
    "objectID": "r/articles/build/interactive-docs/index.html",
    "href": "r/articles/build/interactive-docs/index.html",
    "title": "Introduction to interactive documents",
    "section": "",
    "text": "Interactive documents are a new way to build Shiny apps. An interactive document is an R Markdown file that contains Shiny widgets and outputs. You write the report in markdown, and then launch it as an app with the click of a button.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "Introduction to interactive documents"
    ]
  },
  {
    "objectID": "r/articles/build/interactive-docs/index.html#r-markdown",
    "href": "r/articles/build/interactive-docs/index.html#r-markdown",
    "title": "Introduction to interactive documents",
    "section": "R Markdown",
    "text": "R Markdown\nThe previous article, Introduction to R Markdown, described how to write R Markdown files. R Markdown files are useful because\n\nThey are quick and easy to write.\nYou can embed executable R code into your file, which saves manual labor and creates a reproducible report.\nYou can convert R Markdown files into HTML, PDF, and Word documents with the click of a button.\nYou can convert R Markdown files into ioslides and beamer slideshows with the click of a button.\n\nIn fact, R Markdown files are the ultimate R reporting tool.\nThis article will show you one more thing that R Markdown files can do: you can embed Shiny components in an R Markdown file to create an interactive report or slideshow.\nYour report will be a complete Shiny app. In fact, R Markdown provides the easiest way to build light-weight Shiny apps. I will refer to apps that combine Shiny with R Markdown as interactive documents.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "Introduction to interactive documents"
    ]
  },
  {
    "objectID": "r/articles/build/interactive-docs/index.html#interactive-documents",
    "href": "r/articles/build/interactive-docs/index.html#interactive-documents",
    "title": "Introduction to interactive documents",
    "section": "Interactive documents",
    "text": "Interactive documents\nYou can make an R Markdown document interactive in two steps:\n\nadd runtime: shiny to the document‚Äôs YAML header.\nadd Shiny widgets and Shiny render functions to the file‚Äôs R code chunks\n\nThe rmarkdown package will compile your document into a reactive Shiny app. The document will look just as it would otherwise, but it will include reactive components.\n\nruntime: shiny\nNotify rmarkdown that your file contains Shiny components by adding runtime: shiny to the file‚Äôs YAML header. RStudio will change its ‚ÄúKnit‚Äù icon to a ‚ÄúRun Document‚Äù icon when you save this change.\n\n‚ÄúRun Document‚Äù is a cue that rmarkdown will no longer compile your document into a static file. Instead it will ‚Äúrun‚Äù the document as a live Shiny app.\nSince the document is a Shiny app, you must render it into an HTML format. Do this by selecting either html_document or ioslides_presentation for your final output.\n\n\nWidgets\nTo add a widget to your document, call a Shiny widget function in an R code chunk. R Markdown will add the widget to the code chunk‚Äôs output.\nFor example, the file below creates an HTML document with two widgets.\n---\nruntime: shiny\noutput: html_document\n---\n\n### Here are two Shiny widgets\n\n```{r echo = FALSE}\nselectInput(\"n_breaks\", label = \"Number of bins:\",\n              choices = c(10, 20, 35, 50), selected = 20)\n\nsliderInput(\"bw_adjust\", label = \"Bandwidth adjustment:\",\n              min = 0.2, max = 2, value = 1, step = 0.2)\n```\nThe document looks like this when rendered:\n\n\n\n\nRendered output\nTo add reactive output to your document, call one of the render* functions below in an R code chunk.\n\n\n\nrender function\ncreates\n\n\n\n\nrenderImage\nimages (saved as a link to a source file)\n\n\nrenderPlot\nplots\n\n\nrenderPrint\nany printed output\n\n\nrenderTable\ndata frame, matrix, other table like structures\n\n\nrenderText\ncharacter strings\n\n\nrenderUI\na Shiny tag object or HTML\n\n\n\n R Markdown will include the rendered output in the result of the code chunk.\nThis output will behave like rendered output in a standard Shiny app. The output will automatically update whenever you change a widget value or a reactive expression that it depends on.\nThe file below uses renderPlot to insert a histogram that reacts to the two widgets.\n---\nruntime: shiny\noutput: html_document\n---\n\n### Here are two Shiny widgets\n\n```{r echo = FALSE}\nselectInput(\"n_breaks\", label = \"Number of bins:\",\n              choices = c(10, 20, 35, 50), selected = 20)\n\nsliderInput(\"bw_adjust\", label = \"Bandwidth adjustment:\",\n              min = 0.2, max = 2, value = 1, step = 0.2)\n```\n\n### ...that build a histogram.\n\n```{r echo = FALSE}\nrenderPlot({\n  hist(faithful$eruptions, probability = TRUE,\n       breaks = as.numeric(input$n_breaks),\n       xlab = \"Duration (minutes)\",\n       main = \"Geyser eruption duration\")\n\n  dens &lt;- density(faithful$eruptions, adjust = input$bw_adjust)\n  lines(dens, col = \"blue\")\n})\n```\nThe document creates the app below when you click ‚ÄúRun Document.‚Äù\n\n\n\n\nThe structure of an interactive document\nWhen you run an interactive document, rmarkdown extracts the code in your code chunks and places them into a pseudo server.R file. R Markdown uses the html output of the markdown file as an index.html file to place the reactive elements into.\n\nAs a result, outputs in one code chunk can use widgets and reactive expressions that occur in other code chunks.\nSince the R Markdown document provides a layout for the app, you do not need to write a ui.R file.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "Introduction to interactive documents"
    ]
  },
  {
    "objectID": "r/articles/build/interactive-docs/index.html#sharing-interactive-documents",
    "href": "r/articles/build/interactive-docs/index.html#sharing-interactive-documents",
    "title": "Introduction to interactive documents",
    "section": "Sharing interactive documents",
    "text": "Sharing interactive documents\nInteractive documents are a type of Shiny app, which means that you can share them in the same way that you share other Shiny apps. You can\n\nEmail a .Rmd file to a colleague. He or she can run the file locally by opening the file and clicking ‚ÄúRun Document‚Äù\nHost the document with Shiny Server or Posit Connect\nHost the document at ShinyApps.io\n\nNote: If you are familiar with R Markdown, you might expect RStudio to save an HTML version of an interactive document in your working directory. However, this only works with static HTML documents. Each interactive document must be served by a computer that manages the document. As a result, interactive documents cannot be shared as a standalone HTML file.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "Introduction to interactive documents"
    ]
  },
  {
    "objectID": "r/articles/build/interactive-docs/index.html#conclusion",
    "href": "r/articles/build/interactive-docs/index.html#conclusion",
    "title": "Introduction to interactive documents",
    "section": "Conclusion",
    "text": "Conclusion\nInteractive documents provide a new and easy way to make Shiny apps.\nInteractive documents will not replace standard Shiny apps since they cannot provide the design options that come with a ui.R or index.html file. However, interactive documents do create some easy wins:\n\nThe R Markdown workflow makes it easy to build light-weight apps. You do not need to worry about laying out your app or building an HTML user interface for the app.\nYou can use R Markdown to create interactive slideshows, something that is difficult to do with Shiny alone. To create a slideshow, change output: html_document to output: ioslides_presentation in the YAML front matter of your .Rmd file. R Markdown will divide your document into slides when you click ‚ÄúRun Document.‚Äù A new slide will begin whenever a header or horizontal rule (***) appears.\nInteractive documents enhance the existing R Markdown workflow. R Markdown makes it easy to write literate programs and reproducible reports. You can make these reports even more effective by adding Shiny to the mix.\n\nTo learn more about R Markdown and interactive documents, please visit rmarkdown.rstudio.com.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "Introduction to interactive documents"
    ]
  },
  {
    "objectID": "r/articles/build/htmlwidgets/index.html",
    "href": "r/articles/build/htmlwidgets/index.html",
    "title": "htmlwidgets",
    "section": "",
    "text": "htmlwidgets is framework for embedding JavaScript visualizations into R.\nReady to use examples include:",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "htmlwidgets"
    ]
  },
  {
    "objectID": "r/articles/build/htmlwidgets/index.html#learn-more",
    "href": "r/articles/build/htmlwidgets/index.html#learn-more",
    "title": "htmlwidgets",
    "section": "Learn more",
    "text": "Learn more\nFor more on this topic, see the following resources:\n Interfacing DataTables\n Interactive network visualization with threejs and R\n Mapping in R with Leaflet\n Linking HTML Widgets with Crosstalk",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "htmlwidgets"
    ]
  },
  {
    "objectID": "r/articles/build/html-tags/index.html",
    "href": "r/articles/build/html-tags/index.html",
    "title": "Customize your UI with HTML",
    "section": "",
    "text": "In this article, you will learn how to supplement the functions in your UI with raw HTML to create highly customized Shiny apps. You do not need to know HTML to use Shiny, but if you do, you can use the methods in this article to enhance your app.\nThe user-interface (UI) of a Shiny app is web document. Shiny developers can provide this document as an index.html file or assemble it from R code in their ui object.\nThe UI calls R functions that output HTML code. Shiny turns this code into a web app.\nI will use the 01_hello app throughout this article as an example. You can access this app by running:",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Customize your UI with HTML"
    ]
  },
  {
    "objectID": "r/articles/build/html-tags/index.html#shinyui",
    "href": "r/articles/build/html-tags/index.html#shinyui",
    "title": "Customize your UI with HTML",
    "section": "shinyUI",
    "text": "shinyUI\nMany Shiny apps come with a ui object that determines the layout of the app. The ui object for 01_example looks like the following code:\nlibrary(shiny)\n\n# Define UI for application that draws a histogram\nui &lt;- fluidPage(\n\n  # App title ----\n  titlePanel(\"Hello Shiny!\"),\n\n  # Sidebar layout with input and output definitions ----\n  sidebarLayout(\n\n    # Sidebar panel for inputs ----\n    sidebarPanel(\n\n      # Input: Slider for the number of bins ----\n      sliderInput(inputId = \"bins\",\n                  label = \"Number of bins:\",\n                  min = 1,\n                  max = 50,\n                  value = 30)\n\n    ),\n\n    # Main panel for displaying outputs ----\n    mainPanel(\n\n      # Output: Histogram ----\n      plotOutput(outputId = \"distPlot\")\n\n    )\n  )\n)\nThe code creates this app:\n\n\n\nHello Shiny Screenshot\n\n\nEach ui object calls R functions that return HTML. In other words, Shiny lets you generate HTML with R. This is why you do not need to know HTML to use Shiny.\nYou can see that the functions in the ui object definition return HTML if you run them. fluidPage returns a chunk of HTML as does every function inside of fluidPage. For example, the following code returns the HTML output in the comments below.\nfluidPage(\n\n  # App title ----\n  titlePanel(\"Hello Shiny!\"),\n\n  # Sidebar layout with input and output definitions ----\n  sidebarLayout(\n\n    # Sidebar panel for inputs ----\n    sidebarPanel(\n\n      # Input: Slider for the number of bins ----\n      sliderInput(inputId = \"bins\",\n                  label = \"Number of bins:\",\n                  min = 1,\n                  max = 50,\n                  value = 30)\n\n    ),\n\n    # Main panel for displaying outputs ----\n    mainPanel(\n\n      # Output: Histogram ----\n      plotOutput(outputId = \"distPlot\")\n\n    )\n  )\n)\n\n## &lt;div class=\"container-fluid\"&gt;\n##   &lt;h2&gt;Hello Shiny!&lt;/h2&gt;\n##   &lt;div class=\"row\"&gt;\n##     &lt;div class=\"col-sm-4\"&gt;\n##       &lt;form class=\"well\"&gt;\n##         &lt;div class=\"form-group shiny-input-container\"&gt;\n##           &lt;label class=\"control-label\" for=\"bins\"&gt;Number of bins:&lt;/label&gt;\n##           &lt;input class=\"js-range-slider\" id=\"bins\" data-min=\"1\" data-max=\"50\" data-from=\"30\" ## data-step=\"1\" data-grid=\"true\" data-grid-num=\"9.8\" data-grid-snap=\"false\" ## data-prettify-separator=\",\" data-prettify-enabled=\"true\" data-keyboard=\"true\" ## data-keyboard-step=\"2.04081632653061\" data-data-type=\"number\"/&gt;\n##         &lt;/div&gt;\n##       &lt;/form&gt;\n##     &lt;/div&gt;\n##     &lt;div class=\"col-sm-8\"&gt;\n##       &lt;div id=\"distPlot\" class=\"shiny-plot-output\" style=\"width: 100% ; height: 400px\"&gt;&lt;/div&gt;\n##     &lt;/div&gt;\n##   &lt;/div&gt;\n## &lt;/div&gt; \ntitlePanel(\"Hello Shiny!\")\n## &lt;h2&gt;Hello Shiny!&lt;/h2&gt;\nIn R terminology, the output is a list of character strings with a special class that tells Shiny the contents contain HTML.\nclass(titlePanel(\"Hello Shiny!\"))\n## [1] \"shiny.tag.list\" \"list\" \nShiny‚Äôs UI functions are sufficient for creating most Shiny apps. In a large majority of your Shiny apps, you will probably never think of using anything more complicated. However in some apps, you may want to add custom HTML that is not provided by the usual Shiny functions. You can do this by passing HTML tags with the tags object.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Customize your UI with HTML"
    ]
  },
  {
    "objectID": "r/articles/build/html-tags/index.html#tags",
    "href": "r/articles/build/html-tags/index.html#tags",
    "title": "Customize your UI with HTML",
    "section": "tags",
    "text": "tags\nshiny::tags is a list of 110 functions. Each function builds a specific HTML tag. If you are familiar with HTML, you will recognize these tags by their names. You can learn what the most common tags do in the Shiny HTML tags glossary.\nnames(tags)\n##   [1] \"a\"           \"abbr\"        \"address\"     \"area\"        \"article\"\n##   [6] \"aside\"       \"audio\"       \"b\"           \"base\"        \"bdi\"\n##  [11] \"bdo\"         \"blockquote\"  \"body\"        \"br\"          \"button\"\n##  [16] \"canvas\"      \"caption\"     \"cite\"        \"code\"        \"col\"\n##  [21] \"colgroup\"    \"command\"     \"data\"        \"datalist\"    \"dd\"\n##  [26] \"del\"         \"details\"     \"dfn\"         \"div\"         \"dl\"\n##  [31] \"dt\"          \"em\"          \"embed\"       \"eventsource\" \"fieldset\"\n##  [36] \"figcaption\"  \"figure\"      \"footer\"      \"form\"        \"h1\"\n##  [41] \"h2\"          \"h3\"          \"h4\"          \"h5\"          \"h6\"\n##  [46] \"head\"        \"header\"      \"hgroup\"      \"hr\"          \"html\"\n##  [51] \"i\"           \"iframe\"      \"img\"         \"input\"       \"ins\"\n##  [56] \"kbd\"         \"keygen\"      \"label\"       \"legend\"      \"li\"\n##  [61] \"link\"        \"mark\"        \"map\"         \"menu\"        \"meta\"\n##  [66] \"meter\"       \"nav\"         \"noscript\"    \"object\"      \"ol\"\n##  [71] \"optgroup\"    \"option\"      \"output\"      \"p\"           \"param\"\n##  [76] \"pre\"         \"progress\"    \"q\"           \"ruby\"        \"rp\"\n##  [81] \"rt\"          \"s\"           \"samp\"        \"script\"      \"section\"\n##  [86] \"select\"      \"small\"       \"source\"      \"span\"        \"strong\"\n##  [91] \"style\"       \"sub\"         \"summary\"     \"sup\"         \"table\"\n##  [96] \"tbody\"       \"td\"          \"textarea\"    \"tfoot\"       \"th\"\n## [101] \"thead\"       \"time\"        \"title\"       \"tr\"          \"track\"\n## [106] \"u\"           \"ul\"          \"var\"         \"video\"       \"wbr\"\nTo create a tag, run an element of tags as a function. To create a div tag, you can run:\ntags$div()\n## &lt;div&gt;&lt;/div&gt; \nYou can call some of the most popular tags with helper functions (that wrap the appropriate tags functions). For example, the helper function code calls the tags\\(code and creates text formatted as computer code. The helper functions that can call their equivalent tags without using the tag syntex (tags\\)) are: a, br, code, div, em, h1, h2, h3, h4, h5, h6, hr, img, p, pre, span, and strong.\nThe names of other tags functions conflict with the names of native R functions, so you will need to call them with the tags$ syntax. For example, to embed a plug-in or third party application call it with tags$embed.\nEvery tag function will treat its arguments in a special way: it will treat named arguments as HTML attributes and unnamed arguments as HTML children.\n\nAttributes\nA tag function will use each named argument to add an HTML attribute to the tag. The argument name becomes the attribute name, and the argument value becomes the attribute value. So for example, if you want to create a div with a class attribute, use:\ntags$div(class = \"header\")\n## &lt;div class=\"header\"&gt;&lt;/div&gt;\nTo add an attribute without a value, set the attribute to NA:\ntags$div(class = \"header\", checked = NA)\n## &lt;div class=\"header\" checked&gt;&lt;/div&gt;\n\n\nChildren\nEach tag function will add unnamed arguments to your tag as HTML children. This addition lets you nest tags inside of each other (just as in HTML).\ntags$div(class = \"header\", checked = NA,\n  tags$p(\"Ready to take the Shiny tutorial? If so\"),\n  tags$a(href = \"shyr-test-center.netlify.app/tutorial\", \"Click Here!\")\n)\n## &lt;div class=\"header\" checked&gt;\n##   &lt;p&gt;Ready to take the Shiny tutorial? If so&lt;/p&gt;\n##   &lt;a href=\"shyr-test-center.netlify.app/tutorial\"&gt;Click Here!&lt;/a&gt;\n## &lt;/div&gt; \n\nwithTags\nYou can save typing by wrapping your HTML objects with withTags. withTags is similar to R‚Äôs regular with function. R will lookup each tag function mentioned inside withTags in the tags object, even if you do not specify tags$.\nwithTags({\n  div(class=\"header\", checked=NA,\n    p(\"Ready to take the Shiny tutorial? If so\"),\n    a(href=\"shyr-test-center.netlify.app/tutorial\", \"Click Here!\")\n  )\n})\n## &lt;div class=\"header\" checked&gt;\n##   &lt;p&gt;Ready to take the Shiny tutorial? If so&lt;/p&gt;\n##   &lt;a href=\"shyr-test-center.netlify.app/tutorial\"&gt;Click Here!&lt;/a&gt;\n## &lt;/div&gt; \nOnce you have a complete tag, you can add it directly to your app‚Äôs UI object. For example, you could add the tag above to the ui object of 01-hello:\nlibrary(shiny)\n\n# Define UI for application that draws a histogram\nfluidPage(\n\n  # App title ----\n  titlePanel(\"Hello Shiny!\"),\n\n  # Sidebar layout with input and output definitions ----\n  sidebarLayout(\n\n    # Sidebar panel for inputs ----\n    sidebarPanel(\n\n      # Input: Slider for the number of bins ----\n      sliderInput(inputId = \"bins\",\n                  label = \"Number of bins:\",\n                  min = 1,\n                  max = 50,\n                  value = 30),\n\n      # adding the new div tag to the sidebar            \n      tags$div(class=\"header\", checked=NA,\n               tags$p(\"Ready to take the Shiny tutorial? If so\"),\n               tags$a(href=\"shyr-test-center.netlify.app/tutorial\", \"Click Here!\")\n      )\n    ),\n\n    # Main panel for displaying outputs ----\n    mainPanel(\n\n      # Output: Histogram ----\n      plotOutput(outputId = \"distPlot\")\n\n    )\n  )\n)\nYour updated app will contain the new HTML element.\n\n\n\n01_hello\n\n\n\n\n\nConditional attributes and children\nIf you set an argument of a tag function to NULL, the argument will not appear in the HTML output. NULL gives you a way to build attributes and children that will appear only under certain conditions.\ntags$div(class = \"header\", id = NULL,\n    NULL,\n    \"line 2\"\n)\n## &lt;div class=\"header\"&gt;line 2&lt;/div&gt; \n\n\ntags$div(class = \"header\", id = if (FALSE) 100,\n    if (FALSE) \"line 1\",\n    \"line 2\"\n)\n## &lt;div class=\"header\"&gt;line 2&lt;/div&gt; \n\n\nLists\nYou can pass a list of children to a tag with R‚Äôs list function. The tag function will add each element of the list as a child of the tag.\ntags$div(class=\"header\", checked=NA,\n  list(\n    tags$p(\"Ready to take the Shiny tutorial? If so\"),\n    tags$a(href=\"shyr-test-center.netlify.app/tutorial\", \"Click Here!\"),\n    \"Thank you\"\n  )\n)\n## &lt;div class=\"header\" checked&gt;\n##   &lt;p&gt;Ready to take the Shiny tutorial? If so&lt;/p&gt;\n##   &lt;a href=\"shyr-test-center.netlify.app/tutorial\"&gt;Click Here!&lt;/a&gt;\n##   Thank you\n## &lt;/div&gt;",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Customize your UI with HTML"
    ]
  },
  {
    "objectID": "r/articles/build/html-tags/index.html#raw-html",
    "href": "r/articles/build/html-tags/index.html#raw-html",
    "title": "Customize your UI with HTML",
    "section": "Raw HTML",
    "text": "Raw HTML\nYou cannot put raw HTML directly into a tag or UI object. Shiny will treat raw HTML as a character string, adding HTML as text to your UI document.\ntags$div(\n  \"&lt;strong&gt;Raw HTML!&lt;/strong&gt;\"\n)\n## &lt;div&gt;&lt;strong&gt;Raw HTML!&lt;/strong&gt;&lt;/div&gt; \nTo add raw HTML, use the HTML function. HTML takes a character string and returns it as HTML (a special class of object in Shiny).\ntags$div(\n  HTML(\"&lt;strong&gt;Raw HTML!&lt;/strong&gt;\")\n)\n## &lt;div&gt;&lt;strong&gt;Raw HTML!&lt;/strong&gt;&lt;/div&gt; \nShiny will assume that the code you pass to HTML is correctly written HTML. Be sure to double check it.\n\nWarning\nIt is a bad idea to pass an input object to HTML:\ntags$div(\n  HTML(input$text)\n)\nThis allows the user to add their own HTML to your app, which creates a security vulnerability. What you user enters could be added to the web document or seen by other users, which might break the app. In the worse case scenario, a user may try to deploy malicious Cross Site Scripting (XSS), an undesirable security vulnerability.\n\n\nRecap\nYou can use HTML to customize your Shiny apps. Every Shiny app is built on an HTML document that creates the apps‚Äô user interface. Usually, Shiny developers create this document by building the ui object with R functions that build HTML output. However, you can supply HTML output directly with Shiny‚Äôs tags object.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Customize your UI with HTML"
    ]
  },
  {
    "objectID": "r/articles/build/gadgets/index.html",
    "href": "r/articles/build/gadgets/index.html",
    "title": "Shiny Gadgets",
    "section": "",
    "text": "Shiny was originally conceived as a medium for interactively communicating ideas and results. As the author of a Shiny app, you perform your analysis or build your models, and then write a Shiny app to let other people‚Äìespecially those without R expertise‚Äìexplore your findings or data.\nShiny Gadgets are different. Gadgets are interactive tools that enhance your R programming experience.\nWhere a Shiny app represents the output of an analysis, Shiny Gadgets are designed to be used in the course of analysis.\nWhere Shiny apps are designed to be used by end users, Shiny Gadgets are intended to be used by R users.\nWhere Shiny apps are ultimately intended to be deployed on servers (like Shiny Server or ShinyApps.io) and accessed via a web browser, Shiny Gadgets are only ever intended to be invoked from code (in the R console or from an R script) or from within RStudio.\nShiny Gadgets can be registered with RStudio as Addins, which makes them easy to discover and use in the GUI.",
    "crumbs": [
      "Build",
      "Structure",
      "Gadgets",
      "Shiny Gadgets"
    ]
  },
  {
    "objectID": "r/articles/build/gadgets/index.html#potential-uses",
    "href": "r/articles/build/gadgets/index.html#potential-uses",
    "title": "Shiny Gadgets",
    "section": "Potential uses",
    "text": "Potential uses\nShiny Gadgets could be created for most any task you might do during data loading, cleaning, manipulation, and visualization. Here are just a few ideas:\n\nAn easy-to-use UI for downloading data from a complicated API and turning it into a data frame\nA tool to preview regular expressions for find/replace (sub and gsub)\nVisual selection tools for subsetting or outlier exclusion",
    "crumbs": [
      "Build",
      "Structure",
      "Gadgets",
      "Shiny Gadgets"
    ]
  },
  {
    "objectID": "r/articles/build/gadgets/index.html#writing-shiny-gadgets",
    "href": "r/articles/build/gadgets/index.html#writing-shiny-gadgets",
    "title": "Shiny Gadgets",
    "section": "Writing Shiny Gadgets",
    "text": "Writing Shiny Gadgets\nIf you know how to write Shiny apps, you already know almost everything you need to write Shiny Gadgets, too. You still define UI, and provide a function for the server logic. You use the same reactive programming paradigm.\nThe main difference is how your UI and server logic is packaged. While Shiny apps generally have their own app directory (containing either ui.R/server.R files or a single app.R file), Shiny Gadgets are defined right inside a regular function.\nHere‚Äôs a skeleton:\nlibrary(shiny)\nlibrary(miniUI)\n\nmyGadgetFunc &lt;- function(inputValue1, inputValue2) {\n\n  ui &lt;- miniPage(\n    gadgetTitleBar(\"My Gadget\"),\n    miniContentPanel(\n      # Define layout, inputs, outputs\n    )\n  )\n\n  server &lt;- function(input, output, session) {\n    # Define reactive expressions, outputs, etc.\n\n    # When the Done button is clicked, return a value\n    observeEvent(input$done, {\n      returnValue &lt;- ...\n      stopApp(returnValue)\n    })\n  }\n\n  runGadget(ui, server)\n}\nAs you can see, the ui and server variables are very recognizably Shiny constructs, but they‚Äôre created right inside the gadget function. The fact that they‚Äôre created inside the gadget function is important, because it means they can directly access the function‚Äôs arguments (inputValue1, inputValue2), and the return value from runGadget can be the return value for the function.\nYou might also have noticed that the ui definition uses miniPage and miniContentPanel instead of the more familiar fluidPage, sidebarLayout, etc. That‚Äôs because gadgets default to running in the RStudio Viewer pane, which is much smaller than a typical browser window. Given the smaller real estate, it makes less sense to use the usual layout constructs in Shiny, so the miniUI package provides different layout functions that make better use of the available space. We‚Äôll go into more detail about this below.\nThe gadgetTitleBar call adds a bar across the top of your app that includes the title, plus Cancel and Done buttons. You handle the Done button as shown in the code above, but Cancel is automatically implemented by the runGadget call by stopping the app with a \"User cancel\" error. While this default behavior should be appropriate for almost all gadgets, if you prefer a different behavior for the Cancel button, call runGadget(ui, server, stopOnCancel = FALSE) and handle input$cancel yourself. For example, add a block like this to the server function to return NULL instead of erroring:\nobserveEvent(input$cancel, {\n  stopApp(NULL)\n})",
    "crumbs": [
      "Build",
      "Structure",
      "Gadgets",
      "Shiny Gadgets"
    ]
  },
  {
    "objectID": "r/articles/build/gadgets/index.html#example",
    "href": "r/articles/build/gadgets/index.html#example",
    "title": "Shiny Gadgets",
    "section": "Example",
    "text": "Example\nFirst, let‚Äôs take a look at an actual working example. This gadget takes a data frame and the names of two dimensions as input. It uses ggplot2 to render the data as a scatter plot. The user can click and drag to select points, and hit ‚ÄúDone‚Äù to return the relevant observations.\nTry sourcing this code in your R session:\nlibrary(shiny)\nlibrary(miniUI)\nlibrary(ggplot2)\n\nggbrush &lt;- function(data, xvar, yvar) {\n\n  ui &lt;- miniPage(\n    gadgetTitleBar(\"Drag to select points\"),\n    miniContentPanel(\n      # The brush=\"brush\" argument means we can listen for\n      # brush events on the plot using input$brush.\n      plotOutput(\"plot\", height = \"100%\", brush = \"brush\")\n    )\n  )\n\n  server &lt;- function(input, output, session) {\n\n    # Render the plot\n    output$plot &lt;- renderPlot({\n      # Plot the data with x/y vars indicated by the caller.\n      ggplot(data, aes_string(xvar, yvar)) + geom_point()\n    })\n\n    # Handle the Done button being pressed.\n    observeEvent(input$done, {\n      # Return the brushed points. See ?shiny::brushedPoints.\n      stopApp(brushedPoints(data, input$brush))\n    })\n  }\n\n  runGadget(ui, server)\n}\nNow, run ggbrush(mtcars, \"hp\", \"mpg\") in the R console. You should see something like this:\n\n\n\nScreen shot\n\n\nClick and drag on the plot, then click the Done button. You‚Äôll see the selection you made printed to the console in data frame form.\nHint: If you ever run a gadget (or indeed, any R console command) but forget to save the result to a variable, don‚Äôt worry! R always saves the result of the most recently run top-level expression in the .Last.value variable:\n&gt; runif(1)\n[1] 0.560866\n&gt; num &lt;- .Last.value\n&gt; num\n[1] 0.560866",
    "crumbs": [
      "Build",
      "Structure",
      "Gadgets",
      "Shiny Gadgets"
    ]
  },
  {
    "objectID": "r/articles/build/gadgets/index.html#designing-gadget-ui",
    "href": "r/articles/build/gadgets/index.html#designing-gadget-ui",
    "title": "Shiny Gadgets",
    "section": "Designing Gadget UI",
    "text": "Designing Gadget UI\nWhile technically, any kind of Shiny UI could be used for a Shiny Gadget, we‚Äôve created a miniUI package that we think is particularly well suited for Gadget use. We recommend that you start with miniUI based UI for your gadget, unless you have a specific reason not to.\nLearn more about creating gadget UI with miniUI in the article Designing Gadget UI.",
    "crumbs": [
      "Build",
      "Structure",
      "Gadgets",
      "Shiny Gadgets"
    ]
  },
  {
    "objectID": "r/articles/build/gadgets/index.html#viewer-options",
    "href": "r/articles/build/gadgets/index.html#viewer-options",
    "title": "Shiny Gadgets",
    "section": "Viewer options",
    "text": "Viewer options\nThe runGadget call has a viewer parameter that can be used to control how the gadget will be displayed in RStudio. The shinygadgets package includes functionality for rendering:\n\nIn a pane\nThe example above launched a gadget in RStudio‚Äôs Viewer pane. This is the default behavior.\n\n\n\nScreen shot\n\n\nIf your gadget has a minimum height below which it doesn‚Äôt work properly or looks silly, you can request that Viewer pane be resized to at least that height before displaying:\nrunGadget(ui, server, viewer = paneViewer(minHeight = 500))\n\n\nIn a dialog\nIf you have a larger gadget, you can ask RStudio to show a gadget in a modal ‚Äúdialog‚Äù that floats over the top of the other panes:\n\n\n\nScreen shot of gadget running in a dialog window\n\n\nTo opt into this behavior, change the runGadget call to:\nrunGadget(ui, server, viewer = dialogViewer(\"ggbrush\"))\nYou can pass width and height arguments to dialogViewer to indicate your preferred size (though RStudio is free to render the gadget at a smaller size if the RStudio main window itself is too small to accommodate your size preference).\n\n\nIn a web browser\nFinally, if you prefer to launch the gadget in the system‚Äôs external browser (like Chrome or Firefox) you can do so by using browserViewer:\nrunGadget(ui, server, viewer = browserViewer())",
    "crumbs": [
      "Build",
      "Structure",
      "Gadgets",
      "Shiny Gadgets"
    ]
  },
  {
    "objectID": "r/articles/build/gadgets/index.html#as-an-rstudio-addin",
    "href": "r/articles/build/gadgets/index.html#as-an-rstudio-addin",
    "title": "Shiny Gadgets",
    "section": "As an RStudio Addin",
    "text": "As an RStudio Addin\nAfter you‚Äôve created a gadget, you can register it as an RStudio Addin, making available from a drop-down menu in RStudio:\n\n\n\nRStudio Addin screen shot\n\n\nTo learn how to do this, see the RStudio Addin documentation.",
    "crumbs": [
      "Build",
      "Structure",
      "Gadgets",
      "Shiny Gadgets"
    ]
  },
  {
    "objectID": "r/articles/build/gadgets/index.html#learn-more",
    "href": "r/articles/build/gadgets/index.html#learn-more",
    "title": "Shiny Gadgets",
    "section": "Learn more",
    "text": "Learn more\nFor more on this topic, see the following resources:\n[Shiny Gadgets: Interactive Tools](https://resources.rstudio.com/webinars/shiny-gadgets\n Building interactive tools for exploratory data analysis",
    "crumbs": [
      "Build",
      "Structure",
      "Gadgets",
      "Shiny Gadgets"
    ]
  },
  {
    "objectID": "r/articles/build/execution-scheduling/index.html",
    "href": "r/articles/build/execution-scheduling/index.html",
    "title": "Execution scheduling",
    "section": "",
    "text": "At the core of Shiny is its reactive engine: this is how Shiny knows when to re-execute each component of an application. We‚Äôll trace into some examples to get a better understanding of how it works.\n\nA simple example\nAt an abstract level, we can describe the 01_hello example as containing one source and one endpoint. When we talk about it more concretely, we can describe it as having one reactive value, input$obs, and one reactive observer, output$distPlot.\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlot({\n    hist(rnorm(input$obs))\n  })\n}\nAs shown in the diagram below, a reactive value has a value. A reactive observer, on the other hand, doesn‚Äôt have a value. Instead, it contains an R expression which, when executed, has some side effect (in most cases, this involves sending data to the web browser). But the observer doesn‚Äôt return a value. Reactive observers have another property: they have a flag that indicates whether they have been invalidated. We‚Äôll see what that means shortly.\n\nAfter you load this application in a web page, it be in the state shown above, with input$obs having the value 500 (this is set in the ui object, which isn‚Äôt shown here). The arrow represents the direction that invalidations will flow. If you change the value to 1000, it triggers a series of events that result in a new image being sent to your browser.\nWhen the value of input$obs changes, two things happen: * All of its descendants in the graph are invalidated. Sometimes for brevity we‚Äôll say that an observer is dirty, meaning that it is invalidated, or clean, meaning that it is not invalidated. * The arrows that have been followed are removed; they are no longer considered descendants, and changing the reactive value again won‚Äôt have any effect on them. Notice that the arrows are dynamic, not static.\nIn this case, the only descendant is output$distPlot:\n\nOnce all the descendants are invalidated, a flush occurs. When this happens, all invalidated observers re-execute.\n\nRemember that the code we assigned to output$distPlot makes use of input$obs:\noutput$distPlot &lt;- renderPlot({\n  hist(rnorm(input$obs))\n})\nAs output$distPlot re-executes, it accesses the reactive value input$obs. When it does this, it becomes a dependent of that value, represented by the arrow . When input$obs changes, it invalidates all of its children; in this case, that‚Äôs justoutput$distPlot.\n\nAs it finishes executing, output$distPlot creates a PNG image file, which is sent to the browser, and finally it is marked as clean (not invalidated).\n\nNow the cycle is complete, and the application is ready to accept input again.\nWhen someone first starts a session with a Shiny application, all of the endpoints start out invalidated, triggering this series of events.\n\n\nAn app with reactive conductors\nHere‚Äôs the code for the server function of our Fibonacci program:\nfib &lt;- function(n) ifelse(n&lt;3, 1, fib(n-1)+fib(n-2))\n\nserver &lt;- function(input, output) {\n  currentFib         &lt;- reactive({ fib(as.numeric(input$n)) })\n\n  output$nthValue    &lt;- renderText({ currentFib() })\n  output$nthValueInv &lt;- renderText({ 1 / currentFib() })\n}\nHere‚Äôs the structure. It‚Äôs shown in its state after the initial run, with the values and invalidation flags (the starting value for input$n is set in ui, which isn‚Äôt displayed).\n\nSuppose the user sets input$n to 30. This is a new value, so it immediately invalidates its children, currentFib, which in turn invalidates its children, output$nthValue and output$nthValueInv. As the invalidations are made, the invalidation arrows are removed:\n\nAfter the invalidations finish, the reactive environment is flushed, so the endpoints re-execute. If a flush occurs when multiple endpoints are invalidated, there isn‚Äôt a guaranteed order that the endpoints will execute, so nthValue may run before nthValueInv, or vice versa. The execution order of endpoints will not affect the results, as long as they don‚Äôt modify and read non-reactive variables (which aren‚Äôt part of the reactive graph).\nSuppose in this case that nthValue() executes first. The next several steps are straightforward:\n\n\n\n\n\n\nAs output$nthValueInv() executes, it calls currentFib(). If currentFib() were an ordinary R expression, it would simply re-execute, taking another several seconds. But it‚Äôs not an ordinary expression; it‚Äôs a reactive expression, and it now happens to be marked clean. Because it is clean, Shiny knows that all of currentFib‚Äôs reactive parents have not changed values since the previous run currentFib(). This means that running the function again would simply return the same value as the previous run. (Shiny assumes that the non-reactive objects used by currentFib() also have not changed. If, for example, it called Sys.time(), then a second run of currentFib() could return a different value. If you wanted the changing values of Sys.time() to be able to invalidate currentFib(), it would have to be wrapped up in an object that acted as a reactive source. If you were to do this, that object would also be added as a node on the reactive graph.)\nActing on this assumption. that clean reactive expressions will return the same value as they did the previous run, Shiny caches the return value when reactive expressions are executed. On subsequent calls to the reactive expression, it simply returns the cached value, without re-executing the expression, as long as it remains clean.\nIn our example, when output$nthValueInv() calls currentFib(), Shiny just hands it the cached value, 832040. This happens almost instantaneously, instead of taking several more seconds to re-execute currentFib():\n\nFinally, output$nthValueInv() takes that value, finds the inverse, and then as a side effect, sends the value to the browser.\n\n\n\nSummary\nIn this section we‚Äôve learned about:\n\nInvalidation flags: reactive expressions and observers are invalidated (marked dirty) when their parents change or are invalidated, and they are marked as clean after they re-execute.\nArrow creation and removal: After a parent object invalidates its children, the arrows will be removed. New arrows will be created when a reactive object accesses another reactive object.\nFlush events trigger the execution of endpoints. Flush events occur whenever the browser sends data to the server.",
    "crumbs": [
      "Build",
      "Backend",
      "Reactivity",
      "Execution scheduling"
    ]
  },
  {
    "objectID": "r/articles/build/download/index.html",
    "href": "r/articles/build/download/index.html",
    "title": "Help users download data from your app",
    "section": "",
    "text": "Shiny has the ability to offer file downloads that are created on the fly, which makes it easy to build data exporting features.\n\n\n\nDownloading Data Screenshot\n\n\nSee here for an example app with file downloads.\nTo run the example below, type:\nlibrary(shiny)\nrunExample(\"10_download\")\nYou define a download using the downloadHandler function on the server side, and either downloadButton or downloadLink in the UI:\n\nui\nlibrary(shiny)\nlibrary(bslib)\n\n# Define UI for slider demo app ----\nui &lt;- page_sidebar(\n\n  # App title ----\n  title = \"Downloading Data\",\n\n  # Sidebar panel for inputs ----\n  sidebar = sidebar(\n\n    # Input: Choose dataset ----\n    selectInput(\n      \"dataset\",\n      \"Choose a dataset:\",\n      choices = c(\"rock\", \"pressure\", \"cars\")\n    ),\n\n    # Button\n    downloadButton(\"downloadData\", \"Download\")\n  ),\n  tableOutput(\"table\")\n)\n\n\nserver\n# Define server logic to display and download selected file ----\nserver &lt;- function(input, output) {\n\n  # Reactive value for selected dataset ----\n  datasetInput &lt;- reactive({\n    switch(\n      input$dataset,\n      \"rock\" = rock,\n      \"pressure\" = pressure,\n      \"cars\" = cars\n    )\n  })\n\n  # Table of selected dataset ----\n  output$table &lt;- renderTable({\n    datasetInput()\n  })\n\n  # Downloadable csv of selected dataset ----\n  output$downloadData &lt;- downloadHandler(\n    filename = function() {\n      paste(input$dataset, \".csv\", sep = \"\")\n    },\n    content = function(file) {\n      write.csv(datasetInput(), file, row.names = FALSE)\n    }\n  )\n}\nAs you can see, downloadHandler takes a filename argument, which tells the web browser what filename to default to when saving. This argument can either be a simple string, or it can be a function that returns a string (as is the case here).\nThe content argument must be a function that takes a single argument, the file name of a non-existent temp file. The content function is responsible for writing the contents of the file download into that temp file.\nBoth the filename and content arguments can use reactive values and expressions (although in the case of filename, if you are using a reactive value, be sure your argument is an actual function; filename = paste(input$dataset, \".csv\", sep = \"\") will not work the way you want it to, since it is evaluated only once, when the download handler is being defined).\nGenerally, those are the only two arguments you‚Äôll need. There is an optional contentType argument; if it is NA or NULL, Shiny will attempt to guess the appropriate value based on the filename. Provide your own content type string (e.g.¬†\"text/plain\") if you want to override this behavior.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Help users download data from your app"
    ]
  },
  {
    "objectID": "r/articles/build/datatables/index.html",
    "href": "r/articles/build/datatables/index.html",
    "title": "How to use DataTables in a Shiny App",
    "section": "",
    "text": "Basic Usage\nThe DataTables application demonstrates HTML tables using the jQuery library DataTables.\n\n\n\nDataTables Screenshot\n\n\nTo build DataTables in R, we recommend using the DT package (http://rstudio.github.io/DT/):\nlibrary(DT)\nThe basic usage is to create an output element in the UI using DT::dataTableOutput(id = 'foo'), and render a table on the server side using output$foo &lt;- DT::renderDataTable({ data }). Normally renderDataTable() takes an expression that returns a rectangular data object with column names, such as a data frame or a matrix.\nNote: Both shiny and DT packages have functions named dataTableOutput and renderDataTable. The shiny::renderDataTable function provides the server-side version of DataTables (using R to process the data object on the server side), while DT::renderDataTable allows you to create both server-side and client-side DataTables, and supports additional DataTables features. Hence we recommend using functions from the DT package when building DataTables in your Shiny app.\nBelow is a minimal example:\nlibrary(DT)\n\nui &lt;- basicPage(\n  h2(\"The mtcars data\"),\n  DT::dataTableOutput(\"mytable\")\n)\n\nserver &lt;- function(input, output) {\n  output$mytable = DT::renderDataTable({\n    mtcars\n  })\n}\n  \nshinyApp(ui, server)\nBy default, the data is paginated, showing 10 rows per page. The number of rows to display can be changed through the drop down menu in the top-left. We can sort the columns by clicking on the column headers, and sort multiple columns by holding the Shift key while clicking (the sorting direction loops through ascending, descending, and none if we keep on clicking). We can search globally in the table using the text input box in the top-right, or search individual columns using the text boxes at the bottom. Currently the searching terms are treated as regular expressions in R. Since searching can be time-consuming in large datasets, there is a delay of 0.5 seconds (customizable) before searching is really processed; that means if we type fast enough in the search box, searching may be processed only once on the server side even if we have typed more than one character.\n\n\nCustomizing DataTables\nThere are a large number of options in DataTables that are customizable (see its website for details). In this example, we show a few possibilities. Here is the code for the entire app:\nlibrary(shiny)\nlibrary(ggplot2)  # for the diamonds dataset\n\nui &lt;- fluidPage(\n  title = \"Examples of DataTables\",\n  sidebarLayout(\n    sidebarPanel(\n      conditionalPanel(\n        'input.dataset === \"diamonds\"',\n        checkboxGroupInput(\"show_vars\", \"Columns in diamonds to show:\",\n                           names(diamonds), selected = names(diamonds))\n      ),\n      conditionalPanel(\n        'input.dataset === \"mtcars\"',\n        helpText(\"Click the column header to sort a column.\")\n      ),\n      conditionalPanel(\n        'input.dataset === \"iris\"',\n        helpText(\"Display 5 records by default.\")\n      )\n    ),\n    mainPanel(\n      tabsetPanel(\n        id = 'dataset',\n        tabPanel(\"diamonds\", DT::dataTableOutput(\"mytable1\")),\n        tabPanel(\"mtcars\", DT::dataTableOutput(\"mytable2\")),\n        tabPanel(\"iris\", DT::dataTableOutput(\"mytable3\"))\n      )\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n  \n  # choose columns to display\n  diamonds2 = diamonds[sample(nrow(diamonds), 1000), ]\n  output$mytable1 &lt;- DT::renderDataTable({\n    DT::datatable(diamonds2[, input$show_vars, drop = FALSE])\n  })\n  \n  # sorted columns are colored now because CSS are attached to them\n  output$mytable2 &lt;- DT::renderDataTable({\n    DT::datatable(mtcars, options = list(orderClasses = TRUE))\n  })\n  \n  # customize the length drop-down menu; display 5 rows per page by default\n  output$mytable3 &lt;- DT::renderDataTable({\n    DT::datatable(iris, options = list(lengthMenu = c(5, 30, 50), pageLength = 5))\n  })\n  \n}\n\nshinyApp(ui, server)\n\nui\nFirst, we created the UI to display three datasets diamonds, mtcars, and iris, with each dataset in its own tab. We also added a checkbox group to select the columns to show in the diamonds data.\n\n\nserver\nThe options argument in renderDataTable() can take a list (literally an R list) of options, and pass them to DataTables when the table is initialized. For example, for the mtcars data, we pass orderClasses = TRUE to DataTables so that the sorted columns will have CSS classes attached on them (this is disabled by default); in this example, we can see the sorted columns are highlighted by darker colors. For the iris data, we pass the options lengthMenu and pageLength to customize the drop down menu, which has items [10, 25, 50, 100] by default; now the menu has three items [5, 30, 50], and 5 is selected as the default value.\nFor more DataTable options, please refer to its full reference on its website.\n\n\n\nUpgrading from DataTables v1.9 to v1.10\nShiny (&gt;= v1.10.2) currently uses DataTables v1.10. If you have used DataTables in Shiny before (specifically, before Shiny v0.10.2), you may need to change some parameter names for your DataTables, because Shiny (&lt;= v0.10.1) was using DataTables v1.9, and DataTables v1.10 has changed the parameter names.\nA guide for upgrading parameter names from DataTables 1.9 to 1.10 is here: https://datatables.net/upgrade/1.10-convert. Shiny will try to automatically correct some of the old parameter names, but this automatic correction certainly will not work for all use cases, especially if you have deeply customized your DataTables using complicated JavaScript options. You can see this GIT commit for examples of converting DataTables 1.9 names to 1.10 names.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "How to use DataTables in a Shiny App"
    ]
  },
  {
    "objectID": "r/articles/build/css/index.html#startpoint",
    "href": "r/articles/build/css/index.html#startpoint",
    "title": "Using custom CSS in your app",
    "section": "Startpoint",
    "text": "Startpoint\nWe will be styling the ever-familiar ‚ÄúOld Faithful Geyser Data‚Äù app; this is the app that you get whenever you request a new Shiny app in RStudio. We will be working with a single-file shiny app, so all the code is in this single app.R file. (The line spacing and comments are changed to make the code more compact.)\n\n\napp.R\n\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  titlePanel(\"Old Faithful Geyser Data\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"bins\", \"Number of bins:\", min = 1, max = 50, value = 30)\n    ),\n    mainPanel(plotOutput(\"distPlot\"))\n  )\n)\n\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlot({\n    x    &lt;- faithful[, 2]\n    bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n    hist(x, breaks = bins, col = 'darkgray', border = 'white')\n  })\n}\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Using custom CSS in your app"
    ]
  },
  {
    "objectID": "r/articles/build/css/index.html#our-custom-styles",
    "href": "r/articles/build/css/index.html#our-custom-styles",
    "title": "Using custom CSS in your app",
    "section": "Our custom styles",
    "text": "Our custom styles\nTo update our app‚Äôs style, we will implement a pseudo-dark-mode and change the app title‚Äôs font using a font from Google Fonts. To do this, we will add the following CSS:\n/* Get a fancy font from Google Fonts */\n@import url('https://fonts.googleapis.com/css2?family=Yusei+Magic&display=swap');\n\nbody {\n  background-color: black;\n  color: white; /* text color */\n}\n\n/* Change header text to imported font */\nh2 {\n  font-family: 'Yusei Magic', sans-serif;\n}\n\n/* Make text visible on inputs */\n.shiny-input-container {\n  color: #474747;\n}\n\nSo, while it‚Äôs not a proper dark mode, our app does look a lot different.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Using custom CSS in your app"
    ]
  },
  {
    "objectID": "r/articles/build/css/index.html#getting-our-css-into-the-app",
    "href": "r/articles/build/css/index.html#getting-our-css-into-the-app",
    "title": "Using custom CSS in your app",
    "section": "Getting our CSS into the app",
    "text": "Getting our CSS into the app\nSo how do we go about getting the above CSS into our Shiny app? There are many ways to do this, but they revolve around main options: inline CSS or file-based CSS. ‚ÄúInline‚Äù CSS in the case of a Shiny app is where we write our preferred styles using character strings right in our UI declaration. ‚ÄúFile-based‚Äù is when we write the styles in their own separate .css file and point our app to that file. There are multiple ways to do both options, but we will show the best way to do both for 99% of use-cases in this post. At the end, we will briefly cover the other methods and explain their pros and cons.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Using custom CSS in your app"
    ]
  },
  {
    "objectID": "r/articles/build/css/index.html#inline-css",
    "href": "r/articles/build/css/index.html#inline-css",
    "title": "Using custom CSS in your app",
    "section": "Inline CSS",
    "text": "Inline CSS\nThe quickest and easiest way to get CSS into your app is by ‚Äúinlining‚Äù it. The way to do this in Shiny is using the head and styles tags:\n\n\napp.R\n\n...\n\n# Define UI for application that draws a histogram\nui &lt;- fluidPage(\n  tags$head(\n    # Note the wrapping of the string in HTML()\n    tags$style(HTML(\"\n      @import url('https://fonts.googleapis.com/css2?family=Yusei+Magic&display=swap');\n      body {\n        background-color: black;\n        color: white;\n      }\n      h2 {\n        font-family: 'Yusei Magic', sans-serif;\n      }\n      .shiny-input-container {\n        color: #474747;\n      }\"))\n  ),\n  titlePanel(\"Old Faithful Geyser Data\"),\n  ...\n)\n...\n\n\nInlining Pros\nA significant plus inlining is the CSS sits right in the main app script, and the developer does not need to go far to make changes, reducing the amount of flipping back and forth between files required to make changes. Adding inlined styles is also super quick: no files need to be created and then linked; just type your code and reload the app.\n\n\nInlining Cons\nA downside of your styles living in the same file as your app logic is your UI function can get cumbersome with anything more than a few lines of CSS. In terms of developer convenience, you also lose great editor features like syntax highlighting and auto-complete, as the editor won‚Äôt know your writing CSS inside that string.\n\n\nWhen to use inlining\nWhen developing a Shiny app with custom styles, a balance needs to be struck between easy access to custom styling afforded by inline CSS and having an app script of manageable length. A typical development workflow will involve initial style work being done inline. Once the CSS gets to longer than a few rules, the app is refactored into the file-based workflow.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Using custom CSS in your app"
    ]
  },
  {
    "objectID": "r/articles/build/css/index.html#file-based-css",
    "href": "r/articles/build/css/index.html#file-based-css",
    "title": "Using custom CSS in your app",
    "section": "File-based CSS",
    "text": "File-based CSS\n\n\nwww/dark_mode.css\n\n/* Get a fancy font from Google Fonts */\n@import url('https://fonts.googleapis.com/css2?family=Yusei+Magic&display=swap');\n\nbody {\n  background-color: black;\n  color: white; /* text color */\n}\n\n/* Change header text to imported font */\nh2 {\n  font-family: 'Yusei Magic', sans-serif;\n}\n\n/* Make text visible on inputs */\n.shiny-input-container {\n  color: #474747;\n}\n\n\n\napp.R\n\n...\nui &lt;- fluidPage(\n  tags$head(\n    tags$link(rel = \"stylesheet\", type = \"text/css\", href = \"dark_mode.css\")\n  )\n  ...\n)\n...\n\n\nA note about www/\nOne thing you may notice is that we placed our CSS file in the subfolder www/, but we only specified the CSS file‚Äôs name (dark_mode.css) in our href or ‚Äúhyperlink reference‚Äù argument. The www/ folder is a special one for Shiny. Resources your app may link to, such as images‚Äîor in this case, scripts‚Äîare placed in the www/ folder. Shiny then knows to make these files available for access from the web browser. If we had placed dark_mode.css at the same file hierarchy next as app.R, Shiny would not know that it needs to host it, and your app would tell the browser to look for a file that was not available to it.\n\n\nPros of file-based CSS\nThe benefits of file-based CSS inclusion follow naturally from the cons of the inline approach. You can encapsulate all your styling logic in its own file. This way, style declarations do not clutter your app logic, and‚Äîif your editor supports it‚Äîyou can use proper syntax highlighting and auto-complete. Another big positive is the ability to use tools like SASS or LESS to build your styles and have them transpile to your external CSS file instead of having to copy and paste the results right into a string within your app script.\n\n\nCons of file-based CSS\nWhile a modular workflow can make managing large and complex apps easier, it can also make managing small and simple apps more complicated. As mentioned in the pros of the inline section, the developer needs to flip between files and keep track of class or id dependencies between the UI declaration and the custom CSS. File-based CSS workflows can make sharing your code more difficult. It‚Äôs a lot easier to copy and paste the contents of a single R script rather than layout the creation of files (of course, you could use a service like GitHub to avoid these issues.)\n\n\nWhen to use file-based\nReach for file-based CSS when your CSS is more complicated than a few basic rules.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Using custom CSS in your app"
    ]
  },
  {
    "objectID": "r/articles/build/css/index.html#other-methods",
    "href": "r/articles/build/css/index.html#other-methods",
    "title": "Using custom CSS in your app",
    "section": "Other methods",
    "text": "Other methods\nThose familiar with Shiny may have noticed I left out a couple of ways of getting CSS into your app.\n\ntheme = \"styles.css\"\nYou can pass a CSS file directly to your app using the theme argument in your UI function, much the same as the tags$link() method. However, it‚Äôs not recommended anymore because the theme argument is now commonly used by the bslib package to pass in custom bootstrap theming options. (bslib also provides its own functionality for adding additional CSS to a given bootstrap theme with the function bslib::bs_add_rules().)\n\n\nincludeCSS()\nThe function includeCSS() is an amalgamation of inline and file-based CSS. It takes as its argument a file path‚Äîthis time not necessarily in the www/ folder‚Äîand pastes that file‚Äôs contents directly into the HTML of your app instead of using a file link. This means\n\n\napp.R\n\n...\n\n# Define UI for application that draws a histogram\nui &lt;- fluidPage(\n  includeCSS(\"www/dark_mode.css\"),\n  titlePanel(\"Old Faithful Geyser Data\"),\n  ...\n)\n...\n\nmakes Shiny build the same HTML as doing\n\n\napp.R\n\n...\n\n# Define UI for application that draws a histogram\nui &lt;- fluidPage(\n  tags$head(\n    tags$style(HTML(\"\n      @import url('https://fonts.googleapis.com/css2?family=Yusei+Magic&display=swap');\n      body {\n        background-color: black;\n        color: white;\n      }\n      /* Change font of header text */\n      h2 {\n        font-family: 'Yusei Magic', sans-serif;\n      }\n      /* Make text visible on inputs */\n      .shiny-input-container {\n        color: #474747;\n      }\"))\n  ),\n  titlePanel(\"Old Faithful Geyser Data\"),\n    ...\n)\n...\n\nAs a bonus, you can verify this by viewing your app in a browser and right-clicking and selecting ‚Äúview source.‚Äù You‚Äôll see the same source for both approaches above, but not with the original file-based method.\nFor almost every Shiny app, the difference between including CSS via inlining and with a link is negligible, and there is no need to worry about performance implications. However, when you have a large amount of CSS (which can sometimes occur when using CSS generating languages like SCSS) it‚Äôs better to link to the styles rather than directly place them in the HTML.\n\n\nElement style argument\nWhen dealing with plain tag objects in Shiny, such as is we had declared the title of the app with an h2() instead of titlePanel() you can place any custom CSS you want in the style argument. These styles just apply to that specific element.\n\n\napp.R\n\n...\n# Define UI for application that draws a histogram\nui &lt;- fluidPage(\n  # titlePanel(\"Old Faithful Geyser Data\"),\n  h2(\"Old Faithful Geyser Data\", style = \"font-family: monospace;\"),\n  ...\n)\n...\n\nNote: If you wanted to use the nice Google font we used before, you‚Äôd have to still import that in a chunk of CSS added somewhere else.\nThis type of CSS is good for simple bespoke styling modifications, but, like inlining CSS in general, can quickly get out of hand if styles become too complicated. When this happens it‚Äôs often better to give the element to be styled a unique id and target that id in your general CSS declarations.\n\n\napp.R\n\n...\n# Define UI for application that draws a histogram\nui &lt;- fluidPage(\n  tags$head(\n    # Note the wrapping of the string in HTML()\n    tags$style(HTML(\"\n      /* Change font style for our monospaced title element */\n      #monospaced-title {\n        font-family: monospace;\n      }\"))\n  ),\n  # Application title\n  # titlePanel(\"Old Faithful Geyser Data\"),\n  h2(\"Old Faithful Geyser Data\", id = \"monospaced-title\"),\n  ...\n)\n...",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Using custom CSS in your app"
    ]
  },
  {
    "objectID": "r/articles/build/client-data/index.html#getting-non-input-data-from-the-client",
    "href": "r/articles/build/client-data/index.html#getting-non-input-data-from-the-client",
    "title": "Learn about your user with session$clientData",
    "section": "Getting Non-Input Data From the Client",
    "text": "Getting Non-Input Data From the Client\nOn the server side, Shiny applications use the input object to receive user input from the client web browser. The values in input are set by UI objects on the client web page. There are also non-input values (in the sense that the user doesn‚Äôt enter these values through UI components) that are stored in an object called session$clientData. These values include the URL, the pixel ratio (for high-resolution ‚ÄúRetina‚Äù displays), the hidden state of output objects, and the height and width of plot outputs. You can see an example app which uses client data here.\n\nUsing session$clientData\nTo access session$clientData values, you need to add a session argument to your server function (session is a special object that is used for finer control over a user‚Äôs app session). Once it‚Äôs in there, you can access session$clientData just as you would input.\nIn the example below, the client browser will display out the components of the URL and also parse and print the query/search string (the part of the URL after a ‚Äú?‚Äù):\nui &lt;- bootstrapPage(\n  h3(\"URL components\"),\n  verbatimTextOutput(\"urlText\"),\n\n  h3(\"Parsed query string\"),\n  verbatimTextOutput(\"queryText\")\n)\n\nserver &lt;- function(input, output, session) {\n\n  # Return the components of the URL in a string:\n  output$urlText &lt;- renderText({\n    paste(sep = \"\",\n      \"protocol: \", session$clientData$url_protocol, \"\\n\",\n      \"hostname: \", session$clientData$url_hostname, \"\\n\",\n      \"pathname: \", session$clientData$url_pathname, \"\\n\",\n      \"port: \",     session$clientData$url_port,     \"\\n\",\n      \"search: \",   session$clientData$url_search,   \"\\n\"\n    )\n  })\n\n  # Parse the GET query string\n  output$queryText &lt;- renderText({\n    query &lt;- parseQueryString(session$clientData$url_search)\n\n    # Return a string with key-value pairs\n    paste(names(query), query, sep = \"=\", collapse=\", \")\n  })\n}\n\nshinyApp(ui, server)\nThis app will display the following (note that the query string, ?foo=123&bar=somestring was added manually to the URL after lauching the app):\n\n\n\nURL components\n\n\n\n\nViewing all available values in clientData\nThe values in session$clientData will depend to some extent on the outputs. For example, a plot output object will report its height, width, and hidden status. The app below has a plot output, and displays all the values in session$clientData:\nui &lt;- pageWithSidebar(\n  headerPanel(\"Shiny Client Data\"),\n  sidebarPanel(\n    sliderInput(\"obs\", \"Number of observations:\",\n                min = 0, max = 1000, value = 500)\n  ),\n  mainPanel(\n    h3(\"clientData values\"),\n    verbatimTextOutput(\"clientdataText\"),\n    plotOutput(\"myplot\")\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  # Store in a convenience variable\n  cdata &lt;- session$clientData\n\n  # Values from cdata returned as text\n  output$clientdataText &lt;- renderText({\n    cnames &lt;- names(cdata)\n\n    allvalues &lt;- lapply(cnames, function(name) {\n      paste(name, cdata[[name]], sep = \" = \")\n    })\n    paste(allvalues, collapse = \"\\n\")\n  })\n\n  # A histogram\n  output$myplot &lt;- renderPlot({\n    hist(rnorm(input$obs), main = \"Generated in renderPlot()\")\n  })\n}\n\nshinyApp(ui, server)\nNotice that, just as with input, values in session$clientData can be accessed with session$clientData$myvar or session$clientData[['myvar']]. Or, equivalently, since we‚Äôve saved it into a convenience variable cdata, we can use cdata$myvar or cdata[['myvar']].\nFor the plot output output$myplot, there are at least three entries in clientData:\n\noutput_myplot_height: The height of the plot on the web page, in pixels.\noutput_myplot_width: The width of the plot on the web page, in pixels.\noutput_myplot_hidden: If the object is hidden (not visible), this is TRUE. This is used because Shiny will by default suspend the output object when it is hidden. When suspended, the observer will not execute even when its inputs change.\n\nHere is the view from the client, with all the clientData values:\n\n\n\nAll clientData values\n\n\nAs of Shiny v1.5, this as well as other plot output information (e.g.¬†CSS styles of the HTML container) is accessible via getCurrentOutputInfo(), which provides a more convenient way to access output-specific information since it:\n\nReturns a list of reactive expressions, allowing reactive expressions that depend on output information to depend on particular output information.\nUses htmltools::parseCssColors() to return CSS color string(s) as R color string(s).\n\nTo learn more about getCurrentOutputInfo(), see the reference page.",
    "crumbs": [
      "Build",
      "Backend",
      "Reactivity",
      "Learn about your user with session&#36;clientData"
    ]
  },
  {
    "objectID": "r/articles/build/building-inputs/index.html#building-inputs",
    "href": "r/articles/build/building-inputs/index.html#building-inputs",
    "title": "Build custom input objects",
    "section": "Building Inputs",
    "text": "Building Inputs\nShiny comes equipped with a variety of useful input components, but as you build more ambitious applications, you may find yourself needing input widgets that we don‚Äôt include. Fortunately, Shiny is designed to let you create your own custom input components. If you can implement it using HTML, CSS, and JavaScript, you can use it as a Shiny input! See the demo apps with custom inputs here and here.\n(If you‚Äôre only familiar with R and not with HTML/CSS/JavaScript, then you will likely find it tough to create all but the simplest custom input components on your own. However, other people can¬†‚Äì and hopefully will¬†‚Äì bundle up their custom Shiny input components as R packages and make them available to the rest of the community.)\n\nDesign the Component\nThe first steps in creating a custom input component is no different than in any other form of web development. You write HTML markup that lays out the component, CSS rules to style it, and use JavaScript (mostly event handlers) to give it behavior, if necessary.\nShiny input components should try to adhere to the following principles, if possible:\n\nDesigned to be used from HTML and R: Shiny user interfaces can either be written using R code (that generates HTML), or by writing the HTML directly. A well-designed Shiny input component will take both styles into account: offer an R function for creating the component, but also have thoughtfully designed and documented HTML markup.\nConfigurable using HTML attributes: Avoid requiring the user to make JavaScript calls to configure the component. Instead, it‚Äôs better to use HTML attributes. In your component‚Äôs JavaScript logic, you can easily access these values using jQuery (or simply by reading the DOM attribute directly).\n\nWhen used in a Shiny application, your component‚Äôs HTML markup will be repeated once for each instance of the component on the page, but the CSS and JavaScript will generally only need to appear once, most likely in the &lt;head&gt;. For R-based interface code, you can use the functions singleton and tags$head together to ensure these tags appear once and only once, in the head. (See the full example below.)\n\n\nWrite an Input Binding\nEach custom input component also needs an input binding, an object you create that tells Shiny how to identify instances of your component and how to interact with them. (Note that each instance of the input component doesn‚Äôt need its own input binding object; rather, all instances of a particular type of input component share a single input binding object.)\nAn input binding object needs to have the following methods:\n\n\nfind(scope)\n\n\nGiven an HTML document or element (scope), find any descendant elements that are an instance of your component and return them as an array (or array-like object). The other input binding methods all take an el argument; that value will always be an element that was returned from find.\nA very common implementation is to use jQuery‚Äôs find method to identify elements with a specific class, for example:\nexampleInputBinding.find = function(scope) {\n  return $(scope).find(\".exampleComponentClass\");\n};\n\ngetId(el)\n\n\nReturn the Shiny input ID for the element el, or null if the element doesn‚Äôt have an ID and should therefore be ignored. The default implementation in Shiny.InputBinding reads the data-input-id attribute and falls back to the element‚Äôs id if not present.\n\ngetValue(el)\n\n\nReturn the Shiny value for the element el. This can be any JSON-compatible value.\n\nsetValue(el, value)\n\n\nSet the element to the specified value. (This is not currently used, but in the future we anticipate adding features that will require the server to push input values to the client.)\n\nsubscribe(el, callback)\n\n\nSubscribe to DOM events on the element el that indicate the value has changed. When the DOM events fire, call callback (a function) which will tell Shiny to retrieve the value.\nWe recommend using jQuery‚Äôs event namespacing feature when subscribing, as unsubscribing becomes very easy (see unsubscribe, below). In this example, exampleComponentName is used as a namespace:\nexampleInputBinding.subscribe = function(el, callback) {\n  $(el).on(\"keyup.exampleComponentName\", function(event) {\n    callback(true);\n  });\n  $(el).on(\"change.exampleComponentName\", function(event) {\n    callback();\n  });\n};\nLater on, we can unsubscribe \".exampleComponentName\" which will remove all of our handlers without touching anyone else‚Äôs.\nThe callback function optionally takes an argument: a boolean value that indicates whether the component‚Äôs rate policy should apply (true means the rate policy should apply). See getRatePolicy below for more details.\n\nunsubscribe(el)\n\n\nUnsubscribe DOM event listeners that were bound in subscribe.\nExample:\nexampleInputBinding.unsubscribe = function(el) {\n  $(el).off(\".exampleComponentName\");\n};\n\ngetRatePolicy()\n\n\nReturn an object that describes the rate policy of this component (or null for default).\nRate policies are helpful for slowing down the rate at which input events get sent to the server. For example, as the user drags a slider from value A to value B, dozens of change events may occur. It would be wasteful to send all of those events to the server, where each event would potentially cause expensive computations to occur.\nA rate policy slows down the rate of events using one of two algorithms (so far). Throttling means no more than one event will be sent per X milliseconds. Debouncing means all of the events will be ignored until no events have been received for X milliseconds, at which time the most recent event will be sent. This blog post goes into more detail about the difference between throttle and debounce.\nA rate policy object has two members:\n\npolicy - Valid values are the strings \"direct\", \"debounce\", and \"throttle\". \"direct\" means that all events are sent immediately.\ndelay - Number indicating the number of milliseconds that should be used when debouncing or throttling. Has no effect if the policy is direct.\n\nRate policies are only applied when the callback function in subscribe is called with true as the first parameter. It‚Äôs important that input components be able to control which events are rate-limited and which are not, as different events may have different expectations to the user. For example, for a textbox, it would make sense to rate-limit events while the user is typing, but if the user hits Enter or focus leaves the textbox, then the input should always be sent immediately.\n\n\n\nRegister Input Binding\nOnce you‚Äôve created an input binding object, you need to tell Shiny to use it:\nShiny.inputBindings.register(exampleInputBinding, \"yourname.exampleInputBinding\");\nThe second argument is a name the user can use to change the priority of the binding. On the off chance that the user has multiple bindings that all want to claim the same HTML element as their own, this call can be used to control the priority of the bindings:\nShiny.inputBindings.setPriority(\"yourname.exampleInputBinding\", 10);\nHigher numbers indicate a higher priority; the default priority is 0. All of Shiny‚Äôs built-in input component bindings default to a priority of 0.\nIf two bindings have the same priority value, then the more recently registered binding has the higher priority.\n\n\nExample\nFor this example, we‚Äôll create a button that displays a number, whose value increases by one each time the button is clicked. Here‚Äôs what the end result will look like (click it!):\n\n\n0\n\n\n\nTo start, let‚Äôs design the HTML markup for this component:\n&lt;button id=\"inputId\" class=\"increment btn btn-default\" type=\"button\"&gt;0&lt;/button&gt;\nThe CSS class increment is what will differentiate our buttons from any other kind of buttons. (The btn btn-default classes are there to make the button look decent in Bootstrap.)\nNow we‚Äôll write the JavaScript that drives the button‚Äôs basic behavior:\n$(document).on(\"click\", \"button.increment\", function(evt) {\n\n  // evt.target is the button that was clicked\n  var el = $(evt.target);\n\n  // Set the button's text to its current value plus 1\n  el.text(parseInt(el.text()) + 1);\n\n  // Raise an event to signal that the value changed\n  el.trigger(\"change\");\n});\nThis code uses jQuery‚Äôs delegated events feature to bind all increment buttons at once.\nNow we‚Äôll create the Shiny binding object for our component, and register it:\nvar incrementBinding = new Shiny.InputBinding();\n$.extend(incrementBinding, {\n  find: function(scope) {\n    return $(scope).find(\".increment\");\n  },\n  getValue: function(el) {\n    return parseInt($(el).text());\n  },\n  setValue: function(el, value) {\n    $(el).text(value);\n  },\n  subscribe: function(el, callback) {\n    $(el).on(\"change.incrementBinding\", function(e) {\n      callback();\n    });\n  },\n  unsubscribe: function(el) {\n    $(el).off(\".incrementBinding\");\n  }\n});\n\nShiny.inputBindings.register(incrementBinding);\nBoth the behavioral JavaScript code and the Shiny binding code should generally be run when the page loads. (It‚Äôs important that they run before Shiny initialization, which occurs after all the document ready event handlers are executed.)\nThe cleanest way to do this is to put both chunks of JavaScript into a file. In this case, we‚Äôll use the path ./www/js/increment.js, which we can then access as http://localhost:8100/js/increment.js.\nIf you‚Äôre using an index.html style user interface, you‚Äôll just need to add this line to your &lt;head&gt; (make sure it comes after the script tag that loads shiny.js):\n&lt;script src=\"js/increment.js\"&gt;&lt;/script&gt;\nOn the other hand, if you‚Äôre using ui.R, then you can define this function before the call to shinyUI:\nincrementButton &lt;- function(inputId, value = 0) {\n  tagList(\n    singleton(tags$head(tags$script(src = \"js/increment.js\"))),\n    tags$button(id = inputId,\n                class = \"increment btn btn-default\",\n                type = \"button\",\n                as.character(value))\n  )\n}\nThen in your shinyUI page definition you can call incrementButton wherever you want an increment button rendered. Notice the line that begins with singleton will ensure that the increment.js file will be included just one time, in the &lt;head&gt;, no matter how many buttons you insert into the page or where you place them.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Build custom input objects"
    ]
  },
  {
    "objectID": "r/articles/build/action-buttons/index.html",
    "href": "r/articles/build/action-buttons/index.html",
    "title": "Using Action Buttons",
    "section": "",
    "text": "This article describes five patterns to use with Shiny‚Äôs action buttons and action links. Action buttons and action links are different from other Shiny widgets because they are intended to be used exclusively with observeEvent() or eventReactive().",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Using Action Buttons"
    ]
  },
  {
    "objectID": "r/articles/build/action-buttons/index.html#how-action-buttons-work",
    "href": "r/articles/build/action-buttons/index.html#how-action-buttons-work",
    "title": "Using Action Buttons",
    "section": "How action buttons work",
    "text": "How action buttons work\nCreate an action button with actionButton() and an action link with actionLink(). Each of these functions takes two arguments:\n\ninputId - the ID of the button or link\nlabel - the label to display in the button or link\n\nactionButton(\"button\", \"An action button\")\nactionLink(\"button\", \"An action link\")\nAn action button appears as a button in your app.\n\nAn action link appears as a hyperlink, but behaves in the same way as an action button.\n\nLike all widgets, action buttons have a value. The value is an integer that changes each time a user clicks the button. You can access this value from within your app as input$&lt;inputId&gt; where &lt;inputId&gt; is the ID that you assigned to your action button.\nAction buttons are different from other widgets because the value of an action button is almost never meaningful by itself. The value is designed to be observed by one of observeEvent() or eventReactive(). These functions monitor the value, and when it changes they run a block of code.\nThe patterns below explain this arrangement and illustrate the most popular ways to use an action button or an action link.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Using Action Buttons"
    ]
  },
  {
    "objectID": "r/articles/build/action-buttons/index.html#pattern-1---command",
    "href": "r/articles/build/action-buttons/index.html#pattern-1---command",
    "title": "Using Action Buttons",
    "section": "Pattern 1 - Command",
    "text": "Pattern 1 - Command\nUse observeEvent() to trigger a command with an action button.\n\nExample\n\n\nIn the code above, session$setCustomMessage() generates a popup message. tags$head(tags$script(src = \"message-handler.js\")) supplies the JavaScript that makes this possible. See this example to learn more aboutsendCustomMessage().\n\n\nWhy the pattern works\nAction buttons do not automatically generate actions in Shiny. Like other widgets, action buttons maintain a state (a value). The state changes when a user clicks the button.\nobserveEvent() observes a reactive value, which is set in the first argument of observeEvent(). Whenever the value changes, observeEvent() will run its second argument, which should be a block of code surrounded in braces.\nThis pattern uses observeEvent() to connect the change in an action button‚Äôs value to the code that the action button should trigger.\n\n\nTips\n\nobserveEvent() isolates the block of code in its second argument with isolate().\nobserveEvent() only notices changes in the value of the action button. It does not matter what the actual value of the button is. If your code depends on the value of the action button, it may be mis-written.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Using Action Buttons"
    ]
  },
  {
    "objectID": "r/articles/build/action-buttons/index.html#pattern-2---delay-reactions",
    "href": "r/articles/build/action-buttons/index.html#pattern-2---delay-reactions",
    "title": "Using Action Buttons",
    "section": "Pattern 2 - Delay reactions",
    "text": "Pattern 2 - Delay reactions\nUse eventReactive() to delay reactions until a user clicks the action button.\n\nExample\n\n\n\n\nWhy the pattern works\neventReactive() creates a reactive expression that monitors a reactive value, which is set in the first argument of eventReactive(). The expression will be invalidated whenever the value changes, but it will ignore changes in other reactive values.\nComplete this pattern by using the reactive expression created by eventReactive() in rendered output. Output that depends on the expression will not update until the expression is invalidated, i.e.¬†until the action button is clicked.\n\n\nTips\n\nLike observeEvent(), eventReactive() isolates the block of code in its second argument with isolate().\neventReactive() returns NULL until the action button is clicked. As a result, the graph does not appear until the user asks for it by clicking ‚ÄúGo‚Äù.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Using Action Buttons"
    ]
  },
  {
    "objectID": "r/articles/build/action-buttons/index.html#pattern-3---dueling-buttons",
    "href": "r/articles/build/action-buttons/index.html#pattern-3---dueling-buttons",
    "title": "Using Action Buttons",
    "section": "Pattern 3 - Dueling buttons",
    "text": "Pattern 3 - Dueling buttons\nTo build several action buttons that control the same object, combine observeEvent() calls with reactiveValues().\n\nExample\n\n\n\n\nWhy the pattern works\nreactiveValues() creates a reactive values object, a list of reactive values that you can update and call programmatically. These values are like the values stored in Shiny‚Äôs input object with one difference: you can update the values of a reactive values object, but you cannot normally update the values of the input object (those values are reserved for the user to update interactively).\nTo complete the pattern, monitor each button with its own observeEvent() call. Arrange for the calls to update the object created by reactiveValues(). Reactive values obey reference class semantics, which means that you can update them from within the scope of an observeEvent() function.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Using Action Buttons"
    ]
  },
  {
    "objectID": "r/articles/build/action-buttons/index.html#pattern-4---reset-buttons",
    "href": "r/articles/build/action-buttons/index.html#pattern-4---reset-buttons",
    "title": "Using Action Buttons",
    "section": "Pattern 4 - Reset buttons",
    "text": "Pattern 4 - Reset buttons\nTo create a reset button, use the above pattern to assign NULL to a reactive values object.\n\nExample\n\n\n\n\nWhy this pattern works\nYou can apply the previous pattern to reset an element of a reactvie values object to its intial state (NULL). To do this, arrange for a button to assign NULL to the reactive values object with the help of observeEvent().",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Using Action Buttons"
    ]
  },
  {
    "objectID": "r/articles/build/action-buttons/index.html#pattern-5---reset-on-tab-change",
    "href": "r/articles/build/action-buttons/index.html#pattern-5---reset-on-tab-change",
    "title": "Using Action Buttons",
    "section": "Pattern 5 - Reset on tab change",
    "text": "Pattern 5 - Reset on tab change\nObserve the value of a tabsetPanel(), navlistPanel(), or navbarPage() with observeEvent() to rest the value of an object each time your user switches tabs.\n\nExample\n\n\n\n\nWhy this pattern works\nThis pattern extends the previous reset pattern. You use observeEvent() to reset an element of a reactive values object. However, instead of observing the value of an action button, you observe the value of a tab function.\ntabsetPanel(), navlistPanel(), and navbarPage() each combine multiple tabs (created with tabPanel()) into a single ui object. These functions maintain a reactive value that contains the title of the current tab. When your user navigates to a new tab, this value changes. observeEvent() resets the reactive value to NULL when it does.\nAs with the patterns above, this pattern requires you to store and manipulate a value created with reactiveValues().\n\n\nTips\n\nAlthough the example uses tabsetPanel(), you can acheive the same effect with navlistPanel() and navbarPage().",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Using Action Buttons"
    ]
  },
  {
    "objectID": "r/articles/build/action-buttons/index.html#recap",
    "href": "r/articles/build/action-buttons/index.html#recap",
    "title": "Using Action Buttons",
    "section": "Recap",
    "text": "Recap\nAction buttons and action links are meant to be used with one of observeEvent() or eventReactive(). You can extend the effects of an action button with reactiveValues().\n\nUse observeEvent() to trigger a block of code with an action button.\nUse eventReactive() to update derived/calculated output with an action button.\nUse reactiveValues() to maintain an object for multiple action buttons to interact with.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Using Action Buttons"
    ]
  },
  {
    "objectID": "r/articles/build/action-buttons/index.html#aside-about-submit-buttons",
    "href": "r/articles/build/action-buttons/index.html#aside-about-submit-buttons",
    "title": "Using Action Buttons",
    "section": "Aside: about submit buttons",
    "text": "Aside: about submit buttons\nBefore action buttons existed in Shiny, there were only submit buttons. At this point, our general recommendation is to avoid submit buttons and only use action buttons. Note that any code that uses a submit button can be converted to code that uses an action button instead (while the reverse is generally not true) ‚Äì see example at the bottom.\n\nHow are submit buttons and action buttons different?\nWith an action button, input values are sent from the browser to the server as usual (when they‚Äôre changed) but you can control the reactive flow of the program by telling particular reactives to not compute until the action button is pressed. In contrast, if your app includes a submit button anywhere, none of the inputs will be sent from the client to the server until the button is pressed. However, submit buttons have unusual behavior in many ways, and we recommend that they not be used for anything but the simplest apps.\nThese issues include the following: A submit button has a global scope, so there is no way of specifying which inputs should be on hold and which shouldn‚Äôt. If an app has two submit buttons, both of them will control the entire app, which is probably not what you want. Also, dynamically created submit buttons (for example, with renderUI() or insertUI()) will not work.\n\n\nTranslating submitButton code into actionButton code\nConsider the app below, taken from the documentation for submitButton():\nshinyApp(\n  ui = basicPage(\n    numericInput(\"num\", label = \"Make changes\", value = 1),\n    submitButton(\"Update View\", icon(\"refresh\")),\n    helpText(\"When you click the button above, you should see\",\n             \"the output below update to reflect the value you\",\n             \"entered at the top:\"),\n    verbatimTextOutput(\"value\")\n  ),\n  server = function(input, output) {\n\n    # submit buttons do not have a value of their own,\n    # they control when the app accesses values of other widgets.\n    # input$num is the value of the number widget.\n    output$value &lt;- renderPrint({ input$num })\n  }\n)\nWhile this app is simple enough that a submit button is adequate, it can be easily translated to app using an action button instead (which has the added advantage of being a lot more scalable, since you can now add more inputs that will be independent of the action button):\nshinyApp(\n  ui = basicPage(\n    numericInput(\"num\", label = \"Make changes\", value = 1),\n    actionButton(\"update\" ,\"Update View\", icon(\"refresh\"),\n                 class = \"btn btn-primary\"),\n    helpText(\"When you click the button above, you should see\",\n             \"the output below update to reflect the value you\",\n             \"entered at the top:\"),\n    verbatimTextOutput(\"value\")\n  ),\n  server = function(input, output) {\n     output$value &lt;- renderPrint({ \n       input$update\n       isolate(input$num)\n     })\n  }\n)\nNote: The app above could also have been written using eventReactive() (as outlined in Pattern 2), instead of isolate().",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Using Action Buttons"
    ]
  },
  {
    "objectID": "blog/posts/weather-lookup-caching/index.html",
    "href": "blog/posts/weather-lookup-caching/index.html",
    "title": "Weather App Story Pt. 2: Caching",
    "section": "",
    "text": "Here we demonstrate the use of the new bindCache() function in Shiny to greatly speed up a Shiny app that parses NOAA weather station data for 12,636 locations around the United States. We will demonstrate the addition of bindCache() to existing reactive expressions, explaining where and why it should be used along with some potential gotchas of doing so.\nTo learn more about using caching in Shiny, see the caching article and the reference documentation for bindCache()."
  },
  {
    "objectID": "blog/posts/weather-lookup-caching/index.html#weather-app",
    "href": "blog/posts/weather-lookup-caching/index.html#weather-app",
    "title": "Weather App Story Pt. 2: Caching",
    "section": "Weather App",
    "text": "Weather App\nThe code and results in this post come from the weather lookup app. Here we will just briefly cover the relevant parts of the app, for a more complete intro check out the accompanying post introducing it.\n\n\nScreenshot of the weather lookup app."
  },
  {
    "objectID": "blog/posts/weather-lookup-caching/index.html#performance",
    "href": "blog/posts/weather-lookup-caching/index.html#performance",
    "title": "Weather App Story Pt. 2: Caching",
    "section": "Performance",
    "text": "Performance\nWithout caching enabled, the weather lookup app is still interesting and potentially useful, but it can be a bit slow.\n\n\n\nPerformance of app without caching. Lots of waiting around.\nThis is because for every requested city, the app performs an expensive query data. Anytime you‚Äôre relying on an API, let alone a public one, not on your server‚Äôs network, you‚Äôre going to have a bottleneck in the responsiveness of your app. In the weather app this is compounded by the fact that for any given city we need to do separate queries for every station present.\nNote: Due to service interuptions for all NOAA data servers, the live-version of the app uses a pair of local dataframes containing all the station data. You can see the full code on github\n# Code inside city_data() reactive responsible for running a query for every station in a city\ncity_data &lt;- reactive({\n  ...\n  # Not every station has both temperature and precipitation data. To deal\n  # with this, loop through all stations in a city try to extract whatever\n  # data is present. If a city has a lot of stations, like Fairbanks, AK,\n  # this this can take a while\n  incProgress(1/4, detail = \"Downloading data from all found stations\")\n  stations &lt;- stations %&gt;%\n    mutate(url = build_station_url(station),\n           data = map(url, possibly(readr::read_file)))\n  ...\n})\nEven after the queries are finished, there‚Äôs the additional work needing to be done with cleaning and averaging of all the data.\nAlong with the time the city_data() reactive takes, plot output is a complicated mashup of non-trivial ggplots combined with the patchwork package.\nAll of these reactive computations add up to an interactive experience of less-than-light-speed. While using progress messages to alert the user to what‚Äôs happening can help, ideally we could just make the app faster‚Ä¶"
  },
  {
    "objectID": "blog/posts/weather-lookup-caching/index.html#adding-caching",
    "href": "blog/posts/weather-lookup-caching/index.html#adding-caching",
    "title": "Weather App Story Pt. 2: Caching",
    "section": "Adding caching",
    "text": "Adding caching\nA convenient fact about our app is that it will always look the same when a given city is selected. This means we can use caching to pull up the results for a city by simply remembering the output of our reactive the last time the city was seen.\nAs of Shiny 1.6, adding caching to any reactive is as easy as piping the reactive to the function bindCache(). You tell bindCache() what the important input variable is that determines the output of the reactive and Shiny will automatically setup a cache store and your app will (most likely) see large speed improvements.\nTo take advantage of caching we will add it in three separate places in the app: our city_data reactive and the results plot output$weather_plot.\nserver &lt;- function(input, output, session) {\n  ...\n  city_data &lt;- reactive({...}) %&gt;%\n    bindCache(input$city)\n\n  output$weather_plot &lt;- renderPlot({...}) %&gt;%\n    bindCache(input$city)\n  ...\n}\nThe combination of renderPlot() and bindCache() operates just like the function renderCachedPlot() that was introduced in Shiny 1.2, however now any reactive variable can be cached (in fact, renderCachedPlot() now uses bindCache() under-the-hood.)"
  },
  {
    "objectID": "blog/posts/weather-lookup-caching/index.html#performance-with-caching",
    "href": "blog/posts/weather-lookup-caching/index.html#performance-with-caching",
    "title": "Weather App Story Pt. 2: Caching",
    "section": "Performance with caching",
    "text": "Performance with caching\nSo how much of a benefit do we get from adding those three bindCache() calls to our code? We can investigate this in two ways: a ‚Äúreal world‚Äù side-by-side test and a more formal scripted test scenario.\n\nSide-by-side comparison\nA great place to see the benefits of caching in our app is with the ‚Äúprevious city‚Äù button. Because this button is provided and the concept of comparing two cities is appealing, once a given city is looked up by a user it automatically becomes much more likely to be requested again.\n\n\n\nSpeed comparison of toggling back and forth between a cached and non-cached app. The cached app changes the city almost instantly with no loading needed.\nThe act of retrieving and displaying the previous city is almost instant, compared to the non-cached app. Caching is perfect for these scenarios.\n\n\nUsing shinytest to compare app speed\nWe can be a bit more objective with this comparison by using shinytest. We can record a typical use of the app and then replay the usage on the app with and without caching. We can wrap this test in a function and use the bench package to compare the runtimes over multiple sessions.\nrun_usage_test &lt;- function(app_dir){\n  app &lt;- ShinyDriver$new(app_dir, seed = 42)\n  # Using a seed because the app randomly chooses city in rnd_city button and\n  # initial back button\n\n  app$snapshotInit(\"mytest\")\n  app$setInputs(city = \"Minneapolis, MN\")\n  app$setInputs(city = \"Houston, TX\")\n  app$setInputs(prev_city = \"click\")\n  app$setInputs(prev_city = \"click\")\n  app$setInputs(prev_city = \"click\")\n  app$setInputs(city = \"New York, NY\")\n  app$setInputs(prev_city = \"click\")\n  app$setInputs(prev_city = \"click\")\n}\n\n# Compare runtimes\nbench::mark(run_usage_test(\"cached_app/\"),\n            run_usage_test(\"uncached_app/\"),\n            iterations = 15,\n            check = FALSE)\n\n\nApp runtimes of 15 separate sessions for both cached and non-cached versions of the weather app.\n\nIt‚Äôs important to note that the most time-consuming aspect of these tests is actually starting the shinytest instance, so the difference in usable speed is even greater than seen here."
  },
  {
    "objectID": "blog/posts/weather-lookup-caching/index.html#a-note-on-cache-scope",
    "href": "blog/posts/weather-lookup-caching/index.html#a-note-on-cache-scope",
    "title": "Weather App Story Pt. 2: Caching",
    "section": "A note on cache scope",
    "text": "A note on cache scope\nIt‚Äôs possible to change the scope of your caching (i.e.¬†who/what can read from the cache) using the cache argument in bindCache().\n\nApp-level caching\nThe default cache scope is \"app\". This scoping allows cached reactive to be shared between different sessions of the app.\n# By default, cached values of my_reactive() are available to all users of app\nmy_reactive &lt;- reactive({...}) %&gt;%\n    bindCache(input$key)\n\n# Equivalent to\nmy_reactive &lt;- reactive({...}) %&gt;%\n    bindCache(input$key, cache = \"app\")\nOne benefit of app-level scope for our app is that large cities such as New York or Los Angeles are likely going to be viewed a lot. Once these cities are requested by the first user the app will be much faster for a large portion of the userbase. The nice thing is you don‚Äôt need to try and predict what will be popular, the cache does it for you.\n\n\nSession-level caching\nFor most situations app-level caching the best option, however if you have potentially sensitive data being stored within your reactives the session option may be better.\n# Cached values of my_reactive() are only shared within the same app session\nmy_reactive &lt;- reactive({...}) %&gt;%\n    bindCache(input$key, cache = \"session\")\nThis gives each app usage ‚Äúsession‚Äù its own cache, so there‚Äôs no danger of information leaking between users.\n\nDiving deeper\nFor a more through explanation of options for scoping and other setting such as size of cache see the Cache scoping section of the documentation."
  },
  {
    "objectID": "blog/posts/weather-lookup-caching/index.html#when-to-not-use-caching",
    "href": "blog/posts/weather-lookup-caching/index.html#when-to-not-use-caching",
    "title": "Weather App Story Pt. 2: Caching",
    "section": "When to not use caching",
    "text": "When to not use caching\nCaching in your shiny apps is one of the easiest and most dramatic ways of making performance increases, however, it can sometimes be overkill or even make your app slower. A good rule of thumb is to reach for caching when your reactive:\n\nTakes a while to calculate\nWill likely be needed again\nThe inputs (or cache-keys) are simple.\n\nFor instance, caching a reactive that does a fast operation like building a string from basic inputs will likely yield little to no improvement because the time spent hashing the inputs into a key and searching for the result in the cache may take longer than simply re-building the value.\nA good example of this is the station info panel in the weather lookup app.\noutput$station_info &lt;- renderUI({\n  # Let the user know what stations went into the plot they're seeing and\n  # allow them to explore the data directly\n  pmap(\n    city_data()$station_info,\n     function(url, station, had_temp, had_prcp, ...){\n       div(class = \"station_bubble\",\n        a(href = url, target = \"_blank\",\n          station,\n          if(had_temp) icon('thermometer-half'),\n          if(had_prcp) icon('cloud-rain')\n        )\n      )\n   })\n})\n\n\nExample station info for Ann Arbor, MI.\n\nThis reactive just builds a few divs that show info about the stations within the current city. The runtime here is almost zero so caching will add no benefit.\n\nTo learn more about using caching in Shiny, see the caching article and the reference documentation for bindCache()."
  },
  {
    "objectID": "blog/posts/weather-lookup-about/index.html",
    "href": "blog/posts/weather-lookup-about/index.html",
    "title": "Weather App Story Pt. 1: About",
    "section": "",
    "text": "The ‚ÄúExplore your weather‚Äù app allows a user to look up a city of choice in the United States, and see what the ‚Äúnormal‚Äù temperature and precipitation is for that city over the year. It takes advantage of new features in Shiny 1.6 that make it easier than ever to make fast and good looking apps with R.  View the app here ."
  },
  {
    "objectID": "blog/posts/weather-lookup-about/index.html#what-the-app-does",
    "href": "blog/posts/weather-lookup-about/index.html#what-the-app-does",
    "title": "Weather App Story Pt. 1: About",
    "section": "What the app does",
    "text": "What the app does\nThe goal for the app is to be a tool to quickly get a broad-level grasp of the weather in a given city. Users should be able to answer questions like ‚Äúhow hot is a typical March day?‚Äù and ‚Äúwhat‚Äôs the wettest month?‚Äù for their city of choice."
  },
  {
    "objectID": "blog/posts/weather-lookup-about/index.html#inspiration-for-app",
    "href": "blog/posts/weather-lookup-about/index.html#inspiration-for-app",
    "title": "Weather App Story Pt. 1: About",
    "section": "Inspiration for app",
    "text": "Inspiration for app\nInspiration for the design came from the story ‚ÄúHow Much Warmer Was Your City in 2015?‚Äù in the New York Times, by K.K. Rebecca Lai.\n\n New York Times article providing inspiration for app design.\n\nWhile the inspiration is obvious, our app isn‚Äôt a direct copy. Our focus is more on getting a general idea of typical weather rather than comparing to a given year. Also, unlike the NYTimes article that uses javascript, our app is written completely in R (with a tiny bit of CSS)."
  },
  {
    "objectID": "blog/posts/weather-lookup-about/index.html#noaa-temperature-normals",
    "href": "blog/posts/weather-lookup-about/index.html#noaa-temperature-normals",
    "title": "Weather App Story Pt. 1: About",
    "section": "NOAA Temperature Normals",
    "text": "NOAA Temperature Normals\nThe data driving the application comes from the National Oceanic and Atmospheric Association (NOAA). In the NOAA‚Äôs open data portal they have a set of data for ‚Äúclimate normals.‚Äù These data provide the ‚Äúnormal‚Äù or typical values of various climate measures for ~9.7 thousand weather stations around the US based on readings from 1981 to 2010.\n\n\n\nAll stations present in NOAA Normals database. Figure from Bulletin of the American Meteorological Society 93, 11; 10.1175/BAMS-D-11-00197.1\nThe way the data are stored place all the data for a given station within a text document located at an HTTP endpoint. For instance, the normals data for station USC00200228 located in Ann Arbor, MI is available at the endpoint https://www1.ncdc.noaa.gov/pub/data/normals/1981-2010/products/auxiliary/station/USC00200228.normals.txt\n\n\n\nExample of the first few lines of data for a station. To see the data going into any given app-view check out the ‚ÄúStations contributing data‚Äù section of the app below the plots.\nThere are lots of interesting measures available in these ‚Äúnormals‚Äù but what our app focuses on is the temperature (daily minimum, average, maximum) and precipitation (monthly totals). If you want more info on these data take a look at the NOAA landing page or the scientific manuscript accompanying them."
  },
  {
    "objectID": "blog/posts/weather-lookup-about/index.html#app-flow",
    "href": "blog/posts/weather-lookup-about/index.html#app-flow",
    "title": "Weather App Story Pt. 1: About",
    "section": "App flow",
    "text": "App flow\nWhen thinking about how a Shiny app works it helps to think about the main important reactive variables/expressions: what they depend on and what depends on them. Our app is relatively simple, with one main reactive() variable, an output plot, and some dynamic UI to show information about stations within a city.\n\ncity_data reactive\nThe state of the app centers around the currently selected city. When a city is selected, the app finds the NOAA normals data for every station residing in that city. From this data the temperature and precipitation normals are extracted and averaged together to give an ‚Äúaveraged average‚Äù portrait of the city‚Äôs weather. The results of this querying and parsing is stored in the reactive value city_data‚Ä¶\nserver &lt;- function(input, output, session) {\n  ...\n  city_data &lt;- reactive({\n    ...\n    withProgress(message = 'Fetching data from NOAA', {\n      stations &lt;- filter(station_to_city, city == input$city)\n\n      ...\n      # Not every station has both temperature and precipitation data. To deal\n      # with this, loop through all stations in a city try to extract whatever\n      # data is present. If a city has a lot of stations, like Fairbanks, AK,\n      # this this can take a while\n      incProgress(1/4, detail = \"Downloading data from all found stations\")\n      stations &lt;- stations %&gt;%\n        mutate(url = build_station_url(station),\n               data = map(url, possibly(readr::read_file)))\n      # purrr::possibly allows bad requests to fail without crashing app\n\n      ...\n      incProgress(2/4, detail = \"Extracting temperature data\")\n      stations$temp_res &lt;- map(stations$data, possibly(get_temp_data))\n      temperature &lt;- collapse_stations(stations$temp_res)\n\n      ...\n      incProgress(3/4, detail = \"Extracting precipitation data\")\n      stations$prcp_res &lt;- map(stations$data, possibly(get_prcp_data))\n      precipitation &lt;- collapse_stations(stations$prcp_res)\n\n      ...\n  })})\n\n  ...\n}\nNote: Due to service interuptions for all NOAA data servers, the live-version of the app uses a pair of local dataframes containing all the station data. You can see the full code on github\n\n\noutput$weather_plot\nThe main centerpiece of the app is the output plot. This plot is actually two separate ggplots that are generated using the data stored in r city_data reactive.\nOne of the plots shows temperature and the other shows precipitation. Both of these plots are themselves complex ggplot2 objects, with many layers and annotations. Full ggplot code to generate each plot is available on github: temperature, precipitation.\nIn order to keep the results of the app as a single image that can be copied and shared the R package patchwork is used to set both plots on top of each-other. This means that just a single renderPlot() is needed.\n\n\nExample output of plots generated by app\n\n\n\noutput$station_info\nTo let the user see exactly what weather stations went into generating their city‚Äôs averaged weather, a small panel is provided beneath the plot that lays out the long-and-complicated station id along with the types of data contributed by that station.\noutput$station_info &lt;- renderUI({\n  # Let the user know what stations went into the plot they're seeing and\n  # allow them to explore the data directly\n  pmap(city_data()$station_info,\n       function(url, station, had_temp, had_prcp, ...){\n         div(class = \"station_bubble\",\n             a(href = url, target = \"_blank\",\n               station, if(had_temp) icon('thermometer-half'), if(had_prcp) icon('cloud-rain')))\n       })\n})\nThis pane is generated with series of div tags inserted into the app using the dynamic UI generation functions renderUI() and uiOutput(). The number and contents of these tags depends on the results contained in the city_data() reactive.\n\n Example station info for Ann Arbor, MI. Notice that the first station is missing precipitation data.\n\n\n\nPrevious city button\nA lot of times one may be interested in comparing the weather between two cities. A previous city button allows this interaction. the button simply sets the city to the city viewed just before the current city. To quickly toggle back and forth between two cities to see the differences the user simply needs to tap the button repeatedly.\n\n\n\nThe previous city button lets the user quickly toggle between two cities to compare them."
  },
  {
    "objectID": "blog/posts/weather-lookup-about/index.html#learning-more",
    "href": "blog/posts/weather-lookup-about/index.html#learning-more",
    "title": "Weather App Story Pt. 1: About",
    "section": "Learning more",
    "text": "Learning more\nNow that we have introduced the app. Check out the followup articles that detail how the app uses caching to provide a speedy user experience and how we give the app a bespoke look with the bslib package (coming soon).\nAlso be sure to check out the github repo with all the apps code."
  },
  {
    "objectID": "blog/posts/shinyuieditor-out-of-alpha/index.html#whats-new",
    "href": "blog/posts/shinyuieditor-out-of-alpha/index.html#whats-new",
    "title": "ShinyUiEditor: Out of Alpha",
    "section": "What‚Äôs New?",
    "text": "What‚Äôs New?\nWe‚Äôre excited to announce that ShinyUiEditor, a drag-and-drop interface for building Shiny apps, is officially out of its ‚Äúalpha‚Äù stage. With a year of rigorous development and community feedback behind us, the editor is more robust, feature-rich, and ready for you to try it out!"
  },
  {
    "objectID": "blog/posts/shinyuieditor-out-of-alpha/index.html#the-journey-so-far",
    "href": "blog/posts/shinyuieditor-out-of-alpha/index.html#the-journey-so-far",
    "title": "ShinyUiEditor: Out of Alpha",
    "section": "The Journey So Far",
    "text": "The Journey So Far\nShinyUiEditor debuted at RStudioConf::2022, offering an initial glimpse and hands-on experience for adventurous users. Since then, we have made significant advancements, including the addition of server awareness functionality, and reducing friction for users when adding and updating input and outputs in their apps.\n\n\n\nInputs and outputs are synced between the UI and Server code. \n\n\nNew ways of running\nWe have also introduced two new ways of running the UI editor.\nThe first is a ‚Äústatic‚Äù mode that runs directly on the editor‚Äôs website with no need to install anything. This eliminates the need for installation and provides copy-and-pastable code for your app once you‚Äôre done.\nThe second is a VSCode extension, allowing you to open the editor right next to your app‚Äôs script to instantly see updates.\n\n\nBetter looking apps\nTo ensure apps created with the UI editor look great, we have added new bslib components like value boxes and cards.\nOn the less exciting ‚Äì but very important ‚Äì front, we have also focused on bug fixes, stability improvements, and overall performance enhancements.\n\n\n\nNow if you delete an element with server bindings, the editor will ask if you want to delete the bindings as well. This results in cleaner app code, especially when starting from a template. \n\n\nThe Road Ahead\nJust because we‚Äôre out of alpha doesn‚Äôt mean we‚Äôre done adding features and generally improving the editor. Some upcoming features include exciting components like bslib::sidebar_layout() and bslib::accordian(), and a greater variety of templates to start from. Keep an eye on the GitHub repository and editor website to stay up-to-date with the latest.\n\n\nWe‚Äôre Listening\nFeedback isn‚Äôt just appreciated‚Äîit‚Äôs crucial. Your insights and suggestions will greatly influence ShinyUiEditor‚Äôs continued development. Join the conversation through our Discord channel or raise an issue on our GitHub page.\nWe can‚Äôt wait to see what you build!"
  },
  {
    "objectID": "blog/posts/shinyuieditor-out-of-alpha/index.html#the-road-ahead",
    "href": "blog/posts/shinyuieditor-out-of-alpha/index.html#the-road-ahead",
    "title": "ShinyUiEditor: Out of Alpha",
    "section": "The Road Ahead",
    "text": "The Road Ahead\nJust because we‚Äôre out of alpha doesn‚Äôt mean we‚Äôre done adding features and generally improving the editor. Some upcoming features include exciting components like bslib::sidebar_layout() and bslib::accordian(), and a greater variety of templates to start from. Keep an eye on the GitHub repository and editor website to stay up-to-date with the latest."
  },
  {
    "objectID": "blog/posts/shinyuieditor-out-of-alpha/index.html#were-listening",
    "href": "blog/posts/shinyuieditor-out-of-alpha/index.html#were-listening",
    "title": "ShinyUiEditor: Out of Alpha",
    "section": "We‚Äôre Listening",
    "text": "We‚Äôre Listening\nFeedback isn‚Äôt just appreciated‚Äîit‚Äôs crucial. Your insights and suggestions will greatly influence ShinyUiEditor‚Äôs continued development. Join the conversation through our Discord channel or raise an issue on our GitHub page.\nWe can‚Äôt wait to see what you build!"
  },
  {
    "objectID": "blog/posts/shiny-python-chatstream/index.html",
    "href": "blog/posts/shiny-python-chatstream/index.html",
    "title": "AI chat apps with Shiny for Python",
    "section": "",
    "text": "In the short time since they‚Äôve become publicly available, chat interfaces for Large Language Models (LLMs) have become incredibly popular. With Shiny for Python, you can easily create your own chat application with just a few lines of code. If you‚Äôve wanted to make a web application for interacting with AI, you can do it with Shiny for Python.\nHere‚Äôs a very basic chat app that uses the OpenAI API:\n\n\n\n\n\nIt makes use of a Shiny module in a Python package called chatstream. All you need is one call to chatstream.chat_ui() and one call to chatstream.chat_server(), and to give them the same ID. Here‚Äôs the code for that app:\nfrom shiny import App, Inputs, Outputs, Session, ui\nimport chatstream\n\napp_ui = ui.page_fixed(\n    chatstream.chat_ui(\"mychat\"),\n)\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    chatstream.chat_server(\"mychat\")\n\napp = App(app_ui, server)\nThe user types in some text and clicks the button, which tells the server side of the Shiny app to send a request to the OpenAI API. The OpenAI API endpoint sends a streaming response back, and the server side of the Shiny app then sends the result to the client (browser) side of the Shiny app.\nUsing an LLM to generate text takes some time, and showing the streaming response as it comes in provides for a much better user experience than having it sit there for several seconds before the response shows up all at once.\nThe live streaming update is possible because the Shiny‚Äôs reactive engine is built using Python‚Äôs asyncio library. The streaming HTTP response from the OpenAI server is wrapped into an async generator, which, on each iteration, yields a word of the response.\nBecause the chat component is in a Shiny module, you can easily add multiple modules and even have them talk to each other. Here are two of them playing 20 questions:\n\n\n\n\n\nThe chat app is built using the chatstream library. At the moment, chatstream is not on PyPI, but you can install it directly from GitHub. Please keep in mind that chatstream is in the very early stages and may have significant API changes in the future as we learn more about which abstractions are the right ones to use.\nNow, the chat app above is neat, but it doesn‚Äôt do anything more than the standard web chat inferface provided by OpenAI. We can do something more interesting, though, by using Python to things that Python is good at, and combining that with the LLM for the things that the LLM is good at.\n\nUsing Shiny to combine the power of a programming language, LLM, and you\nYou probably already know that LLMs are extremely useful for generating text and computer code, but they also have another often-overlooked strength: you can feed unstructured data into an LLM and ask it to produce structured data, which you can then do something useful with.\nOn the flip side, the LLM is not a panacea. One of the drawbacks of LLMs is that the output is not completely predictable ‚Äì even in the best of circumstances, a human is often needed to verify that the LLM did what we wanted it to do.\nAn interactive web application can combine the strengths of a programming language, an LLM, and a human. I‚Äôll demonstrate with a Shiny application. If you‚Äôve ever looked for recipes on the internet, you know that many recipe web pages consist mostly of filler material, with a small amount of actual recipe information inside. We can use Shiny to build an app that works this way:\n\nThe programming language (Python) fetches a web page and extracts text from it.\nThe LLM converts the unstructured data (the text of the web page) to structured data.\nThe human verifies that the LLM did the right thing, and if so, tells the app to save the recipe.\n\nWith Shiny, we can build an application that scrapes text from a recipe website using the BeautifulSoup library, then feeds the (unstructured) text to the OpenAI API along with a prompt that describes the structured data that we want. The prompt tells it to generate a JSON representation of the recipe, and provides an example of what the output should look like.\n\n\n\n\n\nIn my experience, the LLM almost always does a good job producing JSON, but it is not 100% perfect. This is where the human comes in. You can take a look at the output, decide if it looks correct, and if so, choose to do something with the data.\nYou can see the code for this app here.\nIn the next version of this app, we‚Äôll process the data while it‚Äôs streaming to produce HTML that displays in a card-like format so that it‚Äôs easier to read, and at the end, we‚Äôll add a button that the user can click on to save it to a database.\n\n\n\n\n\nThe code for this app is here.\nOf course, this technique isn‚Äôt limited to recipes ‚Äì you could do something similar with user product reviews, for example.\nIf you‚Äôve wanted to build an interactive AI chat app using Python, Shiny and chatstream can help make it happen. Take a look at the source and feel free to adapt it to your own use case.\nIn a future blog post, I‚Äôll show how to use Shiny build an app that lets you ask questions about a document or set of documents. Stay tuned!"
  },
  {
    "objectID": "blog/posts/shiny-python-0.6.1/index.html",
    "href": "blog/posts/shiny-python-0.6.1/index.html",
    "title": "Shiny for Python 0.6.1",
    "section": "",
    "text": "Shiny for Python 0.6.1 is out! You can read the full changelog for a complete list of new features."
  },
  {
    "objectID": "blog/posts/shiny-python-0.6.1/index.html#component-gallery",
    "href": "blog/posts/shiny-python-0.6.1/index.html#component-gallery",
    "title": "Shiny for Python 0.6.1",
    "section": "Component gallery",
    "text": "Component gallery\nAs the number of Shiny components grows, it becomes harder to find the component you want. We‚Äôve created a Shiny Component gallery which gives you an interactive example of each component, as well as additional documentation about when and how to use it.\n\nCurrently, this gallery contains mostly inputs and outputs. In the near future, we‚Äôll add layouts, navigation, and other types of visual components."
  },
  {
    "objectID": "blog/posts/shiny-python-0.6.1/index.html#templates",
    "href": "blog/posts/shiny-python-0.6.1/index.html#templates",
    "title": "Shiny for Python 0.6.1",
    "section": "Templates",
    "text": "Templates\nPreviously, when you called shiny create, you would get a basic app without much functionality. This is helpful for hello-world examples, but doesn‚Äôt provide much guidance on how to build a more complicated Shiny application. We‚Äôre now including app templates which you can access through the new shiny create command line interface. This interface will ask you which template you want to build, and allow you to specify its location.\nWe are going to release many more of these, but for the time being, we have covered three of our most common use cases. You can access them through the CLI menu, or by passing their name to the --template flag. We‚Äôve included our current zero-dependency basic app, but have added a Dashboard and Multi-page template.\nThe Dashboard template shows you how to build a nice-looking single-page dashboard. It includes some cards and value boxes which are populated using a reactive calculation. This is a good template to start with if you want to make use of some of the new components which were released in Shiny 0.6.0.\nThe multi-page app gives you a starting point for a large, production application. This app uses page_navbar to display several tabs, but the content of those tabs is stored in individual modules. Shiny modules are a great way to organize large applications because they allow you to break your application apart into simple building blocks which are easier to maintain. The application also uses type annotations which improve the development experience, and includes an external CSS file to customize the look and feel of the app."
  },
  {
    "objectID": "blog/posts/shiny-python-0.6.1/index.html#debugging-shiny-apps",
    "href": "blog/posts/shiny-python-0.6.1/index.html#debugging-shiny-apps",
    "title": "Shiny for Python 0.6.1",
    "section": "Debugging Shiny Apps",
    "text": "Debugging Shiny Apps\nThe Shiny extension for VS Code now lets you run your Shiny apps using the VS Code debugger. This lets you set breakpoints, debug on error, and step through your application code using VS code. To activate it, click the dropdown menu next to the Play button and select ‚ÄúDebug Shiny App‚Äù. To learn more about how to use the VS Code debugger, check out the VS Code documentation."
  },
  {
    "objectID": "blog/posts/shiny-python-0.6.1/index.html#shiny-express-sneak-peek",
    "href": "blog/posts/shiny-python-0.6.1/index.html#shiny-express-sneak-peek",
    "title": "Shiny for Python 0.6.1",
    "section": "Shiny Express sneak peek",
    "text": "Shiny Express sneak peek\nWe‚Äôve been working hard on Shiny Express, which is a new way to write Shiny apps without explicitly defining a UI object. The basic Shiny Express functionality is included in 0.6.1, but you should treat it as experimental for the time being and pin your Shiny version if you use Express. We‚Äôll be releasing additional functionality in our next release, and will have much more to say about it at that point. If you‚Äôre interested in trying it out and giving us feedback, please read this post describing the project.\n\nThat‚Äôs it for today! As always, if you have any questions or feedback, please join us on Discord or open an issue on GitHub. And if you‚Äôre enjoying Shiny for Python, please consider starring us on GitHub to show your support!"
  },
  {
    "objectID": "blog/posts/shiny-python-0.4.0/index.html",
    "href": "blog/posts/shiny-python-0.4.0/index.html",
    "title": "Shiny for Python 0.4.0",
    "section": "",
    "text": "Hello, Shiny for Python users. We have some great new features for you in the latest release!"
  },
  {
    "objectID": "blog/posts/shiny-python-0.4.0/index.html#introducing-data-grid-data-table",
    "href": "blog/posts/shiny-python-0.4.0/index.html#introducing-data-grid-data-table",
    "title": "Shiny for Python 0.4.0",
    "section": "Introducing data grid / data table",
    "text": "Introducing data grid / data table\nWe‚Äôve added a new, fast-scrolling data table output.\n\nIt can easily handle tables with tens of thousands of rows, and supports sorting by columns ‚Äì just click on the column header to sort.\nIn addition to the grid-style appearance, the data can be displayed with a more traditional table-like appearance.\n\nThese tables aren‚Äôt just for displaying data ‚Äì they can also allow you to select rows, use that selection as an input, as shown here:\n\nTo use the new tables, put this in your application‚Äôs UI:\n  ui.output_data_frame(\"mygrid\")\nAnd in your server function, use @render.data_frame and give it a function that returns a render.DataGrid(); in turn, that function a Pandas data frame.\n  @output\n  @render.data_frame\n  def mygrid():\n    return render.DataGrid(my_df)\nTo get the more traditional table-like styling, return a render.DataTable() instead.\n\nTry it out with Shinylive\nAPI documentation"
  },
  {
    "objectID": "blog/posts/shiny-python-0.4.0/index.html#better-looking-sidebars",
    "href": "blog/posts/shiny-python-0.4.0/index.html#better-looking-sidebars",
    "title": "Shiny for Python 0.4.0",
    "section": "Better-looking sidebars",
    "text": "Better-looking sidebars\nIn addition to the new tables, we‚Äôve also improved the look of the basic sidebar. Here‚Äôs what they used to look like:\n\nPreviously, the sidebar was only as tall as the content in the sidebar, but now they span the full height of the application. Here‚Äôs what they look like now:\n\nYou won‚Äôt have to change any code to get the new look ‚Äì your existing code will just work!\nCheck out a live example here.\nEnjoy!"
  },
  {
    "objectID": "blog/posts/introducing-shiny-templates/index.html",
    "href": "blog/posts/introducing-shiny-templates/index.html",
    "title": "Introducing Shiny for Python Templates",
    "section": "",
    "text": "Last month we introduced the Shiny for Python Components and Layouts galleries, which are a simple, visual overview of what Shiny can do mixed with cheatsheet-like information. They are for new and seasoned users alike.\nWe‚Äôre excited to announce a third section which brings those two things together into opinionated boilerplate code: Shiny Templates.\nThese will allow you to hit the ground running, whether you need a quick simple app or a quick complicated one üôÇ.\nWhen making Shiny apps, we‚Äôve noticed we sometimes don‚Äôt know what the app‚Äôs UX will eventually become. As an app‚Äôs functionality grows and grows, the usability of the app can decrease. Our goal here is to set Shiny developers up for success (in the short AND long term.) We hope you feel the same! (If you have any feedback, never hesitate to let us know.)\nSimply put: Shiny Templates will dramatically improve your start time, and save you from UX headaches down the road. This is just a start‚Ä¶ We expect this gallery to grow as time goes on.\nSee Shiny Templates"
  },
  {
    "objectID": "blog/posts/introducing-shiny-templates/index.html#demos",
    "href": "blog/posts/introducing-shiny-templates/index.html#demos",
    "title": "Introducing Shiny for Python Templates",
    "section": "Demos",
    "text": "Demos\nWe asked Carson Sievert to quickly get an app running locally, and show how he‚Äôd begin to make it his own:\n\nIntroducing Shiny for Python Templates\n\n\n\n\n\n\nUsing your dataset in Shiny Templates"
  },
  {
    "objectID": "blog/posts/conf-2023-recap-andrew-holz/index.html",
    "href": "blog/posts/conf-2023-recap-andrew-holz/index.html",
    "title": "Shiny Conf 2023 Recap",
    "section": "",
    "text": "Appsilon‚Äôs Shiny Conf 2023 was a big success, with many incredible speakers (including 3 members of our team!) and many viewers tuning in from afar.\nOne of the highlights was Barret Schloerke‚Äôs talk on the ‚ÄúLessons learned from testing 2500+ Shiny Apps every day‚Äù. This talk provided valuable insights on how to improve the quality of Shiny apps through automated testing and some of the hard lessons learned building out the infrastructure the team uses to maintain quality every day.\nAnother noteworthy talk was by Carson Sievert, who presented ‚ÄúTowards the next generation of Shiny UI‚Äù. His talk delved into some of the new bslib features that we‚Äôre most excited about (e.g., expandable cards, accordions, (sidebar) layouts, input controls, etc.), discussed some best design practices for improving user experience with these tools, and presented some real world examples of these tools in action.\nWinston Chang‚Äôs keynote on ‚ÄúLessons and opportunities with Shiny for Python‚Äù was also a major highlight of the conference. His talk focused on the many lessons learned from his last 10 years of building Shiny for R, and leveraging those lessons while building the latest member of the Shiny family, Shiny for Python.\nWe will be sharing videos for all of these talks as they become available, so keep an eye out for them. We would also like to thank Appsilon for their tireless work making the conference such a great success.\nFinally, we would like to invite you to participate in the survey being conducted along with the conference on the state of Shiny. Everyone who fills it out will get first crack at the data, so don‚Äôt miss out on this opportunity.\n\nFill out the survey"
  },
  {
    "objectID": "blog/posts/announcing-new-r-shiny-ui-components/index.html",
    "href": "blog/posts/announcing-new-r-shiny-ui-components/index.html",
    "title": "Announcing new R Shiny UI components",
    "section": "",
    "text": "I‚Äôm thrilled to share that the latest release of the {bslib} R package introduces new a Card API, Value boxes, and a responsive grid-like layout. These new UI components work in Shiny, R Markdown, Quarto (or really any R-based HTML project) and work best alongside the new {bsicons} package (an R interface to Bootstrap icons) as well as the latest versions of {htmlwidgets} and {shiny}:\nIn the video below, I walk-through a Shiny app which quickly illustrates what‚Äôs possible with these components. Note the responsive full screen behavior of the cards and the ‚Äúsidebar‚Äù layout made possible by the new layout_column_wrap(). It also makes use of the new {histoslider} package for the histogram sliders in the sidebar. See here for the live app and here for the source code."
  },
  {
    "objectID": "blog/posts/announcing-new-r-shiny-ui-components/index.html#cards",
    "href": "blog/posts/announcing-new-r-shiny-ui-components/index.html#cards",
    "title": "Announcing new R Shiny UI components",
    "section": "Cards",
    "text": "Cards\n\nAt their most basic level, cards simply provide borders and padding around content, but {bslib} adds on some additional functionality like expanding to full screen, integration with tab panels, static images, and more.\n\n Learn more about cards  \n\n\n\n\n\n\n\nValue boxes\n\nAt their most basic level, value boxes provide a simple way to highlight single value with a caption. Optionally, value boxes can showcase some HTML content like an icon or even a plotly graph. In addition, value boxes can also be expanded to full screen which, with some clever usage, can be leveraged to implement ‚Äúexpandable spark lines‚Äù, like shown below.\n\n Learn more about value boxes  \n\n\n\n\n\n\n\n\nResponsive grid-like layout\n\nThe new layout_column_wrap() function is designed for wrapping a 1d sequence of UI elements into a responsive 2d grid (powered by CSS Grid).\n\n\nIts defaults are optimized for a grid that has equal column widths and row heights, but it‚Äôs also fairly straightforward to vary heights and widths. In addition, layout_column_wrap() can be nested inside another layout_column_wrap(), which is helpful for more sophisticated layouts, like the motivating example (the one with a ‚Äúsidebar‚Äù at the top of this post). That example also leverages responsive sizing and a clever bit of CSS on the outermost layout_column_wrap() to effectively fit contents to the viewport (minus some space for the navbar height). By the way, without that specified height, the contents would just use their natural height (thanks to the underlying bindFillRole() mechanics there‚Äôs no need for tedious setting of height=‚Äú100%‚Äù everywhere to get children to fill their parent height).\n\n Learn more about layouts \n\n\n\n\n\n\n\n\nFill items and containers\n\nUnderneath the hood, cards, value boxes, and layout_column_wrap() all make use of the new bindFillRole() function from {htmltools} (in fact, the newest shiny::plotOutput() and htmlwidgets::shinyWidgetOutput() do as well) to achieve their intelligent responsive fill sizing behavior. We decided to expose the mechanism behind this fill behavior in {htmltools} since it isn‚Äôt specific to Bootstrap (it‚Äôs based on CSS flexbox), and as a result, could be leveraged in any Shiny (or RMarkdown/Quarto) project.\n\n\nbindFillRole() works by marking a UI element (i.e., a htmltools::tag) as either a fill container or a fill item (or both). When a fill item appears as a direct child of a fill container with an opinionated height, it grows and/or shrinks to fit the containers height. For a concrete example and more explanation, visit the reference page for bindFillRole().\n\n\n\n\n\n\n\n\n\nMore to come\nKeep an eye out for more UI components coming in future releases of {bslib}. We‚Äôre hoping {bslib} can eventually be a ‚Äúone-stop shop‚Äù of tools for building custom and modern looking Shiny UI. Obviously, to meet that goal, we need to at least match the set of functionality that projects like {shinydashboard} provide, so be on the look out for things a new sidebar layout, accordions, and more."
  },
  {
    "objectID": "r/articles/build/generating-reports/index.html",
    "href": "r/articles/build/generating-reports/index.html",
    "title": "Generating downloadable reports",
    "section": "",
    "text": "After interacting with a Shiny application and getting it certain state, your users may want to download a report in HTML or PDF format. You can easily add the ability to generate a report with knitr and rmarkdown at the click of a button.\nThere are two key parts for this:",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "Generating downloadable reports"
    ]
  },
  {
    "objectID": "r/articles/build/generating-reports/index.html#example",
    "href": "r/articles/build/generating-reports/index.html#example",
    "title": "Generating downloadable reports",
    "section": "Example",
    "text": "Example\nThis app takes one input value, and passes it as a parameter to an .Rmd document, which is rendered (or knitted) into an HTML output file. You can see this app in action here.\napp.R:\n```{r}\nshinyApp(\n  ui = fluidPage(\n    sliderInput(\"slider\", \"Slider\", 1, 100, 50),\n    downloadButton(\"report\", \"Generate report\")\n  ),\n  server = function(input, output) {\n    output$report &lt;- downloadHandler(\n      # For PDF output, change this to \"report.pdf\"\n      filename = \"report.html\",\n      content = function(file) {\n        # Copy the report file to a temporary directory before processing it, in\n        # case we don't have write permissions to the current working dir (which\n        # can happen when deployed).\n        tempReport &lt;- file.path(tempdir(), \"report.Rmd\")\n        file.copy(\"report.Rmd\", tempReport, overwrite = TRUE)\n\n        # Set up parameters to pass to Rmd document\n        params &lt;- list(n = input$slider)\n\n        # Knit the document, passing in the `params` list, and eval it in a\n        # child of the global environment (this isolates the code in the document\n        # from the code in this app).\n        rmarkdown::render(tempReport, output_file = file,\n          params = params,\n          envir = new.env(parent = globalenv())\n        )\n      }\n    )\n  }\n)\n```\nreport.Rmd:\n---\ntitle: \"Dynamic report\"\noutput: html_document\nparams:\n  n: NA\n---\n\n```{r}\n# The `params` object is available in the document.\nparams$n\n```\n\nA plot of `params$n` random points.\n\n```{r}\nplot(rnorm(params$n), rnorm(params$n))\n```\nNote that due to an issue in the rmarkdown package, the default value of a parameter in the YAML header cannot be NULL, so we‚Äôve used NA as the default value of n.\n\nNotes\nThe rmarkdown::render() function has many options to control the processing and output. See the rmarkdown website to learn more. Some commonly used options are described below.\nBy default, an HTML file generated by rmarkdown::render() will have all plots and other images embedded directly in the HTML, so you can simply publish or send the HTML file, without needing to handle separate image files.\nIf you want PDF output, the rmarkdown::render() function can do that. This will require two changes:\n\nChange the filename argument of downloadHandler() to \"report.pdf\".\nUse output: pdf_document in the YAML header of the Rmd file.\n\nIt will also require pdflatex to be installed on your system.\nAnother way to generate a PDF is to pass in a value to output_format argument of rmarkdown::render(), as demonstrated in this app.\nTo generate a Microsoft Word document:\n\nChange the filename argument of downloadHandler() to \"report.doc\".\nUse output: word_document in the YAML header of the Rmd file.\n\nWhen calling rmarkdown::render, it is possible for the Rmd document to directly access variables that are available to the Shiny app, including input values like input$slider. This can be done by using the default value for envir (instead of passing in a new environment). However, we recommend passing in params and using a new envir, because it provides better code isolation and makes things easier to debug.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "Generating downloadable reports"
    ]
  },
  {
    "objectID": "blog/posts/cards-in-shinyuieditor/index.html",
    "href": "blog/posts/cards-in-shinyuieditor/index.html",
    "title": "New to the ShinyUiEditor: bslib Cards!",
    "section": "",
    "text": "We‚Äôre thrilled to announce the latest version of ShinyUIEditor. The main feature of this new release is support for the new bslib::card() component. The new bslib cards provide an easy-to-use and attractive way to wrap related content in your app. In addition to the new cards, this release adds a ‚Äústatic text‚Äù component for adding simple descriptions or instructions to your app, fixes a number of bugs, and improves performance across the editor. A full list of changes is available on the editor‚Äôs website.\n\nBefore getting started\nThis release depends on you having the latest version of the gridlayout and bslib packages. Make sure those are up-to-date!\ninstall.packages(\"remotes\")\n\n# Install dependencies using the remotes package\nremotes::install_github(\"rstudio/bslib\")\nremotes::install_github(\"rstudio/gridlayout\")\nremotes::install_github(\"rstudio/shinyuieditor\")\n\n\nbslib::card()\n\n\n\nRecently the bslib package added a card component that allows for the intuitive sizing of elements. These cards have powerful features like automatically growing their contents to fill the available space. This is especially useful for things like plots. Combined with an optional full-screen mode, it can make it super easy for users to dig into a specific view of your app without navigating to a different page or app. For more info, check out the blog post announcing cards.\n\n\nAdding cards to your app\nGetting started with cards is as simple as dragging the card element from the elements palette onto your app. You can place these cards directly on a grid layout, in a tab panel, or even inside another card.\n\n\n\n\n\nAdding content to the card\nOnce the card is in the app you can drag new items into either the card header, body, or footer. For instance, we could drag a plot into the card. This plot will now intelligently size itself to take up all the space it can in the card:\n\n\n\n\n\nUsing the new static-text component to make informative headers/footers\nNewly created cards have a (removable) header with a simple editable text label that uses a new static-text element in the editor. This static text node is not limited to the header, however. For instance, we can use it to add a footer message to our card telling the user about the cool technology used to create the app their viewing:\n\n\n\n\n\nFull-screen mode\nAnother nice feature of the cards is the full-screen toggle. Just like in the bslib::card() component this allows us to expand the card to take up the full app‚Äôs screen. In the editor we can use this to zoom into our card for more fine-grained control of our contents.\n\n\n\n\n\nGoing forward\nWe believe the addition of bslib cards significantly enhances the ability to create sleek and modern user interfaces using the UI editor: ultimately making more engaging apps for your users. This isn‚Äôt the end of new UI components from bslib being added to the editor. Going forward, we will be adding the new modern UI components from bslib to the editor with the goal of making the UI editor the easiest and fastest way to make great-looking Shiny apps.\n\n\nLinks\nTo see the new card component in action and learn more about this release, check out the links below:\n\nShinyUiEditor website\nChange log\nLive demo\nGithub repo\n\nWe hope you enjoy this new release and look forward to hearing your feedback. Your opinions are crucial to our work in creating the best user interface design tool, and we thank you for your continued support.\nHappy designing!"
  },
  {
    "objectID": "blog/posts/introducing-component-layouts/index.html",
    "href": "blog/posts/introducing-component-layouts/index.html",
    "title": "Introducing Component and Layout Galleries for Shiny for Python",
    "section": "",
    "text": "Reference documents are great if you know what you‚Äôre looking for, but they make it hard to discover new components. For that reason, we‚Äôve created Shiny for Python‚Äôs components gallery and layouts gallery.\nThe goal of these galleries is to provide:"
  },
  {
    "objectID": "blog/posts/introducing-component-layouts/index.html#shiny-components",
    "href": "blog/posts/introducing-component-layouts/index.html#shiny-components",
    "title": "Introducing Component and Layout Galleries for Shiny for Python",
    "section": "Shiny Components",
    "text": "Shiny Components\nThe Shiny Components gallery features a list of 33 Shiny Components ready for your apps. Many of them are live examples (buttons, checkboxes, sliders, etc.) to get the feel for how they work. Once you‚Äôve chosen from this list of inputs, outputs, and display components, you‚Äôll arive at a detailed page with:\n\nA Shinylive preview\nCopy/Paste-able code\nRelevant functions used, their signature, and a link to their reference pages\nDetails of how to use the component\nLive example variations (if applicable)\n\nThe code highlights reveal the most important lines for creating the component. You can run the example code in Shinylive and edit it‚Äîright in the browser, without the need to create or host your own Shiny app. This makes it easy to experiment and see the results!\nHere is an example of the Value Box preview and code. Use the tabs to switch between the new Shiny Express syntax and the original Shiny Core syntax.\n\n\n\n\nExpressCore\n\n\nfrom shiny.express import ui\nfrom faicons import icon_svg\n\npiggy_bank = icon_svg(\"piggy-bank\")\n\nwith ui.layout_columns():\n    with ui.value_box(showcase=piggy_bank, theme=\"bg-gradient-indigo-purple\"):\n        \"KPI Title\"\n        \"$1 Billion Dollars\"\n        \"Up 30% VS PREVIOUS 30 DAYS\"\n\n Edit in Shinylive\n\n\n\nfrom shiny import App, ui\nfrom faicons import icon_svg\n\npiggy_bank = icon_svg(\"piggy-bank\")\n\napp_ui = ui.page_fluid(\n    ui.layout_columns(\n        ui.value_box(\n            \"KPI Title\",\n            \"$1 Billion Dollars\",\n            \"Up 30% VS PREVIOUS 30 DAYS\",\n            showcase=piggy_bank,\n            theme=\"bg-gradient-indigo-purple\",\n        ),\n    ),\n)\n\napp = App(app_ui, server=None)\n\n Edit in Shinylive\n\n\n\n\n\n\nVariations\nSome of the more complex components also have a Variations section. Here you will find code templates for commonly used configurations of the component. Like all of the examples in the gallery, these templates can be edited and run right in the browser, thanks to Shinylive. Here is an example of the Value Box Theme and Layout Variation:\n\n\n\n\n\nExpressCore\n\n\nimport faicons\nfrom shiny.express import ui\n\nwith ui.layout_column_wrap():\n    with ui.value_box(\n        showcase=faicons.icon_svg(\"piggy-bank\"),\n        theme=\"bg-gradient-indigo-purple\",  \n    ):\n        \"KPI Title\"\n        \"$1 Billion Dollars\"\n        \"Up 30% VS PREVIOUS 30 DAYS\"\n\n    with ui.value_box(\n        showcase=faicons.icon_svg(\"piggy-bank\"),\n        theme=\"text-green\",  \n        showcase_layout=\"top right\",  \n    ):\n        \"KPI Title\"\n        \"$1 Billion Dollars\"\n        \"Up 30% VS PREVIOUS 30 DAYS\"\n\n    with ui.value_box(\n        showcase=faicons.icon_svg(\"piggy-bank\"),\n        theme=\"purple\",  \n        showcase_layout=\"bottom\",  \n    ):\n        \"KPI Title\"\n        \"$1 Billion Dollars\"\n        \"Up 30% VS PREVIOUS 30 DAYS\"\n\n Edit in Shinylive\n\n\n\nimport faicons\nfrom shiny import App, ui\n\napp_ui = ui.page_fluid(\n    ui.layout_column_wrap(\n        ui.value_box(\n            \"KPI Title\",\n            \"$1 Billion Dollars\",\n            \"Up 30% VS PREVIOUS 30 DAYS\",\n            showcase=faicons.icon_svg(\"piggy-bank\"),\n            theme=\"bg-gradient-indigo-purple\",  \n        ),\n        ui.value_box(\n            \"KPI Title\",\n            \"$1 Billion Dollars\",\n            \"Up 30% VS PREVIOUS 30 DAYS\",\n            showcase=faicons.icon_svg(\"piggy-bank\"),\n            theme=\"text-green\",  \n            showcase_layout=\"top right\",  \n        ),\n        ui.value_box(\n            \"KPI Title\",\n            \"$1 Billion Dollars\",\n            \"Up 30% VS PREVIOUS 30 DAYS\",\n            showcase=faicons.icon_svg(\"piggy-bank\"),\n            theme=\"purple\",  \n            showcase_layout=\"bottom\",  \n        ),\n    )\n)\napp = App(app_ui, server=None)\n\n Edit in Shinylive"
  },
  {
    "objectID": "blog/posts/introducing-component-layouts/index.html#shiny-layouts",
    "href": "blog/posts/introducing-component-layouts/index.html#shiny-layouts",
    "title": "Introducing Component and Layout Galleries for Shiny for Python",
    "section": "Shiny Layouts",
    "text": "Shiny Layouts\nThe Shiny Layouts gallery follows the same display pattern as the components gallery to showcase the different ways you can approach your app‚Äôs user interface (UI) layout. The main page lists out a variety of layouts (navbars, sidebars, tabs, etc.) to give you a quick overview of different ways to arrange your app. We hope it sparks some inspiration to create a very intuitive experience for your users.\n\n\n\n\n\n\n\nOnce you know the overall type of style you like, you get the same set of relevant functions, in-browser preview, example code, and detailed instructions, just like the components gallery.\n\n\n\n\n\nExpressCore\n\n\nfrom shiny.express import ui\n\nui.page_opts(\n    title=\"App with navbar\",  \n)\n\nwith ui.nav_panel(\"A\"):  \n    \"Page A content\"\n\nwith ui.nav_panel(\"B\"):  \n    \"Page B content\"\n\nwith ui.nav_panel(\"C\"):  \n    \"Page C content\"\n\n Edit in Shinylive\n\n\n\nfrom shiny import App, ui\n\napp_ui = ui.page_navbar(  \n    ui.nav_panel(\"A\", \"Page A content\"),  \n    ui.nav_panel(\"B\", \"Page B content\"),  \n    ui.nav_panel(\"C\", \"Page C content\"),  \n    title=\"App with navbar\",  \n    id=\"page\",  \n)  \n\n\ndef server(input, output, session):\n    pass\n\n\napp = App(app_ui, server)\n\n Edit in Shinylive\n\n\n\n\n\nYou can see the layout in action directly on the page, or jump into Shinylive to modify the code as needed and see the results without leaving your browser."
  },
  {
    "objectID": "blog/posts/introducing-component-layouts/index.html#check-it-out",
    "href": "blog/posts/introducing-component-layouts/index.html#check-it-out",
    "title": "Introducing Component and Layout Galleries for Shiny for Python",
    "section": "Check It Out!",
    "text": "Check It Out!\nWe‚Äôve made these pages for both brand new users and long-time app builders. We hope they are helpful for everyone!\nShiny Components Shiny Layouts"
  },
  {
    "objectID": "blog/posts/shiny-on-hugging-face/index.html",
    "href": "blog/posts/shiny-on-hugging-face/index.html",
    "title": "Shiny on Hugging Face",
    "section": "",
    "text": "We‚Äôre thrilled to announce that we‚Äôve partnered with Hugging Face to provide templated Spaces for both the R and Python Shiny packages. These Spaces allow you to deploy an R or Python Shiny app on Hugging Face with a click of a button, and make it easy to integrate Hugging Face models into your app."
  },
  {
    "objectID": "blog/posts/shiny-on-hugging-face/index.html#about-hugging-face",
    "href": "blog/posts/shiny-on-hugging-face/index.html#about-hugging-face",
    "title": "Shiny on Hugging Face",
    "section": "About Hugging Face",
    "text": "About Hugging Face\nHugging Face is the most used open platform for AI, where the machine learning (ML) community has shared more than 150,000 models; 25,000 datasets; and 30,000 ML apps, including Stable Diffusion, Bloom, GPT-J, and open source ChatGPT alternatives. These apps enable the community to explore models, replicate results, and lower the barrier of entry for ML. At Posit, we‚Äôve been extremely impressed with the Hugging Face community, and their commitment to supporting open source machine learning models."
  },
  {
    "objectID": "blog/posts/shiny-on-hugging-face/index.html#what-does-shiny-add",
    "href": "blog/posts/shiny-on-hugging-face/index.html#what-does-shiny-add",
    "title": "Shiny on Hugging Face",
    "section": "What does Shiny add?",
    "text": "What does Shiny add?\nWe think that Shiny is a great front-end for Hugging Face models because it is an efficient and developer-friendly GUI framework. Our reactive execution model allows Shiny to infer the relationships between inputs and outputs and minimally re-render application components. This means that you can quickly build intuitive and beautiful model demos without writing callback functions or caching data, and is particularly useful when calling expensive inference endpoints. Shiny is easy to learn, and there are great educational resources in both R and Python.\nShiny is great for simple demos, but it also has all of the tools you need to build complex, mission-critical applications. You can design delightful layouts and user interfaces, control application routing, and encapsulate and share components using modules."
  },
  {
    "objectID": "blog/posts/shiny-on-hugging-face/index.html#which-space-should-i-use",
    "href": "blog/posts/shiny-on-hugging-face/index.html#which-space-should-i-use",
    "title": "Shiny on Hugging Face",
    "section": "Which Space should I use?",
    "text": "Which Space should I use?\nWe have both R and Python templates available, so you can use your language of choice to write Shiny apps.\nMost of the Hugging Face toolchain is built around Python, and as a result the Shiny for Python Space is a bit easier to use on Hugging Face. Shiny for Python is a pure python implementation of Shiny, and does not require an R installation. This means that Shiny for Python apps will deploy faster on Hugging Face infrastructure, and integrate better with their Python SDKs.\nIf you are an R user, or want to make use of some of the amazing R extensions, then the Shiny for R Space is an excellent option. To call Hugging Face tools we recommend communicating with Hugging Face using an API or calling one of their Python SDKs using reticulate."
  },
  {
    "objectID": "blog/posts/shiny-on-hugging-face/index.html#conclusion",
    "href": "blog/posts/shiny-on-hugging-face/index.html#conclusion",
    "title": "Shiny on Hugging Face",
    "section": "Conclusion",
    "text": "Conclusion\nOur mission at Posit is to support open-source scientific software, and so we‚Äôre very proud to support the effort to build advanced AI models under open-source licenses. We can‚Äôt wait to see what you build with this integration."
  },
  {
    "objectID": "blog/posts/shiny-python-0.6.0/index.html",
    "href": "blog/posts/shiny-python-0.6.0/index.html",
    "title": "Shiny for Python 0.6.0",
    "section": "",
    "text": "We recently released Shiny for Python 0.6.0, this is a big release so it‚Äôs a good idea to check out the changelog for a full set of new features. This post is going to focus on the four most important changes in 0.6.0."
  },
  {
    "objectID": "blog/posts/shiny-python-0.6.0/index.html#optional-output",
    "href": "blog/posts/shiny-python-0.6.0/index.html#optional-output",
    "title": "Shiny for Python 0.6.0",
    "section": "Optional @output",
    "text": "Optional @output\nUp until now every Shiny output needed two decorators, an @output decorator and some kind of @render decorator. The reason for this is that you can pass arguments like id to @output and so having a separate decorator made sense. Requiring both decorators for every output, however, was a common source of bugs for new users. For example if you neglected to include the output decorator, or used the decorators in the wrong order, you would get a silent failure. As a result we‚Äôve made the @output decorator optional, and recommend that you only use it if you need to access one of its arguments.\ndef server(input, output, session):\n    # @output # &lt;- No longer necessary!\n    @render.text\n    def txt():\n        return f\"n*2 is {input.n() * 2}\""
  },
  {
    "objectID": "blog/posts/shiny-python-0.6.0/index.html#new-page-layouts",
    "href": "blog/posts/shiny-python-0.6.0/index.html#new-page-layouts",
    "title": "Shiny for Python 0.6.0",
    "section": "New page layouts",
    "text": "New page layouts\nA large majority of shiny apps use either a sidebar layout or a navbar layout, and up until this point you‚Äôve needed to combine a page_* and layout_* or navset_* call to generate that kind of app. We‚Äôve added two new functions ui.page_sidebar and ui.page_navbar to better accomodate these cases, and we‚Äôve also improved the look and feel of the default applications. Both ui.page_navbar and ui.page_sidebar added a sidebar= argument which includes a responsive, collapsable sidebar (ui.sidebar) on your application across every tab.\nThe updated layout sidebar (ui.layout_sidebar()) no longer needs to include a call to ui.panel_main(). It is recommended to put content inside ui.card() within the main content of ui.page_sidebar(). Please update your calls of ui.panel_sidebar() to ui.sidebar().\n\nSidebars\n\n\n\nOld API\nui.page_fluid(\n    ui.layout_sidebar(\n        ui.panel_sidebar(\n            ui.input_numeric(\"n\", \"N\", min=0, max=100, value=20),\n        ),\n        ui.panel_main(\n            ui.plot_output(\"plot\"),\n        ),\n    )\n)\n\n\n\n\n\nNew API\nui.page_sidebar(\n    ui.sidebar(\n        ui.input_numeric(\"n\", \"N\", min=0, max=100, value=20),\n    ),\n    ui.card(\n        ui.plot_output(\"plot\"),\n    ),\n)\n\n\n\nIn addition to sidebar, we have added ui.page_fillable() to help users create applications that fill the available space in the window. This is great for applications where the plot should fill the entire contents fo the window. ui.page_sidebar() is a wrapper around ui.page_fillable(). In addition to the filling layout method, many UI output methods have added fill= or fillable= parameters to allow for the component to fill the available area (fill=True) or to allow for contained components to fill the available content area (fillable=). The handshake of fill=True and fillable=True must occur to achieve a filling layout. Let‚Äôs take a look at the new layout in action:"
  },
  {
    "objectID": "blog/posts/shiny-python-0.6.0/index.html#new-components",
    "href": "blog/posts/shiny-python-0.6.0/index.html#new-components",
    "title": "Shiny for Python 0.6.0",
    "section": "New components",
    "text": "New components\nThere are a lot of new components in this release, but the two most important ones are ui.card() and ui.value_box(). Cards allow you to visually dilineate parts of your application, and group inputs and outputs together. For example, you might have a card which included a plot and some inputs which filter the data for that particular plot. Cards also provide sensible spacing which makes your app look less cluttered and easier to read.\nValue boxes are for highlighting single numbers or pieces of text. They are useful for calling out important numbers or pieces of text, and can include showcase icons. To top it off, value boxes are enhanced with advanced Bootstrap theming capabilities, allowing you to change the color of the box, the icon, and the text.\n\n\n\nBoth value boxes and cards can be positioned using ui.layout_column_wrap. This function provides a convenient way to display elements in equally spaced columns. The values boxes in the above example are presented using ui.layout_column_wrap.\nWhile you can arrange content with ui.row() and ui.column(), ui.layout_column_wrap() removes a lot of additional boilerplate. For example if you had three cards which you wanted to lay out on a row, you would do it like this:\nui.layout_column_wrap(\n    ui.card(\"Card 1 content\"),\n    ui.card(ui.plot_output(\"plot2\")),\n    ui.card(ui.plot_output(\"plot3\")),\n    width = 1/3,\n)"
  },
  {
    "objectID": "blog/posts/shiny-python-0.6.0/index.html#many-other-components",
    "href": "blog/posts/shiny-python-0.6.0/index.html#many-other-components",
    "title": "Shiny for Python 0.6.0",
    "section": "Many other components",
    "text": "Many other components\nThere are too many new components in this release to blog about, so please check out the documentation to see how they work together.\n\n\n\n\n\n\n‚Ä¶ psst!\n\n\n\nIf you‚Äôre using shiny.experiemental.ui, you can now use shiny.ui instead. We‚Äôve moved virtually all of the experimental components into the main shiny.ui namespace. üéâ\n\n\n\nThat‚Äôs it for today! As always, if you have any questions or feedback, please join us on Discord or open an issue on GitHub. And if you‚Äôre enjoying Shiny for Python, please consider starring us on GitHub to show your support!"
  },
  {
    "objectID": "blog/posts/shiny-python-1.0/index.html",
    "href": "blog/posts/shiny-python-1.0/index.html",
    "title": "Announcing Shiny for Python 1.0",
    "section": "",
    "text": "Your browser does not support the video tag.\nIt‚Äôs time for another Shiny for Python release! Not only does this release include a number of exciting features and big improvements, it‚Äôs also the release we‚Äôre choosing to call Shiny for Python v1.0.\nIn this post, we‚Äôll talk about what v1.0 means to us, and then get into the feast of new features we have for you!"
  },
  {
    "objectID": "blog/posts/shiny-python-1.0/index.html#what-does-it-mean-to-hit-v1.0",
    "href": "blog/posts/shiny-python-1.0/index.html#what-does-it-mean-to-hit-v1.0",
    "title": "Announcing Shiny for Python 1.0",
    "section": "What does it mean to hit v1.0?",
    "text": "What does it mean to hit v1.0?\nFor the Shiny team, bestowing the ‚Äúv1.0‚Äù label on a piece of software is a declaration of a certain level of quality, feature completeness, and API stability.\nIn April 2023, we removed the alpha tag from Shiny for Python, signaling our team‚Äôs belief that its level of quality and runtime stability made it appropriate for production use. And that belief has borne out: the feedback we‚Äôve received from real-world users of the framework has been overwhelmingly positive.\nAt that time, we chose not to use a 1.0 moniker, preferring to stick to 0.x until after we had shipped essential features like interactive data tables (June 2023) and dashboard UI components (Nov 2023). And soon after that, we came up with Shiny Express, a completely new syntax for writing Shiny apps, which meant another period of heavy feedback and potential revisions of the API.\nSitting here in July 2024, it feels like a great time to acknowledge Shiny for Python‚Äôs maturity by bestowing it with the big 1-point-0. The API feels appropriately stable now, and most of the new features of the last few releases have been about building on top of Shiny‚Äôs existing API design vocabulary, rather than extending or changing it (although one notable brand-new primitive is Modules for Shiny Express, which you can read about below).\nSo please join us in raising a proverbial glass to Shiny for Python 1.0! And if you‚Äôve been waiting on the sidelines, now is a great time to get in the game!\nAnd now, let‚Äôs take a look at all the cool features that are part of this release!"
  },
  {
    "objectID": "blog/posts/shiny-python-1.0/index.html#new-chat-component",
    "href": "blog/posts/shiny-python-1.0/index.html#new-chat-component",
    "title": "Announcing Shiny for Python 1.0",
    "section": "New Chat() component",
    "text": "New Chat() component\nThe new Chat() component makes it easy to implement generative AI chatbots, powered by any LLM of your choosing. For a comprehensive overview, see the new component page.\nThe main steps of any generative AI chatbot are:\n\nCreate a Chat instance.\nDisplay the chat .ui().\nDefine a on_user_submit callback.\n\nThis callback typically passes .messages() to a generative AI model (ai_model) and appends the result to the chat.\nThe ai_model can be anything, but Chat makes it especially easy to use interfaces from OpenAI, Anthropic, Google, LangChain, and Ollama.\n\n\n\n\n\napp.py\n\nfrom shiny.express import ui\n\nchat = ui.Chat(id=\"chat\")\nchat.ui()\n\n@chat.on_user_submit\nasync def _():\n    messages = chat.messages()\n    # The next line is a placeholder for the actual generative AI model\n    response = await ai_model.generate_response(messages, stream=True)\n    # Use append_message_stream() when streaming responses\n    await chat.append_message_stream(response)\n\n\nThe generative AI quickstart has a variety of ai_model implementations, but we do recommend starting with LangChain, as it helps standardize response generation across different LLMs. Use the terminal command below to get the LangChain (with OpenAI) template:\nshiny create -g https://github.com/posit-dev/py-shiny/tree/main/examples/chat/hello-providers/langchain\nThen, follow the instructions at the top of app.py to set up your OpenAI API key before running the app. Once you have your credentials set up and run the app and start chatting!\n\nVideo\n\nThe template above is a great starting point for building your own generative AI chatbot. To learn how to do more advanced things with Chat (e.g., system messages, RAG, etc), check out the component page.\nFor now, ui.Chat() is limited to textual input and output. We hope to expand this in the future to include more complex inputs and outputs, such as images, videos, and audio (for now, you can checkout shinymedia for video in / audio out). We also hope to get your feedback on what you‚Äôd like to see in future versions of Chat!"
  },
  {
    "objectID": "blog/posts/shiny-python-1.0/index.html#end-to-end-testing",
    "href": "blog/posts/shiny-python-1.0/index.html#end-to-end-testing",
    "title": "Announcing Shiny for Python 1.0",
    "section": "End-to-end testing",
    "text": "End-to-end testing\nAfter more than a year of development and internal testing, we‚Äôre now exporting an end-to-end testing framework for Shiny apps. End-to-end tests are a great way to maintain code quality by ensuring that apps behave as expected in response to (simulated) user interactions in a real browser. Our approach builds on the fabulous Playwright framework, which provides a fast, powerful, and resilient foundation for browser-based testing.\nThe video below demonstrates the experience of writing an end-to-end test for a Shiny app. Note that the new shiny.playwright module is where you can find dozens of ‚Äúcontrollers‚Äù that make it easy to mimic user interactions with Shiny components and assert their expected state.\n\nVideo\n\nFor a comprehensive overview of end-to-end testing, see the new article on End-to-end testing in Shiny."
  },
  {
    "objectID": "blog/posts/shiny-python-1.0/index.html#data-frame-improvements",
    "href": "blog/posts/shiny-python-1.0/index.html#data-frame-improvements",
    "title": "Announcing Shiny for Python 1.0",
    "section": "Data frame improvements",
    "text": "Data frame improvements\nShiny provides two components for rendering data frames: DataGrid() and DataTable(). The former is a more interactive and feature-rich table, while the latter is a simpler, more lightweight table. All of the improvements described below are available to both components.\n\nStyling\nDataGrid() and DataTable() gain a styles argument for styling the displayed result. styles can take a list of dictionaries where each dictionary represents a style to be applied to the table (and thus should have at least a style (or class) key to apply CSS styles or classes to the relevant cells). To scope the styling to particular cells, use the rows and cols keys (with 0-based indexing). Note that if both rows and cols are specified, the style will be applied only to the intersection of the specified rows and columns.\nrender.DataGrid(\n    pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]}),\n    styles=[\n        # Center the text of each cell (using Bootstrap utility class)\n        {\n            \"class\": \"text-center\",\n        },\n        # Highlight 1st column green\n        {\n            \"cols\": [0],\n            \"style\": {\"background-color\": \"mediumspringgreen\"},\n        },\n        # Highlight rows 1-2 within 2nd column\n        {\n            \"rows\": [0, 1],\n            \"cols\": [1],\n            \"style\": {\"background-color\": \"darkorange\", \"color\": \"white\"},\n        },\n    ],\n)\n\n\n\n\n\nSelection & editing\nIt‚Äôs now possible to enable both selection and editing simultaneously! üéâ\nrender.DataGrid(\n    pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]}),\n    selection_mode=\"row\",\n    editable=True,\n)\nVideo\nNote that a row/cell can be selected by clicking on it, and a cell can be edited by double-clicking on it. Also, keyboard nativigation works as expected: use the arrow keys to navigate the table, press Enter to start editing a cell, and press Esc to cancel editing.\n\n\nPolars & typing support\nBoth DataGrid() and DataTable() now support Polars DataFrames in addition to pandas DataFrames. Also, accessor methods like .data() and .data_view() now return the same type as the rendered data. This even works with type hints, meaning your IDE will know the correct return type of the accessor. See the screenshot below for an example, and note the polars type hint in the tooltip.\n\n\n\n\n\nMore control over sorting and filtering\nIt‚Äôs now easier than ever to access and manipulate the sorting and filtering state of the table. Here are a few new methods to access that state more easily:\n\n.data_view_rows(): Reactive value representing the sorted and filtered row numbers.\n.sort(): Reactive value representing the sorted column information.\n.filter(): Reactive value representing the filtered column information.\n\nAnd, to programmatically update the sorting and filtering:\n\n.update_sort(sort=): Update the sorting of the data frame.\n.update_filter(filter=): Update the filtering of the data frame.\n\nNote that these methods (as well as other methods for accessing and manipulating state), are placed on the render function. Here‚Äôs an example of having a button that sorts the data frame on column 0 in ascending order:\n\n\n\napp.py\n\nimport pandas as pd\nfrom shiny import reactive\nfrom shiny.express import input, render, ui\n\n@render.data_frame\ndef df():\n    return pd.DataFrame({\"A\": [1, 3, 2], \"B\": [4, 5, 6]})\n\n@reactive.effect\n@reactive.event(input.sort)\nasync def update_sort():\n    await df.update_sort([{\"col\": 0, \"desc\": False}])\n\nui.input_action_button(\"sort\", \"Sort on column 0‚Üë\")\n\n\n\n\nLearn more\nFor a comprehensive overview of new and old data frame features, see the updated articles on DataGrid and DataTable."
  },
  {
    "objectID": "blog/posts/shiny-python-1.0/index.html#multimedia-components",
    "href": "blog/posts/shiny-python-1.0/index.html#multimedia-components",
    "title": "Announcing Shiny for Python 1.0",
    "section": "Multimedia components",
    "text": "Multimedia components\nA couple of months ago, a couple of our developers had the privilege of joining one of our favorite data science YouTubers, Tina Huang, on one of her livestreams. Tina challenged us to livecode a Shiny app that provides a video assistant chat UI backed by GPT-4o, like a basic version of the widely viewed OpenAI demo that had just dropped.\nSpoiler: we were fairly successful, and you can experience the result in this live demo.\nOur assistant app takes webcam video as input, and plays audio as output. To make this a nice polished experience, we created a pair of Shiny-enabled web components to serve as input/output:\n\ninput_video_clip(): A video preview of your webcam, with a button that lets you start/stop recording, and a settings menu that lets you choose the camera/microphone.\naudio_spinner(): An audio player than spins and pulses in sync with the audio signal.\n\n\n\n\nThese components are now available in a standalone package called shinymedia. They‚Äôre designed to be super easy to drop into your Shiny for Python app, no different than any input/output component that comes with Shiny.\nAs for the livestream, we had a lot of fun and the feedback was great from everyone in the audience. It‚Äôs astonishing how easy this app was to build, once we had the right widgets. If you‚Äôre at all interested in building AI apps with Shiny, be sure to check out the recording!"
  },
  {
    "objectID": "blog/posts/shiny-python-1.0/index.html#modules-for-express",
    "href": "blog/posts/shiny-python-1.0/index.html#modules-for-express",
    "title": "Announcing Shiny for Python 1.0",
    "section": "Modules for Express",
    "text": "Modules for Express\nWhen it comes to building more complicated Shiny applications, some of the most useful tools at your disposal are Shiny modules. You can use Shiny modules to build components that abstract away complexity and can be reused in your applications.\nShiny Express now has support for using Shiny modules, and you can even create Shiny modules using Express syntax. To learn more, see our documentation on Shiny modules."
  },
  {
    "objectID": "blog/posts/shiny-python-1.0/index.html#use-bootswatch-themes-with-shinyswatch",
    "href": "blog/posts/shiny-python-1.0/index.html#use-bootswatch-themes-with-shinyswatch",
    "title": "Announcing Shiny for Python 1.0",
    "section": "Use Bootswatch themes with shinyswatch",
    "text": "Use Bootswatch themes with shinyswatch\n\n\n\nWe‚Äôre also happy to announce the release of shinyswatch v0.7.0. shinyswatch brings Bootswatch themes to Shiny for Python, allowing you to customize the appearance of your Shiny apps with a variety of themes.\n\n\n\nWe‚Äôre thrilled to bring you these new features and improvements in Shiny for Python 1.0. As always, if you have any questions or feedback, please join us on Discord or open an issue on GitHub. Happy Shiny-ing!"
  },
  {
    "objectID": "blog/posts/shiny-python-general-availability/index.html",
    "href": "blog/posts/shiny-python-general-availability/index.html",
    "title": "Shiny for Python out of alpha",
    "section": "",
    "text": "We are thrilled to announce that Shiny for Python has moved from the alpha stage to general availability. With Shiny for Python, data scientists can build interactive web applications with the expressiveness and power of reactive programming, and combine that with the extensive array of data analysis tools and visualization libraries in Python.\nWe believe that Shiny for Python strikes the perfect balance between simplicity and power. Unlike Streamlit, Shiny is not constrained by the top-to-bottom computing model, and there‚Äôs no limit to how sophisticated your applications can be. Compared to Dash, Shiny is more developer-friendly and boasts a more efficient reactive programming model."
  },
  {
    "objectID": "blog/posts/shiny-python-general-availability/index.html#what-does-it-mean-to-be-out-of-alpha",
    "href": "blog/posts/shiny-python-general-availability/index.html#what-does-it-mean-to-be-out-of-alpha",
    "title": "Shiny for Python out of alpha",
    "section": "What does it mean to be out of Alpha?",
    "text": "What does it mean to be out of Alpha?\nWhen we first introduced Shiny for Python at rstudio::conf last year, we labeled it as an alpha version, acknowledging that we could learn from early users and make changes to the API. After gaining ample experience and feedback, we‚Äôre now confident that Shiny for Python is ready for production work.\nWe‚Äôve gotten some great feedback during the alpha phase of the project, leading to several enhancements:\n\nWe‚Äôve added a quickstart guide for R users.\nYou can now interact with plots created using matplotlib, seaborn, and plotnine. (Example)\nWe‚Äôve improved the API documentation.\nWe‚Äôve created a new package, shinyswatch, which lets you modify an app‚Äôs visual style with a single line of code. (Example)\nWe released shinywidgets, which makes it possible to use Jupyter widgets in a Shiny app, including Plotly and maps with Leaflet."
  },
  {
    "objectID": "blog/posts/shiny-python-general-availability/index.html#get-started",
    "href": "blog/posts/shiny-python-general-availability/index.html#get-started",
    "title": "Shiny for Python out of alpha",
    "section": "Get started",
    "text": "Get started\nIf you want to learn more Shiny for Python check out the web site and live examples.\nIf you‚Äôre a Shiny for R user who‚Äôs curious about learning Shiny for Python, read our Quickstart guide!"
  },
  {
    "objectID": "blog/posts/the-past-and-future-of-shiny-joe-cheng/index.html",
    "href": "blog/posts/the-past-and-future-of-shiny-joe-cheng/index.html",
    "title": "The Past and Future of Shiny",
    "section": "",
    "text": "Shiny is a package that makes it easy to create interactive web apps using R and Python. It‚Äôs hard to believe, but this past summer Shiny turned 10! At rstudio::conf 2022, I shared some stories about its creation, the conditions that have made it a success over the years, and our plans for the near future."
  },
  {
    "objectID": "blog/posts/weather-lookup-bslib/index.html#weather-app",
    "href": "blog/posts/weather-lookup-bslib/index.html#weather-app",
    "title": "Weather App Story Pt. 3: Styling",
    "section": "Weather App",
    "text": "Weather App\nThe code and results in this post come from the weather lookup app. Here we will just briefly cover the relevant parts of the app, for a more complete intro check out the accompanying post introducing it.\n\n\nScreenshot of the weather lookup app."
  },
  {
    "objectID": "blog/posts/weather-lookup-bslib/index.html#why-theme-your-app",
    "href": "blog/posts/weather-lookup-bslib/index.html#why-theme-your-app",
    "title": "Weather App Story Pt. 3: Styling",
    "section": "Why theme your app?",
    "text": "Why theme your app?\nWe‚Äôve come a long way from the early days of the web, where pages all looked relatively the same and customizing your website was almost impossible. Almost any user-interface you can dream up can be constructed with modern HTML, CSS, and Javascript. A well-designed and aesthetically pleasing app is a more memorable experience and helps the user know time and care was put into building it.\n\n\n&lt;img src = \"app_wo_theme.png\"/&gt;\n&lt;p&gt;With default bootstrap theme &lt;/p&gt;\n\n\n&lt;img src = \"app_w_theme.png\"/&gt;\n&lt;p&gt;With 'cerulean' theme&lt;/p&gt;"
  },
  {
    "objectID": "blog/posts/weather-lookup-bslib/index.html#using-bslib-to-set-main-theme-of-app-with-bootswatch",
    "href": "blog/posts/weather-lookup-bslib/index.html#using-bslib-to-set-main-theme-of-app-with-bootswatch",
    "title": "Weather App Story Pt. 3: Styling",
    "section": "Using bslib to set main theme of app with bootswatch",
    "text": "Using bslib to set main theme of app with bootswatch\nUnfortunately, while modern CSS and HTML allow you to create beautiful designs, flexibility comes with complexity. As a Shiny developer, it‚Äôs a lot to ask to not only build a useful app functionality but also wrestle with the CSS to make that app look the way you want it. The new package bslib abstracts away this complexity and makes getting a beautiful app up and running just a few lines of R code.\nAll we need to do to transform our app, as seen above, is create a theme object with bs_theme() and pass that to the theme argument in our UI function. While we‚Äôre at it, we can also use a custom font from Google Fonts. I‚Äôm partial to ‚ÄúRighteous.‚Äù\n\n\napp.R\n\nlibrary(bslib)\nlibrary(showtext) # Needed for custom font support\n# Setup the bslib theme object\nmy_theme &lt;- bs_theme(bootswatch = \"cerulean\",\n                     base_font = font_google(\"Righteous\"))\n\nui &lt;- fluidPage(\n  # Pass that theme object to UI function\n  theme = my_theme,\n  ...\n)\n...\n\nOne thing to note is that if you want the custom fonts to work, you‚Äôll need to have the showtext package installed. One deployment servers that automatically determine the packages needed for your app this means you‚Äôll need to include library(showtext) within your app to let the server know to install it when building your app‚Äôs bundle."
  },
  {
    "objectID": "blog/posts/weather-lookup-bslib/index.html#using-thematic-to-style-your-plots-like-your-app",
    "href": "blog/posts/weather-lookup-bslib/index.html#using-thematic-to-style-your-plots-like-your-app",
    "title": "Weather App Story Pt. 3: Styling",
    "section": "Using thematic to style your plots like your app",
    "text": "Using thematic to style your plots like your app\nWhile bslib makes styling the HTML of your app super easy, what about plots included in your app? In the weather app, we use ggplot2 to build the main plot. There are many customization options to style your ggplot, but the process is very different from styling HTML using CSS.\nThis is where bslib‚Äôs sister package, thematic, comes to the rescue. The purpose of thematic is to automatically style your plots (both base and ggplot2) to match their context. That context may be your current RStudio theme, an RMarkdown document, or a Shiny app.\nAll that‚Äôs needed to enable this themeing is adding thematic_shiny() to our app‚Ä¶ Note that we‚Äôre using the theme ‚Äúdarkly‚Äù here so difference is more obvious.\n\n\napp.R\n\nlibrary(bslib)\nlibrary(showtext)\nlibrary(thematic)\n# Setup the bslib theme object\nmy_theme &lt;- bs_theme(bootswatch = \"darkly\",\n                     base_font = font_google(\"Righteous\"))\n\n# Let thematic know to update the fonts, too\nthematic_shiny(font = \"auto\")\n\nui &lt;- fluidPage(\n  # Pass that theme object to UI function\n  theme = my_theme,\n  ...\n)\n...\n\n\n\n&lt;img src = \"plot_wo_theme.png\"/&gt;\n&lt;p&gt;Default plot appearance with 'darkly' theme&lt;/p&gt;\n\n\n&lt;img src = \"plot_w_theme.png\"/&gt;\n&lt;p&gt;Plot after thematic&lt;/p&gt;\n\n\nJust like that, our plot matches the theme of our app. Note the use of font = \"auto\" in thematic_shiny(); this is important if you want to use the same fonts in your plot as on your page. (If you‚Äôve ever done this manually, you know how much work this just saved us.)"
  },
  {
    "objectID": "blog/posts/weather-lookup-bslib/index.html#using-bslib-theming-variables-on-custom-elements",
    "href": "blog/posts/weather-lookup-bslib/index.html#using-bslib-theming-variables-on-custom-elements",
    "title": "Weather App Story Pt. 3: Styling",
    "section": "Using bslib theming variables on custom elements",
    "text": "Using bslib theming variables on custom elements\nbslib builds its custom themes using the sass CSS-preprocessing library thanks to the sass R package. sass is designed to make building large-scale app styles easier by giving CSS things like variables that can be shared between styles, such as the color of a button. These variables make it easy to make large-scale changes to your app‚Äôs theme by updating a variable, like background-color, without having to find and update every instance of a hard-coded hex color.\nAnother powerful side-effect of bslib‚Äôs use of sass variables is you can use those variables to ensure any bespoke you write elements match the rest of the app‚Äôs theme. (See the Custom Components article for more on this.) In our app, we will do this to make the style of the current station info bubbles reflect match our current bootswatch theme.\n\n\n\nTo do this, we write Sass rules for the station bubbles that reference relevant Bootstrap Sass theming variables.\n\n\nstyles.scss\n\n...\n/* Make station bubble cards respect the colors of the theme */\n.station_bubble {\n  border: $border-width solid $border-color;\n  background: $secondary;\n}\n/* Make station bubble cards respect the colors of the theme */\n.station_bubble &gt; a {\n  @extend .bg-secondary;\n}\n...\n\nThe @extend .bg-secondary line tells Sass to essentially copy and paste the styles from the bg-secondary class into our links. This allows the colors of the text inside our station bubbles to match the text inside buttons.\nThis styles file can then be appended to our bslib theme object we built before using the bs_add_rules() function.\n\n\napp.R\n\n...\n# Setup the bslib theme object with extra custom styles\nmy_theme &lt;- bs_theme(bootswatch = \"darkly\",\n                     base_font = font_google(\"Righteous\")) %&gt;%\n  bs_add_rules(sass::sass_file(\"styles.scss\"))\n...\n\nNow, bslib will use sass to automatically process your styles and convert them to the appropriate CSS. Again, we‚Äôre using the ‚Äúdarkly‚Äù theme here, so this difference is more pronounced.\n\n\n\nIf we go back to the ‚Äúcerulean‚Äù theme, we can see that the station bubbles change again to match:\n\n\n\nSince the \"darkly\" theme customized its colors using the styling variables $white, $secondary (among others), our station bubbles automatically get updated to match. This is way nicer than manually going through and changing the styles anytime you decide you want a new theme. (There are a lot of theming variables available, to see them all check out the list of theming variables on the bslib site.)\nThis auto-magic updating of styling is crucial when we start using one of bslib‚Äôs more exciting features: updating a running app‚Äôs theme."
  },
  {
    "objectID": "blog/posts/weather-lookup-bslib/index.html#setting-up-a-dark-mode-option-with-dynamic-theming",
    "href": "blog/posts/weather-lookup-bslib/index.html#setting-up-a-dark-mode-option-with-dynamic-theming",
    "title": "Weather App Story Pt. 3: Styling",
    "section": "Setting up a dark-mode option with dynamic theming",
    "text": "Setting up a dark-mode option with dynamic theming\nOur app‚Äôs custom styles already make it look bespoke and interesting. However, what if we wanted to let our users choose what theme they desire so they can have a ‚Äúpersonalized‚Äù app? This functionality is made relatively easy thanks to the new function in Shiny: session$setCurrentTheme(). This function essentially lets you swap out whatever theme you want, just like you would pass the theme argument in your ui function, except now, you can do it in real-time. We can use this to add a ‚Äúdark-mode‚Äù toggle to flip our app between light (\"cerulean\") and dark (\"darkly\") modes.\nAll we have to do is create a theme toggle with the radioButtons input and pass the current choice to session$setCurrentTheme() within an observer‚Ä¶\n\n\napp.R\n\n\nui &lt;- fluidPage(\n  theme = my_theme,\n  ...\n  radioButtons(\"current_theme\", \"App Theme:\", c(\"Light\" = \"cerulean\", \"Dark\" = \"darkly\")),\n  ...\n  ),\n  ...\n)\n...\n\nserver &lt;- function(input, output, session){\n  ...\n  observe({\n    # Make sure theme is kept current with desired\n    session$setCurrentTheme(\n      bs_theme_update(my_theme, bootswatch = input$current_theme)\n    )\n  })\n}\n...\n\nNow, once the user selects a different value for the theme, our observer automatically updates the theme for us.\n\nWhile this is a simple example, there are many potential paths one could take with dynamic theming. For instance, the app could change based on the current weather to a ‚Äúcold‚Äù or ‚Äúhot‚Äù theme, or a dashboard could set its entire style to an ‚Äúalert‚Äù mode if some event needing attention occurred in the data being displayed.\n\nA note on caching and dynamic themeing\nIf you read the companion article to this on using caching in our app, you know the main plot is cached. We need to add the current theme to the cache key; otherwise, a plot for a city originally rendered in light mode may be given even though the current viewer is in dark mode. To do this, we can add info on the plot‚Äôs style, provided by getCurrentOutputInfo()$fg() to the cache key.\n\n\napp.R\n\n... %&gt;% \n  bindCache(input$city, getCurrentOutputInfo()$fg(), ...)\n\nThis additional cache key term means that, for any city, two plots can be cached: one for the light mode and another for the dark mode. For best performance you‚Äôll want to make sure you‚Äôre on the latest version of Shiny by installing from github with remotes::install_github(\"rstudio/shiny\")."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Here is a Shiny app",
    "section": "",
    "text": "Easy web apps for data science without the compromises\n\nNo web development skills required\n\n\nGet started in RGet started in Python\n\n\n\n\n\n\n\n\nHere is a Shiny app\nShiny apps are easy to write. Let users interact with your data and your analysis, all with R or Python:\n\n\n\nR\n\n\n\n\nPython\n\n\n\n\n\n\n\n\n\napp.R\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggExtra)\n\npenguins_csv &lt;- \"https://raw.githubusercontent.com/jcheng5/simplepenguins.R/main/penguins.csv\"\n\ndf &lt;- readr::read_csv(penguins_csv)\n# Find subset of columns that are suitable for scatter plot\ndf_num &lt;- df |&gt; select(where(is.numeric), -Year)\n\nui &lt;- page_sidebar(\n  sidebar = sidebar(\n    varSelectInput(\"xvar\", \"X variable\", df_num, selected = \"Bill Length (mm)\"),\n    varSelectInput(\"yvar\", \"Y variable\", df_num, selected = \"Bill Depth (mm)\"),\n    checkboxGroupInput(\n      \"species\", \"Filter by species\",\n      choices = unique(df$Species), \n      selected = unique(df$Species)\n    ),\n    hr(), # Add a horizontal rule\n    checkboxInput(\"by_species\", \"Show species\", TRUE),\n    checkboxInput(\"show_margins\", \"Show marginal plots\", TRUE),\n    checkboxInput(\"smooth\", \"Add smoother\"),\n  ),\n  plotOutput(\"scatter\")\n)\n\nserver &lt;- function(input, output, session) {\n  subsetted &lt;- reactive({\n    req(input$species)\n    df |&gt; filter(Species %in% input$species)\n  })\n\n  output$scatter &lt;- renderPlot({\n    p &lt;- ggplot(subsetted(), aes(!!input$xvar, !!input$yvar)) + list(\n      theme(legend.position = \"bottom\"),\n      if (input$by_species) aes(color = Species),\n      geom_point(),\n      if (input$smooth) geom_smooth()\n    )\n\n    if (input$show_margins) {\n      margin_type &lt;- if (input$by_species) \"density\" else \"histogram\"\n      p &lt;- ggExtra::ggMarginal(p, type = margin_type, margins = \"both\",\n        size = 8, groupColour = input$by_species, groupFill = input$by_species)\n    }\n\n    p\n  }, res = 100)\n}\n\nshinyApp(ui, server)\n\n\n\n\n\n\n\n\n\n\n\n\n\napp.py\n\nfrom pathlib import Path\n\nimport pandas as pd\nimport seaborn as sns\n\nfrom shiny import App, Inputs, Outputs, Session, reactive, render, req, ui\n\nsns.set_theme()\n\n# https://raw.githubusercontent.com/jcheng5/simplepenguins.R/main/penguins.csv\n\ndf = pd.read_csv(Path(__file__).parent / \"penguins.csv\", na_values=\"NA\")\nnumeric_cols = df.select_dtypes(include=[\"float64\"]).columns.tolist()\nspecies = df[\"Species\"].unique().tolist()\nspecies.sort()\n\napp_ui = ui.page_sidebar(\n    ui.sidebar(\n        ui.input_selectize(\n            \"xvar\", \"X variable\", numeric_cols, selected=\"Bill Length (mm)\"\n        ),\n        ui.input_selectize(\n            \"yvar\", \"Y variable\", numeric_cols, selected=\"Bill Depth (mm)\"\n        ),\n        ui.input_checkbox_group(\n            \"species\", \"Filter by species\", species, selected=species\n        ),\n        ui.hr(),\n        ui.input_switch(\"by_species\", \"Show species\", value=True),\n        ui.input_switch(\"show_margins\", \"Show marginal plots\", value=True),\n    ),\n    ui.card(\n        ui.output_plot(\"scatter\"),\n    ),\n)\n\n\ndef server(input: Inputs, output: Outputs, session: Session):\n    @reactive.Calc\n    def filtered_df() -&gt; pd.DataFrame:\n        \"\"\"Returns a Pandas data frame that includes only the desired rows\"\"\"\n\n        # This calculation \"req\"uires that at least one species is selected\n        req(len(input.species()) &gt; 0)\n\n        # Filter the rows so we only include the desired species\n        return df[df[\"Species\"].isin(input.species())]\n\n    @output\n    @render.plot\n    def scatter():\n        \"\"\"Generates a plot for Shiny to display to the user\"\"\"\n\n        # The plotting function to use depends on whether margins are desired\n        plotfunc = sns.jointplot if input.show_margins() else sns.scatterplot\n\n        plotfunc(\n            data=filtered_df(),\n            x=input.xvar(),\n            y=input.yvar(),\n            hue=\"Species\" if input.by_species() else None,\n            hue_order=species,\n            legend=False,\n        )\n\n\napp = App(app_ui, server)\n\n\n\n\n\n\n\n\n\n\n\nGet started in RGet started in Python\n\n\n\nHosting and Deployment\nPut your Shiny app on the web by using your own servers or Posit‚Äôs hosting service.\n\nDeploy for R Deploy for Python \n\n\n\nOrganizations that use Shiny:"
  },
  {
    "objectID": "r/articles/build/app-formats/index.html",
    "href": "r/articles/build/app-formats/index.html",
    "title": "App formats and launching apps",
    "section": "",
    "text": "You may have noticed that there are several different ways that Shiny apps are defined and launched. Sometimes you‚Äôll see the shinyServer() in the server.R file, sometimes not, and the same goes for shinyUI() in ui.R. Sometimes there isn‚Äôt even a server.R file at all.\nThis article provides an overview of the different ways of defining and launching Shiny applications.",
    "crumbs": [
      "Build",
      "Structure",
      "Standalone apps",
      "App formats and launching apps"
    ]
  },
  {
    "objectID": "r/articles/build/app-formats/index.html#server.r-and-ui.r",
    "href": "r/articles/build/app-formats/index.html#server.r-and-ui.r",
    "title": "App formats and launching apps",
    "section": "server.R and ui.R",
    "text": "server.R and ui.R\nMost early Shiny examples will include a server.R and ui.R file like the following:\n## server.R ##\nfunction(input, output) {\n  output$distPlot &lt;- renderPlot({\n    hist(rnorm(input$obs), col = 'darkgray', border = 'white')\n  })\n}\n## ui.R ##\nfluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"obs\", \"Number of observations:\", min = 10, max = 500, value = 100)\n    ),\n    mainPanel(plotOutput(\"distPlot\"))\n  )\n)\nFor applications defined this way, the server.R file must return the server function, and the ui.R file must return the UI object (in this case, the UI object is created by fluidPage()). In other words, if the files contained other code (like utility functions) you must make sure that the last expression in the file is the server function or UI object.\nFor more information, see the article about two-file apps.\n\n\nshinyServer() and shinyUI()\nPrior to Shiny 0.10, the server.R and ui.R files required calls to shinyServer() and shinyUI() respectively. Older Shiny application examples might look like the following. These are the same as in the previous example, except that the code is wrapped in shinyServer() and shinyUI():\n## server.R ##\nshinyServer(function(input, output) {\n  output$distPlot &lt;- renderPlot({\n    hist(rnorm(input$obs), col = 'darkgray', border = 'white')\n  })\n})\n## ui.R ##\nshinyUI(fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"obs\", \"Number of observations:\", min = 10, max = 500, value = 100)\n    ),\n    mainPanel(plotOutput(\"distPlot\"))\n  )\n))\nAs of Shiny 0.10, calling these functions is no longer needed.",
    "crumbs": [
      "Build",
      "Structure",
      "Standalone apps",
      "App formats and launching apps"
    ]
  },
  {
    "objectID": "r/articles/build/app-formats/index.html#app.r",
    "href": "r/articles/build/app-formats/index.html#app.r",
    "title": "App formats and launching apps",
    "section": "app.R",
    "text": "app.R\nAs of Shiny 0.10.2, applications can be created with a single file, app.R, which contains both the UI and server code. This file must return an object created by the shinyApp() function.\n## app.R ##\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlot({\n    hist(rnorm(input$obs), col = 'darkgray', border = 'white')\n  })\n}\n\nui &lt;- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"obs\", \"Number of observations:\", min = 10, max = 500, value = 100)\n    ),\n    mainPanel(plotOutput(\"distPlot\"))\n  )\n)\n\nshinyApp(ui = ui, server = server)\nThis method is more appropriate for smaller applications; for larger applications, you may find that having separate ui.R and server.R files makes your code easier to manage.",
    "crumbs": [
      "Build",
      "Structure",
      "Standalone apps",
      "App formats and launching apps"
    ]
  },
  {
    "objectID": "r/articles/build/app-formats/index.html#the-r-directory",
    "href": "r/articles/build/app-formats/index.html#the-r-directory",
    "title": "App formats and launching apps",
    "section": "The R/ directory",
    "text": "The R/ directory\n\n\nThis section describes features still in development and not available in the version of Shiny that is on CRAN. If you want to try these features, you‚Äôll need to install Shiny from GitHub using: remotes::install_github(\"rstudio/shiny\")\n\n\nAs of Shiny version 1.3.2.9001, any .R files found in an R/ directory adjacent to your app will be automatically loaded when your app starts. Just like R packages, only the files at the top level of R/ are considered; nested directories are ignored. Files in this directory are sourced in alphabetical order and any variables, functions, or modules they create are available to be used in your app.R, ui.R, or server.R files.\n\nDisable automatic loading of R/\nIn order to disable automatically loading the .R files in the R/ directory, there are two options:\n\nPlace a file named _disable_autoload.R in the R/ directory, or\nSet options(shiny.autoload.r = FALSE). Note that this option will apply to the duration of the R session which could impact subsequent applications that run in this session. To undo this setting, run options(shiny.autoload.r = NULL).\n\n\n\nExample using the R/ directory\nBelow is an example of moving the module descibed in the modules article to a supplemental R file.\n## R/counter.R ##\ncounterButton &lt;- function(id, label = \"Counter\") {\n  ns &lt;- NS(id)\n  tagList(\n    actionButton(ns(\"button\"), label = label),\n    verbatimTextOutput(ns(\"out\"))\n  )\n}\n\ncounter &lt;- function(input, output, session) {\n  count &lt;- reactiveVal(0)\n  observeEvent(input$button, {\n    count(count() + 1)\n  })\n  output$out &lt;- renderText({\n    count()\n  })\n  count\n}\n## server.R ##\nfunction(input, output, session) {\n  callModule(counter, \"counter1\")\n}\n## ui.R ##\nfluidPage(\n  counterButton(\"counter1\", \"Counter #1\")\n)\nNotice above that the supplemental R file is nested inside of the R/ directory and that no source() calls are needed; the file was loaded automatically and was available to both the ui and server.",
    "crumbs": [
      "Build",
      "Structure",
      "Standalone apps",
      "App formats and launching apps"
    ]
  },
  {
    "objectID": "r/articles/build/app-formats/index.html#session-and-clientdata",
    "href": "r/articles/build/app-formats/index.html#session-and-clientdata",
    "title": "App formats and launching apps",
    "section": "session and clientData",
    "text": "session and clientData\nIn the server code for some examples, you might see code like this:\nfunction(input, output) { .... }\nIn other examples, you might session as a third argument to the server function:\nfunction(input, output, session) { .... }\nThe session argument is optional. It‚Äôs only needed if you want to use advanced features of Shiny ‚Äì some functions in Shiny take the session variable as an argument.\nYou may also see some older examples that take clientData as an argument to the server function. clientData provides information about the connection and the visibility of various components on the web page (see the client data article for more).\nHowever, it is no longer necessary to use clientData as an argument, because if you have session, you can access the same information client data with session$clientData. For the sake of consistency, we recommend using session$clientData:\n# These two server functions do the same thing\n\n# Using the clientData argument directly (older examples)\nfunction(input, output, clientData) {\n  output$txt &lt;- renderPrint({\n    clientData\n  })\n}\n\n# Using the session argument\nfunction(input, output, session) {\n  output$txt &lt;- renderPrint({\n    session$clientData\n  })\n}",
    "crumbs": [
      "Build",
      "Structure",
      "Standalone apps",
      "App formats and launching apps"
    ]
  },
  {
    "objectID": "r/articles/build/app-formats/index.html#ways-of-calling-runapp",
    "href": "r/articles/build/app-formats/index.html#ways-of-calling-runapp",
    "title": "App formats and launching apps",
    "section": "Ways of calling runApp()",
    "text": "Ways of calling runApp()\nThere are several different things that may be passed to runApp() to launch an application.\n\n\nApp directory\nIf your application resides in a directory myapp/, you could launch it with:\nrunApp(\"myapp\")\n\n\n\nShiny app object\nIf you‚Äôve created a Shiny app object at the console by calling shinyApp(), you can pass that app object to runApp():\n# Create app object (assume ui and server are defined above)\napp &lt;- shinyApp(ui, server)\n\nrunApp(app)\nAdditionally, if you simply type app at the console and press Enter, R will launch the app. This is because when you run code at the console, R will call print() on the return value, and for a Shiny app object, the print() method calls runApp() on the object. So you could do the following to launch the app:\napp &lt;- shinyApp(ui, server)\napp\n\n\n\nlist(ui, server)\nAnother way to launch an app is by giving runApp() a list with the ui and server components. This is an older style that predates the Shiny app object method above.\n# (Assume ui and server are defined above)\nrunApp(list(ui, server))",
    "crumbs": [
      "Build",
      "Structure",
      "Standalone apps",
      "App formats and launching apps"
    ]
  },
  {
    "objectID": "r/articles/build/building-outputs/index.html",
    "href": "r/articles/build/building-outputs/index.html",
    "title": "Build custom output objects",
    "section": "",
    "text": "Right out of the box, Shiny makes it easy to include plots, simple tables, and text as outputs in your application; but we imagine that you‚Äôll also want to display outputs that don‚Äôt fit into those categories. Perhaps you need an interactive choropleth map or a googleVis motion chart.\nSimilar to custom inputs, if you have some knowledge of HTML/CSS/JavaScript you can also build reusable, custom output components. And you can bundle up output components as R packages for other Shiny users to use.\n\nServer-Side Output Functions\nStart by deciding the kind of values your output component is going to receive from the user‚Äôs server side R code.\nWhatever value the user‚Äôs R code returns is going to need to somehow be turned into a JSON-compatible value (Shiny uses jsonlite to do the conversion). If the user‚Äôs code is naturally going to return something jsonlite-compatible¬†‚Äì like a character vector, a data frame, or even a list that contains atomic vectors¬†‚Äì then you can just direct the user to use a function on the server. However, if the output needs to undergo some other kind of transformation, then you‚Äôll need to write a wrapper function that your users will use instead (analogous to renderPlot or renderTable).\nFor example, if the user wants to output time series objects then you might create a renderTimeSeries function that knows how to translate ts objects to a simple list or data frame:\nrenderTimeSeries &lt;- function(expr, env=parent.frame(), quoted=FALSE) {\n    # Convert the expression + environment into a function\n    func &lt;- exprToFunction(expr, env, quoted)\n\n    function() {\n      val &lt;- func()\n      list(start = tsp(val)[1],\n           end = tsp(val)[2],\n           freq = tsp(val)[3],\n           data = as.vector(val))\n    }\n}\nwhich would then be used by the user like so:\noutput$timeSeries1 &lt;- renderTimeSeries({\n    ts(matrix(rnorm(300), 100, 3), start=c(1961, 1), frequency=12)\n})\n\n\nDesign Output Component Markup\nAt this point, we‚Äôre ready to design the HTML markup and write the JavaScript code for our output component.\nFor many components, you‚Äôll be able to have extremely simple HTML markup, something like this:\n&lt;div id=\"timeSeries1\" class=\"timeseries-output\"&gt;&lt;/div&gt;\nWe‚Äôll use the timeseries-output CSS class as an indicator that the element is one that we should bind to. When new output values for timeSeries1 come down from the server, we‚Äôll fill up the div with our visualization using JavaScript.\n\n\nWrite an Output Binding\nEach custom output component needs an output binding, an object you create that tells Shiny how to identify instances of your component and how to interact with them. (Note that each instance of the output component doesn‚Äôt need its own output binding object; rather, all instances of a particular type of output component share a single output binding object.)\nAn output binding object needs to have the following methods:\n\n\nfind(scope)\n\n\nGiven an HTML document or element (scope), find any descendant elements that are an instance of your component and return them as an array (or array-like object). The other input binding methods all take an el argument; that value will always be an element that was returned from find.\nA very common implementation is to use jQuery‚Äôs find method to identify elements with a specific class, for example:\nexampleInputBinding.find = function(scope) {\n  return $(scope).find(\".exampleComponentClass\");\n};\n\ngetId(el)\n\n\nReturn the Shiny input ID for the element el, or null if the element doesn‚Äôt have an ID and should therefore be ignored. The default implementation in Shiny.InputBinding reads the data-input-id attribute and falls back to the element‚Äôs id if not present.\n\nrenderValue(el, data)\n\n\nCalled when a new value that matches this element‚Äôs ID is received from the server. The function should render the data on the element. The type/shape of the data argument depends on the server logic that generated it; whatever value is returned from the R code is converted to JSON using the shiny:::toJSON function.\n\nrenderError(el, err)\n\n\nCalled when the server attempts to update the output value for this element, and an error occurs. The function should render the error on the element. err is an object with a message String property.\n\nclearError(el)\n\n\nIf the element el is currently displaying an error, clear it.\n\n\n\nRegister Output Binding\nOnce you‚Äôve created an output binding object, you need to tell Shiny to use it:\nShiny.outputBindings.register(exampleOutputBinding, \"yourname.exampleOutputBinding\");\nThe second argument is a string that uniquely identifies your output binding. At the moment it is unused but future features may depend on it.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Build custom output objects"
    ]
  },
  {
    "objectID": "r/articles/build/communicating-with-js/index.html",
    "href": "r/articles/build/communicating-with-js/index.html",
    "title": "Communicating with Shiny via JavaScript",
    "section": "",
    "text": "Shiny was designed with an emphasis on distinct input and output components in the UI. Inputs send values from the client to the server, and when the server has values for the client to display, they are received and rendered by outputs.\nBut sometimes, you may want some custom behavior in JavaScript that isn‚Äôt a natural fit for a custom input or output binding. Here are some examples:\nIn these cases, you can skip the machinery around input/output bindings, and more or less directly send messages back and forth between JavaScript and R.\nThis document describes:\nIn both cases, you‚Äôll also need to know how to package your JavaScript code with your Shiny app. See this article to learn about your options for doing that.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Communicating with Shiny via JavaScript"
    ]
  },
  {
    "objectID": "r/articles/build/communicating-with-js/index.html#from-javascript-to-r",
    "href": "r/articles/build/communicating-with-js/index.html#from-javascript-to-r",
    "title": "Communicating with Shiny via JavaScript",
    "section": "From JavaScript to R",
    "text": "From JavaScript to R\nCommunication from JavaScript to R works by setting a reactive input. While this is normally done using an input binding, you can skip all the ceremony and directly send a reactive input value to R with this JavaScript function:\nShiny.setInputValue(id, value);\nFor example, Shiny.setInputValue(\"foo\", \"bar\") will cause the server‚Äôs input$foo to be set to \"bar\". Either use this input value as part of your reactive expressions, output renderers, and observers; or use observeEvent(input$foo, { ‚Ä¶ }) to run arbitrary R code in response to the value.\nThe value can be anything that is JSON-encodable (don‚Äôt perform the encoding yourself‚Äîit will be done automatically by Shiny).\n(Note: if you have heard of a function called Shiny.onInputChange, that‚Äôs just an older, more confusing name for Shiny.setInputValue; the latter was introduced in Shiny v1.1. Despite never being officially documented or supported, Shiny.onInputChange was/is widely used and we‚Äôre not likely to remove it anytime soon, and its behavior is identical to Shiny.setInputValue.)\nThat‚Äôs all most app authors will ever need to know. But Shiny also provides two other features for more advanced use of Shiny.setInputValue that may occasionally be useful.\n\nValues vs.¬†Events\nBy default, Shiny assumes that your app only cares about the latest value of a reactive input. Shiny.setInputValue uses this assumption to perform two optimizations by default:\n\nSetting an input to the same value it already has, is a no-op.\nIf an input is set multiple times (with different values) before control returns to the JavaScript event loop, then only the most recent value will actually be sent to the server.\n\nIf your app just wants to calculate reactive expressions/outputs based on input$foo, then these optimizations are beneficial; any calculation that you perform on data that is outdated or unchanged is simply wasted effort.\nIf, on the other hand, you intend to use input$foo as an event that triggers observeEvent/eventReactive, then you don‚Äôt want these optimizations. If you‚Äôre using input$foo to provide notifications that, say, a button has been clicked, you don‚Äôt want Shiny to ‚Äúhelpfully‚Äù suppress some of those notifications in an effort to save you work. You want to be notified for every call of Shiny.setInputValue.\nAs of Shiny v1.1, you can opt out of the optimizations and have Shiny notify you of every set, by passing a priority: \"event\" option:\nShiny.setInputValue(\"foo\", \"bar\", {priority: \"event\"});\nThis will cause input$foo to notify any reactive objects that depend on it, whether its value has actually changed or not.\n\n\nCustom deserialization with input handlers\nWhen communicating between JavaScript and R, your data will be encoded from JS objects to JSON, and then on the server side, from JSON to R objects (via jsonlite::fromJSON). The data types in JSON don‚Äôt correspond one-to-one with the data types in R, so any attempt to decode JSON to R will inherently have to make some choices. (Should \"null\" be interpreted as NA or NULL? Is \"{a: [1,2], b: [3,4]}\" supposed to be a 2-by-2 matrix, a list of vectors, or a data frame?)\nIn the vast majority of cases, jsonlite::fromJSON will give you satisfactory results out of the box. But if you find a particular type of value isn‚Äôt being decoded into your preferred form, you can define an input handler to refine the values that come out of fromJSON before they‚Äôre set on the input object.\nAn input handler is simply a function that takes the result from fromJSON as an argument, and returns the value that should be used instead.\nFor example, let‚Äôs say that our JavaScript code wants to send a geographic point in latitude/longitude coordinates, like so:\nShiny.setInputValue(\"coord\", {lat: 42.348905, long: -71.0404567})\nWhen decoded into R by jsonlite::fromJSON, it becomes:\nlist(lat = 42.348905, long = -71.0404567)\nso that‚Äôs what you‚Äôll get when you read from input$coord. That‚Äôs OK, but it‚Äôd be even more convenient to turn it into a proper point using the sf package. Here‚Äôs a function that can perform that transformation:\nlibrary(sf)\nconvertToPoint &lt;- function(x, session, inputname) {\n  lat &lt;- x[[\"lat\"]]\n  long &lt;- x[[\"long\"]]\n\n  # Create the point object\n  point &lt;- st_sfc(st_point(long, lat))\n  # Set metadata indicating that the data is in lat/long\n  st_crs(point) &lt;- 4326\n\n  point\n}\nNote that the session and inputname parameters are mandatory, even if you don‚Äôt plan on using them.\nNext, we need to register this handler with Shiny using a type identifier. This is a string you provide that will uniquely identify your handler; stick to simple identifiers with alphanumeric characters, undercores, and periods. In our case, we‚Äôll call it \"sf_coord_point\":\nregisterInputHandler(\"sf_coord_point\", convertToPoint)\nInput handlers should only be registered once per R process. If you‚Äôre doing this for an R package, then your package‚Äôs .onLoad function would be a good place to do this.\nFinally, when sending a value from JavaScript, you need to tell Shiny that your intention is for the sf_coord_point handler to be used. You do this by adding type type identifier a suffix to your input name:\nShiny.setInputValue(\"coord:sf_coord_point\", {lat: lat, long: long});\nNow, input$coordinate will return a full featured sf point object instead of just a generic list object!",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Communicating with Shiny via JavaScript"
    ]
  },
  {
    "objectID": "r/articles/build/communicating-with-js/index.html#from-r-to-javascript",
    "href": "r/articles/build/communicating-with-js/index.html#from-r-to-javascript",
    "title": "Communicating with Shiny via JavaScript",
    "section": "From R to JavaScript",
    "text": "From R to JavaScript\nSending instructions from R to JavaScript is a bit different. Whereas communicating in the JavaScript-to-R direction piggybacks on the machinery for processing reactive inputs, the R-to-JavaScript direction does not have anything to do with reactive outputs, but instead has its own dedicated mechanism.\nMessages sent from R must be directed to a specific browser, i.e.¬†a specific session, so you send messages through a method on the session object:\nsession$sendCustomMessage(type, message)\nThe type is an identifier string that will help Shiny identify the correct JavaScript code to invoke when the message is received. As usual, it‚Äôs best to stick to simple identifiers with alphanumeric characters, undercores, and periods.\nThe message is any R object that can be encoded to JSON. Again, we use jsonlite for this, but Shiny passes specific options to jsonlite::toJSON; you can use shiny:::toJSON(x) (note the triple-colon!) to preview how your object will be converted to JSON.\nOn the JavaScript side, you need to register a function to receive messages of the given type:\nShiny.addCustomMessageHandler(type, function(message) {...});\nThe type string should match the value in the call to session$sendCustomMessage, and the function argument should implement whatever logic you want. The message parameter is for the JSON-decoded object that was sent from the server; you can change the parameter name to something that‚Äôs more meaningful for your data.\nHere‚Äôs a strange little example app that continuously sends rainbow colors from R to JavaScript, and uses the colors to update the background color:\nlibrary(shiny)\n\n# Make a palette of 40 colors\ncolors &lt;- rainbow(40, alpha = NULL)\n# Mirror the rainbow, so we cycle back and forth smoothly\ncolors &lt;- c(colors, rev(colors[c(-1, -40)]))\n\nui &lt;- fluidPage(\n  tags$head(\n    # Listen for background-color messages\n    tags$script(\"\n      Shiny.addCustomMessageHandler('background-color', function(color) {\n        document.body.style.backgroundColor = color;\n        document.body.innerText = color;\n      });\n    \"),\n    \n    # A little CSS never hurt anyone\n    tags$style(\"body { font-size: 40pt; text-align: center; }\")\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  pos &lt;- 0L\n\n  # Returns a hex color string, e.g. \"#FF0073\"\n  nextColor &lt;- function() {\n    # Choose the next color, wrapping around to the start if necessary\n    pos &lt;&lt;- (pos %% length(colors)) + 1L\n    colors[[pos]]\n  }\n  \n  observe({\n    # Send the next color to the browser\n    session$sendCustomMessage(\"background-color\", nextColor())\n\n    # Update the color every 100 milliseconds\n    invalidateLater(100)\n  })\n}\n\nshinyApp(ui, server)\nWhen calling session$sendCustomMessage, keep in mind that this is, in reactive-programming speak, a side effect, and therefore something that generally needs to be done in an observe or observeEvent rather than a reactive or eventReactive.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Communicating with Shiny via JavaScript"
    ]
  },
  {
    "objectID": "r/articles/build/dashboards/index.html",
    "href": "r/articles/build/dashboards/index.html",
    "title": "Dashboards",
    "section": "",
    "text": "You have two package options for building Shiny dashboards: flexdashboard and shinydashboard.",
    "crumbs": [
      "Build",
      "Structure",
      "Dashboards",
      "Dashboards"
    ]
  },
  {
    "objectID": "r/articles/build/dashboards/index.html#flexdashboard",
    "href": "r/articles/build/dashboards/index.html#flexdashboard",
    "title": "Dashboards",
    "section": "flexdashboard",
    "text": "flexdashboard\nEasy interactive dashboards for R that\n\nuse R Markdown to publish a group of related data visualizations as a dashboard,\nsupport a wide variety of components including htmlwidgets; base, lattice, and grid graphics; tabular data; gauges and value boxes; and text annotations,\nare flexible and easy to specify row and column-based layouts with intelligent re-sizing to fill the browser and adapted for display on mobile devices,\noffer storyboard layouts for presenting sequences of visualizations and related commentary, and\noptionally use Shiny to drive visualizations dynamically.\n\nSee documentation and demos on the flexdashboard homepage.",
    "crumbs": [
      "Build",
      "Structure",
      "Dashboards",
      "Dashboards"
    ]
  },
  {
    "objectID": "r/articles/build/dashboards/index.html#shinydashboard",
    "href": "r/articles/build/dashboards/index.html#shinydashboard",
    "title": "Dashboards",
    "section": "shinydashboard",
    "text": "shinydashboard\nSee documentation and demos on the shinydashboard homepage. Here, in addition to instructions for getting started, you can also browse example dashboards built with shinydashboard, along with their source code.",
    "crumbs": [
      "Build",
      "Structure",
      "Dashboards",
      "Dashboards"
    ]
  },
  {
    "objectID": "r/articles/build/dashboards/index.html#comparison-of-two-options",
    "href": "r/articles/build/dashboards/index.html#comparison-of-two-options",
    "title": "Dashboards",
    "section": "Comparison of two options",
    "text": "Comparison of two options\n\n\n\nflexdashboard\nshinydashboard\n\n\n\n\nR Markdown\nShiny UI code\n\n\nSuper easy\nNot quite as easy\n\n\nStatic or dynamic\nDynamic\n\n\nCSS flexbox layout\nBootstrap grid layout",
    "crumbs": [
      "Build",
      "Structure",
      "Dashboards",
      "Dashboards"
    ]
  },
  {
    "objectID": "r/articles/build/dashboards/index.html#learn-more",
    "href": "r/articles/build/dashboards/index.html#learn-more",
    "title": "Dashboards",
    "section": "Learn more",
    "text": "Learn more\nFor more on this topic, see the following resources:\n Dynamic dashboards with Shiny\n Building dashboards with Shiny tutorial\n Dashboards made easy",
    "crumbs": [
      "Build",
      "Structure",
      "Dashboards",
      "Dashboards"
    ]
  },
  {
    "objectID": "r/articles/build/display-modes/index.html",
    "href": "r/articles/build/display-modes/index.html",
    "title": "Display modes",
    "section": "",
    "text": "Shiny can display your apps in two different ways. Your app can appear in normal display mode, as pictured below.\nOr your app can appear in showcase mode. Showcase mode displays your app alongside the code that generates it; showcase mode also displays a title, author and description for your app.\nTo view an app in showcase mode, launch it with the argument display.mode = \"showcase\", e.g.\nApps can be set to open in showcase mode by default. If you would prefer to view such an app in normal mode, use the argument display.mode = \"normal\".\nShiny‚Äôs built in example apps will automatically open in showcase mode when you call runExample, e.g.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Display modes"
    ]
  },
  {
    "objectID": "r/articles/build/display-modes/index.html#showcase-mode-features",
    "href": "r/articles/build/display-modes/index.html#showcase-mode-features",
    "title": "Display modes",
    "section": "Showcase mode features",
    "text": "Showcase mode features\nWhen you display your app in showcase mode, Shiny presents the app along with\n\nthe R files in the app‚Äôs directory, placed in a shared tabset that your user can place next to the app, or below it. These files will always contain server.R and ui.R.\na title\nan author\na license\nexplanatory text\ncode highlighting\n\n\nCode highlighting\nShiny showcase will highlight lines of code in server.R as it runs them. The highlight will appear in yellow and fade out after a few moments. This helps reveal how Shiny creates reactivity; when your user manipulates an app, Shiny reruns parts of server.R to create updated output.\n\n\n\nCode highlighting",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Display modes"
    ]
  },
  {
    "objectID": "r/articles/build/display-modes/index.html#showcase-layout",
    "href": "r/articles/build/display-modes/index.html#showcase-layout",
    "title": "Display modes",
    "section": "Showcase layout",
    "text": "Showcase layout\nOnce an app is open, you can change its layout the buttons labelled show with app and show below. These will place the app‚Äôs R scripts either next to the app or below it. The app will automatically scale to fit nicely with the code in your browser window.\n\n\n\nShowcase layout",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Display modes"
    ]
  },
  {
    "objectID": "r/articles/build/display-modes/index.html#writing-for-showcase-mode",
    "href": "r/articles/build/display-modes/index.html#writing-for-showcase-mode",
    "title": "Display modes",
    "section": "Writing for Showcase mode",
    "text": "Writing for Showcase mode\nYou can provide information about your app that Shiny showcase will use by creating a DESCRIPTION file. The file should be written in plain text and contain Title, Author, and DisplayMode fields in Debian Control File (DCF) format. You can also include other optional fields, such as AuthorUrl, License, and Tags. The description file of Shiny‚Äôs built in 01_hello example is displayed below\nTitle: Hello Shiny!\nAuthor: RStudio, Inc.\nAuthorUrl: http://www.rstudio.com/\nLicense: GPL-3\nDisplayMode: Showcase\nTags: getting-started\nType: Shiny\nShiny will use the DisplayMode field to determine the default display mode for your app. If you set the field to Showcase, Shiny will open your app in showcase mode. If you set it to Normal, Shiny will open your app in Normal mode. Your users can override this default by using the display.mode argument of runApp.\nOnce you‚Äôve written your DESCRIPTION file, place it alongside the server.R and ui.R files in your app‚Äôs directory.\n\n\n\nDESCRIPTION\n\n\nYou can also create a readme file for your app. Shiny will display the text of the readme beneath the app in showcase mode. Write your readme in markdown and save it in your app directory as Readme.md. Shiny will automatically use any DESCRIPTION and Readme.md files that you place in your app.\n\n\n\nREADME\n\n\nHere‚Äôs an example of the short readme for 01_hello.\nThis small Shiny application demonstrates Shiny's automatic UI updates. Move the *Number of observations* slider and notice how the `renderPlot` expression is automatically re-evaluated when its dependant, `input$obs`, changes, causing a new distribution to be generated and the plot to be rendered.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Display modes"
    ]
  },
  {
    "objectID": "r/articles/build/display-modes/index.html#showcase-and-privacy",
    "href": "r/articles/build/display-modes/index.html#showcase-and-privacy",
    "title": "Display modes",
    "section": "Showcase and privacy",
    "text": "Showcase and privacy\nSome developers would prefer not to expose their code with showcase mode. That‚Äôs not a problem. Your users will not be able to turn on showcase mode unless you let them. It is impossible to force an app into Showcase mode unless (a) you manually launch the app in showcase mode, or (b) the DESCRIPTION file explicitly states that the app should be shown in showcase mode.\nHowever, it is possible for users to turn off showcase mode if they do not like it. A user can turn off showcase mode for an app if they add ?showcase=0 to the end of the app‚Äôs URL. This won‚Äôt affect how other users see the app.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Display modes"
    ]
  },
  {
    "objectID": "r/articles/build/dynamic-ui/index.html#dynamic-ui",
    "href": "r/articles/build/dynamic-ui/index.html#dynamic-ui",
    "title": "Build a dynamic UI that reacts to user input",
    "section": "Dynamic UI",
    "text": "Dynamic UI\nShiny apps are often more than just a fixed set of controls that affect a fixed set of outputs. Inputs may need to be shown or hidden depending on the state of another input, or input controls may need to be created on-the-fly in response to user input.\nShiny currently has four different approaches you can use to make your interfaces more dynamic. From easiest to most difficult, they are:\n\nThe conditionalPanel function, which is used in ui.R and wraps a set of UI elements that need to be dynamically shown/hidden.\nThe renderUI function, which is used in server.R in conjunction with the uiOutput function in ui.R, lets you generate calls to UI functions and make the results appear in a predetermined place in the UI.\nThe insertUI and removeUI functions, which are used in server.R and allow you to add and remove arbitrary chunks of UI code (all independent from one another), as many times as you want, whenever you want, wherever you want.\nUse JavaScript to modify the webpage directly.\n\nLet‚Äôs take a closer look at each approach.\n\nShowing and Hiding Controls With conditionalPanel\nconditionalPanel creates a panel that shows and hides its contents depending on the value of a JavaScript expression. Even if you don‚Äôt know any JavaScript, simple comparison or equality operations are extremely easy to do, as they look a lot like R (and many other programming languages).\nHere‚Äôs an example for adding an optional smoother to a ggplot, and choosing its smoothing method:\n# Partial example\ncheckboxInput(\"smooth\", \"Smooth\"),\nconditionalPanel(\n  condition = \"input.smooth == true\",\n  selectInput(\"smoothMethod\", \"Method\",\n              list(\"lm\", \"glm\", \"gam\", \"loess\", \"rlm\"))\n)\nIn this example, the select control for smoothMethod will appear only when the smooth checkbox is checked. Its condition is \"input.smooth == true\", which is a JavaScript expression that will be evaluated whenever any inputs/outputs change.\nThe condition can also use output values; they work in the same way (output.foo gives you the value of the output foo). If you have a situation where you wish you could use an R expression as your condition argument, you can create a reactive expression in the server function and assign it to a new output, then refer to that output in your condition expression. If you do this, make sure to also set outputOptions(output, [newOutputName], suspendWhenHidden = FALSE). (This is necessary because Shiny normally doesn‚Äôt send values to the browser for outputs that are hidden or not present in the UI. In this case, however, the browser does need to know the most up-to-date output value in order to correctly evaluate the condition of the contitionalPanel function - suspendWhenHidden = FALSE ensures this will happen.) For example:\nui &lt;- fluidPage(\n  selectInput(\"dataset\", \"Dataset\", c(\"diamonds\", \"rock\", \"pressure\", \"cars\")),\n  conditionalPanel( condition = \"output.nrows\",\n                    checkboxInput(\"headonly\", \"Only use first 1000 rows\"))\n)\nserver &lt;- function(input, output, session) {\n  datasetInput &lt;- reactive({\n    switch(input$dataset,\n           \"rock\" = rock,\n           \"pressure\" = pressure,\n           \"cars\" = cars)\n  })\n  \n  output$nrows &lt;- reactive({\n    nrow(datasetInput())\n  })\n  \n  outputOptions(output, \"nrows\", suspendWhenHidden = FALSE)  \n}\n\nshinyApp(ui, server)\nHowever, since this technique requires server-side calculation (which could take a long time, depending on what other reactive expressions are executing) we recommend that you avoid using output in your conditions unless absolutely necessary.\n\n\nCreating Controls On the Fly With renderUI\nSometimes it‚Äôs just not enough to show and hide a fixed set of controls. Imagine prompting the user for a latitude/longitude, then allowing the user to select from a checklist of cities within a certain radius. In this case, you can use the renderUI expression to dynamically create controls based on the user‚Äôs input.\n\nui.R\n# Partial example\nnumericInput(\"lat\", \"Latitude\"),\nnumericInput(\"long\", \"Longitude\"),\nuiOutput(\"cityControls\")\n\n\nserver.R\n# Partial example\noutput$cityControls &lt;- renderUI({\n  cities &lt;- getNearestCities(input$lat, input$long)\n  checkboxGroupInput(\"cities\", \"Choose Cities\", cities)\n})\nrenderUI works just like renderPlot, renderText, and the other output rendering functions you‚Äôve seen before, but it expects the expression it wraps to return an HTML tag (or a list of HTML tags, using tagList). These tags can include inputs and outputs.\nIn ui.R, use a uiOutput to tell Shiny where these controls should be rendered.\n\n\n\nAdding/removing UI with insertUI and removeUI\nHere‚Äôs a pretty simple example (also available here) of how one could use insertUI and removeUI to insert and remove text elements using a queue logic:\n\n\nYou might also want to check out this other app that demos how to insert and remove a few common shiny input objects. Finally, this app shows how to dynamically insert modules using insertUI.\n\ninsertUI\nThis function allows you to dynamically add an arbitrarily large UI object into your app, as many times as you want, whenever you want, wherever you want. Unlike renderUI, the UI generated with insertUI is not updatable as a whole: once it‚Äôs created, it stays there. Each new call to insertUI creates more UI objects, in addition to the ones already there (all independent from one another). To update a part of the UI (ex: an input object), you must use the appropriate render function or a customized reactive function.\nThis function is particulaly useful when you want to build up an arbitrary list of stuff in the app‚Äôs UI. For example: you may have some data, and based on some input from the user (clicking buttons, selecting checkboxes, etc), you want to create and display a new model each time. But you don‚Äôt want to simply overwrite the previous model; you want to leave them there and continue adding new ones, so that your user can see the differences between them. If this is what you want, it‚Äôs a lot easier to use insertUI instead of renderUI, because each call to √¨nsertUI creates a new DOM element, rather than updating an existing one. Besides, you also get the flexibility of when and where to insert your UI.\nHere‚Äôs a simple example:\nui &lt;- fluidPage(\n  actionButton(\"add\", \"Add UI\")\n)\n\nserver &lt;- function(input, output, session) {\n  observeEvent(input$add, {\n    insertUI(\n      selector = \"#add\",\n      where = \"afterEnd\",\n      ui = textInput(paste0(\"txt\", input$add),\n                     \"Insert some text\")\n    )\n  })\n}\n\nshinyApp(ui, server)\nThe selector argument determines the element relative to which your ui should be inserted (it must be a string s that is accepted by a jQuery $(s) call). Once that is determined, where refines the place to insert the ui by offering four options relative to the selector: ‚ÄúbeforeBegin‚Äù, ‚ÄúafterBegin‚Äù, ‚ÄúbeforeEnd‚Äù and ‚ÄúafterEnd‚Äù. The ui itself can be anything that you usually put inside your apps‚Äôs ui function. One other argument that may be good to know about, but is not demoed above, is multiple. In case your selector matches more than one element, multiple determines whether Shiny should insert the UI object relative to all matched elements or just relative to the first matched element (default).\nAs you can see, no special piece of code is needed inside the ui function for insertUI to work. However, you will probably always need to pair your use of insertUI with an observe/observeEvent that checks for some input change. This is necessary because, unlike the typical render functions, insertUI has no idea when it should be called (it takes no reactive dependencies).\nNote that, if you are inserting multiple elements in one call, you must wrap them in either a tagList() or a tags$div() (the latter option has the advantage that you can give it an id to make it easier to reference or remove it later on). If you want to insert raw html, use ui = HTML().\n\n\nremoveUI\nThis function allows you to remove any part of your UI. Once removeUI is executed on some element, it is gone forever. While it may be a particularly useful pattern to pair this with insertUI (to remove some UI you had previously inserted), there is no restriction on what you can use removeUI on. Any element that can be selected through a jQuery selector can be removed through this function.\nHere‚Äôs a simple example:\nui &lt;- fluidPage(\n  actionButton(\"rmv\", \"Remove UI\"),\n  textInput(\"txt\", \"This is no longer useful\")\n)\n\nserver &lt;- function(input, output, session) {\n  observeEvent(input$rmv, {\n    removeUI(\n      selector = \"div:has(&gt; #txt)\"\n    )\n  })\n}\n\nshinyApp(ui, server)\nAs with insertUI, you also have a selector argument. This time, however, the selector determines the element(s) themselves that you want to remove. If you want to remove a Shiny input or output, note that many of these are wrapped in divs, so you may need to use a somewhat complex selector (as is indeed the case in the example above). You can avoid this if you wrap the inputs/outputs that you want to be able to remove easily in a div with an id.\nYou also have a multiple argument (again, not demoed here): in case your selector matches more than one element, multiple determines whether Shiny should remove all the matched elements or just the first matched element (default).\n\n\n\nUse JavaScript to Modify the Page\nYou can use JavaScript/jQuery to modify the page directly. General instructions for doing so are outside the scope of this tutorial, except to mention an important additional requirement and provide a quick example. Each time you add new inputs/outputs to the DOM, or remove existing inputs/outputs from the DOM, you need to tell Shiny. Our current recommendation is:\n\nBefore making changes to the DOM that may include adding or removing Shiny inputs or outputs, call Shiny.unbindAll().\nAfter such changes, call Shiny.bindAll().\n\nIf you are adding or removing many inputs/outputs at once, it‚Äôs fine to call Shiny.unbindAll() once at the beginning and Shiny.bindAll() at the end¬†‚Äì it‚Äôs not necessary to put these calls around each individual addition or removal of inputs/outputs.\nHere‚Äôs a short example of both non-reactive and reactive DOM manipulation:",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Build a dynamic UI that reacts to user input"
    ]
  },
  {
    "objectID": "r/articles/build/dynamic-ui/index.html#learn-more",
    "href": "r/articles/build/dynamic-ui/index.html#learn-more",
    "title": "Build a dynamic UI that reacts to user input",
    "section": "Learn more",
    "text": "Learn more\nFor more on this topic, see the following resources:\n Dynamic Shiny interfaces",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Build a dynamic UI that reacts to user input"
    ]
  },
  {
    "objectID": "r/articles/build/gadget-ui/index.html",
    "href": "r/articles/build/gadget-ui/index.html",
    "title": "Designing Gadget UI",
    "section": "",
    "text": "Shiny 0.13 introduces the concept of Shiny Gadgets, which are Shiny apps that are designed to be used directly from the R console (or invoked as an RStudio Add-in) to provide helpful functionality while you‚Äôre analyzing data or coding.\nWhile technically, any kind of Shiny UI could be used for a Shiny Gadget, we‚Äôve created a miniUI package that we think is particularly well suited for Gadget use. We recommend that you start with miniUI based UI for your gadget, unless you have a specific reason not to.\nYou can install miniUI from GitHub using the devtools package:\nminiUI is inspired by the excellent Ratchet CSS library for mobile web apps.",
    "crumbs": [
      "Build",
      "Structure",
      "Gadgets",
      "Designing Gadget UI"
    ]
  },
  {
    "objectID": "r/articles/build/gadget-ui/index.html#learn-more",
    "href": "r/articles/build/gadget-ui/index.html#learn-more",
    "title": "Designing Gadget UI",
    "section": "Learn more",
    "text": "Learn more\nFor more on this topic, see the following resources:\n Shiny Gadgets: Interactive Tools\n Building interactive tools for exploratory data analysis",
    "crumbs": [
      "Build",
      "Structure",
      "Gadgets",
      "Designing Gadget UI"
    ]
  },
  {
    "objectID": "r/articles/build/google-analytics/index.html",
    "href": "r/articles/build/google-analytics/index.html",
    "title": "Add Google Analytics",
    "section": "",
    "text": "This article will show you how to add Google Analytics to a Shiny app. If you don‚Äôt know any JavaScript or jQuery, you can still add simple analytics by following the steps outlined in this article, but customizing the type of analytics you collect will require that you know a little about JavaScript and jQuery (which we will not teach here).\nGoogle Analytics is a free service offered by Google that collects information about who visits your website and what they do while they are there. You can learn more about Google Analytics at support.google.com/analytics, which explains how to set up and use Google Analytics with a web page.\nFrom time to time Google changes how they do content tracking. The following information is current as of August 2023. If you find that the information is out of date at any point, please let us know on RStudio Community.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Add Google Analytics"
    ]
  },
  {
    "objectID": "r/articles/build/google-analytics/index.html#add-analytics-to-an-app",
    "href": "r/articles/build/google-analytics/index.html#add-analytics-to-an-app",
    "title": "Add Google Analytics",
    "section": "Add analytics to an app",
    "text": "Add analytics to an app\nYou can use Google Analytics with a Shiny app, since Shiny apps are a type of web page. In this article, we will add Google Analytics to the Sunshine app, pictured below.\nThe Sunshine app displays the distribution of annual sunlight in the United States. The app is hosted on shinyapps.io at gallery.shinyapps.io/google-analytics. If you‚Äôd like a copy of the app, including its JavaScript and CSS files, you can find them here.\n\nYou can add analytics to the app (and collect results) with the five steps below.\n\nStep 1 - Create an account\nTo use Google Analytics, you must open a free account at google.com/analytics.\n\n\n\nStep 2 - Add a property\nNext, you must register your Shiny app as a property in your Google Analytics account. You can do this on the sign up page, or‚Äîif you already have a Google Analytics account‚Äîyou can do this in the Admin tab.\n\nYou will need to provide a web address for your app to Google Analytics. Since the Sunshine app is hosted at https://gallery.shinyapps.io/google-analytics, I‚Äôll use this address.\n\nOnce you have entered the necessary information, click ‚ÄúCreate‚Äù at the bottom of the form. Google Analytics will open a new window that contains a tracking ID number for your app as well as a short JavaScript script.\n\nThis script will allow Google Analytics to track traffic to and from your app. To use it, you‚Äôll need to put the script in the head of your app‚Äôs DOM, the subject of Step 3.\n\n\nStep 3 - Embed tracking script\nYou should place the Google Analytics tracking script at the end of the head section of the HTML DOM that describes your Shiny app.\nThis is very easy to do if you build your Shiny app around an HTML file, as described in Build your entire UI with HTML.\nIf you built your Shiny app with a app.R file (the traditional method), use the tags$head and includeHTML functions to include the script.\nFor example, Google Analytics has given us the script below to embed in the Sunshine app. Note that your Google tag will be different from ours, which starts with GT- and is used in two places below. The Google tag is an identifier for the content you created on Google Analytics.\n\n\ngoogle-analytics.html\n\n&lt;!-- Global site tag (gtag.js) - Google Analytics --&gt;\n&lt;script async src=\"https://www.googletagmanager.com/gtag/js?id=GT-XXXXXX\"&gt;&lt;/script&gt;\n&lt;script&gt;\n  window.dataLayer = window.dataLayer || [];\n  function gtag(){dataLayer.push(arguments);}\n  gtag('js', new Date());\n\n  gtag('config', 'GT-XXXXXX');\n&lt;/script&gt;\n\nTo include the script in your app, first save it to its own file. Here I‚Äôve saved the script as a file named google-analytics.html, which I have placed in the working directory of the Sunshine app.\n\nTo embed the script in the Sunshine app, call tags$head(includeScript(\"google-analytics.js\")) in the ui.R file. includeScript will import the script and pass it to tags$head(), which will place the script in the head section of your app‚Äôs DOM.\nincludeHTML requires one argument: \"google-analytics.html\", the file path from the App directory to the google-analytics.html file.\nThe final ui of my app will look like the following.\n\n\napp.R\n\nui &lt;- fluidPage(\n  tags$head(includeHTML(\"google-analytics.html\")),\n  includeCSS(\"cerulean.css\"),\n\n  titlePanel(\"Sunlight in the US\"),\n\n  helpText(\"Use this Shiny app to explore the distribution of sunlight in\n           the United States. The map can display three variables by state.\"),\n\n  br(),\n\n  selectInput(\"var\", \"Display\",\n    choices = c(\n      \"Percent of time sunny\" = \"sun_percent\",\n      \"Annual hours of sunshine\" = \"total_hours\",\n      \"Annual clear days\" = \"clear_days\"\n    )\n  ),\n\n  actionButton(\"update_plot\", \"Update Plot\"),\n\n  br(),\n\n  plotOutput(\"map\", width = \"90%\")\n)\n\nSince the app is hosted on shinyapps.io, I will need to redeploy the app to shinyapps.io for the new app.R file to take effect.\nThe Google Analytics script tracks how visitors move from one web page to the next. With it, you can learn a little about:\n\nwho visits your app\nwhere they come from\nhow long they stay on the app while they are there\n\nYou can also use Google Analytics to track how visitors use your app, but to do that you will need to set up specific event trackers.\n\n\nStep 4 - Create event trackers\nAn event tracker is a piece of code that notifies Google Analytics whenever a visitor interacts with a specific part of your app, such as a link or a widget. You create a separate event tracker for each unique event that you want to track.\nWith Google Analytics, you use the basic script to track how people move to and from your page, and you use event trackers to track what they do while they are there. Note that you will need to embed the basic Google Analytics tracking script into your app before you create any event trackers. Event trackers will not work without the basic script.\nTo create an event tracker, you arrange to have a web element‚Äôs event handler execute a simple JavaScript command that looks like this:\ngtag('event', 'action', { key: value });\nWhen the element executes the command, gtag sends an event notification to Google Analytics that lets Google Analytics know that an event occurred. The notification will contain the values of action and event data as a JavaScript object in the form key-value pairs. Later on, you will be able to see these values, as well as when the event occurred, from your Google Analytics dashboard.\nFor example, you can track when users click on a specific link by having the link‚Äôs onClick attribute call gtag:\n&lt;a href=\"http://www.example.com\"\n   onclick=\"tag('event', 'link', { action: 'click': label: 'IKnow' })\"&gt;\n   I know when you click me\n&lt;/a&gt;;\nThis works for tracking events on simple web elements, but you must use a different approach to track events on Shiny widgets.\nShiny does not let you set arbitrary attributes on widgets when you create them. To set an event tracker on a Shiny widget, you will need to identify and modify the widget after it has been created, which you can do with a jQuery script.\nFor example, the Sunshine app has two widgets: a select box and a button. I would like to track how users interact with each of the widgets. To do this I will need to create two event trackers, one for the select box widget and one for the button widget. I will also need to set these event trackers on the widgets with jQuery.\n\nThe following script attaches an event handler to the select box widget. The handler will execute for change events that occur on the widget. In other words, the tracker will notify Google Analytics whenever a visitor changes the value of the select box widget.\nI‚Äôve chosen to have the event report include ‚Äúwidget‚Äù for the category value and ‚Äúselect data‚Äù for the action value. The last argument will return the value of the new selection as the label argument. This tracker will not return a value value; value arguments are optional.\n$(document).on('change', 'select', function(e) {\n  gtag('event', 'widget', {\n    action: 'select data',\n    label: $(e.currentTarget).val()\n  });\n});\nI can track the app‚Äôs ‚ÄúUpdate Plot‚Äù button in a similar way. The script below will send an event notification whenever a user clicks on a button class object in the DOM, e.g.¬†the ‚ÄúUpdate Plot‚Äù button:\n$(document).on('click', 'button', function() {\n  gtag('event', 'button', { action: 'update plot' });\n});\nNote: to write effective jQuery code, you will need to be able to uniquely identify the widgets that you wish to track. This may require you to explore the document structure of the finished app, for example in your browser‚Äôs developer tools console.\nWhen working with Shiny apps, use jQuery code that creates delegated event handling, like the code above does. Delegated events work more nimbly with the dynamic nature of Shiny apps than do direct events.\nNow, that I‚Äôve written the code that will allow event tracking, I need to add it to the app.R file of the Sunshine app. The easiest way to do this is to include the code in the google-analytics.html file that gets added to the app‚Äôs head.\nMy final google-analytics.html file will look like this:\n\n\ngoogle-analytics.html\n\n&lt;!-- Global site tag (gtag.js) - Google Analytics --&gt;\n&lt;script async src=\"https://www.googletagmanager.com/gtag/js?id=GT-XXXXXX\"&gt;&lt;/script&gt;\n&lt;script&gt;\n  window.dataLayer = window.dataLayer || [];\n  function gtag(){dataLayer.push(arguments);}\n  gtag('js', new Date());\n\n  gtag('config', 'GT-XXXXXX');\n\n  $(document).on('change', 'select', function(e) {\n    gtag('event', 'widget', {\n      action: 'select data',\n      label: $(e.currentTarget).val()\n    });\n  });\n\n  $(document).on('click', 'button', function() {\n    gtag('event', 'button', { action: 'update plot' });\n  });\n&lt;/script&gt;\n\nI‚Äôll need to redeploy the app to https://shinyapps.io to make sure the hosted version of the app uses this code.\n\n\nStep 5 - Collect reports\nOnce you have set up your app to use Google Analytics, you can use your account portal as a dashboard to track traffic on your app. The Real-Time tracking features should begin almost immediately, but other tracking features may take a couple hours to a couple days before they start reporting results.\nYou can also extract and analyze traffic data from Google Analytics data with R. The googleAnalyticsR package has extensive documentation with some examples.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Add Google Analytics"
    ]
  },
  {
    "objectID": "r/articles/build/google-analytics/index.html#add-google-analytics-with-shiny-server-open-source-and-shiny-server-pro",
    "href": "r/articles/build/google-analytics/index.html#add-google-analytics-with-shiny-server-open-source-and-shiny-server-pro",
    "title": "Add Google Analytics",
    "section": "Add Google Analytics with Shiny Server Open Source and Shiny Server Pro",
    "text": "Add Google Analytics with Shiny Server Open Source and Shiny Server Pro\nAlternatively, you can use Shiny Server to add Google Analytics to your apps. This will let you manage your Google Analytics configuration at a higher level‚Äîso if you want all apps deployed on a server to share Google Analytics code, you could put this code at the top level of your config and all your apps would automatically inherit it. To learn more, visit the Shiny Server user guide.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Add Google Analytics"
    ]
  },
  {
    "objectID": "r/articles/build/google-analytics/index.html#recap",
    "href": "r/articles/build/google-analytics/index.html#recap",
    "title": "Add Google Analytics",
    "section": "Recap",
    "text": "Recap\nTo add Google Analytics to a Shiny app:\n\nSet up a Google Analytics account.\nAdd the Shiny app to the account as a web property.\nPlace the Google Analytics tracking script into the head section of your app‚Äôs DOM.\nCreate event trackers to track specific events within your app. The easiest way to do this is to modify Shiny widgets with delegated event handlers managed by jQuery.\nUse R or your Google Analytics dashboard to explore the results.\n\nGoogle Analytics isn‚Äôt the only website monitoring service, but it is the most popular. You can add similar services to your app with the same techniques.\nThese techniques serve as a proof of concept that will allow you to track how visitors use your apps. We will look to make it easier to track Shiny apps in future development.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Add Google Analytics"
    ]
  },
  {
    "objectID": "r/articles/build/html-ui/index.html",
    "href": "r/articles/build/html-ui/index.html",
    "title": "Build your entire UI with HTML",
    "section": "",
    "text": "The HTML UI application demonstrates defining a Shiny user interface using a standard HTML page rather than a UI object. To run the example type:",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Build your entire UI with HTML"
    ]
  },
  {
    "objectID": "r/articles/build/html-ui/index.html#learn-more",
    "href": "r/articles/build/html-ui/index.html#learn-more",
    "title": "Build your entire UI with HTML",
    "section": "Learn more",
    "text": "Learn more\nFor more on this topic, see the following resources:\n Shiny UI",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Build your entire UI with HTML"
    ]
  },
  {
    "objectID": "r/articles/build/images/index.html#sending-images",
    "href": "r/articles/build/images/index.html#sending-images",
    "title": "Render images in a Shiny app",
    "section": "Sending Images",
    "text": "Sending Images\nWhen you want to have R generate a plot and send it to the client browser, the renderPlot() function will in most cases do the job. But when you need finer control over the process, you might need to use the renderImage() function instead. This is demonstrated in the image output demo application.\n\nAbout renderPlot()\nrenderPlot() is useful for any time where R generates an image using its normal graphical device system. In other words, any plot-generating code that would normally go between png() and dev.off() can be used in renderPlot(). If the following code works from the console, then it should work in renderPlot():\npng()\n# Your plotting code here\ndev.off()\n# This would go in the server function\noutput$myPlot &lt;- renderPlot({\n  # Your plotting code here\n})\nrenderPlot() takes care of a number of details automatically: it will resize the image to fit the output window, and it will even increase the resolution of the output image when displaying on high-resolution (‚ÄúRetina‚Äù) screens.\nThe limitation to renderPlot() is that it won‚Äôt send just any image file to the browser ‚Äì the image must be generated by code that uses R‚Äôs graphical output device system. Other methods of creating images can‚Äôt be sent by renderPlot(). For example, the following won‚Äôt work:\n\nImage files generated by the writePNG() function from the png package.\nImage files generated by the rgl.snapshot() function, which creates images from 3D plots made with the rgl package.\nImages generated by an external program.\nPre-rendered images.\n\nThe solution in these cases is the renderImage() function.\n\n\nUsing renderImage()\nImage files can be sent using renderImage(). The expression that you pass to renderImage() must return a list containing an element named src, which is the path to the file. Here is a very basic example of a Shiny app with an output that generates a plot and sends it with renderImage():\nlibrary(shiny)\n\nui &lt;- pageWithSidebar(\n  headerPanel(\"renderImage example\"),\n  sidebarPanel(\n    sliderInput(\"obs\", \"Number of observations:\",\n                min = 0, max = 1000,  value = 500)\n  ),\n  mainPanel(\n    # Use imageOutput to place the image on the page\n    imageOutput(\"myImage\")\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  output$myImage &lt;- renderImage({\n    # A temp file to save the output.\n    # This file will be removed later by renderImage\n    outfile &lt;- tempfile(fileext = '.png')\n\n    # Generate the PNG\n    png(outfile, width = 400, height = 300)\n    hist(rnorm(input$obs), main = \"Generated in renderImage()\")\n    dev.off()\n\n    # Return a list containing the filename\n    list(src = outfile,\n         contentType = 'image/png',\n         width = 400,\n         height = 300,\n         alt = \"This is alternate text\")\n  }, deleteFile = TRUE)\n}\n\nshinyApp(ui, server)\nEach time this output object is re-executed, it creates a new PNG file, saves a plot to it, then returns a list containing the filename along with some other values.\nBecause the deleteFile argument is TRUE, Shiny will delete the file (specified by the src element) after it sends the data. This is appropriate for a case like this, where the image is created on-the-fly, but it wouldn‚Äôt be appropriate when, for example, your app sends pre-rendered images.\nIn this particular case, the image file is created with the png() function. But it just as well could have been created with writePNG() from the png package, or by any other method. If you have the filename of the image, you can send it with renderImage().\n\nStructure of the returned list\nThe list returned in the example above contains the following:\n\nsrc: The output file path.\ncontentType: The MIME type of the file. If this is missing, Shiny will try to autodetect the MIME type, from the file extension.\nwidth and height: The desired output size, in pixels.\nalt: Alternate text for the image.\n\nExcept for src and contentType, all values are passed through directly to the &lt;img&gt; DOM element on the web page. The effect is similar to having an image tag with the following:\n{% highlight xml %} \n\nNote that the `src=\"...\"` is shorthand for a longer URL. For browsers that support the [data URI scheme](http://en.wikipedia.org/wiki/Data_URI_scheme), the `src` and `contentType` from the returned list are put together to create a special URL that embeds the data, so the result would be similar to something like this:\n\n{% highlight xml %}\n&lt;img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAm0AAAGnCAYAAADlkGDxAAAACXBIWXMAAAsTAAALEwEAmpwYAAAgAElEQVR4nOydd3ic1ZX/P2+ZKmlU\" \n     width=\"400\" \n     height=\"300\" \n     alt=\"This is alternate text\"&gt;\nFor browsers that don‚Äôt support the data URI scheme, Shiny sends a URL that points to the file.\n\n\n\nSending pre-rendered images with renderImage()\nIf your Shiny app has pre-rendered images saved in a subdirectory, you can send them using renderImage(). Suppose the images are in the subdirectory images/, and are named image1.jpeg, image2.jpeg, and so on. The following server function would send the appropriate image, depending on the value of input$n:\nserver &lt;- function(input, output, session) {\n  # Send a pre-rendered image, and don't delete the image after sending it\n  output$preImage &lt;- renderImage({\n    # When input$n is 3, filename is ./images/image3.jpeg\n    filename &lt;- normalizePath(file.path('./images',\n                              paste('image', input$n, '.jpeg', sep='')))\n \n    # Return a list containing the filename and alt text\n    list(src = filename,\n         alt = paste(\"Image number\", input$n))\n\n  }, deleteFile = FALSE)\n}\nIn this example, deleteFile is FALSE because the images aren‚Äôt ephemeral; we don‚Äôt want Shiny to delete an image after sending it.\nNote that this might be less efficient than putting images in www/images and emitting HTML that points to the images, because in the latter case the image will be cached by the browser.\n\n\nUsing clientData values\nIn the first example above, the plot size was fixed at 400 by 300 pixels. For dynamic resizing, it‚Äôs possible to use values from session$clientData to detect the output size.\nIn the example below, the output object is output$myImage, and the width and height on the client browser are sent via session$clientData$output_myImage_width and session$clientData$output_myImage_height. This example also uses session$clientData$pixelratio to multiply the resolution of the image, so that it appears sharp on high-resolution (Retina) displays:\nserver &lt;- function(input, output, session) {\n\n  # A dynamically-sized plot\n  output$myImage &lt;- renderImage({\n    # Read myImage's width and height. These are reactive values, so this\n    # expression will re-run whenever they change.\n    width  &lt;- session$clientData$output_myImage_width\n    height &lt;- session$clientData$output_myImage_height\n\n    # For high-res displays, this will be greater than 1\n    pixelratio &lt;- session$clientData$pixelratio\n\n    # A temp file to save the output.\n    outfile &lt;- tempfile(fileext='.png')\n\n    # Generate the image file\n    png(outfile, width = width*pixelratio, height = height*pixelratio,\n        res = 72*pixelratio)\n    hist(rnorm(input$obs))\n    dev.off()\n\n    # Return a list containing the filename\n    list(src = outfile,\n         width = width,\n         height = height,\n         alt = \"This is alternate text\")\n  }, deleteFile = TRUE)\n\n  # This code reimplements many of the features of `renderPlot()`.\n  # The effect of this code is very similar to:\n  # renderPlot({\n  #   hist(rnorm(input$obs))\n  # })\n}\nThe width and height values passed to png() specify the pixel dimensions of the saved image. These can differ from the width and height values in the returned list: those values are the pixel dimensions to used display the image. For high-res displays (where pixelratio is 2), a ‚Äúvirtual‚Äù pixel in the browser might correspond to 2 x 2 physical pixels, and a double-resolution image will make use of each of the physical pixels.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Render images in a Shiny app"
    ]
  },
  {
    "objectID": "r/articles/build/isolation/index.html#isolation-avoiding-dependency",
    "href": "r/articles/build/isolation/index.html#isolation-avoiding-dependency",
    "title": "Stop reactions with isolate()",
    "section": "Isolation: avoiding dependency",
    "text": "Isolation: avoiding dependency\nSometimes it‚Äôs useful for an observer/endpoint to access a reactive value or expression, but not to take a dependency on it. For example, if the observer performs a long calculation or downloads large data set, you might want it to execute only when a button is clicked.\nFor this, we‚Äôll use actionButton. We‚Äôll define a UI that lets the user choose number of observations to generate from the normal distribution, and has an actionButton labeled ‚ÄúGo!‚Äù. You can see it in action here.\nThe actionButton includes some JavaScript code that sends numbers to the server. When the web browser first connects, it sends a value of 0, and on each click, it sends an incremented value: 1, 2, 3, and so on.\nui &lt;- pageWithSidebar(\n  headerPanel(\"Click the button\"),\n  sidebarPanel(\n    sliderInput(\"obs\", \"Number of observations:\",\n                min = 0, max = 1000, value = 500),\n    actionButton(\"goButton\", \"Go!\")\n  ),\n  mainPanel(\n    plotOutput(\"distPlot\")\n  )\n)\nIn our server function, there are two items to note. First, output$distPlot will take a dependency on input$goButton, simply by accessing it. When the button is clicked, the value of input$goButton increases, and so output$distPlot re-executes.\nThe second is that the access to input$obs is wrapped with isolate(). This function takes an R expression, and it tells Shiny that the calling observer or reactive expression should not take a dependency on any reactive objects inside the expression.\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlot({\n    \n    # Take a dependency on input$goButton\n    input$goButton\n\n    # Use isolate() to avoid dependency on input$obs\n    dist &lt;- isolate(rnorm(input$obs))\n    hist(dist)\n  })\n}\nThe resulting graph looks like this:\n\n\n\nIsolated reactive value\n\n\nAnd here‚Äôs a walkthrough of the process when input$obs is set to 1000, and then the Go button is clicked:\n\n\n\n\n\n\nIn the actionButton example, you might want to prevent it from returning a plot the first time, before the button has been clicked. Since the starting value of an actionButton is zero, this can be accomplished with the following:\n  output$distPlot &lt;- renderPlot({\n    if (input$goButton == 0)\n      return()\n\n    # plot-making code here\n  })\nReactive values are not the only things that can be isolated; reactive expressions can also be put inside an isolate(). Building off the Fibonacci example from above, this would calculate the _n_th value only when the button is clicked:\noutput$nthValue &lt;- renderText({\n  if (input$goButton == 0)\n    return()\n\n  isolate({ fib(as.numeric(input$n)) })\n})\nIt‚Äôs also possible to put multiple lines of code in isolate(). For example here are some blocks of code that have equivalent effect:\n# Separate calls to isolate -------------------------------\nx &lt;- isolate({ input$xSlider }) + 100\ny &lt;- isolate({ input$ySlider })  * 2\nz &lt;- x/y\n\n# Single call to isolate ----------------------------------\nisolate({\n  x &lt;- input$xSlider + 100\n  y &lt;- input$ySlider * 2\n  z &lt;- x/y\n})\n\n# Single call to isolate, use return value ----------------\nz &lt;- isolate({\n  x &lt;- input$xSlider + 100\n  y &lt;- input$ySlider * 2\n  x/y\n})\nIn all of these cases, the calling function won‚Äôt take a reactive dependency on either of the input variables.",
    "crumbs": [
      "Build",
      "Backend",
      "Reactivity",
      "Stop reactions with isolate()"
    ]
  },
  {
    "objectID": "r/articles/build/js-dashboard/index.html#introduction",
    "href": "r/articles/build/js-dashboard/index.html#introduction",
    "title": "Putting everything together to create an interactive dashboard",
    "section": "Introduction",
    "text": "Introduction\nIn this tutorial we‚Äôll put everything together we‚Äôve learned in the previous five tutorials to create an interactive dashboard. We learn how we can set up an interactive filter system that uses a brushable timeline component and the button groups developed in the previous tutorial. In addition, we learn how to send events from JavaScript to R at different rates such that we don‚Äôt overflow R with computations when we slide our brush over the timeline. Finally, in order to control the complexity of our app, we‚Äôll use Shiny modules to create a modular code base for our dashboard.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "Putting everything together to create an interactive dashboard"
    ]
  },
  {
    "objectID": "r/articles/build/js-dashboard/index.html#module-setup",
    "href": "r/articles/build/js-dashboard/index.html#module-setup",
    "title": "Putting everything together to create an interactive dashboard",
    "section": "Module setup",
    "text": "Module setup\nThe dashboard layout is based on the navbarPage layout. This layout creates a page with a top level navigation bar and has several tabPanels. In addition, it contains a button on the right hand side to launch the interactive help system developed in tutorial 4.\n\n\n\nnavbar layout\n\n\nEach tabpanel, however, only holds a single Shiny module (see below). You can think of a module as a piece of a Shiny app. Furthermore, a module usually has reactive inputs and outputs. More in depth discussions on Shiny modules are available here and here. From a module perspective, our dashboard essentially has three main pillars:\n\nA front panel module with a brushable timeline to filter the data on the front panel, combined with a filter module with a set of buttongroups (not shown) to filter the data of the whole app.\nA filter processing reactive that depends on the filter module that outputs a reactive data frame (rdf).\nA set of other modules that take the reactive data as their input.\n\nThe figure below provides a graphical overview of this setup:\n\n\n\nPassing a reactive into a module\n\n\nFor the sake of this tutorial it doesn‚Äôt really matter what the modules x, y, and z do in step 3. It only matters that they all take the same reactive dataset as their input and that the data module reacts to the filter module, which in turn depends on the brush events in the timeline and the button group filter controls.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "Putting everything together to create an interactive dashboard"
    ]
  },
  {
    "objectID": "r/articles/build/js-dashboard/index.html#capturing-timeline-brush-events",
    "href": "r/articles/build/js-dashboard/index.html#capturing-timeline-brush-events",
    "title": "Putting everything together to create an interactive dashboard",
    "section": "Capturing timeline brush events",
    "text": "Capturing timeline brush events\nIn tutorial 3) we‚Äôve created a C3LineBarChart, that has a brushable timeline, based on C3 subchart method.\nHere‚Äôs what the timeline part of our C3LineBarChart looks like:\n\n\n\ntimeline with a brush\n\n\nTo add a brushable subchart in C3 we simply call the subchart method inside c3.generate:\nc3.generate({\n  ...\n  subchart: {\n    show: true,\n    onbrush: function (domain) { ... }\n  }\n})\nThis code snippet tells C3 we want to add a subchart and call a function when an onbrush event occurs.\nIn our case, domain refers to the timeline domain of our chart i.e.¬†the brush start and end dates. Inside the onbrush callback i.e.¬†function (domain) { ... }, we can easily tell JavaScript to send the domain information to Shiny, using the Shiny.onInputChange method (see tutorial 3).\nHowever, this may trigger a large number of events when we slide the brush around. Therefore, we introduce a rate policy, to limit the number of events.\n\nControling the number of events\nEvent listeners such as a brush may fire many events. If these events are coupled with expensive computations, e.g.¬†filtering a big data set, this can result in a poor user experience. Therefore, we sometimes might want to limit the number of events that get sent. Two popular ways of controlling the number of events are throttling and debouncing.\nThrottling means no more than one event will be sent per x milliseconds, while debouncing means all of the events will be ignored until no events have been received for x milliseconds, at which time the most recent event will be sent. Luckily, using underscore.js, applying throttling or debouncing is quite straightforward.\nSuppose we want to debounce events using a 250 millisecond interval and then send the domain info to Shiny. Using underscore and Shiny.onInputChange the relevant code snippet becomes:\nsubchart: {\n  show: true,\n  onbrush: _.debounce( function (domain) {Shiny.onInputChange(el.id + \"-domain\", domain)} , 250)\n}\nNote that we wrapped the anonymous function function (domain) {Shiny.onInputChange(el.id + \"-domain\", domain)} inside a call to _.debounce( ... , 250) and that is it. In the code above, el.id is simply the id of our chart. For example, say the id equals id1, then in R we can capture the start and end times in a vector via input$\"id1-domain\". Now we can rest assured that when we move the brush we don‚Äôt flood Shiny with events since only after we‚Äôve stopped moving the brush for at least 250 milliseconds an event gets sent!",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "Putting everything together to create an interactive dashboard"
    ]
  },
  {
    "objectID": "r/articles/build/js-dashboard/index.html#putting-it-all-together-a-complete-example",
    "href": "r/articles/build/js-dashboard/index.html#putting-it-all-together-a-complete-example",
    "title": "Putting everything together to create an interactive dashboard",
    "section": "Putting it all together: a complete example",
    "text": "Putting it all together: a complete example\nA complete example application involving all aspects from the previous tutorials can be found can be downloaded here.\nThis repo contains the complete code base for a small dashboard application, that has a front page module using a number of C3 based HTMLWidgets, a brushable timeline component, our custom input binding switch component, as well as the intro.js based help system developed in tutorial 4.\nThe example app also involves a small filter module using the custom input binding button groups. Finally, the example contains two simple modules that consume the filtered data by visualizing a subset of the data via a Sankey chart from the googleVis package and a datatable from the DT package.\nThe screenshots below give an impression of the various parts of the dashboard demo app:\n\nDashboard front page\n\n\n\ndashboard front page with C3.js HTMLWidgets and a custom input binding switch\n\n\n\n\nDashboard brushable timeline\n\n\n\nDashboard brushable timeline filter\n\n\n\n\nDashboard intro.js based help system\n\n\n\nDashboard intro.js based help system\n\n\n\n\nDashboard filter module with custom input binding button groups\n\n\n\nSimple filter module with custom input binding button groups\n\n\n\n\nComplementary module 1 consuming the filtered data (sankey)\n\n\n\nComplementary module consuming the filtered data, using a Sankey chart\n\n\n\n\nComplementary module 2 consuming the filtered data (datatable)\n\n\n\nComplementary module consuming the filtered data, using a datatable\n\n\nTo run this example you must first run the install.R script inside the packages folder of the repo. This script makes sure all dependencies are installed.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "Putting everything together to create an interactive dashboard"
    ]
  },
  {
    "objectID": "r/articles/build/js-dashboard/index.html#outlook",
    "href": "r/articles/build/js-dashboard/index.html#outlook",
    "title": "Putting everything together to create an interactive dashboard",
    "section": "Outlook",
    "text": "Outlook\nIn this series we have described the process of extending the capabilities of Shiny apps with JavaScript. In the first 3 tutorials we mostly focused our attention on creating HTMLWidgets, based on C3.js, which in turn is based on d3.js. In tutorial 4 we‚Äôve shown how you can use other JavaScript libraries such as intro.js to make a step-by-step guide for your Shiny apps, while in tutorial 5 we learned how to create your own custom input bindings. Finally, in this tutorial we‚Äôve combined all the previous techniques into a complete dashboard app and learned how to control the number of events so Shiny isn‚Äôt flooded with computations. So where to go from here?\nFortunately, there are tons of other JavaScript libraries that can be useful to tie into the Shiny ecosystem. For some excellent work on combining JavaScript and Shiny, please check out the work of Kent Russell i.e.¬†timeportfolio or buildingwidgets, or the work on shinyjs by Dean Attali. Both served as an inspiration for the work in this tutorial series.\nThe most flexible JavaScript visualization framework that Shiny can benefit from is likely d3.js. Unfortunately, d3.js has a quite steep learning curve. A good resource for getting started with d3.js is Interactive Data Visualization for the Web by Scott Murray, while a more in depth treatment is provided in D3.js in Action by Elijah Meeks. Of note, d3.js itself is actively developed, which often means more work for widget builders.\nFor instance, at the time of writing d3.js has moved to version 4.x, which is a major departure from the 3.x version. This creates challenges for widget builders as older code is likely to break. Unfortunately, this is also the case for the current version of C3.js, which depends on d3.js version 3.5.0. A fork of C3.js, called billboard.js has recently been released. Billboard.js has feature parity with C3.js, however, it uses d3.js version 4+ under the hood!\nA very useful feature of Shiny is that you can always extend it by using raw HTML, CSS, and JavaScript. Hence, investing in these techniques is always sensible as they are what the web is about! If you‚Äôre just starting out, one of the best and most accessible books on these techniques are the books by Duckett i.e.¬†HTML & CSS and JavaScript & jQuery. The knowledge in these books are excellent starting points to dive deeper into more complex Shiny features such as HTMLTemplates and Crosstalk, which can bring your Shiny apps and widgets to an even higher level!",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "Putting everything together to create an interactive dashboard"
    ]
  },
  {
    "objectID": "r/articles/build/js-send-message/index.html#introduction",
    "href": "r/articles/build/js-send-message/index.html#introduction",
    "title": "How to send messages from the browser to the server and back using Shiny",
    "section": "Introduction",
    "text": "Introduction\nIn the previous tutorial we learned how to create C3 based widgets for\n\na pie chart\na combined line + bar chart, and\na stacked area chart.\n\nWe mainly focused on constructing these charts from R and sending data in such a way that C3 could animate the transition between the old and new data. This tutorial is all about sending messages from R to JavaScript and back, including how to listen for events.\nThe ability to send and receive messages greatly improves the capabilities of our widgets, as C3 offers a powerful API with a vast set of options and methods that allow you to modify a chart after it is initialized. For instance, we can use messages to\n\nupdate a legend\nadd or remove data, or\nfocus the viewing area of a chart to a particular subset of its data.\n\nImportantly, we want to be able to do all of this from R. In addition, it want to be able to chain operations together via the pipe operator (%&gt;%) in a way similar to ggplot2 (which uses the + operator).\n\nMessages, events and event listeners\nAn advantage of JavaScript charts is that they lend themselves well to user interaction. For instance, you can have JavaScript highlight a specific segment of the chart when you hover over the legend. Or, you can have JavaScript remove a segment of the chart when you click on a legend element. Tooltips are another example of chart interaction, in which you can show additional information when hovering over particular elements in the chart.\nIn JavaScript, things like clicking, hovering, brushing etc. are called events. Often you want JavaScript to do something when an event occurs, i.e.¬†you want to fire a specific function. An event listener, also called an event handler, is a special function that listens for particular events and that fires another function, called a callback function, if JavaScript detects the event. For instance, when you click a button, JavaScript can detect the click event via an event handler, which subsequently can fire another function.\nJavaScript has many events that you can listen to, see here for a more complete overview. Luckily, C3.js has an easy mechanism built in that allows you to call specific functions for click events, mouseover, mouseout and drag events. In this tutorial, you‚Äôll learn how to use these.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to send messages from the browser to the server and back using Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/js-send-message/index.html#sending-and-receiving-messages-from-shiny-to-javascript-and-back",
    "href": "r/articles/build/js-send-message/index.html#sending-and-receiving-messages-from-shiny-to-javascript-and-back",
    "title": "How to send messages from the browser to the server and back using Shiny",
    "section": "Sending and receiving messages from Shiny to JavaScript and back",
    "text": "Sending and receiving messages from Shiny to JavaScript and back\nSo far we have discussed events that happen solely in JavaScript. Sometimes, however, you may want to:\n\nactivate JavaScript functions from R, e.g.¬†to activate a chart method that modifies the chart, or\nlet Shiny listen to events that happen in the browser.\n\nLet‚Äôs see how we can do that!\nShiny offers three pivotal functions for sending and receiving messages. These are:\n\nthe R function sendCustomMessage\nthe JavaScript function Shiny.addCustomMessageHandler\nthe JavaScript function Shiny.onInputChange.\n\nIn the last two items, Shiny refers to a JavaScript object that is provided by Shiny and is available in JavaScript during the lifetime of an app. This object has various methods e.g.¬†addCustomMessageHandler and onInputChange that we can use. Before we use these methods in a C3 context, we first show two basic scenarios that use these functions.\n\nScenario 1: calling a JavaScript function from Shiny\nMany modern R packages like leaflet, the DT package, visNetwork and plotly, use JavaScript functions behind the scenes to perform key functionality. However, as they are all R packages, they invoke such functions from R. How can we do the same? Consider the following figure:\n\nSuppose in JavaScript our main goal is to call the function DoAwesomeThing1 (step 3), which has as an input object message and sends a simple text string to the browser console.\nIf we want to call this function from R, we can create an event handler in JavaScript (step 2), that handles requests from R, which tells JavaScript to call the function and to pass it a message that it got from R. Suppose we call this handler handler1. In JavaScript, we can create a message handler like this:\nShiny.addCustomMessageHandler(\"handler1\", doAwesomeThing1);\nThe first argument is the name of our handler, while the second argument is the callback function we want it to execute, i.e.¬†doAwesomeThing1. Whenever this handler gets a message from Shiny, it will pass the message as a function argument and call our JavaScript function doAwesomeThing1. In the example, the function doAwesomeThing1 displays the message via console.log to the browser console.\nFinally, in R we can send a message to our handler (which lives in JavaScript) via:\nsession$sendCustomMessage(\"handler1\", message)\nHere, message is a simple text string, e.g.¬†message &lt;- \"hello!\". To make things more concrete, let‚Äôs create an example.\n\n\nExample 1\nSuppose we have a Shiny action button; and when we press it, we want R to send a message string, e.g.¬†‚Äúhello!‚Äù, to JavaScript. Subsequently, we want JavaScript to create an alert that shows the value JavaScript received from R. The following 4 step procedure shows how we can handle this scenario. The procedure contains an R part (steps 1 & 2, light gray) and a JavaScript part (steps 3 & 4, light blue).\n\n  \n\nExample calling a JavaScript function from R. Click on the image to see a shiny app implementing this example!\n\n\nAt step 1, we define an action button in ui.R and we include a JavaScript file, i.e.¬†message.js, which we store in the www folder of a Shiny app. The file message.js contains two pieces of JavaScript code, displayed in steps 3 and 4.\nIn step 2, we create an observeEvent block, which is triggered via the action button. Inside it, we create a message and use session$sendCustomMessage with two arguments. The first argument is the name of the JavaScript message handler we want it to pass our message to. The second argument is the message itself.\nNext, on the JavaScript side (step 3) we add our custom message handler via Shiny.addCustomMessageHandler. We‚Äôll give the handler a name (or more formally, a type) equal to handler1 and a callback function, i.e.¬†doAwesomeThing.\nFinally, in step 4, we define the function doAwesomeThing, which has a single argument message1, which is subsequently used to raise an alert with the message.\nThe complete code for this example app can be downloaded here.\n\n\nScenario 2: sending a message from JavaScript to Shiny\nInstead of sending a message from Shiny to JavaScript, we can also send messages from JavaScript to Shiny. These actions are often coupled to events, e.g.¬†when we want R to do something when we click on an element. Such messages can be sent using the JavaScript method Shiny.onInputChange, which is made available by shiny. Consider the figure below:\n\nIn this example, we have a JavaScript function doAwesomeThing2, which takes an id and some data object (this can be anything), who‚Äôs task it is to send this information to Shiny. Within the function, here we first create an object with name message, and subsequently use it to send a message back to Shiny. Here, we tell it to make the message available in the R world under the name jsValue. That is, in R we can now listen for events via input$jsValue. So now if doAwesomeThing2 is called, Shiny gets a message. Nice!\nCaveat: Shiny only listens for changes in the value of a message. Hence, if you call doAwesomeThing2 twice with the same arguments, the second call will not trigger the observeEvent block because the object you send is unchanged. This can be overcome by adding a random value to your object, which makes the object as a whole appear changed to Shiny. In R, you simply ignore that part of the object. Such a value is sometimes known as a nonce, see here.\nFor instance in JavaScript via:\nvar message = {id: \"id1\", data = [1,2], nonce: Math.random()};\nWe can force reactivity in repeated calls to doAwesomeThing2 even if the values of id and data don‚Äôt change.\nLet‚Äôs see how we can incorporate these ideas into a small toy app!\n\n\nExample 2\nLet‚Äôs say that we have an image on a web page, e.g.¬†the RStudio ball, and when we click on it, we want to send a message from JavaScript to R, indicating that we clicked on the image. To see a Shiny toy app implementing this example, click on the blue RSTUDIO ball below!\n\n\n\nexample app showing how to use Shiny.onInputChange\n\n\nIf you run the app, the code can be seen next to the logo. Under the www tab you‚Äôll find the css file and the JavaScript file associated with this example. In the app, a counter below the logo shows how often you have clicked on the RStudio ball.\nThe complete code for this example app can be downloaded here.\nThe example itself is slightly more complex than what we previously encountered and involves a number of techniques. However, a complete understanding will help you handle various things that can come up when you create more complex Shiny apps. Assuming you opened the app, here are a few things to notice:\n\nthe ui.r file contains a link to a css file used to style the logo, to align the text under the image, and to change the mouse pointer on hover.\nwe included a JavaScript file message.js that initializes a counter n and sets up an event handler, in this case a click handler. The click handler increases the value of the counter each time we click the image and passes the value of n to Shiny via Shiny.onInputChange via a variable called count.\nthe click handler is created via jQuery (which comes standard with Shiny apps) and uses the $ sign (which is short for jQuery). jQuery is a JavaScript utility library packed with many useful functions. This library is known as the ‚Äòcode less do more‚Äô library. If you‚Äôre serious about Shiny, this library is well worth checking out! See here for an easy tutorial. Many jQuery functions work by using a css selector to create a selection and then to call a function on that selection. Of note, under the hood, jQuery plays an important role in many parts of the Shiny implementation by RSTUDIO.\n\nFor C3, you don‚Äôt have to create your own event listeners. However, it is very valuable if you understand how to create and use your own event listeners.\n\nin server.r, we can capture the value sent by JavaScript via input$count. Note here we used req to indicate that the value in input$count must be truthy.\nin message.js, we wrapped our code in $(document).ready(function() { ... }. This jQuery function will tell the browser to only run the code inside, once the page, i.e.¬†the Document Object Model (DOM), is ready for JavaScript code to execute. Note that when we activate this code too soon, i.e.¬†before the image is loaded, we cannot yet attach an event handler to it. In other words, here we want to be sure that the image exists before attaching an event handler to it.\n\n\n\nData transformation from R to JavaScript and back\nAs noted in the previous tutorial, all objects that are sent from R to JavaScript, or from JavaScript to R, are tacitly passed and processed by Shiny via jsonlite, using the functions toJSON and fromJSON. These functions transform R objects into JavaScript objects and vice versa. Especially in the beginning, this may lead to unexpected results, as the transformations are tacit and the returned objects may look different after processing than you might expect. With the hazard of sounding like a broken record: it‚Äôs very well worth your time to investigate how objects are transformed!\n\n\n\nAll objects that are send from R to JavaScript, or from JavaScript to R, are tacitly passed and processed by shiny via jsonlite.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to send messages from the browser to the server and back using Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/js-send-message/index.html#sending-messages-from-c3-to-shiny",
    "href": "r/articles/build/js-send-message/index.html#sending-messages-from-c3-to-shiny",
    "title": "How to send messages from the browser to the server and back using Shiny",
    "section": "Sending messages from C3 to Shiny",
    "text": "Sending messages from C3 to Shiny\nIn Example 2, we set up our own click handler using jQuery. If that was confusing, your worries are over!\nLuckily, C3 makes it very easy to bind functions to events without using jQuery. We can listen for:\nonclick, onmouseover, onmouseout, ondragstart, and ondragend\nevents, for instance. You can find more information on these events here.\nConsider the C3 pie in the following jsFiddle which contains data for series data1 and data2. Just click on a slice and see what happens!\n\n\nHere we use C3 to pass some information on the slice we click on. Using the concepts from the sections above, we can send this information back to shiny as well.\nConsider the JavaScript panel of the fiddle above. Here we used the C3 onclick method to display some of C3‚Äôs underlying data. Similar to D3, C3 stores this information in a variable called d. For instance, we can extract the slice data name via d.id. In this fiddle, the bottom line shows the complete content stored in the d variable by C3. In order to display the content inside a div element, here we use jQuery‚Äôs html method, in concert with JavaScript‚Äôs native JSON.stringify method. The latter method allows you to convert a JavaScript object to JSON, which you then can print.\nBack to our example, relaying the information stored in d.id back to Shiny is quite easy with the help of our new found friend Shiny.onInputChange. In a Shiny context, the relevant code snippet to pass the information to Shiny would look something like this:\n// c3 main method to construct a new chart\nchart = c3.generate({\n  bindto: el,\n  data: {\n\n    // insert toy data\n    json : {\"data1\": 50,\"data2\": 120},\n\n    type : 'pie',\n\n    onclick: function(d, element) {\n\n      // id of pie to shiny to input$chartId_click\n      var inputId = el.id + \"_click\";\n\n      // pie slice label\n      var value = d.id;\n\n      // send message to shiny\n      Shiny.onInputChange(inputID,value);\n\n    }\n  }\n});\nNote that in this case, we are also interested in the id of the container element that holds the pie chart, which we can get via el.id. We are interested in this because we will want to know which specific pie we clicked on should we have multiple pie charts in the Shiny app. Here we use this id, combined with the string _click and use this compound id to send the value back to Shiny.\nSuppose the pie container has an id equal to pie1, then in a Shiny context, we can observe the underlying data of a pie slice click in R via input$pie1_click.\nobserveEvent(input$pie1_click,{\n  cat(\"\\nyou clicked on a pie with pie slice data:\", input$pie1_click)\n})",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to send messages from the browser to the server and back using Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/js-send-message/index.html#sending-messages-to-an-already-existing-chart",
    "href": "r/articles/build/js-send-message/index.html#sending-messages-to-an-already-existing-chart",
    "title": "How to send messages from the browser to the server and back using Shiny",
    "section": "Sending messages to an already existing chart",
    "text": "Sending messages to an already existing chart\nSometimes we need to manipulate an already existing chart in order to control a specific aspect of that chart. Importantly, you would like to do that without redrawing the whole visualization from scratch. Fortunately, C3 provides a variety of methods to update a chart after it‚Äôs rendered.\nTo get an impression of what C3 can do, click the start button on the fiddle below and take a guided tour!\n\n\nAs you can see, C3 can do quite a lot. Please take a look at the JavaScript panel of the fiddle above. In it, you‚Äôll encounter a demos array. This shows a lot of methods that allow you to update a chart. In the sections below, we‚Äôll see how we can use these methods from R.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to send messages from the browser to the server and back using Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/js-send-message/index.html#creating-chainable-functions-using-the-pipe-operator",
    "href": "r/articles/build/js-send-message/index.html#creating-chainable-functions-using-the-pipe-operator",
    "title": "How to send messages from the browser to the server and back using Shiny",
    "section": "Creating chainable functions using the pipe operator",
    "text": "Creating chainable functions using the pipe operator\nIn the sections above, we learned how to send custom messages to JavaScript from R using sendCustomMessage. Even though it‚Äôs great to have this ability, executing statements this way can become a bit cumbersome, especially if we want to send multiple messages. Wouldn‚Äôt it be neat if we could chain statements like these? In particular, we would like to write code statements like:\ngetChart('id') %&gt;%  doAwesomeThing1() %&gt;%  doAwesomeThing2() %&gt;% doAwesomeThing3()\nIn the pseudo code above, we first get access to the chart object using an id and subsequently apply operation 1 on it. Then on the result of this we apply operation 2 and on the result of that we apply operation 3. The symbol %&gt;% represents the pipe operator from the magrittr package.\nThe pipe operator is a binary operator which places the argument on the left hand side as the first argument of the function on the right hand side, i.e.¬†it turns an operation like x %&gt;% f(y) into f(x, y). How can we use this to create chainable statements?\nActually, the trick is quite simple:\n\nAlways make sure that the return type of a chainable function is identical to its first argument.\n\nNote: here we‚Äôre not really interested in the return type of each function, which is identical to something we have up front, i.e.¬†its first argument, but in the side effects of each function, i.e.¬†the messages they send via sendCustomMessage. Confused? Don‚Äôt be, it will all be clear in a minute!\n\nCreating a proxy object\nIn most practical cases, in order to send a custom message we need an id, so we can get to a specific chart instance, and a session object, which allows us to call the method sendCustomMessage. Here‚Äôs a simple implementation:\n c3ChartProxy &lt;- function(id, session = shiny::getDefaultReactiveDomain()){\n\n  proxy        &lt;- list( id = shinyId, session = session )\n  class(proxy) &lt;- \"c3ChartProxy\"\n\n  return(proxy)\n}\nFactually, all that this function does is to create a list that holds an id and a session object. For satefy, we also assign a class that can be used in other functions to check if we receive the object we expect. Here, we give it class c3ChartProxy, but this could be anything you like.\nIn the code in the sections below, each chainable function receives this list as its first argument (via the pipe operator), but also uses this list as its return value.\nFrom the sections above we learned that we can call any JavaScript method an object has from R. So if we have access to the object, i.e.¬†the chart, from R, we can send messages to JavaScript that update the chart, via the chart‚Äôs own methods. This begs the question, if we have an id, how do we get access to a chart?\n\n\nAccessing a widget instance via an id\nFrom the second tutorial, we know that in JavaScript we can define a widget via the function HTMLWidgets.widget, and that it has a factory method, which looks something like this:\nHTMLWidgets.widget({\n\n  name: ...,\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // create an empty chart\n    var chart = null;\n\n    return {\n\n      renderValue: function(x) {\n\n        // if the chart does not exist, create it via c3.generate\n        if(chart === null){\n\n             // create a C3 chart\n             chart = c3.generate({\n                     ...\n            });\n        }\n            ...\n      }\n  }\n});\nHere chart contains the actual C3 chart. If we have that, we can further manipulate the chart via any of C3‚Äôs methods. Assuming we have access to our widget instance, how do we expose the chart that we create to the outside? Wait, mmm ‚Ä¶ ah ha, we simply create a method just for it!\nLuckily, this is extremely simple, i.e.¬†we only need to add a function like this:\ngetChart: function(){\n      return chart;\n}\nIf we combine the previous two snippets we end up with:\nHTMLWidgets.widget({\n\n  name: ...,\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // create an empty chart\n    var chart = null;\n\n    return {\n\n      renderValue: function(x) {\n\n        // if the chart does not exist, create it via c3.generate\n        if(chart === null){\n\n             // create a C3 chart\n             chart = c3.generate({\n                      ...\n            });\n        }\n            ...\n      },\n\n      // a method to expose our chart to the outside\n      getChart: function(){\n        return chart;\n      }\n  }\n});\nNext, we create a little JavaScript helper function that given an HTMLWidgets instance, calls this method, i.e.¬†getChart. Our helper function looks like this:\nfunction getC3Chart(id){\n\n  // Get the HTMLWidgets object\n  var htmlWidgetsObj = HTMLWidgets.find(\"#\" + id);\n\n  // Use the getChart method we created to get the underlying C3 chart\n  var c3Obj = htmlWidgetsObj.getChart();\n\n  return(c3Obj);\n}\nNote here we use the find() method of our HTMLWidgets object, that allows us to find the widget instance that sits inside the element for a given css selector. As we can see, here we use the id to create a css selector.\nOnce we have the htmlWidgets instance, i.e.¬†htmlWidgetsObj, we call our newly created getChart() method on it, which subsequently provides us access to our chart, i.e.¬†c3Obj. Sweet! We can now use any valid method defined in the C3 API to manipulate our chart!",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to send messages from the browser to the server and back using Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/js-send-message/index.html#putting-it-all-together",
    "href": "r/articles/build/js-send-message/index.html#putting-it-all-together",
    "title": "How to send messages from the browser to the server and back using Shiny",
    "section": "Putting it all together",
    "text": "Putting it all together\nThe sections above covered a lot of ground. Don‚Äôt worry if this is a bit overwhelming. Here we present a toy Shiny app, that combines all the steps in the sections above, which lets you manipulate existing C3 charts in various ways. Just click on the image below to launch the app!\n   \n\nToy Shiny app demonstrating how we can manipulate a chart via a proxy object. Click on the image to see this app in action!\n\nInitially, the app shows a series of stacked bar charts, which displays three time series over a time period of 30 days, i.e.¬†data1, data2 and data3.\nUsing a set of action buttons, we can zoom to the first 15 days, the last 15 days, reset the zoom domain, or update and reset the bar colors. However, we can also transform the series into a set of line charts, area charts, or spline charts. We can also update the type of chart for each dataset independently, by using the bottom left controls and pressing the blue action button. Finally, we can use the bottom right selector to stack or unstack various series in the chart.\n\nAbout the app\nThe app implements various R and JavaScript functions that allow you to manipulate the chart. However, these are all based on the concept of using a proxy object, which is combined with an R function that sends a custom message to a JavaScript message handler, which then finds the chart object via our helper function getC3Chart, which subsequently calls a C3 method on our chart.\nThe demonstration app has 5 functions that allow you to modify an existing C3 chart, i.e.¬†zoomChart, setColors, setGroups, setTypes and transformTo, which are accompanied by the JavaScript custom message handlers of the same name. It also uses an updated C3 package (from the previous tutorial), which in addition implements a slightly more robust version of c3ChartProxy and now also has a new C3StackedChart widget, with associated C3StackedChartOutput (in ui.r) and renderC3StackedChart (in server.R), Shiny helper functions.\nThe complete code for this example app can be downloaded here. In addition, you need to install an updated version of the C3 package, which you can download here. Furthermore, this demo uses shinyBS, which you can download here.\nIn the next section, we discuss the implementation of the zoomChart function, as used in the demo app.\nWe leave it as an exercise to inspect the app source code to find out how the other functions are implemented. This process, however, is very similar to the steps described below. Furthermore, here we assume we already have an implementation that allows you to create and render a stacked chart widget. The code for this widget can be found here.\n\n\nBuilding a zoom function\nAssumming we have a C3StackedChart widget function and a suitable render function renderC3StackedAreaChart (see here. In server.r, our code looks somewhat like this:\noutput$chart1 &lt;- renderC3StackedAreaChart({\n\n  C3StackedChart(dataset  = dataset,\n                 types    = list(data1 = \"bar\", data2 = \"bar\", data3 = \"bar\"),\n                 colors   = list(data1 = \"purple\", data2 = \"blue\", data3 = \"gray\"),\n                 groups   = c(\"data1\",\"data2\",\"data3\"))\n})\nAs we can see, our C3StackedChart takes four arguments.\nHere dataset is a dataframe (assumed created in an earlier step), with 30 rows (days) and 4 columns: one time column and one numeric column for each of the 3 series, in which each cell gives a total count per day for that series.\nNext, types is a list that tells C3 to display each series as a set of bars; colors is a list that defines the color for each series, while groups tells C3 that we want to stack the data for series data1, data2 and data3 (instead of displaying each series next to each other). Note the id of the widget in this case is chart1.\nNext, suppose we have an action button with id update1 and when we press it, we want C3 to zoom our chart to a specific region. In server.r of our demonstration app, we have:\n# update 1\nobserveEvent(input$update1, {\n  c3ChartProxy(\"chart1\") %&gt;% zoomChart(\"2016-10-01\", \"2016-10-15\")\n})\nThis observe block uses our c3ChartProxy and calls zoomChart, which passes a start date and an end date for our zoom domain.\nIn R, we defined C3ChartZoom as:\nzoomChart &lt;- function(chartProxy, minX, maxX){\n\n  # prepair a message using the function arguments\n  message &lt;- list(id = chartProxy$id, minX = minX, maxX = maxX)\n\n  # send a custom message to JavaScript\n  chartProxy$session$sendCustomMessage(\"zoomChart\", message)\n\n  # return the proxy i.e. the list that holds the chart id and session object\n  # so we can plug it into the next function (if any), via the pipe operator\n  return(chartProxy)\n}\nNote that chartProxy provides access to both the session object (which we can send via custom messages), as well as the widget id, which allows us to get to the correct chart.\nNext, in JavaScript we create a custom message handler, that given an id, gets the correct chart and subsequently calls a C3 method on that chart, passing any required data it got from R.\nHere‚Äôs what our ZoomC3Chart custom message handler looks like:\nShiny.addCustomMessageHandler('zoomChart', function(message){\n\n    // get the correct HTMLWidget instance\n    var chart = getC3Chart(message.id);\n\n    // parse the dates received from R to the correct format, using a tiny bit of JavaScript\n    var minDate = Date.parse(message.minX);\n    var maxDate = Date.parse(message.maxX);\n\n    // call the C3 zoom method, which according to the C3 reference needs an array\n    chart.zoom([minDate,maxDate]);\n});\nNote that here, via message, we get the widgets id. We can get our actual chart object back via our helper function getC3Chart. When we have this, we simply call a built in C3 method, here zoom, and provide it with the data it needs, i.e.¬†two JavaScript data objects.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to send messages from the browser to the server and back using Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/js-send-message/index.html#closing-remarks",
    "href": "r/articles/build/js-send-message/index.html#closing-remarks",
    "title": "How to send messages from the browser to the server and back using Shiny",
    "section": "Closing remarks",
    "text": "Closing remarks\nCongrats! You made it to the end! This tutorial, by far, is the most technical tutorial of all the Shiny JavaScript tutorials in this series. Don‚Äôt worry if you didn‚Äôt get everything the first time, experimenting with R and JavaScript takes a bit of time.\nLuckily, on CRAN and GITHUB there are many HTMLWidgets available. By looking at the source code of other widget implementers, you can learn a lot about how things work! For those who want to use JavaScript to extend shiny, we suggest you also look into shinyJS, which offers a lot of handy JavaScript routines out of the box. To pay attribution, many of the concepts on sending custom messages were inspired by this excellent blog post and by looking into the source code of both RSTUDIO‚Äôs leaflet and the awesome visNetwork package.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to send messages from the browser to the server and back using Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/js-send-message/index.html#next-tutorial",
    "href": "r/articles/build/js-send-message/index.html#next-tutorial",
    "title": "How to send messages from the browser to the server and back using Shiny",
    "section": "Next tutorial",
    "text": "Next tutorial\nIn the next tutorial, we will look into an entirely different aspect of Shiny apps: how to create a dynamic interactive help system! In that tutorial, we will show you how you can create a step-by-step guide for a website via intro.js, which allows you to draw cool HTML based boxes around elements of your choice, combined with an annotation layer and a navigation system. Each aspect is explained in depth in a step by step manner. As a bonus, we present a completely tricked out shiny example app, that allows you to use intro.js to switch tab panels in a multi page shiny app, use voice recognition to activate and control intro.js and that uses voice synthesis to speak out the text inside each box, all from within a Shiny app! Sweet!",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to send messages from the browser to the server and back using Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/modal-dialogs/index.html",
    "href": "r/articles/build/modal-dialogs/index.html",
    "title": "Modal dialogs",
    "section": "",
    "text": "As of version 0.14, Shiny has built-in support for displaying modal dialogs like the one below:\nYou can see the app in action here.\nFor the majority of use cases, there are three parts for displaying a modal dialog:\nThis simple app illustrates how these things fit together:\nThe call to modalDialog() generates the HTML. If you simply run modalDialog() at the R console, it will print out the HTML for a modal dialog.\nThe call to showModal() sends the HTML to the client browser to be displayed.\nFinally, there is observeEvent(). When input$show changes (in other words, when the button is pressed), it runs the showModal(modalDialog()) code.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Modal dialogs"
    ]
  },
  {
    "objectID": "r/articles/build/modal-dialogs/index.html#options",
    "href": "r/articles/build/modal-dialogs/index.html#options",
    "title": "Modal dialogs",
    "section": "Options",
    "text": "Options\nThere are a few options that control the appearance an behavior of modalDialog():\n\ntitle: An optional title for the modal dialog.\nsize: Controls the width of the modal dialog. Can be \"s\" for small, \"m\" for medium (the default), or \"l\" for large.\nfooter: Content to display in an optional footer for the modal dialog. The default is to display a button that dismisses the modal dialog.\neasyClose: If TRUE, then clicking outside the modal dialog or pressing Esc will close the dialog. If FALSE (the default), then the user will have to click on the Dismiss button to close it.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Modal dialogs"
    ]
  },
  {
    "objectID": "r/articles/build/output-args/index.html",
    "href": "r/articles/build/output-args/index.html",
    "title": "Setting Output args via Render functions",
    "section": "",
    "text": "Basic Usage\nOften in an interactive R Markdown document, you want to embed snippets of Shiny code without having to specify the corresponding ui function. For example, you may want to use a renderPlot() function without having to create a plotOutput() slot beforehand. In this case, Shiny helpfully associates the corresponding output object to each render function, letting you use Shiny code outside of a full app. However, some functionality is lost in this process. In particular, plotOutput() can take in some optional arguments to set things like width and height, or allow you to click or brush over the plot (and store that information). Previously, this functionality was not available to you outside of a full Shiny app (one with a server function and a ui function, where all the output objects are made explicit).\nNow, for the sake of convenience, when working with just snippets of Shiny code, you‚Äôre able to set output arguments directly from the corresponding render function. To do so, use the outputArgs argument, which is available to all render functions. For example, let‚Äôs say that you want to render a plot and specify its width to be 200px and its height 100px. Then you should use:\nrenderPlot({ \n  plot(yourData) \n}, outputArgs = list(width = \"200px\", \n                     height = \"100px\")\n)\nNo matter how many arguments you set (all the way from zero to all possible ones), outputArgs always takes in a list (as you‚Äôd expect, the default is an empty list, which sets no output arguments). If you try to pass in a non-existent argument, you‚Äôll get an error with the following message (in this example, you tried to set an argument named ‚Äúnot_an_argument‚Äù):\n\nError: Unused argument: in ‚ÄòoutputArgs‚Äô, ‚Äònot_an_argument‚Äô is not an valid argument for the output function\n\nTo see this in action, check out the R Markdown script and resulting document below. The document is interactive ‚Äì brush over the image and see the ‚Äòxmin‚Äô, ‚Äòxmax‚Äô, ‚Äòymin‚Äô and ‚Äòymax‚Äô values change (printed just under the image).\n\nScript:\n---\ntitle: Setting `output` args via `render` functions\nruntime: shiny\noutput: html_document\n---\n\nThis interactive Rmd document makes use of the `outputArgs` argument now available to all Shiny `render` functions. To give an example, this allows you to set arguments to `imageOutput` through `renderImage`. This means that you don't have to create a `ui` object just to be able to brush over an image. Note that this only applies to snippets of Shiny code during an interactive Rmd (and not to embedded full apps -- the ones you need to call `shinyApp` to run).\n\n### Brushing over an image (and storing the data)\n\n```{r setup, echo=FALSE}\nlibrary(datasets)\n\ngenerateImage &lt;- function() {\n  outfile &lt;- tempfile(fileext = '.png')\n  png(outfile)\n  par(mar = c(0,0,0,0))\n  image(volcano, axes = FALSE)\n  contour(volcano, add = TRUE)\n  dev.off()\n  list(src = outfile)\n}\n```\n\n```{r image}\nrenderImage({\n  generateImage()\n}, deleteFile = TRUE, \n   outputArgs = list(brush = brushOpts(id = \"plot_brush\"),\n                     width = \"250\",\n                     height = \"250px\")\n)\n```\n\n##### Here's some of the brushing info sent to the server:\n(brush over the image to change the data)\n\n```{r brush info}\nrenderText({ \n  print(input$plot_brush)\n  brush &lt;- input$plot_brush\n  paste0(\"xmin: \", brush$xmin, \"; \",\n         \"xmax: \", brush$xmax, \"; \",\n         \"ymin: \", brush$ymin, \"; \",\n         \"ymax: \", brush$ymax)\n})\n```\n\n---\n\n### Resizing a plot\n\n```{r plot}\nrenderPlot({ \n  plot(cars) \n}, outputArgs = list(width = \"75%\", \n                     height = \"250px\")\n)\n```\n\n\n\nResult:\n\n\n\n\n\nA caveat\nIt‚Äôs important to highlight that you can only use this functionality within an interactive R Markdown document (i.e.¬†you must set runtime: shiny in the header). But even if that is the case, this is only applicable to ui-less pieces of Shiny code. If you embed a full Shiny application in your document and try to use outputArgs, it will be ignored and print the following warning to the R Markdown console (in this case, your ui function would be something like ui &lt;- plotOutput(\"plot\")):\n\nWarning in output$plot(‚Ä¶) : Unused argument: outputArgs. The argument outputArgs is only meant to be used when embedding snippets of Shiny code in an R Markdown code chunk (using runtime: shiny). When running a full Shiny app, please set the output arguments directly in the corresponding output function of your UI code.\n\nThe same will happen if you try to use outputArgs in any other context, like inside a regular (i.e.¬†not embedded) Shiny app. The rationale is that, if you are already specifying a ui function with all the output objects made explicit, you should set their arguments directly there, instead of going through this round-about way.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "Setting Output args via Render functions"
    ]
  },
  {
    "objectID": "r/articles/build/packaging-javascript/index.html",
    "href": "r/articles/build/packaging-javascript/index.html",
    "title": "Packaging JavaScript code for Shiny",
    "section": "",
    "text": "If you want to write custom JavaScript code to customize and extend your Shiny app, you‚Äôll eventually need to figure out how to get Shiny to serve up your JavaScript. There are a number of different possibilities:\nThe right choice for your situation will depend primarily on how much JavaScript code you are writing, and whether/how you intend to reuse the JavaScript code across multiple Shiny apps (no reuse, ad hoc, or R package).",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Packaging JavaScript code for Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/packaging-javascript/index.html#inlined-script-text",
    "href": "r/articles/build/packaging-javascript/index.html#inlined-script-text",
    "title": "Packaging JavaScript code for Shiny",
    "section": "Inlined script text",
    "text": "Inlined script text\nThe quickest way to inject a bit of JavaScript is to include a &lt;script&gt; tag directly in your Shiny UI, using tags$script() and HTML():\nui &lt;- fluidPage(\n  tags$script(HTML(\n    \"document.body.style.backgroundColor = 'skyblue';\"\n  ))\n)\nYou can generally feel free to add tags$script() calls anywhere in your UI where ‚Äúnormal‚Äù content is expected. (If for some reason you feel strongly about JavaScript only appearing in the &lt;head&gt; of a document, you can do tags$head(tags$script(...)) and Shiny will hoist your script to the head at page render time.)\nInlined script text should be reserved for only the smallest, one-time-use snippets of JavaScript. While quick and convenient, there are considerable downsides to this approach:\n\nNo assistance from your IDE or text editor for coloring, indenting, or error-checking your JS code\nIncluding multiple lines of code is a bit awkward\nNeed to escape double quotes (or single quotes, depending on which you use to form your R string) using ‚Äú\\‚Äù\n\nNote the HTML() in the example above. This is necessary to prevent your JavaScript code string from being treated as regular text and being HTML-escaped; if that happens, all instances of the special characters &, &lt;, and &gt; in your code will be turned into &amp;, &lt;, and &gt;, respectively.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Packaging JavaScript code for Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/packaging-javascript/index.html#javascript-file-under-www",
    "href": "r/articles/build/packaging-javascript/index.html#javascript-file-under-www",
    "title": "Packaging JavaScript code for Shiny",
    "section": "JavaScript file under www/",
    "text": "JavaScript file under www/\nAnother option is creating a separate .js file and saving it in a www subdirectory (it must be directly under your app directory). This is only slightly less convenient than inlined script text, and removes most of the downsides.\n\nwww/myscript.js:\ndocument.body.style.backgroundColor = \"skyblue\";\n\n\napp.R:\nui &lt;- fluidPage(\n  tags$script(src = \"myscript.js\")\n)\nAn app directory‚Äôs www subdirectory is special to Shiny: any files and folders contained there are automatically made available to download. (Files in the app dir itself, or any other subdirectories, are not available to download; this is intentional, for obvious security reasons.) Notice that the script tag‚Äôs src attribute is \"myscript.js\", not \"www/myscript.js\"; you should never include a www prefix when creating URLs to content in the www directory.\nBecause the JavaScript code is in a dedicated file, you can use your favorite IDE or text editor to its full advantage. And there‚Äôs no need to worry about escaping quotes.\nUse JavaScript files under www/ anytime you are writing substantial logic that‚Äôs specific to a single app. The downsides to this approach come into play when you want your logic to be used in multiple apps. Because a file must be physically copied into each app dir‚Äôs www subdirectory, it will never be as convenient for reuse as the next two approaches.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Packaging JavaScript code for Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/packaging-javascript/index.html#inlined-javascript-file",
    "href": "r/articles/build/packaging-javascript/index.html#inlined-javascript-file",
    "title": "Packaging JavaScript code for Shiny",
    "section": "Inlined JavaScript file",
    "text": "Inlined JavaScript file\nThis approach can be thought of as a hybrid of the previous two approaches: you write your JavaScript code in a standalone .js file, but the end result is that the JavaScript is inlined completely into the main app‚Äôs HTML.\nTo use this approach, place your .js file directly in the app directory (or in any subdirectory, like js/). Then, use the includeScript function in your UI, just like you would use tags$script in the previous two approaches.\n\nmyscript.js:\ndocument.body.style.backgroundColor = \"skyblue\";\n\n\napp.R:\nui &lt;- fluidPage(\n  includeScript(path = \"myscript.js\")\n)\nThe path argument to includeScript should be a relative path to your script file, starting from the app directory (in this example, myscript.js would be placed directly in the app directory).\nUnlike the previous (www/) option, this approach can also be easily used in package functions intended to be used by multiple apps. Put the JavaScript file under your package‚Äôs inst directory, and use the base::system.file function to obtain an absolute path to your JavaScript file, which you then pass to includeScript. Do all this in a package function that returns the results of includeScript.\n\n\nmypackage/inst/js/myscript.js\ndocument.body.style.backgroundColor = \"skyblue\";\n\n\nmypackage/R/bluebg.R\n#' @export\nblueBgScript &lt;- function() {\n  includeScript(system.file(\"js/myscript.js\", package = \"mypackage\"))\n}\n\n\napp.R\nui &lt;- fluidPage(\n    mypackage::blueBgScript()\n)\nInline a JavaScript file into the UI if you want to reuse it via package functions (but also see the next option for an even more flexible approach).\nAvoid using includeScript with a hardcoded absolute path to your user directory, or to any other directory outside of your app directory. Doing so will prevent your app from working for other R users, or for yourself on a different computer, or from being deployed successfully on ShinyApps.io or Posit Connect.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Packaging JavaScript code for Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/packaging-javascript/index.html#htmldependency-object",
    "href": "r/articles/build/packaging-javascript/index.html#htmldependency-object",
    "title": "Packaging JavaScript code for Shiny",
    "section": "htmlDependency object",
    "text": "htmlDependency object\nThe previous approaches were just different ways of injecting &lt;script&gt; tags directly into your UI. This last option is very different.\nUnlike includeScript or tags$script, the htmltools::htmlDependency function does not directly create a &lt;script&gt; tag. Instead, it creates an object that describes a bundle of JS/CSS assets:\n\nname: The name of the bundle. If you‚Äôre creating an htmlDependency for a 3rd-party JS/CSS library, you‚Äôd use its name; e.g.¬†\"jquery\", \"font-awesome\", \"bootstrap\". If you‚Äôre bundling some custom JS/CSS for your own package, pick a unique name based on your package name.\nversion: A version number. For a 3rd-party JS/CSS library, just use its version number; if custom JS/CSS for your own package, use packageVersion() to get the package version number.\nsrc: A source directory (or URL). This is the parent directory (or URL) for all of the JS/CSS files.\n\nIf you‚Äôre using a URL (like to a CDN), you must make this explicit by using a named vector: src = c(href = url).\nIf you are building a package and the scripts/stylesheets are somewhere in the inst directory, you can also provide a package argument with your package name, and then the source directory would be a path that‚Äôs relative to the package path.\n\nscript and stylesheet: Relative paths to all JS and CSS files that should get their own &lt;script&gt; and &lt;link&gt; tags. These paths should be relative to the source directory/URL.\n\nHere‚Äôs an example. Given an R package with this directory structure:\nmypackage/\n‚îî‚îÄ inst/\n   ‚îî‚îÄ assets/\n      ‚îú‚îÄ js/\n      ‚îÇ  ‚îî‚îÄ myscript.js\n      ‚îî‚îÄ css/\n         ‚îú‚îÄ reset.css\n         ‚îî‚îÄ mystyles.css\nYou‚Äôd create an htmlDependency like this:\nmypackageDependencies &lt;- function() {\n  htmlDependency(name = \"mypackage-assets\", version = \"0.1\",\n    package = \"mypackage\",\n    src = \"assets\",\n    script = \"js/myscript.js\",\n    stylesheet = c(\"css/reset.css\", \"css/mystyles.css\")\n  )\n}\nYou can include htmlDependency objects in your UI just like other tag objects. But they don‚Äôt directly translate into &lt;script&gt; and &lt;link&gt;‚Äîat least, not right away. Instead, the dependency object is left alone until the entire page is ready to render.\nAt page render time, Shiny will look at all the htmlDependency objects present in the page, and crucially, weed out any duplicate dependencies (i.e.¬†for a given dependency name, only a single copy of htmlDependency will be kept). The remaining dependency objects are then injected into the &lt;head&gt; of the page with the appropriate &lt;script&gt; and &lt;link&gt; tags.\nIf multiple dependencies have the same name but different versions, the more recent version is kept. (We assume that dependency libraries are backward compatible. Things get a bit complicated if that‚Äôs not true, such as with d3 3.x vs 4.x.)\nUse htmlDependency objects if you have initialization code that should be run only once, but may be used multiple times on a single page; or if you intend for your JavaScript to be reused by other packages.",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Packaging JavaScript code for Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/packaging-javascript/index.html#r-markdown-only-use-a-js-chunk",
    "href": "r/articles/build/packaging-javascript/index.html#r-markdown-only-use-a-js-chunk",
    "title": "Packaging JavaScript code for Shiny",
    "section": "[R Markdown only] Use a ```{js} chunk",
    "text": "[R Markdown only] Use a ```{js} chunk\nFor R Markdown documents, in addition to the options above, you can also use the JavaScript chunk engine. This is very convenient for small to medium sized code chunks, as it doesn‚Äôt require you to create a separate file, nor must you stuff your JavaScript code into a string literal.\n(One caveat for runtime: shiny apps, regardless of which option you choose: your Rmd is not rendered until well after the browser page has loaded, so you can‚Äôt rely on the DOMContentLoaded event, or its jQuery equivalent, $(document).ready().)",
    "crumbs": [
      "Build",
      "Frontend",
      "Customizing Shiny",
      "Packaging JavaScript code for Shiny"
    ]
  },
  {
    "objectID": "r/articles/build/plot-interaction-advanced/index.html",
    "href": "r/articles/build/plot-interaction-advanced/index.html",
    "title": "Interactive plots - advanced",
    "section": "",
    "text": "This article contains information about using Shiny‚Äôs image and plot interaction features to perform some more advanced tasks.\nTo get a look at most of the features available in plot interactions, see the advanced demo app.",
    "crumbs": [
      "Build",
      "Frontend",
      "Graphics & visualization",
      "Interactive plots - advanced"
    ]
  },
  {
    "objectID": "r/articles/build/plot-interaction-advanced/index.html#interactions-with-bitmap-images",
    "href": "r/articles/build/plot-interaction-advanced/index.html#interactions-with-bitmap-images",
    "title": "Interactive plots - advanced",
    "section": "Interactions with bitmap images",
    "text": "Interactions with bitmap images\nThe plot interaction article describes how to interact with plots generated by R‚Äôs base graphics and ggplot2. Shiny also supports interactions with arbitrary bitmap (for example, PNG or JPEG) images. There is one change in the information returned for these mouse events: instead of plot coordinates scaled to the data, they will contain pixel coordinates. You may need to transform these coordinates to something useful for your data.\nThe only difference in the code is that, instead of using renderPlot(), you would use renderImage(). For an example, see the image interaction demo app.",
    "crumbs": [
      "Build",
      "Frontend",
      "Graphics & visualization",
      "Interactive plots - advanced"
    ]
  },
  {
    "objectID": "r/articles/build/plot-interaction-advanced/index.html#mouse-event-data",
    "href": "r/articles/build/plot-interaction-advanced/index.html#mouse-event-data",
    "title": "Interactive plots - advanced",
    "section": "Mouse event data",
    "text": "Mouse event data\nIf you‚Äôd like to see the data structures returned by mouse interactions, see the basic demo app.",
    "crumbs": [
      "Build",
      "Frontend",
      "Graphics & visualization",
      "Interactive plots - advanced"
    ]
  },
  {
    "objectID": "r/articles/build/plot-interaction-advanced/index.html#zooming",
    "href": "r/articles/build/plot-interaction-advanced/index.html#zooming",
    "title": "Interactive plots - advanced",
    "section": "Zooming",
    "text": "Zooming\nMouse interactions can be used to implement zooming in plots. The zooming demo app shows two ways of doing this: by zooming in a single plot, and by using one plot to control the zoom in a second plot.",
    "crumbs": [
      "Build",
      "Frontend",
      "Graphics & visualization",
      "Interactive plots - advanced"
    ]
  },
  {
    "objectID": "r/articles/build/plot-interaction-advanced/index.html#excluding-points-from-a-scatter-plot",
    "href": "r/articles/build/plot-interaction-advanced/index.html#excluding-points-from-a-scatter-plot",
    "title": "Interactive plots - advanced",
    "section": "Excluding points from a scatter plot",
    "text": "Excluding points from a scatter plot\nIt can be useful to interactively select outliers to exclude from a prediction model. The exclude demo app shows how to do this.",
    "crumbs": [
      "Build",
      "Frontend",
      "Graphics & visualization",
      "Interactive plots - advanced"
    ]
  },
  {
    "objectID": "r/articles/build/plot-interaction-advanced/index.html#dates-and-date-times",
    "href": "r/articles/build/plot-interaction-advanced/index.html#dates-and-date-times",
    "title": "Interactive plots - advanced",
    "section": "Dates and date-times",
    "text": "Dates and date-times\nWhen dates and date-times are used on the x or y axis, the selected values will be returned from the browser as numeric values. The nearPoints() and brushedPoints() functions will automatically handle the type conversions, but if you want to do the conversions manually, you would use something like the following:\n# If the x variable is a Date\nas.Date(input$plot_click$x, origin = \"1970-01-01\")\n\n# If the y variable is POSIXct\nas.POSIXct(input$plot_click$y, origin = \"1970-01-01\")\nThe origin is the date or time to count from, and midnight on 1970-01-01 is the usual value.\nNote: for datetimes, it is generally preferable to use data of class POSIXct instead of POSIXlt, because the storage format of POSIXlt is more difficult to work with.\nAnother possibility is, instead of converting the mouse coordinates to dates or times, you could convert the data values to numbers, and then do some comparison with the input values:\n# If the x variable, in data$dates, is a Date\n# Find which rows are within 1 day of the click\nselectedRows &lt;- abs(as.numeric(data$dates) - input$plot_click$x) &lt; 1",
    "crumbs": [
      "Build",
      "Frontend",
      "Graphics & visualization",
      "Interactive plots - advanced"
    ]
  },
  {
    "objectID": "r/articles/build/plot-interaction-advanced/index.html#categorical-axes-including-bar-graphs",
    "href": "r/articles/build/plot-interaction-advanced/index.html#categorical-axes-including-bar-graphs",
    "title": "Interactive plots - advanced",
    "section": "Categorical axes (including bar graphs)",
    "text": "Categorical axes (including bar graphs)\nFor plots that have axes with categorical values (factors or character vectors), the values returned from the browser will be numeric. To compare the mouse coordinate values to the data values, you will need to coerce the data to numeric values.\nFor mouse click/double-click/hover events, you will typically want to round the mouse‚Äôs x or y value so that it can be compared to the data values. The app below demonstrates how to do this:\nlibrary(shiny)\nlibrary(ggplot2)\n\nui &lt;- fluidPage(\n  fluidRow(\n    column(6,\n      plotOutput(\"plot1\", click = \"plot1_click\")\n      ),\n    column(5,\n      br(), br(), br(),\n      htmlOutput(\"x_value\"),\n      verbatimTextOutput(\"selected_rows\")\n    ))\n)\n\nserver &lt;- function(input, output) {\n  output$plot1 &lt;- renderPlot({\n    plot(ToothGrowth$supp, ToothGrowth$len)\n  })\n  \n  # Print the name of the x value\n  output$x_value &lt;- renderText({\n    if (is.null(input$plot1_click$x)) return(\"\")\n    else {\n      lvls &lt;- levels(ToothGrowth$supp)\n      name &lt;- lvls[round(input$plot1_click$x)]\n      HTML(\"You've selected &lt;code&gt;\", name, \"&lt;/code&gt;\",\n           \"&lt;br&gt;&lt;br&gt;Here are the first 10 rows that \",\n           \"match that category:\")\n    }\n  })\n  \n  # Print the rows of the data frame which match the x value\n  output$selected_rows &lt;- renderPrint({\n    if (is.null(input$plot1_click$x)) return()\n    else {\n      keeprows &lt;- round(input$plot1_click$x) == as.numeric(ToothGrowth$supp)\n      head(ToothGrowth[keeprows, ], 10)\n    }\n  })\n}\n\nshinyApp(ui, server)\nClick on each box on the plot below to see this in action:\n\n\nFor brushing, it usually make more sense to check if a factor level‚Äôs corresponding numeric value is within the xmin and xmax (or ymin and ymax).",
    "crumbs": [
      "Build",
      "Frontend",
      "Graphics & visualization",
      "Interactive plots - advanced"
    ]
  },
  {
    "objectID": "r/articles/build/plot-interaction-advanced/index.html#learn-more",
    "href": "r/articles/build/plot-interaction-advanced/index.html#learn-more",
    "title": "Interactive plots - advanced",
    "section": "Learn more",
    "text": "Learn more\nFor more on this topic, see the following resources:\n Interactive Graphics with Shiny\n Creating interactive web graphics suitable for exploratory data analysis",
    "crumbs": [
      "Build",
      "Frontend",
      "Graphics & visualization",
      "Interactive plots - advanced"
    ]
  },
  {
    "objectID": "r/articles/build/pool-advanced/index.html#installation",
    "href": "r/articles/build/pool-advanced/index.html#installation",
    "title": "Using the pool package (advanced)",
    "section": "Installation",
    "text": "Installation\nYou can get both shiny and DBI from CRAN, but you must get pool from GitHub (since it‚Äôs not yet on CRAN):\ninstall.packages(\"shiny\")\ninstall.packages(\"DBI\")\n\n# get pool from GitHub, since it's not yet on CRAN\ndevtools::install_github(\"rstudio/pool\")",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Using the pool package (advanced)"
    ]
  },
  {
    "objectID": "r/articles/build/pool-advanced/index.html#overview",
    "href": "r/articles/build/pool-advanced/index.html#overview",
    "title": "Using the pool package (advanced)",
    "section": "Overview",
    "text": "Overview\nYou should read this article only once you have a good idea of the basics of the pool package. In here, we‚Äôll cover:\n\nhow to customize your pool, by providing extra arguments to dbPool;\nhow to handle transactions using a pool;\nfuture work.",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Using the pool package (advanced)"
    ]
  },
  {
    "objectID": "r/articles/build/pool-advanced/index.html#customizing-your-pool",
    "href": "r/articles/build/pool-advanced/index.html#customizing-your-pool",
    "title": "Using the pool package (advanced)",
    "section": "Customizing your pool",
    "text": "Customizing your pool\nFirst, let‚Äôs get to know our Pool object:\nlibrary(DBI)\nlibrary(pool)\n\npool &lt;- dbPool(\n  drv = RMySQL::MySQL(),\n  dbname = \"shinydemo\",\n  host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",\n  username = \"guest\",\n  password = \"guest\"\n)\n\ndbGetInfo(pool)\n&gt;# $class\n&gt;# [1] \"Pool\"\n&gt;#\n&gt;# $valid\n&gt;# [1] TRUE\n&gt;#\n&gt;# $minSize\n&gt;# [1] 1\n&gt;#\n&gt;# $maxSize\n&gt;# [1] Inf\n&gt;#\n&gt;# $idleTimeout\n&gt;# [1] 60000\n&gt;#\n&gt;# $pooledObjectClass\n&gt;# [1] \"MySQLConnection\"\n&gt;#\n&gt;# $numberFreeObjects\n&gt;# [1] 0\n&gt;#\n&gt;# $numberTakenObjects\n&gt;# [1] 1\nAs you can see, dbGetInfo() will give you information about your pool. This can be useful to learn how many connections you have open (both free/idle and in use). But for this section, let‚Äôs turn our attention to other features: minSize, maxSize and idleTimeout. These are extra, optional parameters that you can pass in to dbPool():\n\nminSize: minimum number of connections that the pool should have at all times (default is 1);\nmaxSize: maximum number of connections that the pool may have at any time (default is Inf);\nidleTimeout: number of milliseconds to wait before closing a connection, if the number of connections is above minSize (default is 60000, which is one minute).\n\nThese parameters are what allows the pool to ‚Äúknow‚Äù when it should shrink and when it should grow. When created, the pool always creates the minSize number of connections, and keeps them around until they‚Äôre requested. If all the idle connections are taken up when another request for a connection comes up, the pool will create a new connection. At this point, the pool will be over the minSize. It will keep following this pattern up until the total number of connections (both free and taken) is equal to the maxSize; at this point, any further requests for new connections will be denied (and throw an error). In the meantime, any connection that is created when we‚Äôre over the minSize will have a timer attached to it: from the moment it is returned back to the pool, a countdown of idleTimeout milliseconds will start. If that connection is not requested again during that period, it will be destroyed when the countdown finishes. If it is requested and checked out of the pool, the countdown will the reset when it is returned back to the pool.\nThe optimal values of these three parameters will depend on the particulars of how your using your pool, as, together, they represent a tradeoff between how adaptable your pool is and how efficient it is. For example, a large values for all three parameters would mean that your pool is highly adaptable (it can handle spikes in traffic easily), but potentially not very efficient (it might be fetching and subsequently holding on to idle connections that are really no longer needed, if they ever were). On the other hand, small values for these parameters would mean that your pool is very strict about the number of connections it has (it will very rarely allow for idle connections). This may result in an efficient pool if traffic is consistent. However, this type of pool won‚Äôt be able to handle spikes in traffic easily: on one hand, it will often have to do the computationally expensive fetching of connections directly from the database, since it doesn‚Äôt hold on to idle connections for long; on the other hand, once it hits the maxSize number of connections, it won‚Äôt be able to scale up any further.\nConsidering where your pool falls on this spectrum, you should choose the value for these arguments accordingly. For example, if you want a stable pool that will adapt and scale up easily (and you‚Äôre not too worried about efficiency), you could do something like:\nlibrary(DBI)\nlibrary(pool)\n\npool &lt;- dbPool(\n  drv = RMySQL::MySQL(),\n  dbname = \"shinydemo\",\n  host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",\n  username = \"guest\",\n  password = \"guest\",\n  minSize = 10,\n  maxSize = Inf,    # this could have been omitted since it's the default\n  idleTimeout = 3600000  # one hour\n)\n\ndbGetInfo(pool)\n&gt;# $class\n&gt;# [1] \"Pool\"\n&gt;#\n&gt;# $valid\n&gt;# [1] TRUE\n&gt;#\n&gt;# $minSize\n&gt;# [1] 10\n&gt;#\n&gt;# $maxSize\n&gt;# [1] Inf\n&gt;#\n&gt;# $idleTimeout\n&gt;# [1] 3600000\n&gt;#\n&gt;# $pooledObjectClass\n&gt;# [1] \"MySQLConnection\"\n&gt;#\n&gt;# $numberFreeObjects\n&gt;# [1] 9\n&gt;#\n&gt;# $numberTakenObjects\n&gt;# [1] 1",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Using the pool package (advanced)"
    ]
  },
  {
    "objectID": "r/articles/build/pool-advanced/index.html#transactions",
    "href": "r/articles/build/pool-advanced/index.html#transactions",
    "title": "Using the pool package (advanced)",
    "section": "Transactions",
    "text": "Transactions\nSo far, we‚Äôve recommended you always use the Pool object directly when you need to query the database. Given that the pool ‚Äúknows‚Äù when to grow and shrink, for the vast majority of cases, this is a good approach (especially because it means you never have to worry about connection management and leaked connections - this is all taken care of for you). However, there is one type of situation for which this does not apply: transactions. From Wikipedia:\n\nTransactions provide an ‚Äúall-or-nothing‚Äù proposition, stating that each work-unit performed in a database must either complete in its entirety or have no effect whatsoever. Further, the system must isolate each transaction from other transactions, results must conform to existing constraints in the database, and transactions that complete successfully must get written to durable storage.\n\nIn order for these conditions to be met, you need to have access to the same connection for longer than the duration of a query. For example, imagine you‚Äôre transaction consists of two consecutive queries, A and B. You want to make sure that either both of these taken effect or neither does, and that nothing else is going on in the meantime. So the following will not work:\ndbGetQuery(pool, A)\ndbGetQuery(pool, B)\nThe easiest way around this is for you to check a connection from the pool directly, and then use the appropriate DBI transaction functions:\nconn &lt;- poolCheckout(pool)\n\ndbBegin(conn)\ndbGetQuery(conn, A)\ndbGetQuery(conn, B)\ndbCommit(conn)   # or dbRollback(conn) if something went wrong\n\npoolReturn(conn)\nWhen you use poolCheckout(pool) to get an actual connection from the pool, you become responsible for returning to the pool when you‚Äôre done with it (using poolReturn(conn)). If you don‚Äôt do this, this connection will stay open (and count as a taken connection) when, in fact, you no longer need it. So this means that you lose the connection management benefit usually associated with a pool, in return for a finer level of control over transactions. However, you still retain the performance benefits, since you don‚Äôt have to go get a connection all the way to the database: you simply get it from and return it to the pool.\n\nNote\nAs of this moment, DBI‚Äôs development version has a new function called dbWithTransaction that lets you pass in arbitrary R code and makes sure that is treated as a transaction. The advantage is that you don‚Äôt have to remember to do dbBegin and dbCommit or dbRollback ‚Äì that is all taken care of. For instance, the example above could be written as:\nconn &lt;- poolCheckout(pool)\n\ndbWithTransaction(conn, {\n  dbGetQuery(conn, A)\n  dbGetQuery(conn, B)\n})\n\npoolReturn(conn)\nIf an error occurs inside the body of dbWithTransaction, the transaction will be rolled back. If everything is successful, the transaction is committed.\nAs soon as this new DBI feature hits CRAN, the pool package will also wrap it, so that you wouldn‚Äôt actually need to check out a connection directly. Instead, you will simply be able to do:\ndbWithTransaction(pool, {\n  dbGetQuery(pool, A)\n  dbGetQuery(pool, B)\n})\nEven when this becomes a reality, however, it will still be useful to consider the first approach. If you‚Äôre working on a complicated or interactive transaction (for instance, the success of your transaction could depend on some user input), you won‚Äôt be able to do it all at once in a block of code as the example we‚Äôve had so far. In those situations, it will be necessary to directly check out a connection from the pool and then return it when you‚Äôre done.",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Using the pool package (advanced)"
    ]
  },
  {
    "objectID": "r/articles/build/pool-advanced/index.html#future-work",
    "href": "r/articles/build/pool-advanced/index.html#future-work",
    "title": "Using the pool package (advanced)",
    "section": "Future work",
    "text": "Future work\nThe pool package is still hot off the press at this point, so there are some features that are still in development. Let us know if there is something else that would be important for your app that we haven‚Äôt covered anywhere.\nRight now, here are some of the the limitations of pool that we hope will be addressed in future releases:\n\n\nSecurity and privacy: You may have noticed that in all examples throughout this series of articles, we‚Äôve hardcoded the username and password credentials to access a database directly in the dbPool() function. If these are not read-only (and maybe even in that case), this is not a very good idea. For reasons of privacy and security, you shouldn‚Äôt read authorization arguments directly from the Shiny app. We hope to provide a friendly interface to do this in the near future.\n\nUser-defined variables: If you need to modify a connection‚Äôs default variables (which should be a fairly uncommon practice), you probably should not use the pool package. For example, let‚Äôs say your database connections are, by default, encoded in latin1, and you check out a connection and change the encoding to utf8:\nconn &lt;- poolCheckout(pool)\ndbSendQuery(conn, \"SET NAMES utf8;\")\n# do something with conn\npoolReturn(conn)\nAs of right now, these user-defined variables don‚Äôt get reset when you return a connection to the pool. So, you either never set variables on connections, or if you do, you can never be sure if the next connection you fetch from the pool will be brand new (default settings) or a connection whose settings were previously changed. Since the latter is really undesirable, we currently recommend that you don‚Äôt use pool if you do need to set variables at the connection level. In order for the resetting behavior to be supported by pool, it would first have to be supported by DBI (which in turn means that it would have to be first supported by all the DBI-compliant drivers). So, there is no telling when this difficulty may be overcome.\n\nNoSQL databases: At the moment, both DBI and pool only support relational databases (like SQLite, MySQL and PostgreSQL). If you wish to integrate a NoSQL database (e.g.¬†MongoDB) into your Shiny app, we hope that these articles will still have helped give a sense of best practices and common problems that may arise. However, the burden will be mostly on you to find out the correct driver for your database and how to do your own connection management (if you‚Äôre an overachiever, consider implementing your own backend to the pool package by following the instructions on its Github page).",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Using the pool package (advanced)"
    ]
  },
  {
    "objectID": "r/articles/build/pool-dplyr/index.html",
    "href": "r/articles/build/pool-dplyr/index.html",
    "title": "Using dplyr and pool to query a database",
    "section": "",
    "text": "Note (6/22/17): pool is now compatible with dplyr 0.7.0 and the brand new dbplyr. If you want to continue using pool with an older version of dplyr, please install pool@dplyr-pre-0.7.0-compat (devtools::install_github(\"rstudio/pool@dplyr-pre-0.7.0-compat).",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Using dplyr and pool to query a database"
    ]
  },
  {
    "objectID": "r/articles/build/pool-dplyr/index.html#installation",
    "href": "r/articles/build/pool-dplyr/index.html#installation",
    "title": "Using dplyr and pool to query a database",
    "section": "Installation",
    "text": "Installation\nThere are four packages that you need throughout this series of articles. Here are the installation instructions, so your code runs smoothly:\n# get shiny, DBI, dplyr and dbplyr from CRAN\ninstall.packages(\"shiny\")\ninstall.packages(\"DBI\")\ninstall.packages(\"dplyr\")\ninstall.packages(\"dbplyr\")\n\n# get pool from GitHub, since it's not yet on CRAN\ndevtools::install_github(\"rstudio/pool\")",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Using dplyr and pool to query a database"
    ]
  },
  {
    "objectID": "r/articles/build/pool-dplyr/index.html#motivation",
    "href": "r/articles/build/pool-dplyr/index.html#motivation",
    "title": "Using dplyr and pool to query a database",
    "section": "Motivation",
    "text": "Motivation\nMany of you might be using dplyr to connect to your database, especially because it allows you to query it using R code, rather than the more cumbersome SQL equivalent. For this reason and for performance, we‚Äôd actually recommend users to use dplyr by default, unless they actually need more functionality and must turn to DBI instead (when it comes to databases, dplyr only allows you to do queries that can be transformed into a SELECT SQL statement). If you‚Äôre not familiar with dplyr applied to databases, make sure to read the section about this on the first article of this series.\nHere‚Äôs why dplyr tends to perform better than DBI (from dplyr‚Äôs vignette about databases):\n\nWhen working with databases, dplyr tries to be as lazy as possible:\n\nIt never pulls data into R unless you explicitly ask for it.\nIt delays doing any work until the last possible moment: it collects together everything you want to do and then sends it to the database in one step.\n\n\nBut on top of this, it‚Äôs possible to get even better performance by using a pool. Most importantly, however, you should use a pool for its connection management benefits. To do so, you only need to do minor changes to your existing code.",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Using dplyr and pool to query a database"
    ]
  },
  {
    "objectID": "r/articles/build/pool-dplyr/index.html#combining-dplyr-and-pool",
    "href": "r/articles/build/pool-dplyr/index.html#combining-dplyr-and-pool",
    "title": "Using dplyr and pool to query a database",
    "section": "Combining dplyr and pool",
    "text": "Combining dplyr and pool\n\nComparison to dplyr code\nFirst, let‚Äôs consider how you‚Äôd connect to and query a MySQL database using only dplyr:\nlibrary(dplyr)\n\nmy_db &lt;- dbPool(\n  RMySQL::MySQL(), \n  dbname = \"shinydemo\",\n  host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",\n  username = \"guest\",\n  password = \"guest\"\n)\n\n# get the first 5 rows:\nmy_db %&gt;% tbl(\"City\") %&gt;% head(5)\n## # Source:   lazy query [?? x 5]\n## # Database: mysql 10.0.17-MariaDB [guest@shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com:/shinydemo]\n##      ID           Name CountryCode      District Population\n##   &lt;dbl&gt;          &lt;chr&gt;       &lt;chr&gt;         &lt;chr&gt;      &lt;dbl&gt;\n## 1     1          Kabul         AFG         Kabol    1780000\n## 2     2       Qandahar         AFG      Qandahar     237500\n## 3     3          Herat         AFG         Herat     186800\n## 4     4 Mazar-e-Sharif         AFG         Balkh     127800\n## 5     5      Amsterdam         NLD Noord-Holland     731200\nNow, let‚Äôs do the same thing using a Pool object:\nlibrary(pool)\nlibrary(dplyr)\n\npool &lt;- dbPool(\n  drv = RMySQL::MySQL(),\n  dbname = \"shinydemo\",\n  host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",\n  username = \"guest\",\n  password = \"guest\"\n)\n\n# get the first 5 rows:\npool %&gt;% tbl(\"City\") %&gt;% head(5)\n## # Source:   lazy query [?? x 5]\n## # Database: mysql 10.0.17-MariaDB [guest@shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com:/shinydemo]\n##      ID           Name CountryCode      District Population\n##   &lt;dbl&gt;          &lt;chr&gt;       &lt;chr&gt;         &lt;chr&gt;      &lt;dbl&gt;\n## 1     1          Kabul         AFG         Kabol    1780000\n## 2     2       Qandahar         AFG      Qandahar     237500\n## 3     3          Herat         AFG         Herat     186800\n## 4     4 Mazar-e-Sharif         AFG         Balkh     127800\n## 5     5      Amsterdam         NLD Noord-Holland     731200\n\n\nShiny apps\nWhat‚Äôs the advantage of using pool with dplyr, rather than just using dplyr to query a database? As usual with pool, the answer is performance and connection management. In order to reap these benefits within a Shiny app, however, you need to be careful about where you create your pool and where you use tbl (or equivalent). The same idea that we used for combining DBI and pool, also applies here. First, you should create your pool at the top of server.R (or in global.R), but outside the actual server function. Then, for each query, you should use tbl (or equivalent). In a Shiny app, this means that each reactive or function that queries the database has its own call to tbl. For example, here‚Äôs the same app used in the pool basics article, but written with dplyr instead of DBI:\nlibrary(shiny)\nlibrary(DBI)\nlibrary(pool)\n\npool &lt;- dbPool(\n  drv = RMySQL::MySQL(),\n  dbname = \"shinydemo\",\n  host = \"shiny-demo.csa7qlmguqrf.us-east-1.rds.amazonaws.com\",\n  username = \"guest\",\n  password = \"guest\"\n)\n\nui &lt;- fluidPage(\n  textInput(\"ID\", \"Enter your ID:\", \"5\"),\n  tableOutput(\"tbl\"),\n  numericInput(\"nrows\", \"How many cities to show?\", 10),\n  plotOutput(\"popPlot\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$tbl &lt;- renderTable({\n    pool %&gt;% tbl(\"City\") %&gt;%\n      filter(ID == input$ID)\n  })\n  output$popPlot &lt;- renderPlot({\n    df &lt;- pool %&gt;% tbl(\"City\") %&gt;%\n      head(as.integer(input$nrows)[1]) %&gt;% collect()\n    pop &lt;- df$Population\n    names(pop) &lt;- df$Name\n    barplot(pop)\n  })\n}\n\nshinyApp(ui, server)\nYou‚Äôll note that there is no need to do our own input sanitizing for SQL injection prevention (i.e.¬†no need to call a function like DBI‚Äôs sqlInterpolate). This is because dplyr acts a middleman between you and the actual SQL query sent to the database; as that middleman, it also sanitizes your inputs for you.",
    "crumbs": [
      "Build",
      "Backend",
      "Data",
      "Using dplyr and pool to query a database"
    ]
  },
  {
    "objectID": "r/articles/build/reactivity-overview/index.html",
    "href": "r/articles/build/reactivity-overview/index.html",
    "title": "Reactivity - An overview",
    "section": "",
    "text": "It‚Äôs easy to build interactive applications with Shiny, but to get the most out of it, you‚Äôll need to understand the reactive programming model used by Shiny.\nIn Shiny, there are three kinds of objects in reactive programming: reactive sources, reactive conductors, and reactive endpoints, which are represented with these symbols:\n\n\n\nReactive roles\n\n\n\nReactive sources and endpoints\nThe simplest structure of a reactive program involves just a source and an endpoint:\n\n\n\nSimplest structure\n\n\nIn a Shiny application, the source typically is user input through a browser interface. For example, when the user selects an item, types input, or clicks on a button, these actions will set values that are reactive sources. A reactive endpoint is usually something that appears in the user‚Äôs browser window, such as a plot or a table of values.\nIn a simple Shiny application, reactive sources are accessible through the input object, and reactive endpoints are accessible through the output object. (Actually, there are other possible kinds of sources and endpoints, which we‚Äôll talk about later, but for now we‚Äôll just talk about input and output.)\nThis simple structure, with one source and one endpoint, is used by the 01_hello example. The server function code for that example looks something like this:\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlot({\n    hist(rnorm(input$obs))\n  })\n}\n\n\n\nStructure of 01_hello\n\n\nYou can see it in action at https://gallery.shinyapps.io/01_hello/.\nThe output$distPlot object is a reactive endpoint, and it uses the reactive source input$obs. Whenever input$obs changes, output$distPlot is notified that it needs to re-execute. In traditional program with an interactive user interface, this might involve setting up event handlers and writing code to read values and transfer data. Shiny does all these things for you behind the scenes, so that you can simply write code that looks like regular R code.\nA reactive source can be connected to multiple endpoints, and vice versa. Here is the server function of a slightly more complex Shiny application:\nserver &lt;- function(input, output) {\n  output$plotOut &lt;- renderPlot({\n    hist(faithful$eruptions, breaks = as.numeric(input$nBreaks))\n    if (input$individualObs)\n      rug(faithful$eruptions)\n  })\n\n  output$tableOut &lt;- renderTable({\n    if (input$individualObs)\n      faithful\n    else\n      NULL\n  })\n}\n\n\n\nStructure of Old Faithful example\n\n\nIn a Shiny application, there‚Äôs no need to explictly describe each of these relationships and tell R what to do when each input component changes; Shiny automatically handles these details for you.\nIn an app with the structure above, whenever the value of the input$nBreaks changes, the expression that generates the plot will automatically re-execute. Whenever the value of the input$individualObs changes, the plot and table functions will automatically re-execute. (In a Shiny application, most endpoint functions have their results automatically wrapped up and sent to the web browser.)\n\n\nReactive conductors\nSo far we‚Äôve seen reactive sources and reactive endpoints, and most simple examples use just these two components, wiring up sources directly to endpoints. It‚Äôs also possible to put reactive components in between the sources and endpoints. These components are called reactive conductors.\nA conductor can both be a dependent and have dependents. In other words, it can be both a parent and child in a graph of the reactive structure. Sources can only be parents (they can have dependents), and endpoints can only be children (they can be dependents) in the reactive graph.\nReactive conductors can be useful for encapsulating slow or computationally expensive operations. For example, imagine that you have this application that takes a value input$n and prints the _n_th value in the Fibonacci sequence, as well as the inverse of _n_th value in the sequence plus one (note the code in these examples is condensed to illustrate reactive concepts, and doesn‚Äôt necessarily represent coding best practices):\n# Calculate nth number in Fibonacci sequence\nfib &lt;- function(n) ifelse(n&lt;3, 1, fib(n-1)+fib(n-2))\n\nserver &lt;- function(input, output) {\n  output$nthValue    &lt;- renderText({ fib(as.numeric(input$n)) })\n  output$nthValueInv &lt;- renderText({ 1 / fib(as.numeric(input$n)) })\n}\nThe graph structure of this app is:\n\n\n\nFibonacci app without conductor\n\n\nThe fib() algorithm is very inefficient, so we don‚Äôt want to run it more times than is absolutely necessary. But in this app, we‚Äôre running it twice! On a reasonably fast modern machine, setting input$n to 30 takes about 15 seconds to calculate the answer, largely because fib() is run twice.\nThe amount of computation can be reduced by adding a reactive conductor in between the source and endpoints:\nfib &lt;- function(n) ifelse(n&lt;3, 1, fib(n-1)+fib(n-2))\n\nserver &lt;- function(input, output) {\n  currentFib         &lt;- reactive({ fib(as.numeric(input$n)) })\n\n  output$nthValue    &lt;- renderText({ currentFib() })\n  output$nthValueInv &lt;- renderText({ 1 / currentFib() })\n}\nHere is the new graph structure:\n\n\n\nFibonacci app with conductor\n\n\nKeep in mind that if your application tries to access reactive values or expressions from outside a reactive context ‚Äî that is, outside of a reactive expression or observer ‚Äî then it will result in an error. You can think of there being a reactive ‚Äúworld‚Äù which can see and change the non-reactive world, but the non-reactive world can‚Äôt do the same to the reactive world. Code like this will not work, because the call to fib() is not in the reactive world (it‚Äôs not in a reactive() or renderXX() call) but it tries to access something that is, the reactive value input$n:\nserver &lt;- function(input, output) {\n  # Will give error\n  currentFib      &lt;- fib(as.numeric(input$n))\n  output$nthValue &lt;- renderText({ currentFib })\n}\nOn the other hand, if currentFib is a function that accesses a reactive value, and that function is called within the reactive world, then it will work:\nserver &lt;- function(input, output) {\n  # OK, as long as this is called from the reactive world:\n  currentFib &lt;- function() {\n    fib(as.numeric(input$n))\n  }\n\n  output$nthValue &lt;- renderText({ currentFib() })\n}\n\n\nSummary\nIn this section, we‚Äôve learned about:\n\nReactive sources can signal objects downstream that they need to re-execute.\nReactive conductors are placed somewhere in between sources and endpoints on the reactive graph. They are typically used for encapsulating slow operations.\nReactive endpoints can be told to re-execute by the reactive environment, and can request upstream objects to execute.\nInvalidation arrows diagram the flow of invalidation events. It can also be said that the child node is a dependent of or takes a dependency on the parent node.\n\n\n\nImplementations of sources, conductors, and endpoints: values, expressions, and observers\nWe‚Äôve discussed reactive sources, conductors, and endpoints. These are general terms for parts that play a particular role in a reactive program. Presently, Shiny has one class of objects that act as reactive sources, one class of objects that act as reactive conductors, and one class of objects that act as reactive endpoints, but in principle there could be other classes that implement these roles.\n\nReactive values are an implementation of Reactive sources; that is, they are an implementation of that role.\nReactive expressions are an implementation of Reactive conductors. They can access reactive values or other reactive expressions, and they return a value.\nObservers are an implementation of Reactive endpoints. They can access reactive sources and reactive expressions, and they don‚Äôt return a value; they are used for their side effects.\n\n\n\n\nImplementations of reactive roles\n\n\nAll of the examples use these three implementations, as there are presently no other implementations of the source, conductor, and endpoint roles.\n\n\nReactive values\nReactive values contain values (not surprisingly), which can be read by other reactive objects. The input object is a ReactiveValues object, which looks something like a list, and it contains many individual reactive values. The values in input are set by input from the web browser.\n\n\nReactive expressions\nWe‚Äôve seen reactive expressions in action, with the Fibonacci example above. They cache their return values, to make the app run more efficiently. Note that, abstractly speaking, reactive conductors do not necessarily cache return values, but in this implementation, reactive expressions, they do.\nA reactive expressions can be useful for caching the results of any procedure that happens in response to user input, including:\n\naccessing a database\nreading data from a file\ndownloading data over the network\nperforming an expensive computation\n\n\n\nObservers\nObservers are similar to reactive expressions, but with a few important differences. Like reactive expressions, they can access reactive values and reactive expressions. However, they do not return any values, and therefore do not cache their return values. Instead of returning values, they have side effects ‚Äì typically, this involves sending data to the web browser.\nThe output object looks something like a list, and it can contain many individual observers.\nIf you look at the code for renderText() and friends, you‚Äôll see that they each return a function which returns a value. They‚Äôre typically used like this:\noutput$number &lt;- renderText({ as.numeric(input$n) + 1 })\nThis might lead you to think that the observers do return values. However, this isn‚Äôt the whole story. The function returned by renderText() is actually not an observer/endpoint. When it is assigned to output$x, the function returned by renderText() gets automatically wrapped into another function, which is an observer. The wrapper function is used because it needs to do special things to send the data to the browser.\n\n\nDifferences between reactive expressions and observers\nReactive expressions and observers are similar in that they store expressions that can be executed, but they have some fundamental differences.\n\nObservers (and endpoints in general) respond to reactive flush events, but reactive expressions (and conductors in general) do not. We‚Äôll learn more about flush events in the next section. If you want a reactive expression to execute, it must have an observer as a descendant on the reactive dependency graph.\nReactive expressions return values, but observers don‚Äôt.",
    "crumbs": [
      "Build",
      "Backend",
      "Reactivity",
      "Reactivity - An overview"
    ]
  },
  {
    "objectID": "r/articles/build/rm-cheatsheet/index.html",
    "href": "r/articles/build/rm-cheatsheet/index.html",
    "title": "The R Markdown cheatsheet",
    "section": "",
    "text": "The R Markdown cheatsheet is a quick reference guide for writing reproducible reports with R Markdown.\n\n\nDownload R Markdown Cheatsheet\n\n\nSee all cheatsheets",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "The R Markdown cheatsheet"
    ]
  },
  {
    "objectID": "r/articles/build/rmd-integration/index.html",
    "href": "r/articles/build/rmd-integration/index.html",
    "title": "R Markdown integration in the RStudio IDE",
    "section": "",
    "text": "Introduction to interactive documents describes how to use R Markdown to build light-weight Shiny apps that are easy to assemble.\nThe RStudio IDE contains many features that make it easy to write and run interactive documents. This article will highlight some of the most useful:",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "R Markdown integration in the RStudio IDE"
    ]
  },
  {
    "objectID": "r/articles/build/rmd-integration/index.html#file-templates",
    "href": "r/articles/build/rmd-integration/index.html#file-templates",
    "title": "R Markdown integration in the RStudio IDE",
    "section": "1. File templates",
    "text": "1. File templates\nThe RStudio IDE provides a template document when you open a new .Rmd file. To open a new file, click File &gt; New File &gt; R Markdown in the RStudio menu bar.\n\nA window will pop up that helps you build the YAML frontmatter for the .Rmd file.\n\nFrom the window‚Äôs sidebar, select the category of output that you plan to convert your .Rmd file into. You can select\n\nDocument - a static document\nPresentation - an ioslides or beamer slideshow\nShiny - an interactive document\nFrom Template - a format that you have pre-saved as a template (if you have one)\n\nUse the radio buttons to select the specific type of output that you wish to build. Your options will depend on the category you selected in the sidebar.\nYou can also use the window to give your file a title and author field.\nTo make an interactive document, select Shiny from the sidebar and Shiny Document from the radio buttons. Then click OK.\nRStudio will open a new .Rmd file for you to use. The file will contain a YAML header that includes all of the parameters that your file will need to correctly render with rmarkdown::render(). You can manually change these parameters afterwords if you like.\nRStudio will fill the rest of the file with a template that demonstrates the basic features of .Rmd files. The templates work right out of the box, which means that you can immediately knit or run one. The image below shows the template for interactive documents.\n\nStudy the template as a refresher on R Markdown, or erase it and begin writing your own document.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "R Markdown integration in the RStudio IDE"
    ]
  },
  {
    "objectID": "r/articles/build/rmd-integration/index.html#using-r-markdown",
    "href": "r/articles/build/rmd-integration/index.html#using-r-markdown",
    "title": "R Markdown integration in the RStudio IDE",
    "section": "2. Using R Markdown",
    "text": "2. Using R Markdown\nThe IDE places a question mark icon in the scripts pane whenever you open a .Rmd file. The question mark opens a drop down menu with two helpful resources.\n\nThe first option, ‚ÄúUsing R Markdown,‚Äù opens the development website for the rmarkdown package, rmarkdown.rstudio.com. Here you can look up the many useful features of R Markdown.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "R Markdown integration in the RStudio IDE"
    ]
  },
  {
    "objectID": "r/articles/build/rmd-integration/index.html#markdown-quick-reference",
    "href": "r/articles/build/rmd-integration/index.html#markdown-quick-reference",
    "title": "R Markdown integration in the RStudio IDE",
    "section": "3. Markdown Quick Reference",
    "text": "3. Markdown Quick Reference\nThe second link, ‚ÄúMarkdown Quick Reference,‚Äù opens a reference guide to the markdown syntax. This guide will appear in the help pane of the RStudio IDE.\nThe guide uses examples to explain the different formatting options of markdown. It is like a markdown cheat sheet that is built right in to the RStudio IDE.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "R Markdown integration in the RStudio IDE"
    ]
  },
  {
    "objectID": "r/articles/build/rmd-integration/index.html#the-run-document-button",
    "href": "r/articles/build/rmd-integration/index.html#the-run-document-button",
    "title": "R Markdown integration in the RStudio IDE",
    "section": "4. The Run Document button",
    "text": "4. The Run Document button\nIf your .Rmd file contains runtime: shiny in its YAML header, the RStudio IDE will display a ‚ÄúRun Document‚Äù button at the top of the scripts pane.\n\nThe ‚ÄúRun Document‚Äù button is a shortcut for the rmarkdown::render command. It let‚Äôs you quickly render your .Rmd file into an interactive document hosted locally on your computer. The RStudio IDE will diplay your document in a preview window.\nYou can edit the .Rmd file while the preview is running. To see your changes, save the .Rmd file. Then click the refresh icon in the top left corner of the preview window.\n\nIf your .Rmd file does not contain runtime: shiny, the RStudio IDE will display a ‚ÄúKnit HTML‚Äù button in place of the ‚ÄúRun Document‚Äù button. The ‚ÄúKnit HTML‚Äù button works in the same way. It renders your .Rmd file and launches a preview of your output document.\nThe Knit HTML button contains a dropdown menu that let‚Äôs you choose which type of output to knit your file into (this will override the output type specified in your file‚Äôs YAML header).",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "R Markdown integration in the RStudio IDE"
    ]
  },
  {
    "objectID": "r/articles/build/rmd-integration/index.html#viewer-pane",
    "href": "r/articles/build/rmd-integration/index.html#viewer-pane",
    "title": "R Markdown integration in the RStudio IDE",
    "section": "5. Viewer Pane",
    "text": "5. Viewer Pane\nBy default, the RStudio IDE opens a preview window to display the output of your .Rmd file. However, you can choose to display the output in a dedicated viewer pane.\nTo do this, select ‚ÄúView in Pane‚Äù for m the drop down menu that appears when you click on the ‚ÄúRun Document‚Äù button (or ‚ÄúKnit HTML‚Äù button).\nThe viewer pane provides a side-by-side view that resembles some text and Latex editors.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "R Markdown integration in the RStudio IDE"
    ]
  },
  {
    "objectID": "r/articles/build/rmd-integration/index.html#document-options",
    "href": "r/articles/build/rmd-integration/index.html#document-options",
    "title": "R Markdown integration in the RStudio IDE",
    "section": "6. Document options",
    "text": "6. Document options\nThe gear icon beside ‚ÄúRun Document‚Äù opens a wizard that lets you customize your interactive document. You can use this wizard to\n\nInclude a table of contents\nApply syntax highlighting to code chunks\nApply one of eight built in bootstrap CSS themes to your document\nLink to your own custom CSS file to style your document\nNumber section headings\nSize figures and add captions, and\nTweak the render process\n\n\nSet the features you like, and the RStudio IDE will apply them when you click ‚ÄúRun Document‚Äù.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "R Markdown integration in the RStudio IDE"
    ]
  },
  {
    "objectID": "r/articles/build/rmd-integration/index.html#insert-chunk",
    "href": "r/articles/build/rmd-integration/index.html#insert-chunk",
    "title": "R Markdown integration in the RStudio IDE",
    "section": "7. Insert Chunk",
    "text": "7. Insert Chunk\nThe Chunks button in the top left corner of the Scripts pane opens a dropdown menu that you can use to manage code chunks in your .Rmd file.\n\nThe first option in the menu is the most useful. ‚ÄúInsert Chunk‚Äù will insert a blank code chunk into your .Rmd file at the location of your cursor. You can then fill this chunk with code.\nYou can use basic RStudio tab completion to write arguments inside the {r} braces at the top of each code chunk.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "R Markdown integration in the RStudio IDE"
    ]
  },
  {
    "objectID": "r/articles/build/rmd-integration/index.html#deploy-to-shinyapps.io",
    "href": "r/articles/build/rmd-integration/index.html#deploy-to-shinyapps.io",
    "title": "R Markdown integration in the RStudio IDE",
    "section": "8. Deploy to shinyapps.io",
    "text": "8. Deploy to shinyapps.io\nIf you‚Äôve set up the shinyapps package as described in Getting started with shinyapps.io, the RStudio IDE will place a deploy button at the top of your interactive document‚Äôs preview window.\n\nYou can click this button to deploy your document directly to your shinyapps.io account. Shinyapps.io will host the document at its own web URL for people to visit.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "R Markdown integration in the RStudio IDE"
    ]
  },
  {
    "objectID": "r/articles/build/rmd-integration/index.html#the-r-markdown-console",
    "href": "r/articles/build/rmd-integration/index.html#the-r-markdown-console",
    "title": "R Markdown integration in the RStudio IDE",
    "section": "9. The R Markdown console",
    "text": "9. The R Markdown console\nWhen you render a .Rmd file, the RStudio IDE opens a second console pane that displays R Markdown output. This pane shows the status of the render process and displays any errors or warnings that occur while rendering your document. If your document is an interactive document, the pane will also display errors that occur while you navigate the app.\nThis extra pane keeps your original R console clean and uncluttered.",
    "crumbs": [
      "Build",
      "Structure",
      "Interactive documents",
      "R Markdown integration in the RStudio IDE"
    ]
  },
  {
    "objectID": "r/articles/build/selectize/index.html",
    "href": "r/articles/build/selectize/index.html",
    "title": "Using selectize input",
    "section": "",
    "text": "The JavaScript library selectize.js provides a much more flexible interface compared to the basic select input. It allows you to type and search in the options, use placeholders, control the number of options/items to show/select, and so on. See here for an example app.\nTo create a selectize input, you can use the function selectizeInput(), and the usage is very similar to selectInput():\nA major difference between the usage of selectizeInput() and selectInput() is the options argument, which is a list of parameters to initialize the selectize input. Please check out the usage documentation of selectize.js for all the possible parameters. This example shows a side by side comparision between selectize and select input.\nWhen we type in the input box, selectize will start searching for the options that partially match the string we typed. The searching can be done on the client side (default behavior), when all the possible options have been written on the HTML page. It can also be done on the server side, using R to match the string and return results. This is particularly useful when the number of choices is very large. For example, when there are 100,000 choices for the selectize input, it will be slow to write all of them at once into the page, but we can start from an empty selectize input, and only fetch the choices that we may need, which can be much faster. We will introduce both types of the selectize input below.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Using selectize input"
    ]
  },
  {
    "objectID": "r/articles/build/selectize/index.html#client-side-selectize",
    "href": "r/articles/build/selectize/index.html#client-side-selectize",
    "title": "Using selectize input",
    "section": "Client-side selectize",
    "text": "Client-side selectize\nThe selectize input returns the item(s) that you selected, but keep in mind that it may also return an empty string when all the selected items are deleted using the key Backspace or Delete.\nWe can make use of the options argument to specify a list of initialization options. Here are some quick examples:\n# allow creation of new items in the drop-down list\nselectizeInput(\n  'foo', label = NULL, choices = state.name,\n  options = list(create = TRUE)\n)\n\n# show at most 5 options in the list\nselectizeInput(..., options = list(maxOptions = 5))\n\n# allow at most 2 items to be selected\nselectizeInput(..., options = list(maxItems = 2))\n\n# add a placeholder in the text box\nselectizeInput(..., options = list(placeholder = 'select a state name'))\nOf course, you can combine multiple options, e.g.\nselectizeInput(..., options = list(maxItems = 3, placeholder = 'hi there'))",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Using selectize input"
    ]
  },
  {
    "objectID": "r/articles/build/selectize/index.html#server-side-selectize",
    "href": "r/articles/build/selectize/index.html#server-side-selectize",
    "title": "Using selectize input",
    "section": "Server-side selectize",
    "text": "Server-side selectize\nThe client-side selectize input relies solely on JavaScript to process searching on typing. The server-side selectize input uses R to process searching, and R will return the filtered data to selectize. To use the server version, you need to create a selectize instance in the UI, and update it to the server version:\n# in ui\nselectizeInput('foo', choices = NULL, ...)\n\n# in server\nserver &lt;- function(input, output, session) {\n  updateSelectizeInput(session, 'foo', choices = data, server = TRUE)\n}\nYou may use choices = NULL to create an empty selectize instance, so that it will load quickly initially, then use updateSelectize(server = TRUE) to pass the choices data to R. Here data can be an arbitrary R data object, such as a (named) character vector, or a data frame. Note the client-side selectize can only accept a character vector for the choices argument.\nWhat happens when we type in the text box is:\n\nthe character string in the text box is sent to R, and split into multiple keywords using white spaces;\nR matches each keyword in the variable(s) specified in the searchField option of selectize initialization options;\ndepending on the searchConjunction option ('and' or 'or'), the results from each keyword are combined using AND or OR;\nthe first maxOptions records of the data is returned (as JSON);\n\nWhen we use the server version of selectize, we may want to define the render method for selectize, although normally the default rendering method should just work. A custom rendering method allows us to create richer content in the drop-down list, instead of just some plain text options. This example shows how we can render images in the options.\nupdateSelectizeInput(..., options = list(render = I(\n  '{\n    option: function(item, escape) {\n      // your own code to generate HTML here for each option item\n    }\n  }'\n)))\nThe options element of the render object is a JavaScript function that has two arguments, item and escape. Please read the selectize.js documentation to understand what they mean. Basically you can treat item as a record in the data that we passed in as choices. For example, if choices = state.name, an item might be\n{\n  label: \"California\",\n  value: \"California\"\n}\nYou can define the rendering method for options as\nfunction(item, escape) {\n  return \"&lt;div&gt;\" + escape(item.value) + \"&lt;/div&gt;\";\n}\nThis means we create a div for each of the items, and the div contains their values. This is a very simple example, and we can use more complicated data objects, and write rendering methods accordingly. Here is a quick example:\nupdateSelectizeInput(\n  ...,\n  choices = cbind(name = rownames(mtcars), mtcars),\n  options = list(render = I(\n  '{\n    option: function(item, escape) {\n      return \"&lt;div&gt;&lt;strong&gt;\" + escape(item.name) + \"&lt;/strong&gt; (\" +\n             \"MPG: \" + item.mpg +\n             \", Transmission: \" + item.am == 1 ? \"automatic\" : \"manual\" + \")\"\n    }\n  }'))\n)\nThen in the drop-down list, we will see the name of the car in bold text, and the variables mpg and am in the parentheses (e.g.¬†Mazda RX4 (MPG: 21.0, Transmission: manual)).",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Using selectize input"
    ]
  },
  {
    "objectID": "r/articles/build/sliders/index.html",
    "href": "r/articles/build/sliders/index.html",
    "title": "Using sliders",
    "section": "",
    "text": "The Sliders app demonstrates the many capabilities of slider controls, including the ability to run an animation sequence.\n\n\n\nSliders Screenshot\n\n\nTo run the example locally type:\nlibrary(shiny)\nrunExample(\"05_sliders\")\n\nCustomizing Sliders\nShiny slider controls are extremely capable and customizable. Features supported include:\n\nThe ability to input both single values and ranges\nCustom formats for value display (e.g for currency)\nThe ability to animate the slider across a range of values\n\nSlider controls are created by calling the sliderInput function. The UI demonstrates using sliders with a variety of options:\n\nui\n# Define UI for slider demo app ----\nui &lt;- fluidPage(\n\n  # App title ----\n  titlePanel(\"Sliders\"),\n\n  # Sidebar layout with input and output definitions ----\n  sidebarLayout(\n\n    # Sidebar to demonstrate various slider options ----\n    sidebarPanel(\n\n      # Input: Simple integer interval ----\n      sliderInput(\"integer\", \"Integer:\",\n                  min = 0, max = 1000,\n                  value = 500),\n\n      # Input: Decimal interval with step value ----\n      sliderInput(\"decimal\", \"Decimal:\",\n                  min = 0, max = 1,\n                  value = 0.5, step = 0.1),\n\n      # Input: Specification of range within an interval ----\n      sliderInput(\"range\", \"Range:\",\n                  min = 1, max = 1000,\n                  value = c(200,500)),\n\n      # Input: Custom currency format for with basic animation ----\n      sliderInput(\"format\", \"Custom Format:\",\n                  min = 0, max = 10000,\n                  value = 0, step = 2500,\n                  pre = \"$\", sep = \",\",\n                  animate = TRUE),\n\n      # Input: Animation with custom interval (in ms) ----\n      # to control speed, plus looping\n      sliderInput(\"animation\", \"Looping Animation:\",\n                  min = 1, max = 2000,\n                  value = 1, step = 10,\n                  animate =\n                    animationOptions(interval = 300, loop = TRUE))\n\n    ),\n\n    # Main panel for displaying outputs ----\n    mainPanel(\n\n      # Output: Table summarizing the values entered ----\n      tableOutput(\"values\")\n\n    )\n  )\n)\n\n\n\nServer Script\nThe server side of the Slider application is very straightforward ‚Äì it creates a data frame containing all of the input values and then renders it as an HTML table:\n\nserver\n# Define server logic for slider examples ----\nserver &lt;- function(input, output) {\n\n  # Reactive expression to create data frame of all input values ----\n  sliderValues &lt;- reactive({\n\n    data.frame(\n      Name = c(\"Integer\",\n               \"Decimal\",\n               \"Range\",\n               \"Custom Format\",\n               \"Animation\"),\n      Value = as.character(c(input$integer,\n                             input$decimal,\n                             paste(input$range, collapse = \" \"),\n                             input$format,\n                             input$animation)),\n      stringsAsFactors = FALSE)\n\n  })\n\n  # Show the values in an HTML table ----\n  output$values &lt;- renderTable({\n    sliderValues()\n  })\n\n}",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Using sliders"
    ]
  },
  {
    "objectID": "r/articles/build/tabsets/index.html",
    "href": "r/articles/build/tabsets/index.html",
    "title": "Tabsets",
    "section": "",
    "text": "Tabsets Screenshot\n\n\nThe Tabsets application demonstrates using tabs to organize output. To run the example type:\nlibrary(shiny)\nrunExample(\"06_tabsets\")\n\nTab Panels\nTabsets are created by combining nav_panels()s in a navigation container. The bslib package provides many styles of navigation containers, including:\n\nnavset_underline() and navset_card_underline()\nnavset_tab() and navset_card_tab()\nnavset_pill_list()\nnavset_pill() and navset_card_pill()\nnavset_hidden()\nnavset_bar()\n\nEach allows the user to navigate the panels in a different way. Functions that contain card in their name place the navigation container within its own card.\nIn this example, we added a summary and table view of the data to the Hello Shiny app, each rendered in their own panel. We combined the panels with a navigation element that underlines the name of the active tab. Here is the source code for the UI object:\nlibrary(shiny)\nlibrary(bslib)\n\n# Define UI for random distribution app ----\n# Sidebar layout with input and output definitions ----\nui &lt;- page_sidebar(\n\n  # App title ----\n  title =\"Tabsets\",\n\n  # Sidebar panel for inputs ----\n  sidebar = sidebar(\n\n    # Input: Select the random distribution type ----\n    radioButtons(\"dist\", \"Distribution type:\",\n                 c(\"Normal\" = \"norm\",\n                   \"Uniform\" = \"unif\",\n                   \"Log-normal\" = \"lnorm\",\n                   \"Exponential\" = \"exp\")),\n    # br() element to introduce extra vertical spacing ----\n    br(),\n    # Input: Slider for the number of observations to generate ----\n    sliderInput(\"n\",\n                \"Number of observations:\",\n                value = 500,\n                min = 1,\n                max = 1000)\n  ),\n\n  # Main panel for displaying outputs ----\n  # Output: A tabset that combines three panels ----\n  navset_card_underline(\n    title = \"Visualizations\",\n    # Panel with plot ----\n    nav_panel(\"Plot\", plotOutput(\"plot\")),\n\n    # Panel with summary ----\n    nav_panel(\"Summary\", verbatimTextOutput(\"summary\")),\n\n    # Panel with table ----\n    nav_panel(\"Table\", tableOutput(\"table\"))\n  )\n)\nBuilding a tabset is very similar to building a multi-page app. Instead of passing nav_panel()s to page_navbar(), we instead pass them to a navigation container. Also, just as with a multi-page app, we can use bslib‚Äôs nav_spacer(), to control the alignment of UI elements in the tabset‚Äôs navbar, and nav_item(), to add items to the navbar, such as an html link.\n\n\nTabs and Reactive Data\nIntroducing tabs into our user interface underlines the importance of creating reactive expressions for shared data. In this example, each tab provides its own view of the dataset. If the dataset is expensive to compute then our user interface might be quite slow to render. The server function below demonstrates how to calculate the data once in a reactive expression and have the result be shared by all of the output tabs:\n# Define server logic for random distribution app ----\nserver &lt;- function(input, output) {\n\n  # Reactive expression to generate the requested distribution ----\n  # This is called whenever the inputs change. The output functions\n  # defined below then use the value computed from this expression\n  d &lt;- reactive({\n    dist &lt;- switch(input$dist,\n                   norm = rnorm,\n                   unif = runif,\n                   lnorm = rlnorm,\n                   exp = rexp,\n                   rnorm)\n\n    dist(input$n)\n  })\n\n  # Generate a plot of the data ----\n  # Also uses the inputs to build the plot label. Note that the\n  # dependencies on the inputs and the data reactive expression are\n  # both tracked, and all expressions are called in the sequence\n  # implied by the dependency graph.\n  output$plot &lt;- renderPlot({\n    dist &lt;- input$dist\n    n &lt;- input$n\n\n    hist(d(),\n         main = paste(\"r\", dist, \"(\", n, \")\", sep = \"\"),\n         col = \"#007bc2\", border = \"white\")\n  })\n\n  # Generate a summary of the data ----\n  output$summary &lt;- renderPrint({\n    summary(d())\n  })\n\n  # Generate an HTML table view of the data ----\n  output$table &lt;- renderTable({\n    d()\n  })\n\n}\n\n\n\n\n\n\nTip\n\n\n\nYou can access the name of the currently active nav_panel() as a reactive variable. To do this, pass an optional id argument to the navigation container, e.g.¬†navset_card_underline(id = \"tab\", ...). The name will be available in reactive contexts as input$&lt;id&gt;, e.g.¬†input$tab.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Tabsets"
    ]
  },
  {
    "objectID": "r/articles/build/templates/index.html",
    "href": "r/articles/build/templates/index.html",
    "title": "HTML Templates",
    "section": "",
    "text": "In most cases, the best way to create a Shiny application‚Äôs user interface is to build it with R code, using functions like fluidPage(), div(), and so on. Sometimes, though, you may want to integrate Shiny with existing HTML, and starting with Shiny 0.13 (and htmltools 0.3), this can be done with the HTML templates. Templates can be used to generate complete web pages, and they can also be used to generate the HTML for components that are included in a Shiny app.\n\nComplete web pages\nTo use an HTML template for the UI, first create an HTML file in your app directory, at the same level as the ui.R, server.R, or app.R files (not in a www/ subdirectory). Here‚Äôs an example template for a complete web page, template.html:\n{% raw %}\n&lt;!DOCTYPE html&gt;\n&lt;!-- template.html --&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    {{ headContent() }}\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div&gt;\n      {{ button }}\n      {{ slider }}\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n{% endraw %}\nAnd here‚Äôs a corresponding ui.R that uses the template:\n## ui.R ##\nhtmlTemplate(\"template.html\",\n  button = actionButton(\"action\", \"Action\"),\n  slider = sliderInput(\"x\", \"X\", 1, 100, 50)\n)\nSome things to notice:\nThe template is just plain HTML, except for the parts in {{ \"{{ and \" }}}}. The parts in those curly braces are R code which is evaluated when the template is processed.\nheadContent() must be placed in the &lt;head&gt; section of the HTML, if this is a complete HTML page (as opposed to a component of a page, which we‚Äôll discuss later). This tells Shiny that the various Shiny header code should be included here.\nIn ui.R, htmlTemplate() is called with the named arguments button and slider. The values are used when evaluating the R code in the template.\nOnce processed, the HTML produced will look something like this. You can see where the Shiny head content was inserted, and similarly, the actionButton and sliderInput HTML code.\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;  \n    &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\"/&gt;  \n    &lt;script type=\"application/shiny-singletons\"&gt;&lt;/script&gt;  \n    &lt;script type=\"application/html-dependencies\"&gt;\n            json2[2014.02.04];\n            jquery[1.11.3];\n            shiny[0.13];\n            ionrangeslider[2.0.12];\n            strftime[0.9.2]\n    &lt;/script&gt;\n    &lt;script src=\"shared/json2-min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"shared/jquery.min.js\"&gt;&lt;/script&gt;\n    &lt;link href=\"shared/shiny.css\" rel=\"stylesheet\"/&gt;\n    &lt;script src=\"shared/shiny.min.js\"&gt;&lt;/script&gt;\n    &lt;link href=\"shared/ionrangeslider/css/ion.rangeSlider.css\" \n          rel=\"stylesheet\"/&gt;\n    &lt;link href=\"shared/ionrangeslider/css/ion.rangeSlider.skinShiny.css\" \n          rel=\"stylesheet\"/&gt;\n    &lt;script src=\"shared/ionrangeslider/js/ion.rangeSlider.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"shared/strftime/strftime-min.js\"&gt;&lt;/script&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div&gt;\n      &lt;button id=\"action\" type=\"button\" \n              class=\"btn btn-default action-button\"&gt;Action&lt;/button&gt;\n      &lt;div class=\"form-group shiny-input-container\"&gt;\n        &lt;label class=\"control-label\" for=\"x\"&gt;X&lt;/label&gt;\n        &lt;input class=\"js-range-slider\" \n               id=\"x\" \n               data-min=\"1\" \n               data-max=\"100\"\n               data-from=\"50\" data-step=\"1\" data-grid=\"true\" \n               data-grid-num=\"9.9\" data-grid-snap=\"false\" \n               data-prettify-separator=\",\" \n               data-keyboard=\"true\" \n               data-keyboard-step=\"1.01010101010101\" \n               data-drag-interval=\"true\" \n               data-data-type=\"number\"/&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\nEvaluating code and passing variables\nIn the previous example, the double-curly braces in the template simply contain the names of variables, button and slider. However, the R code blocks aren‚Äôt limited to simple names; any R code can be placed inside a code block. In the example below, we‚Äôll put actionButton() and sliderInput() directly in the template, and we‚Äôll pass in an initial value to the sliderInput():\n{% raw %}\n&lt;!DOCTYPE html&gt;\n&lt;!-- template.html --&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    {{ headContent() }}\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div&gt;\n      {{ actionButton(\"action\", \"Action\") }}\n      {{ sliderInput(\"x\", \"X\", 1, 100, sliderValue) }}\n    &lt;/div&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n{% endraw %}\n## ui.R ##\nhtmlTemplate(\"template.html\",\n  sliderValue = 50\n)\nTo process the template‚Äôs R code, the htmlTemplate() function first creates a child environment of the global environment, populates it with variables that were passed in as arguments to the function (like sliderValue), and then evaluates the template‚Äôs R code. This means that the template‚Äôs R code will also have access to any variables set in R‚Äôs global environment ‚Äì but it‚Äôs not good practice to make use of global variables in the template; it‚Äôs better to pass values explicitly in the call to htmlTemplate().\nNOTE: Only the last thing in a code block is included in the HTML output. This is because of how the code blocks are evaluated; only the last thing is returned. If you have a code block with multiple elements that you want in the HTML, you can split it into multiple code blocks, or put the elements together with tagList().\n\n\nIncluding other web dependencies\nA common reason for using templates is to include custom JavaScript or CSS files. You can add these just as you would with ordinary HTML, with &lt;script&gt; or &lt;link&gt; tags. For example, here‚Äôs a template that uses a custom JavaScript library.\n{% raw %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=\"customlib.js\"&gt;&lt;/script&gt;\n    {{ headContent() }}\n  &lt;/head&gt;\n  &lt;body&gt;\n    ...\n  &lt;/body&gt;\n&lt;/html&gt;\n{% endraw %}\nIn this example, the file customlib.js would be expected to be in the www/ subdirectory of the app, so that it could served to the client browser. You could also point to an absolute URL (starting with //, http://, or https://) served from another host. This is useful for using popular libraries served from a CDN.\nWhen you include a web dependency this way, there is a possibility that some Shiny code will pull in the same dependency. Imagine that your web page uses D3, so you include a &lt;script&gt; tag for it, but then you also use an R component that pulls in a D3 dependency automatically, like d3heatmap.\n{% raw %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=\"//d3js.org/d3.v3.min.js\" charset=\"utf-8\"&gt;&lt;/script&gt;\n    {{ headContent() }}\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;!-- JavaScript code that uses D3 here --&gt;\n\n    {{ d3heatmap::d3heatmap(mtcars, scale=\"column\", colors=\"Blues\") }}\n  &lt;/body&gt;\n&lt;/html&gt;\n{% endraw %}\nIn this case, the HTML after processing the template will include the D3 JavaScript library twice ‚Äì once from the &lt;script&gt; tag that you added, and once from d3heatmap() automatically pulling it in:\n{% raw %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=\"//d3js.org/d3.v3.min.js\" charset=\"utf-8\"&gt;&lt;/script&gt;\n    ...\n    &lt;script src=\"d3-3.5.3/./d3.min.js\"&gt;&lt;/script&gt;\n    ...\n  &lt;/head&gt;\n  ...\n&lt;/html&gt;\n{% endraw %}\nThis could cause problems in running the D3 code. To avoid having two copies of a library, use suppressDependencies(). This will ensure that Shiny components won‚Äôt automatically pull in their own versions of web dependencies, and only the one that you manually added to the template will be used:\n{% raw %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;script src=\"//d3js.org/d3.v3.min.js\" charset=\"utf-8\"&gt;&lt;/script&gt;\n    {{ suppressDependencies(\"d3\") }}\n    {{ headContent() }}\n  &lt;/head&gt;\n  ...\n&lt;/html&gt;\n{% endraw %}\n\n\nUsing Bootstrap components\nSome web components in Shiny require the Bootstrap web framework in order to display correctly. These include, for example, tabsetPanel() and actionButton().\nBootstrap is included automatically when a Shiny UI is created with bootstrapPage(), basicPage(), fluidPage(), navbarPage(), and others. However, if you use an HTML template to generate the web page, using headContent() will not include Bootstrap ‚Äì it only includes Shiny‚Äôs basic web dependencies. In order to include Bootstrap, use bootstrapLib():\n{% raw %}\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    {{ headContent() }}\n    {{ bootstrapLib() }}\n  &lt;/head&gt;\n  &lt;body&gt;\n    {{ actionButton(\"action\", name) }}\n  &lt;/body&gt;\n&lt;/html&gt;\n{% endraw %}\n\n\n\nTemplates for components\nIn the examples above, HTML templates were used to generate an entire web page. They can also be used for components that are included in a larger application. For example, you could have this component.html and ui.R:\n{% raw %}\n&lt;!-- component.html --&gt;\n&lt;div&gt;\n  This is an HTML template named &lt;code&gt;{{ name }}&lt;/code&gt;.\n&lt;/div&gt;\n{% endraw %}\n## ui.R ##\nbootstrapPage(\n  h2(\"HTML template example\"),\n  htmlTemplate(\"component.html\", name = \"component1\")\n)\nWhen using a template as a component, don‚Äôt include headContent(), or a &lt;html&gt; or &lt;head&gt; tag. Just include the HTML which you want to be inserted in the web page.\n\n\nUsing templates in packages\nPackages can use HTML templates for components. If you have a package named mypackage and have a template file in the package sources at inst/templates/component.html, you can access that file with:\nsystem.file(\"templates\", \"component.html\", package = \"mypackage\"),\nThe package could contain a function that makes use of the template:\nmyComponent &lt;- function(name = \"component\") {\n  htmlTemplate(\n    system.file(\"templates\", \"component.html\", package = \"mypackage\"),\n    name = name\n  )\n}\nSomeone using your package could call myComponent(\"examplename\") to put the component in their UI.\nThe example above use a template to generate a component, but the same strategy can be used to generate a complete web page.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "HTML Templates"
    ]
  },
  {
    "objectID": "r/articles/build/two-file/index.html",
    "href": "r/articles/build/two-file/index.html",
    "title": "Two-file Shiny apps",
    "section": "",
    "text": "Before version 0.10.2, Shiny applications needed to be split into two separate files, server.R and ui.R, that include the code needed to define the UI and server components, respectively. This method is still supported in later versions of Shiny.",
    "crumbs": [
      "Build",
      "Structure",
      "Standalone apps",
      "Two-file Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/build/two-file/index.html#example",
    "href": "r/articles/build/two-file/index.html#example",
    "title": "Two-file Shiny apps",
    "section": "Example",
    "text": "Example\nTo create a two-file app, create a new directory (for example, newdir/) and place two files, called ui.R and server.R, in the directory.\n~/newdir\n|-- ui.R\n|-- server.R\n\nTo run it, call runApp(\"newdir\").\n\nui.R\nWe place the user interface definition in ui.R:\nui &lt;- fluidPage(\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"obs\", \"Number of observations:\", min = 10, max = 500, value = 100)\n    ),\n    mainPanel(plotOutput(\"distPlot\"))\n  )\n)\n\n\nserver.R\nAnd we place the server function definition in server.R:\nserver &lt;- function(input, output) {\n  output$distPlot &lt;- renderPlot({\n    hist(rnorm(input$obs), col = 'darkgray', border = 'white')\n  })\n}\nFor applications defined this way, the server.R file must return the server function, and the ui.R file must return the UI object (in this case, the UI object is created by fluidPage()). In other words, if the files contained other code (like utility functions) you must make sure that the last expression in the file is the server function or UI object.\nIf you have larger apps, you may find that having separate ui.R and server.R files makes your code easier to manage.",
    "crumbs": [
      "Build",
      "Structure",
      "Standalone apps",
      "Two-file Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/build/upload/index.html",
    "href": "r/articles/build/upload/index.html",
    "title": "Help users upload files to your app",
    "section": "",
    "text": "Sometimes you‚Äôll want users to be able to upload their own data to your application. Shiny makes it easy to offer your users file uploads straight from the browser, which you can then access from your server logic.\n\n\n\nUploading Files Screenshot\n\n\nImportant notes: * This feature does not work with Internet Explorer 9 and earlier (not even with Shiny Server). * By default, Shiny limits file uploads to 5MB per file. You can modify this limit by using the shiny.maxRequestSize option. For example, adding options(shiny.maxRequestSize = 30*1024^2) to the top of app.R would increase the limit to 30MB.\nTo run this example, type:\n&gt; library(shiny)\n&gt; runExample(\"09_upload\")\nFile upload controls are created by using the fileInput function in your UI. You access the uploaded data similarly to other types of input: by referring to input$inputId. The fileInput function takes a multiple parameter that can be set to TRUE to allow the user to select multiple files, and an accept parameter can be used to give the user clues as to what kind of files the application expects.\n\napp.R\nlibrary(shiny)\nlibrary(bslib)\n\n# Define UI for slider demo app ----\nui &lt;- page_sidebar(\n\n  # App title ----\n  title = \"Uploading Files\",\n\n  # Sidebar panel for inputs ----\n  sidebar = sidebar(\n\n    # Input: Select a file ----\n    fileInput(\n      \"file1\",\n      \"Choose CSV File\",\n      multiple = TRUE,\n      accept = c(\n        \"text/csv\",\n        \"text/comma-separated-values,text/plain\",\n        \".csv\"\n      )\n    ),\n\n    # Horizontal line ----\n    tags$hr(),\n\n    # Input: Checkbox if file has header ----\n    checkboxInput(\"header\", \"Header\", TRUE),\n\n    # Input: Select separator ----\n    radioButtons(\n      \"sep\",\n      \"Separator\",\n      choices = c(\n        Comma = \",\",\n        Semicolon = \";\",\n        Tab = \"\\t\"\n      ),\n      selected = \",\"\n    ),\n\n    # Input: Select quotes ----\n    radioButtons(\n      \"quote\",\n      \"Quote\",\n      choices = c(\n        None = \"\",\n        \"Double Quote\" = '\"',\n        \"Single Quote\" = \"'\"\n      ),\n      selected = '\"'\n    ),\n\n    # Horizontal line ----\n    tags$hr(),\n\n    # Input: Select number of rows to display ----\n    radioButtons(\n      \"disp\",\n      \"Display\",\n      choices = c(\n        Head = \"head\",\n        All = \"all\"\n      ),\n      selected = \"head\"\n    )\n  ),\n\n  # Output: Data file ----\n  tableOutput(\"contents\")\n)\n\n# Define server logic to read selected file ----\nserver &lt;- function(input, output) {\n  output$contents &lt;- renderTable({\n    # input$file1 will be NULL initially. After the user selects\n    # and uploads a file, head of that data file by default,\n    # or all rows if selected, will be shown.\n\n    req(input$file1)\n\n    df &lt;- read.csv(\n      input$file1$datapath,\n      header = input$header,\n      sep = input$sep,\n      quote = input$quote\n    )\n\n    if (input$disp == \"head\") {\n      return(head(df))\n    } else {\n      return(df)\n    }\n  })\n}\n\n# Create Shiny app ----\nshinyApp(ui, server)\nThis example receives a file and attempts to read it as comma-separated values using read.csv, then displays the results in a table. As the comment in the server function indicates, inFile is either NULL or a dataframe that contains one row per uploaded file. In this case, fileInput did not have the multiple parameter so we can assume there is only one row.\nThe file contents can be accessed by reading the file named by the datapath column. See the ?fileInput help topic to learn more about the other columns that are available.",
    "crumbs": [
      "Build",
      "Frontend",
      "User interface",
      "Help users upload files to your app"
    ]
  },
  {
    "objectID": "r/articles/improve/caching/index.html",
    "href": "r/articles/improve/caching/index.html",
    "title": "Using caching in Shiny to maximize performance",
    "section": "",
    "text": "Suppose you want to scale your application so that it can serve more traffic. One way to do this, of course, is to increase the amount of computing power available by getting more servers. Another way to do this is to reduce the amount of computing power needed by your application.\nWith careful use of caching, you can dramatically improve the performance of your Shiny applications. This is especially true of applications where many users see the same information, such as data dashboards.\nWhat is caching?\nIn Shiny 1.6.0, reactives and render functions can cache their values, using the bindCache() function. In other words, the application will do the computation with a given set of inputs once, and then after that, if those inputs are seen again, it can simply retrieve the value saved in the cache, instead of having to compute it again.\nWhen does caching help?\nBecause caching saves computed values for use later, it is most effective when the same computation is done multiple times. If, for example, you have a data dashboard where many users see the same data and the same plots of the data, then with caching, the data processing and plotting can happen once, and after that, the results simply have to be retrieved from the cache.\nThis document covers the following:",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Using caching in Shiny to maximize performance"
    ]
  },
  {
    "objectID": "r/articles/improve/caching/index.html#using-bindcache",
    "href": "r/articles/improve/caching/index.html#using-bindcache",
    "title": "Using caching in Shiny to maximize performance",
    "section": "Using bindCache()",
    "text": "Using bindCache()\nUsing bindCache() is simple: just pass your reactive() or render function to bindCache(). For example, if this is your reactive expression:\ncity_data &lt;- reactive({\n  fetchData(input$city)\n})\nYou can replace it with:\ncity_data &lt;- reactive({\n    fetchData(input$city)\n  }) %&gt;%\n  bindCache(input$city)\nNotice that we used %&gt;%, which is the pipe operator from the magrittr package. You don‚Äôt have to use the pipe operator, but it does make the code a bit easier to read.\nWe called bindCache(input$city) ‚Äî the input$city part is used as the cache key. Suppose the value of input$city is \"Boston\". The first time that someone uses city_data() when \"Boston\" is the city, the user-written code inside of the reactive() will run; it will call fetchData(\"Boston\") and store that in the cache, using \"Boston\" as the cache key.\nIf city_data() is called in the future without a change to input$city, it doesn‚Äôt have to run the code again; it simply returns the saved value. This works the same as regular a reactive(): they always store their most recent value.\nWhere the cached reactive() differs from a regular reactive() is with previous values. Suppose the value of input$city changes to \"New York\", and then back to \"Boston\". A normal reactive() would then have to re-run the code and go fetch the data for Boston. However, a cached reactive would be able to just get Boston data from the cache.\n\n\nClick to see code for an example application\n\nThis is an example application that demonstrates how caching can speed up a computation. It simply multiplies input$x and input$y, with an artificial two-second delay. You can try out this application by copying and pasting into your R session:\nlibrary(shiny)\nlibrary(magrittr)\nshinyApp(\n  ui = fluidPage(\n    sliderInput(\"x\", \"x\", 1, 10, 5),\n    sliderInput(\"y\", \"y\", 1, 10, 5),\n    div(\"x * y: \"),\n    verbatimTextOutput(\"txt\")\n  ),\n  server = function(input, output) {\n    r &lt;- reactive({\n      # The value expression is an _expensive_ computation\n      message(\"Doing expensive computation...\")\n      Sys.sleep(2)\n      input$x * input$y\n    }) %&gt;%\n      bindCache(input$x, input$y)\n\n    output$txt &lt;- renderText(r())\n  }\n)\n\n\nbindCache() with render functions\nWe‚Äôve seen bindCache() used with reactive expressions, but it can also be used with render functions, like renderPlot(), renderText(), renderUI(), as well as render functions from other packages, like plotly::renderPlotly().\nHere‚Äôs an example with renderTable(). Suppose that fetchData() returns a data frame:\noutput$table &lt;- renderTable({\n    fetchData(input$city)\n  }) %&gt;%\n  bindCache(input$city)\nLike our earlier example, input$city is used as the cache key. The first time it has particular value, like \"Boston\", the code inside the renderTable() will run. Later on, if input$city has the same value, it won‚Äôt have to run the code again; it can simply fetch the value from the cache.\nSome render functions may require small modifications to work with caching. Others will not work with caching; one possible reason for this is that the render function modifies some internal state of the session, and so caching it would prevent necessary code from running.\nNote that some render functions may need modifications in order to work with bindCache() ‚Äî if you are a developer of such a function, see Updating render functions below.\n\n\nUnderstanding cache keys\nFor caching to work well for your application, it‚Äôs important to understand how cache keys are computed and used.\nAs a general rule of thumb, the cache key expression should capture all reactive objects used in the reactive/render code. In this example, the renderText() uses three reactive objects: input$x, input$y, and r(). Additionally, all of them are passed to the bindCache() to use as cache key:\nr &lt;- reactive({ input$z * 2 })\n\noutput$txt &lt;- renderText({\n    paste(\"The value is\", input$x * input$y * r())\n  }) %&gt;%\n  bindCache(input$x, input$y, r())\nIf you don‚Äôt use all of them in the cache key, you can end up with a cache collision. For example, suppose that we only used input$x for the cache key, like this:\noutput$txt &lt;- renderText({\n    paste(\"The value is\", input$x * input$y * r())\n  }) %&gt;%\n  bindCache(input$x)\nIn this case, changes to input$y and r() would not cause the cache key to be recomputed, and incorrect values could be fetched from the cache.\nAfter the cache key expression(s) are executed, they are combined into a list and then that list is hashed to produce a string, which is used as the actual cache key. This means that if a large object (for example, a data set) is used in the cache key, it can take a nontrivial amount of time to hash it. If this is an issue for you, see this question.\nA second thing that bindCache() cache key expression(s) are used for is to set up reactive dependencies for the resulting object. Reactive dependencies are based on cache key expression(s), and not the original code in the reactive() or render function. (In technical terms, that code is run inside of isolate().)\nThe reason that the cache key expressions are used for reactive dependencies is because we don‚Äôt want upstream reactive invalidations to cause the user-code to re-execute; that could be an expensive operation. Instead, we want those invalidations to cause the cache key expressions to re-execute; this should be a fast operation. If the resulting key is not in the cache, only then do we want to re-execute the (expensive) user code.\nBehind the scenes, bindCache() adds in a few more things as part of the cache key. The code that the user passes to reactive() is also added to cache key before it‚Äôs hashed. This is to avoid collisions among objects. In addition, information about the type of object is hashed, so that two different reactive/render functions that have the same user-provided expression will not collide. This may sound confusing, but this example should make it clear. The following will not have collisions among them, even though the bindCache() calls all have the same user-specified portion of the cache key and (in one pairing) the same code passed to reactive() and renderText():\n# No collisions\nr2          &lt;- reactive(  { input$x * 2 }) %&gt;% bindCache(input$x)\nr4          &lt;- reactive(  { input$x * 4 }) %&gt;% bindCache(input$x)\noutput$txt4 &lt;- renderText({ input$x * 4 }) %&gt;% bindCache(input$x)\n\n\nbindCache() and renderPlot()\nPlots can be cached with bindCache(). For example:\noutput$plot &lt;- renderPlot({\n    data &lt;- fetchData(input$city)\n    plot(data)\n  }) %&gt;%\n  bindCache(input$city)\nIn versions of Shiny prior to 1.6.0, the same could be done with renderCachedPlot() (and that code will still work with newer versions of Shiny):\noutput$plot &lt;- renderCachedPlot({\n    data &lt;- fetchData(input$city)\n    plot(data)\n  },\n  cacheKeyExpr = input$city\n)\n\n\nClick to see an example application\n\nThis is an example application that demonstrates how caching can speed up a plot. For a given slider value, it makes a plot with an artificial two-second delay. You can try out this application by copying and pasting into your R session:\nlibrary(shiny)\nlibrary(magrittr)\nshinyApp(\n  fluidPage(\n    sidebarLayout(\n      sidebarPanel(\n        sliderInput(\"n\", \"Number of points\", 4, 32, value = 8, step = 4)\n      ),\n      mainPanel(plotOutput(\"plot\"))\n    )\n  ),\n  function(input, output, session) {\n    output$plot &lt;- renderPlot({\n        Sys.sleep(2)  # Add an artificial delay\n        rownums &lt;- seq_len(input$n)\n        plot(cars$speed[rownums], cars$dist[rownums],\n          xlim = range(cars$speed), ylim = range(cars$dist))\n      }) %&gt;%\n      bindCache(input$n)\n  }\n)\n\n\nPlot sizing\nSizing for cached plots works a bit differently from regular plots: with regular plots, the plot is rendered to exactly fit the div on the web page; with cached plots, the plot is rendered to a close-fitting size, and the web browser scales it to fit the div.\nWith an uncached renderPlot(), the plot is rendered at exactly the dimensions of the div containing the image in the browser. If the div is 500 pixels wide and 400 pixels tall, then it will create a plot that is exactly 500√ó400 pixels. If you resize the window, and the div then becomes 550x400 pixels (typically the width is variable, but the height is fixed), then Shiny will render another plot that is 550x400, which can take some time.\nWith renderPlot() %&gt;% bindCache(), the plot is not rendered to be an exact fit. There are a number of possible sizes, and Shiny will render the plot to be the closest size that is larger than the div on the web page, and cache it. For example, possible widths include 400, 480, 576, 691, and so on, both smaller and larger; each width is 20% larger than the previous one. Heights work the same way.\nIf the width of the div is 450 pixels, then Shiny will render a plot that is 480 pixels wide and scale it down to fit the 450 pixel wide div. If the div is then resized to 500 pixels, then Shiny will render a plot that is 576 pixels wide.\nThe reason that cached plots work this way is so that it doesn‚Äôt have to cache a plot of every possible size; doing that would greatly reduce the usefuless of caching, since each browser would likely have a slightly different width, and so there would be very few cache hits.\nThis behavior is controlled by the sizePolicy parameter ‚Äì it is a function that takes two numbers (the actual dimensions of the div) and returns two numbers (the dimensions of the plot that will be rendered). If you want to use a different strategy, you can pass in a different function. See here for more information.\n\n\n\nUsing bindCache() with bindEvent()\nThe bindEvent() function makes it easy to make reactive code run only when specified reactive values are invalidated. You may be familiar with the existing eventReactive() and observeEvent() functions. bindEvent() can be used with reactive() and observe() to do the same thing (and in fact, the older functions are now implemented using bindEvent()):\n# These are equivalent:\neventReactive(input$button, { ... })\nreactive({ ... }) %&gt;% bindEvent(input$button)\n\n# These are equivalent:\nobserveEvent(input$button, { ... })\nobserve({ ... }) %&gt;% bindEvent(input$button)\nbindEvent() can also be used with render functions. For example, if you have a plot that you want to redraw only when a button is clicked, you could do this:\noutput$plot &lt;- renderPlot({\n    plot(cars[seq_len(input$nrows), ])\n  }) %&gt;%\n  bindEvent(input$button)\nbindCache() and bindEvent() can be used together:\noutput$plot &lt;- renderPlot({\n    plot(cars[seq_len(input$nrows), ])\n  }) %&gt;%\n  bindCache(input$nrows) %&gt;%\n  bindEvent(input$button)\nThis would cache the plot based on the value of input$nrows, and also make it so the plot redraws only when input$button is clicked. Keep in mind that the bind events are ‚Äúdecorators‚Äù, and that each one wraps up the object from the previous step; when the code is executed, you can think of them running in the reverse order of which they are applied (when using the pipe operator). So the bindEvent(input$button) acts as a gatekeeper for the bindCache(input$nrows): the input$button event must happen before the caching code looks at input$nrows. And then if the key isn‚Äôt already in the cache, it tells the code in renderPlot() to run.\n\n\nClick to see an example application\n\nThis is an example application that demonstrates using bindCache() with bindEvent(). You can try out this application by copying and pasting into your R session:\nlibrary(shiny)\nlibrary(magrittr)\nshinyApp(\n  fluidPage(\n    sidebarLayout(\n      sidebarPanel(\n        sliderInput(\"n\", \"Number of points\", 4, 32, value = 8, step = 4),\n        actionButton(\"go\", \"Draw plot\")\n      ),\n      mainPanel(plotOutput(\"plot\"))\n    )\n  ),\n  function(input, output, session) {\n    output$plot &lt;- renderPlot({\n        Sys.sleep(2)  # Add an artificial delay\n        rownums &lt;- seq_len(input$n)\n        plot(cars$speed[rownums], cars$dist[rownums],\n          xlim = range(cars$speed), ylim = range(cars$dist))\n      }) %&gt;%\n      bindCache(input$n) %&gt;%\n      bindEvent(input$go)\n  }\n)",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Using caching in Shiny to maximize performance"
    ]
  },
  {
    "objectID": "r/articles/improve/caching/index.html#using-memoise",
    "href": "r/articles/improve/caching/index.html#using-memoise",
    "title": "Using caching in Shiny to maximize performance",
    "section": "Using memoise()",
    "text": "Using memoise()\nThe memoise package provides the memoise() function, which takes a function as input, and returns a version of that function with that caches the result.\nMemoized functions are similar to a reactive() used with bindCache(), although there are a few differences:\n\nmemoise() doesn‚Äôt know anything about reactivity, whereas bindCache() is designed to be used with reactive objects, and it handles reactive dependencies.\nmemoise() automatically infers the expressions to use in the cache key (it uses the arguments to the original function), whereas bindCache() requires you to tell it what to use for the cache key.\nmemoise() doesn‚Äôt automatically use an application or session-level cache; the package is separate from Shiny, so it doesn‚Äôt know about those things. (See the Cache scoping section for more.)\n\nUsing memoise() is easy. Suppose you have a function named myfun. Creating a memoized version of the function is as simple as passing it to memoise():\nmyfun &lt;- function(n) {\n  # Do something slow\n  ...\n}\n\nmyfun_m &lt;- memoise(myfun)\nThen you can call myfun_m() just as you would call myfun(), and it will return the same values, but with caching.\nNote that, in order to work reliably, the function should be a pure function: the returned value should depend only on the input values to the function (and shouldn‚Äôt be influenced by any global variables), and the function shouldn‚Äôt alter any global state. If the function is not a pure function (for example, if the return value depends on a global variable) then it is possible for the memoized version to behave differently from the non-memoized version.\nBy default, memoise() creates a new cache_mem() for each memoized function, as the memoise package completely independent of Shiny. However, for a Shiny application, it usually makes sense to tell it to use the app or session-level cache.\nHere‚Äôs how to memoize with an application-level cache:\n# In app.R, server.R, or global.R\nmyfun &lt;- function(x, y) {\n  ...\n}\n\n# Memoize, using application-level cache\nmyfun_m &lt;- memoise(slow_fn, cache = getShinyOption(\"cache\"))\nTo memoize with a session-level cache:\nfunction(input, output, session) {\n  # Call memoise() in server function, and tell it to use session$cache\n  myfun_m &lt;- memoise(slow_fn, cache = session$cache)\n}",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Using caching in Shiny to maximize performance"
    ]
  },
  {
    "objectID": "r/articles/improve/caching/index.html#cache-scoping",
    "href": "r/articles/improve/caching/index.html#cache-scoping",
    "title": "Using caching in Shiny to maximize performance",
    "section": "Cache scoping",
    "text": "Cache scoping\nBy default, when bindCache() is used, it is scoped to the running application. That means that it shares a cache with all user sessions connected to the application (within the R process). This is done with the cache parameter‚Äôs default value, \"app\" (as in bindCache(..., cache = \"app\")).\nWith an app-level cache scope, one user can benefit from the work done for another user‚Äôs session. In most cases, this is the best way to get performance improvements from caching. However, in some cases, this could leak information between sessions. For example, if the cache key does not fully encompass the inputs used by the value, then data could leak between the sessions. Or if a user sees that a cached reactive returns its value very quickly, they may be able to infer that someone else has already used it with the same values.\nInstead of an application-level cache, you can scope the cache to the session, with cache=\"session\". This removes the risk of information leaking between sessions, but then one session cannot benefit from computations performed in another session. For example, you could use one of the following:\n# Use the application-level cache that is shared with other users' sessions\nbindCache(..., cache = \"app\")\n\n# Use the session-level cache that is unique to this user's session\nbindCache(..., cache = \"session\")\nAnother way to scope a cache is by passing a caching object directly to bindCache(). This can be useful if, for example, you want to use a a different type of cache with specific objects. We‚Äôll learn more about this in Finer control over caching.\nBy default, a session-level cache‚Äôs lifetime ends when the user session ends, and the application-scoped cache‚Äôs lifetime ends when the application stops running.\nThe default application-level cache is a cache_mem() with a max_size 200 MB, and the default session-level cache is also a cache_mem() with a max_size of 200 MB.\nTo use different settings for an application-scoped cache, you can call shinyOptions() at the top of your app.R, server.R, or global.R. For example, this will create a cache with 500 MB of space instead of the default 200 MB:\n# Set the application-level cache\nshinyOptions(cache = cachem::cache_mem(max_size = 500e6))\nTo use different settings for a session-scoped cache, you can set self$cache at the top of your server function. To use the session-scoped cache, when you call bindCache(), use cache=\"session\". For example, this will create a 100 MB cache for the session:\nfunction(input, output, session) {\n  # Set the session-level cache\n  session$cache &lt;- cachem::cache_mem(max_size = 100e6)\n\n  r &lt;- reactive(...) %&gt;% bindCache(input$x, cache = \"session\")\n  ...\n}\nIf you want to use a cache that is shared across multiple R processes, you can use a cachem::cache_disk(). You can create a application-level shared cache by putting this at the top of your app.R, server.R, or global.R:\nshinyOptions(cache = cachem::cache_disk(file.path(dirname(tempdir()), \"myapp-cache\"))\nThis will create a subdirectory in your system temp directory named myapp-cache (replace myapp-cache with a unique name of your choosing). On most platforms, this directory will be removed when your system reboots. This cache will persist across multiple starts and stops of the R process, as long as you do not reboot.\nTo have the cache persist even across reboots, you can create the cache in a location outside of the temp directory. For example, it could be a subdirectory of the application:\nshinyOptions(cache = cachem::cache_disk(\"./myapp-cache\"))\nIn this case, resetting the cache will have to be done manually, by deleting the directory.\nUsing a cache_disk() can allow multiple concurrent R processes serving the same Shiny application to share a cache, which can result in even greater performance benefits. Bear in mind that the various platforms have different behavior for sharing disk space; see Best practices for deployed applications to learn more.\n\nFiner control over caching\nThe \"app\" and \"session\" options for cache scoping offer a simple way to control cache scoping, but in some cases you may want to have finer control over the caching.\nIn addition to the application- and session-level caches, you can create separate cache objects and use them with specific calls to bindCache(). This could be useful if there are particular items that require different cache settings. For example, you might want a specific data set to be cached for only one hour, but other objects to be cached as usual.\n# A cache with 5 minute max age, created outside of the server function, so it\n# is shared across sessions.\ncache_5min &lt;- cachem::cache_mem(max_age = 5 * 60)\n\nfunction(input, output, session) {\n  # This specific object will be cached with the cache_5min\n  output$plot &lt;- renderPlot( ... ) %&gt;%\n    bindCache(input$x, cache = cache_5min)\n}",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Using caching in Shiny to maximize performance"
    ]
  },
  {
    "objectID": "r/articles/improve/caching/index.html#best-practices-for-deployed-applications",
    "href": "r/articles/improve/caching/index.html#best-practices-for-deployed-applications",
    "title": "Using caching in Shiny to maximize performance",
    "section": "Best practices for deployed applications",
    "text": "Best practices for deployed applications\nIn most cases, the default memory cache provides enough of a performance boost so that no other changes need to be made to an application. With a memory cache, the cache can be shared among all Shiny user sessions within a single R process.\nIf your application has a large number of users and runs on multiple R processes, you can use a disk cache. Below are best practices for using a shared cache on various hosting platforms. If you have specialized needs, it might make sense to use a custom cache backed by Redis or other database.\n\nPosit Connect\nPosit Connect includes support for running multiple R process for an application. For applications deployed to Posit Connect, the best practice is to use a disk cache located in the application directory. To do so, add a line like this to your application:\n# At the top of app.R, server.R, or global.R\nshinyOptions(cache = cachem::cache_disk(\"./app_cache/cache/\"))\nNote: the reason for using the path app_cache/cache/ is because (1) the rsconnect package (which is used to deploy the app) knows to not deploy the app_cache/ subdirectory and (2) inside of that directory, various packages create subdirectories. The sass package, for example, uses a directory called app_cache/sass/. The subdirectory app_cache/cache/ avoids colliding with other directories.\n\n\n\n\n\n\nImportant\n\n\n\nAs of 2021-01-28, the CRAN version of rsconnect does not know to ignore app_cache/. This requires the development version of rsconnect, which can be installed with:**\n\n\nremotes::install_github(\"rstudio/rsconnect\")\nIf you are using the CRAN version of rsconnect, and you have run the application on the computer which you are deploying from, it will have a local cache directory which should not be deployed. Make sure to deselect the cache directory when you deploy the application. In the RStudio IDE, you can do this:\n\n\n\nThe cache will be shared across multiple R processes running the same application. If you are using a multi-host cluster, the cache will also be shared across hosts, since the application directory resides on networked storage.\nWhen the application is redeployed, the newly-deployed version will start with an empty cache, which ensures that new versions of the application do not inherit a stale cache.\n\n\nShiny Server and Shiny Server Pro\nShiny Server Open Source and Shiny Server Pro are typically run on a single server, though they can also be used on multiple servers, with a web proxy in front of them directing traffic to the individual servers.\nWith Shiny Server Open Source, on a server each application is served by at most a single R process, so a disk cache will not provide a performance benefit over a memory cache, because it cannot be shared. However, a disk cache can be useful if you want the cache to persist even after an R process shuts down.\nWith Shiny Server Pro, multiple processes on a single server can serve the same application, and so a shared disk cache can provide performance benefits. To create a persistent disk cache that can be shared across processes, use a subdirectory of the application for the cache directory. To do that, add a line like this to your application:\n# At the top of app.R, server.R, or global.R\nshinyOptions(cache = cachem::cache_disk(\"./app_cache/cache/\"))\nNote: the reason for using the path app_cache/cache/ is because (1) the rsconnect package (which is used to deploy the app) knows to not deploy the app_cache/ subdirectory and (2) inside of that directory, various packages create subdirectories. The sass package, for example, uses a directory called app_cache/sass/. The subdirectory app_cache/cache/ avoids colliding with other directories.\n\n\n\n\n\n\nImportant\n\n\n\nAs of 2021-01-28, the CRAN version of rsconnect does not know to ignore app_cache/. This requires the development version of rsconnect, which can be installed with:**\n\n\nremotes::install_github(\"rstudio/rsconnect\")\nWhen you update your application, R packages, or R itself, you should remove or clear the cache directory, since the cached objects may no longer be correct for the updated code.\nIf you are using multiple servers, you can use a shared disk cache on networked storage, although there may be a performance penalty with this.\n\n\nshinyapps.io\nAnywhere you deploy a Shiny application, multiple user sessions can share one R process. For applications deployed on Shinyapps.io, multiple R processes can run on one instance, and multiple instances can run simultaneously.\nR processes within an instance share a filesystem, so it is possible to share a disk cache within an instance. Filesystems are not shared across instances, so a disk cache cannot be shared across instances.\nOn shinyapps.io, the application directory is reset after an instance is shut down, and there is currently no storage that persists after an application shuts down. An application typically shuts down after there are no more user sessions connected to the R processes in that instance (although it is possible to configure an application to have different behavior).",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Using caching in Shiny to maximize performance"
    ]
  },
  {
    "objectID": "r/articles/improve/caching/index.html#faq",
    "href": "r/articles/improve/caching/index.html#faq",
    "title": "Using caching in Shiny to maximize performance",
    "section": "FAQ",
    "text": "FAQ\n\nI want to use a large object as the cache key, but hashing it is slow. How do I deal with this?\nIf the object that you want to use as the cache key is large, hashing it may take a non-trivial amount of time.\nSuppose you have a cached plot that uses a reactive expression named bigData:\noutput$plot &lt;- renderPlot({ ... }) %&gt;%\n  bindCache(bigData())\nEvery time bigData is invalidated, the cache key expression will be re-executed and the result will be hashed.\nBefore trying to optimize performance in these cases, first make sure that it‚Äôs a real problem. You can find out how much time it takes to hash the object by running system.time(rlang::hash(x)) on the object. For example, here is the time it takes to hash a data frame with 2 columns and 500,000 rows:\nd &lt;- data.frame(x = rnorm(500000), y = rnorm(500000))\nsystem.time(rlang::hash(d))\n#&gt;   user  system elapsed\n#&gt;  0.001   0.000   0.001\nThe total time is about 1 millisecond, which is fast enough that you don‚Äôt need to worry about it.\nAntoher example: the diamonds data set from ggplot2 contains 10 columns and about 54,000 rows:\nsystem.time(rlang::hash(ggplot2::diamonds))\n#&gt;   user  system elapsed\n#&gt;  0.001   0.000   0.002\nThis takes about 2 milliseconds. If your data hashes this quickly, then you don‚Äôt have to worry about it; if it‚Äôs slow, keep reading.\nThere are a few ways to improve performance by reducing the amount of data that needs to be hashed. One way is to extract only the necessary piece of information from the data set and hash that. For example, if bigData() returns log data that has timestamps, then simply using the most recent timestamp in the data set may be sufficient for caching purposes.\noutput$plot &lt;- renderPlot({ ... }) %&gt;%\n  bindCache({\n    # Extract and return the latest time\n    df &lt;- bigData()\n    max(df$time)\n  })\nThe example above only needs to hash a single timestamp extracted from bigData(), which may greatly reduce hashing time. Keep in mind that it still takes a reactive dependency on bigData(), because it is executed in the cache key expressions.\nAnother possible way to deal with it is to not use bigData() in the cache key expression. If the value of bigData() depends on some other reactive input, then you could use that input as the cache key ‚Äì as long as you are sure that the value of bigData() is uniquely determined by that reactive input. Here‚Äôs an example where bigData depends on input$city.\nbigData &lt;- reactive({ fetchData(input$city) })\n\noutput$plot &lt;- renderPlot({ ... }) %&gt;%\n  bindCache(bigData())    # Might be slow because of hashing bigData()\nInstead of using bigData() in the cache key, we can just use input$city:\noutput$plot &lt;- renderPlot({ ... }) %&gt;%\n  bindCache(input$city)   # Fast, because input$city is small\nAgain, this will work only if the value of bigData() is uniquely determined by the value input$city. If there are other things that could cause bigData() to change, then the cache could provide incorrect results due to cache collisions.\n\n\nCan I customize the behavior of cachem::cache_mem and cachem::cache_disk?\ncache_mem and cache_disk from the cachem package provide many options to customize behavior. The default for both is to set a maximum size for the cache and to use a LRU (least-recently used) eviction policy. However, it is also possible to expire objects after a certain amount of time, by setting the max_age.\nFor example, if you want to use an app-level memory cache with unlimited size, but where the objects expire after five minutes, you would do the following at the top of your app.R/server.R:\nshinyOptions(cache = cachem::cache_mem(max_size = Inf, max_age = 300))\nSee the cachem documentation for more information about how to customize caching behavior.\n\n\nCan I cache objects with reference semantics?\nSome R objects, such as environments, R6 objects, and external pointers, have reference semantics. This means that altering the object in one place will cause anyone else with a reference to it to also see the altered version.\nWith caches that serialize objects (essentially, anything besides cache_mem), these objects may not behave as expected when restored. With a cache_disk, you can have it warn when reference objects are serialized. For example, here‚Äôs how to set your app-level cache to a cache_disk that warns:\nshinyOptions(cache = cachem::cache_disk(warn_ref_objects = TRUE))\nThen, when serializing a reference object, it will emit a warning like this:\nWarning message:\nIn d$set(key, value) :\n  A reference object was cached in a serialized format. The restored object may not work as expected.\nWhen a cache_disk stores an R object, it serializes the object and then saves the serialized data to disk. However, reference objects such as environments and external pointers cannot be guaranteed to restore exactly the same as when they are stored, especially if they are restored in another R session.\nThe warning will be shown when caching an environment, as below:\ndc &lt;- cachem::cache_disk(warn_ref_objects = TRUE)\ne &lt;- new.env()\ndc$set(\"x\", e)\n#&gt; Warning message:\n#&gt; In dc$set(\"x\", e) :\n#&gt;   A reference object was cached in a serialized format. The restored object may not work as expected.\nBut other objects also can contain environments. Functions, for instance, consist of formals (the function parameters), body, and environment, and so serializing a function will result in the same warning.\nf &lt;- function() 1+1\ndc$set(\"x\", f)\n#&gt; Warning message:\n#&gt; In dc$set(\"x\", f) :\n#&gt;   A reference object was cached in a serialized format. The restored object may not work as expected.\nA reactive expression from Shiny is a special function, and it will result in the warning as well:\nr &lt;- reactive(1)\ndc$set(\"x\", r)\n#&gt; Warning message:\n#&gt; In dc$set(\"x\", r) :\n#&gt;   A reference object was cached in a serialized format. The restored object may not work as expected.\nIn the context of a bindCache(), this warning can help you detect accidental usage of a reactive expression in the cache key, when you actually intended to use the result of a reactive expression in the cache key.\n# r is some reactive expression\nr &lt;- reactive(...)\n\n\n# Bad: Using reactive expression in cacheKeyExpr. This will raise a warning.\nrenderPlot(...) %&gt;% bindCache(r)\n\n\n# Good: Using the value of reactive expression in cacheKeyExpr.\nrenderCachedPlot(...) %&gt;% bindCache(r())\n\n\nCan I write my own caching backend?\nIt is possible to use a caching backend other than cachem‚Äôs cache_mem and cache_disk. To do this, you simply need to supply a caching object ‚Äì that is, an object that has $get() and $set() methods on it. In this section, we‚Äôll see how to create a cache object that can be used by Shiny.\nHere is a function that creates an extremely simple caching object:\nsimple_cache &lt;- function() {\n  e &lt;- new.env(parent = emptyenv())\n\n  list(\n    get = function(key) {\n      if (exists(key, envir = e, inherits = FALSE)) {\n        return(e[[key]])\n      } else {\n        return(structure(list(), class = \"key_missing\"))\n      }\n    },\n    set = function(key, value) {\n      e[[key]] &lt;- value\n    }\n  )\n}\nTo use it:\nsc &lt;- simple_cache()\n\nsc$set(\"abc\", 123)\nsc$get(\"abc\")\n#&gt; [1] 123\n\n# Calling $get() on a missing key returns a key_missing object\nsc$get(\"xyz\")\n#&gt; &lt;Key Missing&gt;\nThe object returned by simple_cache() does all the things that a Shiny application needs from a cache. The requirements are very simple:\n\nThere is a $set(key, value) method which takes a string key, and any R object as a value.\nThere is a $get(key) method which returns a cached value, and if the value is not present, returns an empty list with class \"key_missing\". (This is the same as what cachem::key_missing() returns.)\n\nOur example is a simple memory cache ‚Äì unlike cachem‚Äôs cache_mem(), it doesn‚Äôt do any pruning, and so it will just keep on growing arbitrarily large. But it does the job for this example.\nIf you put the following at the top of app.R, server.R, or global.R, it will use one of these simple cache objects as the default application-level cache.\nshinyOptions(cache = simple_cache())\nSimilarly, you can put it in the server function to serve as the session-level cache:\nfunction(input, output, session) {\n  shinyOptions(cache = simple_cache())\n\n  # ...\n}\nFinally, you can also create the cache object and pass it directly to bindCache(). As described in the previous section, the cache would be shared among all Shiny sessions connected to this R process, but other plots in the app would use the default app-level cache.\n# Note that this is defined outside of the server function.\nmy_cache &lt;- simple_cache()\n\nfunction(input, output, session) {\n  output$plot &lt;- renderPlot({ ... }) %&gt;%\n    bindCache(cache = my_cache)\n}\n\n\nCan I use Redis for the cache?\nIn the previous section, we saw how to create a simple cache. Here we‚Äôll create a cache that uses a local Redis store as the backend. In this case, we‚Äôll use an R6 class for the caching objects, instead of a list.\nlibrary(shiny)\nlibrary(redux)\nlibrary(R6)\n\nRedisCache &lt;- R6Class(\"RedisCache\",\n  public = list(\n    initialize = function(..., namespace = NULL) {\n      private$r &lt;- redux::hiredis(...)\n      # Configure redis as a cache with a 20 MB capacity\n      private$r$CONFIG_SET(\"maxmemory\", \"20mb\")\n      private$r$CONFIG_SET(\"maxmemory-policy\", \"allkeys-lru\")\n      private$namespace &lt;- namespace\n    },\n    get = function(key) {\n      key &lt;- paste0(private$namespace, \"-\", key)\n      s_value &lt;- private$r$GET(key)\n      if (is.null(s_value)) {\n        return(structure(list(), class = \"key_missing\"))\n      }\n      unserialize(s_value)\n    },\n    set = function(key, value) {\n      key &lt;- paste0(private$namespace, \"-\", key)\n      s_value &lt;- serialize(value, NULL)\n      private$r$SET(key, s_value)\n    }\n  ),\n  private = list(\n    r = NULL,\n    namespace = NULL\n  )\n)\nRedis provides a key-value store, and our RedisCache objects can have a namespace ‚Äì which is simply implemented as a prefix to the keys. So of the namespace is \"myapp\" and you store an object with the key \"abc\", then it will be stored in Redis with the namespaced key \"myapp-abc\". This allows you to share the same Redis store among multiple different Shiny applications, each with its own namespace.\nBefore we create a cache, we need to start up a local Redis server. On a Mac, you can do this by running the following from the command line:\n# Install redis via Homebrew\nbrew install redis\n\nredis-server /usr/local/etc/redis.conf\nNow that Redis is running, we can create a RedisCache object and test it out:\nrc &lt;- RedisCache$new(namespace = \"test\")\n\nrc$set(\"abc\", 123)\nrc$get(\"abc\")\n#&gt; [1] 123\n\n# Getting a key that's not present\nrc$get(\"xyz\")\n#&gt; &lt;Key Missing&gt;\nThis example is the same as the earlier ones, except that it uses a Redis cache as the default application-level cache. (Note once again that if you run shinyOptions(cache=...) from the console instead of in an app.R/server.R, it will set the default cache for the rest of the R session instead of for the duration of the application.)\n## app.R ##\nshinyOptions(cache = RedisCache$new(namespace = \"myapp\"))\n\nshinyApp(\n  fluidPage(\n    sidebarLayout(\n      sidebarPanel(\n        sliderInput(\"n\", \"Number of points\", 4, 32, value = 8, step = 4)\n      ),\n      mainPanel(plotOutput(\"plot\"))\n    )\n  ),\n  function(input, output, session) {\n    output$plot &lt;- renderPlot({\n        Sys.sleep(2)  # Add an artificial delay\n        seqn &lt;- seq_len(input$n)\n        plot(mtcars$wt[seqn], mtcars$mpg[seqn],\n             xlim = range(mtcars$wt), ylim = range(mtcars$mpg))\n      }) %&gt;%\n      bindCache(input$n)\n      # Another alternative: set the cache just for this plot.\n      # bindCache(cache = RedisCache$new(namespace = \"myapp-plot\"))\n    )\n  }\n)\nThe Redis cache can be shared among multiple R processes running the same app, as long as they point to the same Redis cache and use the same namespace (in this case, \"myapp\").\nAn alternative is to use the Redis cache just for a specific plot. In the code above, the renderCachedPlot() call has a commented-out cache argument. If you uncomment the cache argument (instead of calling shinyOptions() above) then that plot will use the Redis cache, with the namespace \"myapp-plot\". Multiple instances of this application, or multiple different applications could share the Redis store using the same namespace.\nIn the RedisCache class defined above, the Redis store was configured to behave as a cache with a 20 MB capacity and a LRU (least-recently-used) expiration policy, by the following lines:\nprivate$r$CONFIG_SET(\"maxmemory\", \"20mb\")\nprivate$r$CONFIG_SET(\"maxmemory-policy\", \"allkeys-lru\")\nIf the Redis store is shared among applications, it may not be a good idea to configure Redis from R, because one application may set certain settings, and then another application may change them. In these cases, it is advisable to configure the Redis store using the Redis configuration file. In production, you should also use a more secure configuration, including a password for Redis.\n\n\nCan I use storr for the caching backend?\nThe storr package provides a consistent key-value interface for several different kinds of backends, including SQLite, Postgres, R environments, RDS files, and more.\nIt‚Äôs possible to wrap a storr object so that it behaves in a way that is compatible with what Shiny‚Äôs caching objects expect. The main difference is that, when cachem‚Äôs cache_mem or cache_disk try to retrieve a key that is not present, they return a key_missing object, while storr throws a KeyError.\nIn the code below, the keyMissingCacheDecorator takes a storr object, and wraps it so that when the get() method encounters a missing key, it returns a key_missing object instead of throwing a KeyError.\nkeyMissingCacheDecorator &lt;- function(cacheObj) {\n  list(\n    get = function(key) {\n      is_missing &lt;- FALSE\n      tryCatch(\n        { val &lt;- cacheObj$get(key) },\n        KeyError = function(e) {\n          is_missing &lt;&lt;- TRUE\n        }\n      )\n\n      if (is_missing) {\n        return(structure(list(), class = \"key_missing\"))\n      }\n\n      val\n    },\n\n    set = cacheObj$set\n  )\n}\nTo test it out, we can use a storr cache that is backed by an R environment ‚Äì this is similar to a cachem::cache_mem(), but without pruning.\nlibrary(storr)\n\n# Create the storr cache\nse &lt;- storr_environment()\n\n# Wrap it in the decorator\nse_cache &lt;- keyMissingCacheDecorator(se)\n\n# Test it out\nse_cache$set('x',123)\nse_cache$get('x')\n#&gt; [1] 123\n\nse_cache$get('abc')\n#&gt; &lt;Key Missing&gt;\nThe keyMissingCacheDecorator can be used with any storr cache, not just the environment-backed cache used in the example above.\n\n\nHow do I make my render function to work with caching?\nIf you are a package developer and have created a render function, it is possible that it will just work with bindCache(), but it See the documentation for bindCache() for more information about this.",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Using caching in Shiny to maximize performance"
    ]
  },
  {
    "objectID": "r/articles/improve/debugging/index.html#introduction",
    "href": "r/articles/improve/debugging/index.html#introduction",
    "title": "Debugging Shiny applications",
    "section": "Introduction",
    "text": "Introduction\nDebugging Shiny applications can be challenging. Because Shiny is reactive, code execution isn‚Äôt as linear as you might be used to, and your application code runs behind a web server and the Shiny framework itself, which can make it harder to access.\nThe goal of this article is to arm you with tools and techniques for debugging in Shiny specifically. If you‚Äôre interested in tools for debugging R more generally, we recommend reading Debugging with RStudio instead. The Debugging and Exceptions chapter in Hadley Wickham‚Äôs excellent book Advanced R is also extremely helpful if you‚Äôre new to debugging in R.\nWe‚Äôll cover three main approaches:\n\nDebugging\nPausing execution of your program, at a place you choose, to inspect its state as each following statement is executed. Best used when you suspect where a problem lies or need to verify the state around a particular section of code.\nTracing\nCollecting information as your program runs, without pausing it, for later analysis. Best used when you‚Äôre diagnosing systemic issues (for instance, reactivity), when you can‚Äôt debug, or when frequent interruption is inappropriate.\nError handling\nFinding the source of errors (both on the client and server side) and ascertaining their cause.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Debugging Shiny applications"
    ]
  },
  {
    "objectID": "r/articles/improve/debugging/index.html#debugging",
    "href": "r/articles/improve/debugging/index.html#debugging",
    "title": "Debugging Shiny applications",
    "section": "Debugging",
    "text": "Debugging\n\nBreakpoints\nIf you know, or suspect you know, where in the code the problem lies, the most straightforward debugging technique is setting a breakpoint. In RStudio, you can do this just by clicking to the left of the line number.\n\n\n\nBreakpoint\n\n\nWhen you run your Shiny app, R will stop execution at the breakpoint, and you can begin stepping through your code.\n\n\n\nBreakpoint\n\n\nWhile stepping, you can examine the contents of the environment and the callstack to see how execution reached your code, and what values it‚Äôs working with.\nCurrently, setting breakpoints inside Shiny applications is only possible in the RStudio IDE because no other R front end implements the Shiny debugging interface; the traditional R breakpoint utilities such as setBreakpoint don‚Äôt work with Shiny.\n\nBreakpoint Limitations\nUnfortunately, breakpoints aren‚Äôt helpful in all situations. For technical reasons, breakpoints can only be used inside the shinyServer function. You can‚Äôt use them in code in other .R files. And breakpoints can tell you something about why code is executing, but they can‚Äôt always tell you why something isn‚Äôt executing.\n\n\n\nbrowser() statements\nThe browser() statement is another useful debugging tool. It acts like a breakpoint‚Äìwhen evaluated, it halts execution and enters the debugger. You can add it anywhere an R expression is valid.\n\n\n\nbrowser()\n\n\nUnlike breakpoints, browser() works everywhere, so it‚Äôs suitable for use in any code invoked by your Shiny app. You can also invoke browser() conditionally to create conditional breakpoints; for instance:\nif (input$bins &gt; 50)\n  browser()\nThe downside of browser() is that you need to re-run your Shiny application to apply it, and you need to remember to take it out afterwards.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Debugging Shiny applications"
    ]
  },
  {
    "objectID": "r/articles/improve/debugging/index.html#tracing",
    "href": "r/articles/improve/debugging/index.html#tracing",
    "title": "Debugging Shiny applications",
    "section": "Tracing",
    "text": "Tracing\nIn many cases it‚Äôs difficult to diagnose a problem by halting execution, and instead you need to observe the system as it runs. This is particularly true of Shiny applications since the system doesn‚Äôt run once through linearly as an R script does! We‚Äôll look at a number of ways to peek into the system while it‚Äôs running.\n\nShowcase Mode\nIf you‚Äôve ever visited the Shiny Gallery, you‚Äôve probably seen Showcase Mode. In Showcase Mode, your code is shown alongside your application, and your application‚Äôs server code flashes yellow when it executes. Here, for example, you can see the plot output chunk re-executing when the inputs change.\n\n\n\nShowcase Mode\n\n\nShowcase Mode is useful for visualizing which parts of your code are executing as a user interacts with your application. It is not enabled by default for privacy reasons (most people don‚Äôt want it to be easy for others to see their app‚Äôs code!), but it‚Äôs easy to turn on. Just invoke runApp directly with display.mode=\"showcase\":\nshiny::runApp(display.mode=\"showcase\")\nIf you want showcase mode to be on by default (for an extended debugging session, or if you want to use showcase mode in conjunction with the IDE Run App button), add a file named DESCRIPTION to your app‚Äôs folder, with these contents:\nTitle: My App\nAuthor: Alice Smith\nDisplayMode: Showcase\nType: Shiny\n\n\nThe Reactive Log\nAnother way to trace the execution of reactives at runtime is to use the Shiny reactive log. In addition to telling you which reactives are executing, the reactive log will help you visualize the dependencies between reactive objects, and give you very detailed information about what‚Äôs happening under the hood as Shiny evaluates your application.\nStart a new R session and run the command:\noptions(shiny.reactlog=TRUE) \nThen, launch your Shiny app. In the Shiny app, press Ctrl+F3 to launch the reactive log visualization. It‚Äôll look something like this:\n\n\n\nShiny reactive log\n\n\nThe reactive log has many features and controls and we won‚Äôt belabor them here; for more information, visit the reactlog documentation website.\n\n\n‚Äúprintf‚Äù tracing\nIn some situations the best tracing technique is the oldest: a statement that emits text to the console when it‚Äôs reached. These are more work to use, but offer the unique advantage of allowing you to emit the values of variables without interrupting execution.\nYou can do this by using the cat command in your Shiny application to print to standard error (stderr()). For instance, from the sample Shiny application:\n# generate bins based on input$bins from ui.R\nx    &lt;- faithful[, 2] \nbins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\ncat(file=stderr(), \"drawing histogram with\", input$bins, \"bins\", \"\\n\")\nAfter adding your cat statement, run your Shiny application and watch the R console. You‚Äôll see a line emitted each time the code runs.\n    Listening on http://127.0.0.1:5757\n    drawing histogram with 30 bins\n    drawing histogram with 35 bins\nA note about stderr(): in most cases cat(\"my output\") (i.e.¬†printing to standard out) will work correctly, but in others (e.g.¬†inside a renderPrint, which uses capture.output to redirect output), it won‚Äôt, so we recommend always sending trace output to stderr().\n\nTracing on Shinyapps.io\ncat() is also one of the few tracing techniques which works well even on a remote system. If your application is deployed on RStudio‚Äôs ShinyApps.io service, then you can see the output the cat() traces in your deployed app, in real time. Here‚Äôs how:\n\nAdd cat(file=stderr(), ..., \"\\n\") tracing statements to your application.\nDeploy your application, using the RStudio IDE or the rsconnect::deployApp() function.\nFrom the application‚Äôs directory, run rsconnect::showLogs(streaming = TRUE)\nNavigate to the application (on ShinyApps.io) in your browser, and watch the R console for output.\n\nYou‚Äôll see something like the following:\n    2016-01-29T01:26:12.291216+00:00 shinyapps[77594]: \n    2016-01-29T01:26:12.291218+00:00 shinyapps[77594]: Starting R with process ID: '26'\n    2016-01-29T01:26:14.162374+00:00 shinyapps[77594]: drawing histogram with 30 bins\n    2016-01-29T01:26:14.495249+00:00 shinyapps[77594]: drawing histogram with 35 bins\nIf your application gets a lot of usage, you may wish to guard the cat() output so that only your own sessions emit it, as it will be otherwise difficult to distinguish output from your own sessions with output from other sessions.\n\n\nTracing on Shiny Server\nThe cat(file=stderr(), ..., \"\\n\") mechanism also works in Shiny Server. The trace output will be placed in a log under:\n    /var/log/shiny-server/*.log\nThere‚Äôs one log for each R process; you can tail -f the log file for any process to see output in real time. Because logs are deleted when the R process ends, you‚Äôll only be able to see logs while your application is open (so don‚Äôt close your browser!).\nYou can read more about Shiny Server‚Äôs logging files/directories for individual Shiny apps in the Logging and Analytics section of the Shiny Server Professional Administrator‚Äôs Guide.\n\n\ncat() Caveats\nOne thing to keep in mind while using cat() to trace values at runtime is that Shiny doesn‚Äôt give it special treatment‚Äìif your cat() expression references reactive values, a dependency will be created. This may cause your application to behave differently with the cat() statement than without it, which is obviously undesirable.\nMake certain that any reactives referenced by the cat() statement are already referenced elsewhere in the observer or reactive in which it resides.\n\n\n\nClient/Server Tracing\nShiny‚Äôs architecture consists of a client (the browser) and a server (an R process). The two are connected by a websocket that receives state changes from the client, such as new values for input controls, and distributes state changes from the server, such as new output values.\nIn some cases (for instance, if you‚Äôre writing your own custom bindings) it‚Äôs helpful to see exactly what‚Äôs going across the wire. You can watch the JSON emitted to and received from the websocket by turning on tracing:\noptions(shiny.trace = TRUE)\nOnce tracing is on, you‚Äôll se a lot of output in the console while your app is running. Here‚Äôs a sample:\n    SEND {\"config\":{\"workerId\":\"\",\"sessionId\":\"04531d50d12554bd981b24b9d3983cc4\"}}\n    RECV {\"method\":\"init\",\"data\":{\"bins\":30,\".clientdata_output_distPlot_width\":610,\".clientdata_output_distPlot_height\":400,\".clientdata_output_distPlot_hidden\":false,\".clientdata_pixelratio\":1,\".clientdata_url_protocol\":\"http:\",\".clientdata_url_hostname\":\"127.0.0.1\",\".clientdata_url_port\":\"5569\",\".clientdata_url_pathname\":\"/\",\".clientdata_url_search\":\"\",\".clientdata_url_hash_initial\":\"\",\".clientdata_singletons\":\"\",\".clientdata_allowDataUriScheme\":true}}\nThe log is from the perspective of the client, so:\nSEND indicates data sent from the browser to the R session.\nRECV indicates data sent from the R session to the browser.\nAnother way to dig into the data available to the R session is to look at the session$clientData object. You can read more in this article on the Shiny developer center:\nLearn about your user with session$clientData\n\n\nWhat about trace()?\nIf you‚Äôre a seasoned R programmer, you may have used the trace() function to add tracing without modifying your script. Unfortunately, it‚Äôs not possible to use this utility (or any that depend on it, such as setBreakpoint) with Shiny. trace() works by rewriting the body of the function to be traced, so the function must already exist when you run it. Shiny generates functions at runtime that aren‚Äôt easily addressable.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Debugging Shiny applications"
    ]
  },
  {
    "objectID": "r/articles/improve/debugging/index.html#errors",
    "href": "r/articles/improve/debugging/index.html#errors",
    "title": "Debugging Shiny applications",
    "section": "Errors",
    "text": "Errors\nSome code defects will result in a runtime error. While no one likes to see errors, they can be an invaluable tool for helping you verify code preconditions at runtime. Often, throwing an error immediately when the system‚Äôs state becomes invalid (known as the fail-fast property) will save you debugging time, as an observed problem may be miles downstream from its source.\nWhether you‚Äôre throwing your own errors or handling errors thrown elsewhere (for instance, by packages your Shiny application uses), here are some essentials for your toolkit.\n\nR errors\nMost of the errors you‚Äôll be dealing with will be raised by R; here we‚Äôll describe strategies for dealing with these errors.\n\nR error tracebacks\nIn earlier versions of Shiny, it could be difficult to locate errors; they the error itself would be printed at the console, but it was always necessary to do some work to see where the error originated.\nThankfully the latest version of Shiny (0.13.0 at time of writing) includes a feature which automatically dumps not only the error but a stack trace indicating where the error occurred to the console.\nTry, for example, introducing an error into the sample Shiny app.\nbins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\nif (input$bins &gt; 40)\n  stop(\"too many bins\")\nNow, run the app and drag the slider to the right to enter the error condition. The console will show you a stack trace: ```console     Warning: Error in renderPlot: too many bins     Stack trace (innermost first):         76: renderPlot [server.R#20]         68: output$distPlot          1: shiny::runApp\nWhat are those numbers before the function names (76, 68, and 1)? They‚Äôre the indices into the call stack, which in this case contains nearly 80 calls. Most of those calls, though, are Shiny internals, which are hidden to make the stack trace easier to read. In the vast majority of cases, these internals won‚Äôt be relevant to your error.\nIf you do need to see the entire call stack, you can set:\noptions(shiny.fullstacktrace = TRUE)\nAs you might imagine, this prints a very verbose stack strace!\n\n    Warning: Error in renderPlot: too many bins\n    Stack trace (innermost first):\n        79: h\n        78: .handleSimpleError\n        77: stop\n        76: renderPlot [server.R#20]\n        75: ..stacktraceon..\n        74: func\n        73: withVisible\n        72: func\n        71: &lt;Anonymous&gt;\n        70: do.call\n        69: ..stacktraceoff..\n        68: output$distPlot\n        67: ..stacktraceon..\n        66: orig\n        65: func\n        64: withCallingHandlers\n        63: captureStackTraces\n        62: withCallingHandlers\n        61: shinyCallingHandlers\n        60: doTryCatch\n        59: tryCatchOne\n        58: tryCatchList\n        57: doTryCatch\n        56: tryCatchOne\n        55: tryCatchList\n        54: tryCatch\n        53: observerFunc\n        52: doTryCatch\n        51: tryCatchOne\n        50: tryCatchList\n        49: tryCatch\n        48: contextFunc\n        47: env$runWith\n        46: withReactiveDomain\n        45: ctx$run\n        44: run\n        43: withCallingHandlers\n        42: captureStackTraces\n        41: withCallingHandlers\n        40: shinyCallingHandlers\n        39: doTryCatch\n        38: tryCatchOne\n        37: tryCatchList\n        36: tryCatch\n        35: flushCallback\n        34: FUN\n        33: lapply\n        32: ctx$executeFlushCallbacks\n        31: .getReactiveEnvironment()$flush\n        30: flushReact\n        29: withReactiveDomain\n        28: messageHandler\n        27: withCallingHandlers\n        26: captureStackTraces\n        25: withCallingHandlers\n        24: withLogErrors\n        23: handler\n        22: doTryCatch\n        21: tryCatchOne\n        20: tryCatchList\n        19: tryCatch\n        18: try\n        17: &lt;Anonymous&gt;\n        16: eval\n        15: evalq\n        14: doTryCatch\n        13: tryCatchOne\n        12: tryCatchList\n        11: doTryCatch\n        10: tryCatchOne\n         9: tryCatchList\n         8: tryCatch\n         7: run\n         6: service\n         5: serviceApp\n         4: withCallingHandlers\n         3: captureStackTraces\n         2: ..stacktraceoff..\n         1: runApp\nThe ..stacktraceon.. and ..stacktraceoff.. calls indicate where Shiny would ordinarily have collapsed the stack.\n\n\nPausing on errors\nSometimes, knowing where an error occurred gives you enough information to fix it. At other times, though, you‚Äôll need additional context: What were the arguments to functions in the callstack? What were the values of local variables at the time the error occured? And so on.\nYou can cause Shiny to enter the debugger when an error occurs by using the following statement:\noptions(shiny.error = browser)\nWhen an error occurs, Shiny will run the function you name (here it‚Äôs our old frind browser()) and wait for it to return before handling the error. This gives you an opportunity to inspect the state of the system at the exact moment the error arose.\n\n\n\nShiny error\n\n\nNow you can see, for example, the value of bins and x at the time the error occurred. There are some subtleties associated with error debugging, however:\n\nSelecting a stack frame\nSometimes, the debugger won‚Äôt put you in the frame you expect. If this happens, use the Traceback pane in RStudio and click on the frame you‚Äôre interested in to see the code and values in that frame.\nNote, however, that clicking on a frame won‚Äôt actually change the environment in which expressions entered at the R console are evaluated. If you want to actually browse the environment of a stack frame interactively, use recover() to select a frame.\n\n\nContinuing after an error\nThe shiny.error function is invoked when an error occurs, but once the error has occurred, it‚Äôs too late to suppress it! You‚Äôre debugging, but there‚Äôs no next expression to step to; after you‚Äôre finished inspecting the error, continue in the debugger (type c or press Continue in RStudio) to let Shiny handle the error as it normally would.\n\n\n\n\nJavaScript errors\nOccasionally, a runtime problem will be caused by an error occurring in JavaScript. This is most common when working with custom bindings and third-party JavaScript components.\nMost web browsers contain a JavaScript console that can be used to view logs and unhandled exceptions. We‚Äôll focus here on Chrome since it‚Äôs widely used on all three major desktop platforms, but the other major browsers are structured very similarly.\nTo reach the JavaScript console in Chrome, do one of the following:\n\nClick on the ‚Äúhamburger menu‚Äù in the upper right corner of the browser\nNavigate to More Tools -&gt; Developer Tools.\n\nOr, right click on the Shiny app and choose Inspect.\nOnce you have the developer tools open, click the Console tab. Here you‚Äôll see any unhandled JavaScript exceptions; for instance, here‚Äôs an error raised when trying to load a Shiny app that‚Äôs no longer running:\n\n\n\nconsole error\n\n\nLeaving the development tools open is also a good idea when looking for JavaScript issues; in most browsers, merely having the developer tools open is enough to cause the browser enter the debugger automatically when an unhandled exception occurs.\n\nFirst-chance exceptions\nThe JavaScript console doesn‚Äôt tell you about all the JavaScript exceptions that were thrown, only those that were never caught. Sometimes, however, an exception that‚Äôs swallowed by an exception handler contains crucial information.\nA little-known feature in most JavaScript debuggers will allow you to see exceptions when they‚Äôre thrown (regardless of whether they‚Äôre caught later). These are sometimes called ‚Äúfirst chance‚Äù exceptions. You can break on them in Chrome by clicking the stop button labeled with pause (representing break on exception) and then checking the box ‚ÄúPause on Caught Exceptions‚Äù.\n\n\n\npause on exceptions\n\n\nIf the thrown/caught terminology is confusing to you, remember that the debugger typically pauses on uncaught (or unhandled) exceptions; you‚Äôre asking it to pause on caught (handled) exceptions too.\nThere are great reference materials online available for most browser debugging tools (here‚Äôs one for Chrome).\n\n\nRStudio Desktop\nOn Windows and Linux, there‚Äôs a JavaScript console and debugger built into RStudio (many components of RStudio, including the window that displays Shiny applications, is built on an embedded copy of QtWebKit. You can‚Äôt access it through a menu, but you can by right-clicking on your Shiny application and choosing Inspect.\nOn OS X, RStudio uses your system‚Äôs version of Safari to show Shiny applications. By default, Safari‚Äôs JavaScript debugging tools are turned off inside RStudio, but you can turn them on using this command in Terminal:\ndefaults write org.rstudio.RStudio WebKitDeveloperExtras -bool true\nRestart RStudio, start your Shiny app, right-click on it, and you‚Äôll see a new Inspect Element option. Click it to launch the Safari JavaScript debugger.\n\n\n\ninspect element",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Debugging Shiny applications"
    ]
  },
  {
    "objectID": "r/articles/improve/debugging/index.html#asking-for-help",
    "href": "r/articles/improve/debugging/index.html#asking-for-help",
    "title": "Debugging Shiny applications",
    "section": "Asking for Help",
    "text": "Asking for Help\nSome bugs won‚Äôt yield to even the most determined attempts at analysis, and you‚Äôll need to enlist the help of a second set of eyes. Fortunately there are several active forums where you can ask questions. Two we recommend are ‚Äòshiny‚Äô at StackOverflow and the shiny-discuss Google group.\nWhen asking for help, try to eliminate all the parts of your application that aren‚Äôt related to the problem, so that anyone volunteering to help can understand the issue quickly. You‚Äôll often find that the process of isolating the problem and formulating a description leads you to the answer before you can post the question!\nThe article How to get help on the Shiny Developer Center describes in detail what you‚Äôll want to include when asking for help.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Debugging Shiny applications"
    ]
  },
  {
    "objectID": "r/articles/improve/debugging/index.html#learn-more",
    "href": "r/articles/improve/debugging/index.html#learn-more",
    "title": "Debugging Shiny applications",
    "section": "Learn more",
    "text": "Learn more\nFor more on this topic, see the following resources:\n Debugging techniques",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Debugging Shiny applications"
    ]
  },
  {
    "objectID": "r/articles/improve/performance/index.html",
    "href": "r/articles/improve/performance/index.html",
    "title": "Performance",
    "section": "",
    "text": "Now that you know how to profile your Shiny app code to identify which parts of your code is slowing down your app, the next step is to increase the performance of your code and hence your app. The following video from rstudio::conf 2018 has some tips on this.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis video‚Äôs page at Posit.co",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Performance"
    ]
  },
  {
    "objectID": "r/articles/improve/profiling/index.html",
    "href": "r/articles/improve/profiling/index.html",
    "title": "Profiling your Shiny app",
    "section": "",
    "text": "The profvis package provides tools for helping you to understand how R spends its time. It provides a interactive graphical interface for visualizing data from Rprof, R‚Äôs built-in tool for collecting profiling data.\nThe profvis homepage provides an extensive instructions for working with this package, as well as an example on specifically profiling a Shiny app.",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Profiling your Shiny app"
    ]
  },
  {
    "objectID": "r/articles/improve/profiling/index.html#learn-more",
    "href": "r/articles/improve/profiling/index.html#learn-more",
    "title": "Profiling your Shiny app",
    "section": "Learn more",
    "text": "Learn more\nFor more on this topic, see the following resources:\n\nFaster Shiny apps with profiling tools",
    "crumbs": [
      "Improve",
      "Scale",
      "Performance and scalability",
      "Profiling your Shiny app"
    ]
  },
  {
    "objectID": "r/articles/improve/req/index.html",
    "href": "r/articles/improve/req/index.html",
    "title": "Handling missing inputs with req(‚Ä¶)",
    "section": "",
    "text": "When writing Shiny apps, it‚Äôs fairly common to have a reactive expression or output that can only proceed under certain conditions.\nPerhaps we need to wait until the user chooses a value from a selectInput or clicks an actionButton, and if such conditions are not met, the output should not be shown.\nOr if your app uses renderUI to dynamically populate the app‚Äôs input controls, then for a few moments during app startup, the inputs you depend on might not even exist.\nIf you write your application without considering such conditions, you may find your outputs rendering with ugly and confusing error messages. Here‚Äôs an example:\nThe value of input$datasetName starts out as \"\", which causes the dataset reactive expression to fail.\nA primitive solution is to add precondition checks to all reactive expressions and outputs, and return NULL if any conditions are not met. Most (though not all) outputs will clear themselves if they are asked to render NULL.\nSee below as we add if (...) return(NULL) to dataset, output$plot, and output$table.\nWhile this does work, it seems a shame that such a simple app needs three different manual checks and early returns. If any new reactive expressions or outputs are introduced that depend on dataset, they‚Äôll also need to remember to check for null and return early.\nFortunately, there‚Äôs a better way.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Handling missing inputs with req(...)"
    ]
  },
  {
    "objectID": "r/articles/improve/req/index.html#introducing-req",
    "href": "r/articles/improve/req/index.html#introducing-req",
    "title": "Handling missing inputs with req(‚Ä¶)",
    "section": "Introducing req",
    "text": "Introducing req\nThe req(...) function was introduced in Shiny 0.13 to simplify dealing with missing inputs and other preconditions. req is short for ‚Äúrequire‚Äù, so req(x) can be read as either ‚Äúrequire x to be available‚Äù.\nYou call req with one or more arguments. req will evaluate each argument one at a time, and if it encounters an argument that it considers to be ‚Äúmissing‚Äù or ‚Äúfalse‚Äù (see below for exactly what this means), it will stop.\nHere‚Äôs our previous example again, using req this time:\nlibrary(shiny)\n\nui &lt;- fluidPage(\n  selectInput(\"datasetName\", \"Dataset\", c(\"\", \"pressure\", \"cars\")),\n  plotOutput(\"plot\"),\n  tableOutput(\"table\")\n)\n\nserver &lt;- function(input, output, session) {\n  dataset &lt;- reactive({\n    # Make sure requirements are met\n    req(input$datasetName)\n\n    get(input$datasetName, \"package:datasets\", inherits = FALSE)\n  })\n\n  output$plot &lt;- renderPlot({\n    plot(dataset())\n  })\n\n  output$table &lt;- renderTable({\n    head(dataset(), 10)\n  })\n}\n\nshinyApp(ui, server)\nAs you can see, dataset uses the req function, and the outputs don‚Äôt do any checking. Unlike using return(NULL), when you use req to check your preconditions, a failure not only stops the current calculation (the dataset reactive expression, in this case) but also any callers on the call stack. In this case, if the user has not chosen a dataset, then output$plot and output$table both stop upon calling dataset().\nThis is because when req detects a failure, it doesn‚Äôt simply return, but actually raises an error by calling stop().\nYou can think of req as being like base::stopifnot, with a couple of key differences:\n\nFirst, the error raised by req is a special, ‚Äúsilent‚Äù error that Shiny knows shouldn‚Äôt actually be displayed to the user, nor printed to the console.\nSecond, while stopifnot simply checks if its arguments are TRUE, req has a more complicated set of rules that determine what arguments trigger an error.\n\n\nTruthy and falsy values\nThe terms ‚Äútruthy‚Äù and ‚Äúfalsy‚Äù generally indicate whether a value, when coerced to a logical, is TRUE or FALSE. We use the term a little loosely here; our usage tries to match the intuitive notions of ‚ÄúIs this value missing or available?‚Äù, or ‚ÄúHas the user provided an answer?‚Äù, or in the case of action buttons, ‚ÄúHas the button been clicked?‚Äù.\nFor example, a textInput that has not been filled out by the user has a value of \"\", so that is considered a falsy value.\nTo be precise, req considers a value truthy unless it is one of:\n\nFALSE\nNULL\n\"\"\nAn empty atomic vector\nAn atomic vector that contains only missing values\nA logical vector that contains all FALSE or missing values\nAn object of class \"try-error\" (see ?base::try)\nA value that represents an unclicked actionButton\n\nNote in particular that the value 0 is considered truthy, even though as.logical(0) is FALSE.\nIf the built-in rules for truthiness do not match your requirements, you can always work around them. Since FALSE is falsy, you can simply provide the results of your own checks to req, e.g.: req(input$a != 0).\n\n\nSee also: validate/need\nSince req causes outputs to stop silently, it‚Äôs not useful in situations where the user needs to be told what values are missing or what user actions need to be taken to proceed.\nIn that case, you need the more flexible validation feature, which provides a superset of req‚Äôs features via the validate/need functions; req(x) is mostly just shorthand for validate(need(x, message = FALSE)).\nThe downside of validate is that its API is more complicated and less intuitive than req, so we recommend that you stick to req whenever you can.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Handling missing inputs with req(...)"
    ]
  },
  {
    "objectID": "r/articles/improve/scaling-and-tuning-ssp-rsc/index.html",
    "href": "r/articles/improve/scaling-and-tuning-ssp-rsc/index.html",
    "title": "Scaling and Performance Tuning with Shiny Server Pro and Posit Connect",
    "section": "",
    "text": "If you have already read the Scaling and Performance Tuning with shinyapps.io, you should be familiar with some of the tips and tricks for tuning your Shiny app. However if your app is deployed on Shiny Server Pro or Posit Connect, the following support documents will be more directly relevant to you:\n\nScaling and Performance Tuning Applications in Shiny Server Pro\nScaling and Performance Tuning in Posit Connect",
    "crumbs": [
      "Improve",
      "Scale",
      "Tuning",
      "Scaling and Performance Tuning with Shiny Server Pro and Posit Connect"
    ]
  },
  {
    "objectID": "r/articles/improve/scoping/index.html#scoping",
    "href": "r/articles/improve/scoping/index.html#scoping",
    "title": "Scoping rules for Shiny apps",
    "section": "Scoping",
    "text": "Scoping\nWhere you define objects will determine where the objects are visible. There are three different levels of visibility that you‚Äôll want to be aware of when writing Shiny apps. Some objects are visible within the server code of each user session; other objects are visible in the server code across all sessions (multiple users could use a shared variable); and yet others are visible in the server and the ui code across all user sessions.\nThis document describes how scoping works within a single R process. One R process can support multiple Shiny sessions. Some hosting platforms (including Posit Connect, Shiny Server Pro, and shinyapps.io) also allow running multiple R processes to handle heavier traffic. Within each R process, the scoping works as explained below, but between the R processes, no objects are shared. So, for example, if you configure Posit Connect to start a new R process for each connection to your app, no objects will ever be shared between different sessions of the app, since these sessions all belong to different R processes. (To learn more about about this, and how it affects the performance of your apps, see this article.)\n\nPer-session objects\nIn app.R, the server function takes three arguments: input, output and session.\nserver &lt;- function(input, output, session) {\n  # Server code here\n  # ...\n})\nThe function is called once for each session. In other words, the server function is called each time a web browser is pointed to the Shiny application.\nEverything within this function is instantiated separately for each session. This includes the input, output and session objects that are passed to it: each session has its own input, output and session objects, visible within this function.\nOther objects inside the function, such as variables and functions, are also instantiated for each session. In this example, each session will have its own variable named startTime, which records the start time for the session:\nserver &lt;- function(input, output, session) {\n  startTime &lt;- Sys.time()\n\n  # ...\n}\n\n\nObjects visible across all sessions\nYou might want some objects to be visible across all sessions. For example, if you have large data structures, or if you have utility functions that are not reactive (ones that don‚Äôt involve the input or output objects), then you can create these objects once and share them across all user sessions (within the same R process), by placing them in app.R, but outside of the server function definition.\nFor example:\n# A read-only data set that will load once, when Shiny starts, and will be\n# available to each user session\nbigDataSet &lt;- read.csv(\"bigdata.csv\")\n\n# A non-reactive function that will be available to each user session\nutilityFunction &lt;- function(x) {\n  # Function code here\n  # ...\n}\n\nserver &lt;- function(input, output, session) {\n  # Server code here\n  # ...\n}\nYou could put bigDataSet and utilityFunction inside the server function, but doing so will be less efficient, because they will be created each time a user connects.\nIf the objects change, then the changed objects will be visible in every user session. But note that you would need to use the &lt;&lt;- assignment operator to change bigDataSet, because the &lt;- operator only assigns values in the local environment.\nvarA &lt;- 1\nvarB &lt;- 1\nlistA &lt;- list(X = 1, Y = 2)\nlistB &lt;- list(X = 1, Y = 2)\n\nserver &lt;- function(input, output, session) {\n  # Create a local variable varA, which will be a copy of the shared variable\n  # varA plus 1. This local copy of varA is not be visible in other sessions.\n  varA &lt;- varA + 1\n\n  # Modify the shared variable varB. It will be visible in other sessions.\n  varB &lt;&lt;- varB + 1\n\n  # Makes a local copy of listA\n  listA$X &lt;- 5\n\n  # Modify the shared copy of listB\n  listB$X &lt;&lt;- 5\n\n  # ...\n}\nThings work this way because app.R is sourced when you start your Shiny app. Everything in this script is run immediately. However, your server function is only actually called when a web browser connects and a new session is started\n\n\nGlobal objects\nObjects defined in global.R are similar to those defined in app.R outside of the server function definition, with one important difference: they are loaded into the global environment of the R session; all R code in a Shiny app is run in the global environment or a child of it.\nIn practice, there aren‚Äôt many times where it‚Äôs necessary to share variables between server and ui. The code in ui is run once, when the Shiny app is started and it generates an HTML file which is cached and sent to each web browser that connects. This may be useful for setting some shared configuration options.\n\n\nScope for included R files\nIf you want to split the server or ui code into multiple files, you can use source(local = TRUE) to load each file. You can think of this as putting the code in-line, so the code from the sourced files will receive the same scope as if you copied and pasted the text right there.\nThis example app.R file shows how sourced files will be scoped:\n# Objects in this file are shared across all sessions in the same R process\nsource('all_sessions.R', local = TRUE)\n\nserver &lt;- function(input, output, session) {\n  # Objects in this file are defined in each session\n  source('each_session.R', local = TRUE)\n\n  output$text &lt;- renderText({\n    # Objects in this file are defined each time this function is called\n    source('each_call.R', local = TRUE)\n\n    # ...\n  })\n}\nIf you use the default value of local = FALSE, then the file will be sourced in the global environment.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Scoping rules for Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/improve/shinytest/index.html",
    "href": "r/articles/improve/shinytest/index.html",
    "title": "shinytest",
    "section": "",
    "text": "The shinytest package is one part of a comprehensive strategy for testing Shiny applications. To understand how it fits in, please see the testing overview.\nIf you‚Äôd like to use shinytest, see the package getting started guide.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Testing",
      "shinytest"
    ]
  },
  {
    "objectID": "r/articles/improve/shinytest/index.html#learn-more",
    "href": "r/articles/improve/shinytest/index.html#learn-more",
    "title": "shinytest",
    "section": "Learn more",
    "text": "Learn more\nFor more on this topic, see the following resources:\n Testing Shiny applications with Shinytest",
    "crumbs": [
      "Improve",
      "Refactor",
      "Testing",
      "shinytest"
    ]
  },
  {
    "objectID": "r/articles/improve/unicode/index.html",
    "href": "r/articles/improve/unicode/index.html",
    "title": "Unicode characters in Shiny apps",
    "section": "",
    "text": "Since Shiny v0.10.1, we have added support for multi-byte characters in Shiny apps on Windows. Linux and Mac OS X users normally do not need to worry about character encodings or non-ASCII characters, and they can basically ignore this article, since their system locale is often UTF-8 based. However, Windows does not have a single consistent locale or native character encoding, which makes it tricky to support multi-byte characters there. For the sake of consistency and portability, Shiny requires the character encoding of all its components to be UTF-8, which include ui.R, server.R, global.R, DESCRIPTION, and/or README.md. Note a Shiny app may not contain all of these files, but all of them must be encoded in UTF-8 if they exist.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Unicode characters in Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/improve/unicode/index.html#text-editors",
    "href": "r/articles/improve/unicode/index.html#text-editors",
    "title": "Unicode characters in Shiny apps",
    "section": "Text Editors",
    "text": "Text Editors\nA modern text editor should allow you to save a text file with a specified encoding. For example, if you use the RStudio IDE, you can click the menu File -&gt; Save with Encoding to (re)save a file with the UTF-8 encoding:\n\n\n\nUse UTF-8 in RStudio\n\n\nIf you do not use RStudio, there is one more thing to keep in mind: when you save a file with UTF-8, you should make sure not to include the byte order mark (BOM). Some text editors do include it by default, such as Notepad (the default text editor on Windows). Shiny will try to detect the BOM character, and give a warning if it exists. For a file that is encoded in UTF-8 with BOM, you can open it with the UTF-8 encoding in RStudio, re-save it with the UTF-8 encoding, and the BOM will be removed. There are many other text editors that support UTF-8 with or without BOM, such as Notepad++:\n\n\n\nUTF-8 without BOM in Notepad++",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Unicode characters in Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/improve/unicode/index.html#an-example-chinese-characters",
    "href": "r/articles/improve/unicode/index.html#an-example-chinese-characters",
    "title": "Unicode characters in Shiny apps",
    "section": "An Example (Chinese Characters)",
    "text": "An Example (Chinese Characters)\nThere is an example in the gallery demonstrating Simplified Chinese characters in a Shiny app, in which we used Chinese characters in many places, such as R comments, the title of the page, the label and choices of the select input, the JavaScript condition of the conditional panel, the id of the verbatim text output, the R formula, and so on.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Unicode characters in Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/improve/unicode/index.html#file-inputoutput",
    "href": "r/articles/improve/unicode/index.html#file-inputoutput",
    "title": "Unicode characters in Shiny apps",
    "section": "File Input/Output",
    "text": "File Input/Output\nWhen your Shiny app involves file input/output, the character encoding does not have to be UTF-8. Although we recommend UTF-8 in Shiny, it is not the default encoding on Windows anyway, so your app users may have trouble especially when they have file interactions with your app.\nMany I/O functions in R have an argument named encoding (sometimes fileEncoding). If the data to be read or written is not encoded with the native encoding of your system, you may have to use the encoding argument. For example, when reading a text file encoded in UTF-8 into a Shiny app, you may use readLines('foo.txt', encoding = 'UTF-8'). Similarly, when writing a CSV file with the GB2312 encoding (a commonly used encoding for Simplified Chinese), you can use write.csv(data, fileEncoding = 'GB2312'). This is very important when using the fileInput() or downloadHandler() functions in the shiny package.\nIf you read a file into R as a character vector, and the file is not encoded with your system‚Äôs native encoding, you are recommended to convert the encoding of the character vector to your system‚Äôs native encoding before you process the text data. Some character string processing functions such as gsub(..., fixed = TRUE) may not work if the string does not have the native encoding.\nx &lt;- readLines('foo.txt', encoding = 'UTF-8')\nx &lt;- enc2native(x)\ngsub(' ', '-', x, fixed = TRUE)",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Unicode characters in Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/improve/unicode/index.html#the-global-encoding-option",
    "href": "r/articles/improve/unicode/index.html#the-global-encoding-option",
    "title": "Unicode characters in Shiny apps",
    "section": "The Global encoding Option",
    "text": "The Global encoding Option\nThe function options() in base R can be used to set some global options for the current R session, among which there is an encoding option. Its default value is native.enc (native encoding), which is not really a standard encoding name, and its meaning differs on different platforms. On Linux and Mac OS X, the native encoding is often UTF-8. If you are not sure what your native encoding is, the function localeToCharset() in base R should give a reasonable guess in most cases.\nWhen dealing with encoding problems, you are not recommended to set the encoding option to a specific encoding name, e.g.¬†options(encoding = 'UTF-8'). This may have very bad consequences, since it makes a strong assumption that all file connections and character manipulations should use this encoding by default.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Unicode characters in Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/improve/unicode/index.html#shinyapps.io",
    "href": "r/articles/improve/unicode/index.html#shinyapps.io",
    "title": "Unicode characters in Shiny apps",
    "section": "Shinyapps.io",
    "text": "Shinyapps.io\nFor shinyapps.io users, the platform is based on Linux containers, and has a UTF-8 locale. If your app reads/writes data files that contain multi-byte characters, you are strongly recommended to be specific about the encodings when calling the I/O functions, because your local environment may not be based on UTF-8. The functions iconv(), iconvlist(), enc2native(), and enc2utf8() may be useful if you need to convert the encoding from one to another.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Unicode characters in Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/improve/unicode/index.html#summary",
    "href": "r/articles/improve/unicode/index.html#summary",
    "title": "Unicode characters in Shiny apps",
    "section": "Summary",
    "text": "Summary\nTo sum up, three things to keep in mind when dealing with character strings in R:\n\nThe encoding should be specified explicitly per (file) connection basis, if you want your R code to be portable;\nAfter you read Unicode characters into R, convert them to the native encoding of your system, e.g.¬†using enc2native();\nDo not set options(encoding).",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Unicode characters in Shiny apps"
    ]
  },
  {
    "objectID": "r/articles/improve/validation/index.html",
    "href": "r/articles/improve/validation/index.html",
    "title": "Write error messages for your UI with validate",
    "section": "",
    "text": "Have you ever seen a Shiny app go wrong? Shiny delivers a bold red error message to your user. This message is often unhelpful because it mentions things that you may understand as a developer, but that your user may not.\nThis article will show you how to craft ‚Äúvalidation errors,‚Äù errors designed to lead your user through the UI of your Shiny app. Validation errors are user-friendly and, unlike the bold red error message, pleasing to the eye. Best of all, validation errors respond directly to your user‚Äôs input.\nWe‚Äôll start by creating an app that quickly returns an error message. The app.R script below makes a simple app that displays a table and draws a plot. To make this app, copy these scripts into your working directory and run:\nNote: This file needs to be the only one named app.R in your working directory.\nWhen you first launch the app, it should look like this picture:\nThe app displays a table and then draws a plot beneath it, but both the table and plot depend on the value of the select box. Until your user selects a data set, the app will display two red error messages.\nOur goal is to replace these error messages. We want messages that:\nYou can write these more helpful messages with Shiny‚Äôs validate function.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Write error messages for your UI with validate"
    ]
  },
  {
    "objectID": "r/articles/improve/validation/index.html#validate",
    "href": "r/articles/improve/validation/index.html#validate",
    "title": "Write error messages for your UI with validate",
    "section": "validate",
    "text": "validate\nvalidate tests a condition and returns a validation error if the test fails. Validation errors are designed to interact with the Shiny framework in a pleasing way. Shiny will:\n\nrecognize a validation error\ndisplay a validation error in a neutral grey color\npass a validation error to any reactive expression or observer object that depends on it\n\nvalidate takes one or more specially formatted arguments. You can provide these arguments need, a new function designed to work with validate. You can also provide these arguments with your own functions if you like.\n\nneed\nneed provides a simple way to tell Shiny what to test and what to return if the test goes wrong. need uses two arguments\n\nAn R expression that returns TRUE or FALSE.\nA character string. Shiny will display this string as a validation error message if the R expression returns FALSE. If the R expression returns TRUE, Shiny treats the validation test as if it passed and continues with the app.\n\nLet‚Äôs put these ideas all together.\nYou can create a complete validation test by calling validate and passing it the output of need:\nvalidate(\n  need(input$data != \"\", \"Please select a data set\")\n)\nThe validation test above checks whether an object named input$data is an empty string. If the object is an empty string, the test returns the message: ‚ÄúPlease select a data set.‚Äù\nTo use this validation test in your app, place it at the start of any reactive or render* expression that calls input$data. In our app, our validation test appears in this server function after reactive({:\nserver &lt;- function(input, output) {\n\n  data &lt;- reactive({\n    validate(\n      need(input$data != \"\", \"Please select a data set\")\n    )\n    get(input$data, 'package:datasets')\n  })\n\n  output$plot &lt;- renderPlot({\n    hist(data()[, 1], col = 'forestgreen', border = 'white')\n  })\n\n  output$table &lt;- renderTable({\n    head(data())\n  })\n\n}\nModify your script and relaunch the app. Now Shiny runs the validation test before it uses input$data and encounters an error, and the app does not show the bold red error message. Instead it displays your user-friendly validation error message.\n\n\nBest practices\nNotice that neither output$plot nor output$table call the validation test. However, both the plot and table objects display the validation error message.\nWhen these objects call data(), data() retrieves the value of the reactive expression data. In our example, the value of the reactive expression data is the validation error message because the validation test fails.\nYou can use this arrangement to write efficient apps: one that fail fast and in a useful manner. To do this:\n\nSeparate input objects that might cause trouble into their own reactive expressions.\nHave each reactive expression run a validation test on the input.\nArrange for other objects to access the input by calling the reactive expression.\n\nThis arrangement will let you use one validation test per input to catch any errors generated by your apps UI.\n\n\nLabels\nYou do not have to provide need with a full message to display. If you prefer, you can skip the message and pass need a label argument. If you do, need will construct a message by adding ‚Äúmust be provided‚Äù to the end of your label.\nYou can see this behavior in this app:\n\nIt uses the following server function.\nserver &lt;- function(input, output) {\n\n  data &lt;- reactive({\n    validate(\n      need(input$data != \"\", label = \"data set\")\n    )\n    get(input$data, 'package:datasets')\n  })\n\n  output$plot &lt;- renderPlot({\n    hist(data()[, 1], col = 'forestgreen', border = 'white')\n  })\n\n  output$table &lt;- renderTable({\n    head(data())\n  })\n\n}\n\n\nErrors vs.¬†Validation errors\nValidation tests do not remove the possibility of other types of errors. Shiny will still display system error messages in the familiar bold red font (designed to catch the developer‚Äôs eye) when they happen.\nFor example, Shiny will display a red error message if the R expression in need returns an error. In the code below, the need expression calls the object foo, but foo does not exist.\nserver &lt;- function(input, output) {\n\n  data &lt;- reactive({\n    validate(\n      need(input$data != foo, \"Please select a data set\")\n    )\n    get(input$data, 'package:datasets')\n  })\n\n  output$plot &lt;- renderPlot({\n    hist(data()[, 1], col = 'forestgreen', border = 'white')\n  })\n\n  output$table &lt;- renderTable({\n    head(data())\n  })\n\n}\nSince Shiny cannot find foo, it displays a system error message.\n\nYou can prevent validation tests from generating system errors by wrapping the first argument of need in try:\n    validate(\n      need(try(input$data != foo), \"Please select a data set\")\n    )\ntry returns a try error if input$data != foo fails. need treats try errors the same way it treats FALSEs. If the first argument of need returns a try error, need returns a validation error that displays its message.\nSeveral other types of output also trigger need to return a validation error. You can write the first argument of need to return any output from the list below (if the validation fails). need returns a validation error for each of these outputs.\n\nFALSE\nNULL\n‚Äú‚Äù\nAn empty atomic vector\nAn atomic vector that contains only missing values\nA logical vector that contains all FALSE or missing values\nAn object of class try-error\nA value that represents an unclicked actionButton\n\n\n\n\nWrite your own tests\nShiny power users can write their own need functions. This can be useful if you test for the same conditions across many apps. You can use any function in place of need as long as your function returns one of three objects:\n\nNULL\nA character string\nFALSE\n\nvalidate will run the function and then proceed in one of three ways.\n\nIf your function returns NULL, validate will consider the check to have passed, and proceed as normal.\nIf your function returns a character string, validate will consider the check to have failed and will return the string as a validation error to be displayed.\nIf your function returnsFALSE, validate will fail silently. Shiny will not continue with the app (which would result in a red error message), but it will not display a grey validation error message either.\n\nHere is an example of a need type function:\nnot_mtcars &lt;- function(input) {\n  if (input == \"mtcars\") {\n     \"Choose another data set. No mtcars please!\"\n  } else if (input == \"\") {\n     FALSE\n  } else {\n    NULL\n  }\n}\nHere is the function in use:\nnot_mtcars &lt;- function(input) {\n  if (input == \"mtcars\") {\n     \"Choose another data set. No mtcars please!\"\n  } else if (input == \"\") {\n     FALSE\n  } else {\n    NULL\n  }\n}\n\nserver &lt;- function(input, output) {\n\n  data &lt;- reactive({\n    validate(\n      not_mtcars(input$data)\n    )\n    get(input$data, 'package:datasets')\n  })\n\n  output$plot &lt;- renderPlot({\n    hist(data()[, 1], col = 'forestgreen', border = 'white')\n  })\n\n  output$table &lt;- renderTable({\n    head(data())\n  })\n\n}\nWhen this app first launches, it looks like this app:\n\nWhen you select mtcars in the select box, the app looks like this:\n\nWhen you select another data set, the app displays the table and plot:\n\n\n\nMultiple conditions\nYou can check multiple conditions in a single validate call. To do this, pass validate multiple need statements (or similar functions, as described above) separated by commas. Shiny will display the message of every condition that fails.\nThis code contains three conditions that fail and one that passes:\nserver &lt;- function(input, output) {\n\n  data &lt;- reactive({\n    validate(\n      need(input$data != \"\", \"Please select a data set\"),\n      need(input$data %in% c(\"mtcars\", \"faithful\", \"iris\"),\n        \"Unrecognized data set\"),\n      need(input$data, \"Input is an empty string\"),\n      need(!is.null(input$data),\n        \"Input is not an empty string, it is NULL\")\n    )\n    get(input$data, 'package:datasets')\n  })\n\n  output$plot &lt;- renderPlot({\n    hist(data()[, 1], col = 'forestgreen', border = 'white')\n  })\n\n  output$table &lt;- renderTable({\n    head(data())\n  })\n\n}\nWhen you run it, the code creates this app:\n\n\n%then%\nIf you prefer to display one validation error message at a time, you may chain conditions together with the %then% operator, which we‚Äôll define at the top of this app:\n`%then%` &lt;- function(a, b) {\n  if (is.null(a)) b else a\n}\n\nserver &lt;- function(input, output) {\n\n  data &lt;- reactive({\n    validate(\n      need(input$data != \"\", \"Please select a data set\") %then%\n      need(input$data %in% c(\"mtcars\", \"faithful\", \"iris\"),\n        \"Unrecognized data set\") %then%\n      need(input$data, \"Input is an empty string\") %then%\n      need(!is.null(input$data),\n        \"Input is not an empty string, it is NULL\")\n    )\n    get(input$data, 'package:datasets')\n  })\n\n  output$plot &lt;- renderPlot({\n    hist(data()[, 1], col = 'forestgreen', border = 'white')\n  })\n\n  output$table &lt;- renderTable({\n    head(data())\n  })\n\n}\nShiny will display only the message of the first condition that fails. Here is an example:\n\nBe careful not to use %then% in a way that might frustrate your user. A user may not enjoy fixing one validation error to find another (and then another) take its place.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Write error messages for your UI with validate"
    ]
  },
  {
    "objectID": "r/articles/improve/validation/index.html#style-validation-errors",
    "href": "r/articles/improve/validation/index.html#style-validation-errors",
    "title": "Write error messages for your UI with validate",
    "section": "Style validation errors",
    "text": "Style validation errors\nOnce you create a validation test, you can style its output with CSS (just as you can style any element in the Shiny user-interface).\nValidation errors are HTML div objects with the class shiny-output-error-validation. Provide a CSS style for this class to change the appearance of every validation error message. For example, this ui object adds CSS that colors the messages green.\nNote: if your server function matches the last script (above), you need to select mtcars in your select box before you see the validation error message.\nui &lt;- fluidPage(\n\n  tags$head(\n    tags$style(HTML(\"\n      .shiny-output-error-validation {\n        color: green;\n      }\n    \"))\n  ),\n\n  titlePanel(\"Validation App\"),\n\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\"data\", label = \"Data set\",\n        choices = c(\"\", \"mtcars\", \"faithful\", \"iris\"))\n    ),\n\n    # Show a plot of the generated distribution\n    mainPanel(\n      plotOutput(\"plot\"),\n      tableOutput(\"table\")\n    )\n  )\n)\n\nIf you would like to style an individual validate message, give the message its own class with the errorClass of validate. Shiny will assign the message a class that begins with ‚Äúshiny-output-error-‚Äù and ends with the character string that you pass errorClass.\nFor example, this validate call returns a message of class ‚Äúshiny-output-error-myClass‚Äù that you can style with CSS.\n    validate(\n      need(input$data != \"\", \"Please select a data set\"),\n      errorClass = \"myClass\"\n    )",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Write error messages for your UI with validate"
    ]
  },
  {
    "objectID": "r/articles/improve/validation/index.html#recap",
    "href": "r/articles/improve/validation/index.html#recap",
    "title": "Write error messages for your UI with validate",
    "section": "Recap",
    "text": "Recap\nYou can make your Shiny apps more attractive and user friendly with validate. validate tests inputs and delivers messages to your user, which creates an agreeable alternative to Shiny‚Äôs default error messages.\nPair validate with one or more need calls to validate an input. You need to validate an input only once (in a reactive or render* expression). Shiny will pass the valuation results to any observer or expression that calls upon the input.\nYou can personalize validation error messages by writing your own need functions or by styling validation output with CSS.",
    "crumbs": [
      "Improve",
      "Refactor",
      "Code quality",
      "Write error messages for your UI with validate"
    ]
  },
  {
    "objectID": "r/articles/share/admin-deployment/index.html",
    "href": "r/articles/share/admin-deployment/index.html",
    "title": "Administrating Shiny Server, Shiny Server Pro, and Posit Connect",
    "section": "",
    "text": "We offer full admin documentation for each of our on-premises deployment options for Shiny apps. You can access these docs at the links listed below.\nFull admin documentation for all RStudio products is available at docs.rstudio.com.\nIn addition, the RStudio Support site includes articles and advice on installing and configuring each product.",
    "crumbs": [
      "Share",
      "Deployment",
      "Administrating Shiny Server, Shiny Server Pro, and Posit Connect"
    ]
  },
  {
    "objectID": "r/articles/share/admin-deployment/index.html#learn-more",
    "href": "r/articles/share/admin-deployment/index.html#learn-more",
    "title": "Administrating Shiny Server, Shiny Server Pro, and Posit Connect",
    "section": "Learn more",
    "text": "Learn more\nFor more on this topic, see the following resources:\n\nPosit Connect Internals - The Basics\nAdministering Posit Connect in Production",
    "crumbs": [
      "Share",
      "Deployment",
      "Administrating Shiny Server, Shiny Server Pro, and Posit Connect"
    ]
  },
  {
    "objectID": "r/articles/share/bookmarking-modules/index.html",
    "href": "r/articles/share/bookmarking-modules/index.html",
    "title": "Bookmarking and modules",
    "section": "",
    "text": "Shiny‚Äôs bookmarking works with modules. As with Shiny applications, if the state of your module‚Äôs outputs are fully determined by the state of the inputs at a given time, then no modifications are necessary. If bookmarking is enabled by the application, then it will work for the module.\nThis application contains a very simple module, and bookmarking works for it just by calling enableBookmarking() as we did in other applications:\n# A simple module that captializes input text\ncapitalizerUI &lt;- function(id) {\n  ns &lt;- NS(id)\n  wellPanel(\n    h4(\"Text captializer module\"),\n    textInput(ns(\"txt\"), \"Enter text:\"),\n    verbatimTextOutput(ns(\"out\"))\n  )\n}\ncapitalizerServer &lt;- function(input, output, session) {\n  output$out &lt;- renderText({\n    toupper(input$txt)\n  })\n}\n\n# Main app code\nui &lt;- function(request) {\n  fluidPage(\n    capitalizerUI(\"tc\"),\n    bookmarkButton()\n  )\n}\nserver &lt;- function(input, output, session) {\n  callModule(capitalizerServer, \"tc\")\n}\nshinyApp(ui, server, enableBookmarking = \"url\")\nIf the bookmarking for the module requires customization, the API is the same as for a full Shiny application. Modules can have their own onBookmark, onRestore, and onRestored callbacks (they can‚Äôt have onBookmarked, because that one is meant to display UI for the app as a whole), and they can have their own set of excluded inputs by calling setBookmarkExclude(). Using these functions in the module will not affect the parent application, and vice versa.\nIn the following example, the module has its own input$text, as well as onBookmark and onRestore callbacks which store a value in state$values$hash. The main application also has input$text, as well as onBookmark and onRestore callbacks which store a value in state$values$hash. Even though the variable names look the same, Shiny‚Äôs module logic namespaces them and prevents the module‚Äôs code and application‚Äôs code from interfering with each other.\n# A basic module that captializes text. When bookmarked, it saves the text and a\n# hash of the text.\ncapitalizerUI &lt;- function(id) {\n  ns &lt;- NS(id)\n  wellPanel(\n    h4(\"Text captializer module\"),\n    textInput(ns(\"text\"), \"Enter text:\"),\n    \"Capitalized text:\", \n    verbatimTextOutput(ns(\"out\"))\n  )\n}\ncapitalizerServer &lt;- function(input, output, session) {\n  output$out &lt;- renderText({\n    toupper(input$text)\n  })\n  onBookmark(function(state) {\n    state$values$hash &lt;- digest::digest(input$text, \"md5\")\n  })\n  onRestore(function(state) {\n    if (identical(digest::digest(input$text, \"md5\"), state$values$hash)) {\n      showNotification(paste0('Module\\'s input text \"', input$text,\n        '\" matches hash ', state$values$hash))\n    } else {\n      showNotification(paste0('Module\\'s input text \"', input$text,\n        '\" does not match hash ', state$values$hash))\n    }\n  })\n}\n\n# The main application calls the module, and also saves its own text and a hash\n# of the text.\nui &lt;- function(request) {\n  basicPage(\n    capitalizerUI(\"tc\"),\n    h4(\"Main app\"),\n    textInput(\"text\", \"Enter text:\"),\n    \"Verbatim text:\",\n    verbatimTextOutput(\"out\"),\n    bookmarkButton()\n  )\n}\nserver &lt;- function(input, output, session) {\n  callModule(capitalizerServer, \"tc\")\n\n  output$out &lt;- renderText({\n    input$text\n  })\n  onBookmark(function(state) {\n    state$values$hash &lt;- digest::digest(input$text, \"md5\")\n  })\n  onRestore(function(state) {\n    if (identical(digest::digest(input$text, \"md5\"), state$values$hash)) {\n      showNotification(paste0('App\\'s input text \"', input$text,\n        '\" matches hash ', state$values$hash))\n    } else {\n      showNotification(paste0('App\\'s input text \"', input$text,\n        '\" does not match hash ', state$values$hash))\n    }\n  })\n}\nshinyApp(ui, server, enableBookmarking = \"url\")",
    "crumbs": [
      "Share",
      "Bookmarking",
      "Bookmarking and modules"
    ]
  },
  {
    "objectID": "r/articles/share/custom-domains/index.html",
    "href": "r/articles/share/custom-domains/index.html",
    "title": "Setting up custom domains on shinyapps.io",
    "section": "",
    "text": "The shinyapps.io Professional plan offers customers the ability to host their Shiny applications using their own domains. This can be useful if you want to control the URL that is viewed by the end-user when you share your application with them.\nIn order to enable this feature you will want to follow these steps:\n\nDecide on domain(s) or subdomain(s) that you would want to host your applications on: (Example: acmeshinyapps.com or apps.acme.com)\nAsk your IT administrator to setup a CNAME from that domain/subdomain to your account domain. (Example: If your account name is acme and your domain you would like to setup is apps.acme.com, then you must create a CNAME from apps.acme.com to acme.shinyapps.io.) Steps to complete this can vary depending on domain registrar or DNS provider, so we recommend you consult your provider‚Äôs documentation for exact instructions on completing this step.\nOnce the domain record has been created, log into the shinyapps.io dashboard, and navigate to Account-&gt;Domains. From here you can add the domain or subdomain from above and then click Add Domain.\n\n\n\nNow you are ready to add additional URLs to any of your existing applications. Within the dashboard, find your application in the Applications tab and click on the URLs menu bar choice. You will notice that there is already a single URL which is the one that is created by default. (Note the default URL cannot be removed)\nClick on Add URL. You can now select from the list of domains you have entered (Example: apps.acme.com) and can now specify the path to the application. The URL field below will show you what the final URL would look like.\n\n\nNote: a single application can be hosted on multiple domains and using different paths, and that all paths are case sensitive.",
    "crumbs": [
      "Share",
      "Deployment",
      "Setting up custom domains on shinyapps.io"
    ]
  },
  {
    "objectID": "r/articles/share/deployment-web/index.html",
    "href": "r/articles/share/deployment-web/index.html",
    "title": "Deploying Shiny apps to the web",
    "section": "",
    "text": "Once you‚Äôve written your Shiny app, you can make it available to anyone who has a web browser, using our Shiny Server software. You can either host the applications on your own server, or let us host your Shiny applications for you.\nIf you want a simple way to distribute your Shiny app so that users can run them on their own computers, see Sharing apps to run locally.\nHowever if you want your users to access your apps easily via their browser, you will need to deploy your apps to the web. The following four\n\nShinyapps.io\nWant to deploy to the web but prefer not to run your own server? You can host your Shiny apps on the web in minutes with Shinyapps.io. It is easy to use, secure, and scalable. No hardware, installation, or annual purchase contract required. If you choose to use Shinyapps.io for deploying your apps to the web, you do niot need to run your own server and you can easily deploy to the web at the push of a button (or one line of R code). However it is important to keep in mind that your code and data must be copied to our servers since this service is hosted by Posit. Free and paid options available. Find out more about Shinyapps.io here.\n\n\nShiny Server\nWith our open-source Shiny Server software, you can deploy Shiny applications to the web so that users need only a web browser and your application‚Äôs URL. Shiny Server allows you to take advantage of centralized computing resources, and requires a Linux server that you will need to set up and maintain. To can find out more about Shiny Server, see Introduction to Shiny Server.\n\n\nPosit Connect\nPosit Connect is RStudio‚Äôs publishing platform for the work your teams create in R. With Posit Connect, you can share Shiny applications, R Markdown reports, dashboards, plots, Jupyter Notebooks, and more in one convenient place with push-button publishing from the RStudio IDE. Features include scheduled execution of reports and flexible security policies to bring the power of data science to your entire enterprise. Find out more about Posit Connect here.",
    "crumbs": [
      "Share",
      "Deployment",
      "Deploying Shiny apps to the web"
    ]
  },
  {
    "objectID": "r/articles/share/libraries/index.html",
    "href": "r/articles/share/libraries/index.html",
    "title": "Allowing different libraries for different apps on Shiny Server, Shiny Server Pro, and Posit Connect",
    "section": "",
    "text": "This article describes two ways to configure applications to use different sets of libraries in Shiny Server, Shiny Server Pro, and Posit Connect.",
    "crumbs": [
      "Share",
      "Deployment",
      "Allowing different libraries for different apps on Shiny Server, Shiny Server Pro, and Posit Connect"
    ]
  },
  {
    "objectID": "r/articles/share/libraries/index.html#different-libraries-for-different-apps-on-posit-connect",
    "href": "r/articles/share/libraries/index.html#different-libraries-for-different-apps-on-posit-connect",
    "title": "Allowing different libraries for different apps on Shiny Server, Shiny Server Pro, and Posit Connect",
    "section": "Different libraries for different apps on Posit Connect",
    "text": "Different libraries for different apps on Posit Connect\nPosit Connect installs the R package dependencies of Shiny applications using the rsconnect and packrat R packages to identify the target source code and enumerate its dependencies. That information is bundled into an archive (.tar.gz) file and uploaded to Posit Connect. This is done on a per-app basis, therefore two apps on Posit Connect can use different packages or different versions of the same packages. The packrat package attempts to re-use R packages whenever possible, so if two apps share the same version of a package as a dependency, they can take advantage of previously-installed packages, hence making deployment faster.",
    "crumbs": [
      "Share",
      "Deployment",
      "Allowing different libraries for different apps on Shiny Server, Shiny Server Pro, and Posit Connect"
    ]
  },
  {
    "objectID": "r/articles/share/libraries/index.html#different-libraries-for-different-apps-on-shiny-server-and-shiny-server-pro",
    "href": "r/articles/share/libraries/index.html#different-libraries-for-different-apps-on-shiny-server-and-shiny-server-pro",
    "title": "Allowing different libraries for different apps on Shiny Server, Shiny Server Pro, and Posit Connect",
    "section": "Different libraries for different apps on Shiny Server and Shiny Server Pro",
    "text": "Different libraries for different apps on Shiny Server and Shiny Server Pro\nAllowing for different libraries for different apps on Shiny Server and Shiny Server Pro requires a different approach. In the remainder of this article we describe two ways to configure applications to use different sets of libraries on Shiny Server and Shiny Server Pro.\n\nMethod 1 relies on Shiny Server‚Äôs exec_supervisor feature. It will only work with Shiny Server Pro.\nMethod 2 relies on Shiny Server‚Äôs run_as feature. It will work with both Shiny Server and Shiny Server Pro.\n\n\nMethod 1 - exec_supervisor\nWith Shiny Server Pro, you can run R sessions under a program supervisor that modifies the environment of the sessions. You can use this supervisor to set the R_LIBS_USER environmental variable, which controls which libraries a session may use.\nSection 3.6 of the Shiny Server Administrator‚Äôs Guide explains how to add a program supervisor. You add an exec_supervisor setting to your server config file to specify a supervisor (and the arguments which control its behavior).\nThe file below uses exec_supervior to modify the default /etc/shiny-server/shiny-server.conf file that ships with Shiny Server. exec_supervisor partitions the applications up by setting the R_LIBS_USER environment variable.\nNear the bottom of the file, a /finance sub-location is defined for apps that use a specific set of libraries. Beneath that, a specific app is given its own set of libraries.\n# Instruct Shiny Server to run applications as the user \"shiny\"\nrun_as shiny;\n\n# Specify the authentication method to be used.\n# Initially, a flat-file database stored at the path below.\nauth_passwd_file /etc/shiny-server/passwd;\n\n# Define a server that listens on port 3838\nserver {\n  listen 3838;\n\n  # Define a location at the base URL\n  location / {\n    # Define a default library for applications\n    exec_supervisor \"R_LIBS_USER=/usr/lib/LibraryA\";\n\n    # Only up tp 20 connections per Shiny process and \n    # at most 3 Shiny processes per application. \n    # Proactively spawn a new process when our processes \n    # reach 90% capacity.\n    utilization_scheduler 20 .9 3;\n\n    # Host the directory of Shiny apps stored in this directory\n    site_dir /srv/shiny-server;\n\n    # Log all Shiny output to files in this directory\n    log_dir /var/log/shiny-server;\n\n    # When a user visits the base URL rather than a particular application,\n    # an index of the applications available in this directory will be shown.\n    directory_index on;\n\n    # Now define a sub-location at /finance\n    location /finance {\n      # Define a library that should be used by the finance department\n      exec_supervisor \"R_LIBS_USER=/usr/lib/FinanceLibrary\";\n\n      \n      # Further, define another sub-location that happens to correspond to \n      # a particular app.\n      location /app1 {\n        #Define a specific library to be used by this application\n        exec_supervisor \"R_LIBS_USER=/usr/lib/LibraryC\";\n      }\n    }\n  }\n}\n\n# Provide the admin interface on port 4151\nadmin 4151 {\n  \n  # Restrict the admin interface to the usernames listed here. Currently\n  # just one user named \"admin\"\n  required_user admin;\n}\nIn this case, you could set up as many different libraries as you want and specify a different library for each location, or even each application that you want to deploy. This would give you fine-grained control over each of your applications.\n\n\nMethod 2 - run_as\nShiny Server (and Shiny Server Pro) use a run_as setting to determine which user should spawn each R Shiny processes. The user setting determines which library R will look in for packages (as well as which directories the app will be able to read and write to).\nThe run_as setting can be configured globally, or for a particular server or location. As a result, you can set up different locations for hosting apps that use different packages. Each location can be affiliated with its own user‚Äîeach of which presumably has a different set of libraries specified with a ~/.Rprofile file.\nWith this approach, you would probably have only a handful of users that you create that each maintain their own separate libraries.\nSection 2.3 of the Shiny Server Administrator‚Äôs Guide explains how to set a user with run_as.\nThe file below uses run_as to modify the default /etc/shiny-server/shiny-server.conf file that ships with Shiny Server. run_asdefines a global user, shiny, for the server. It then defines a different user for the /finance location, shinyFinance. The finance department can deploy apps in this location. Those apps will be restricted to the packages in the library of shinyFinance, which may be different than the packages in the library of the user namedshiny.\n# Specify the authentication method to be used.\n# Initially, a flat-file database stored at the path below.\nauth_passwd_file /etc/shiny-server/passwd;\n\n# Define a server that listens on port 3838\nserver {\n  listen 3838;\n\n  # Define a location at the base URL\n  location / {\n    # Instruct Shiny Server to run applications as\n    # the user \"shiny\" by default\n    run_as shiny;\n\n    # Only up tp 20 connections per Shiny process and \n    # at most 3 Shiny processes per application. \n    # Proactively spawn a new process when our processes \n    # reach 90% capacity.\n    utilization_scheduler 20 .9 3;\n\n    # Host the directory of Shiny apps stored in this directory\n    site_dir /srv/shiny-server;\n\n    # Log all Shiny output to files in this directory\n    log_dir /var/log/shiny-server;\n\n    # When a user visits the base URL rather than a particular application,\n    # an index of the applications available in this directory will be shown.\n    directory_index on;\n    \n    location /finance {\n      # Run as a different user for this location\n      run_as shinyFinance;\n    }\n  }\n}\n\n# Provide the admin interface on port 4151\nadmin 4151 {\n  \n  # Restrict the admin interface to the usernames listed here. Currently\n  # just one user named \"admin\"\n  required_user admin;\n}",
    "crumbs": [
      "Share",
      "Deployment",
      "Allowing different libraries for different apps on Shiny Server, Shiny Server Pro, and Posit Connect"
    ]
  },
  {
    "objectID": "r/articles/share/permissions/index.html",
    "href": "r/articles/share/permissions/index.html",
    "title": "Creating user privileges on Posit Connect and Shiny Server Pro",
    "section": "",
    "text": "It is easy to create User Privileges in Shiny apps when you use Posit Connect or Shiny Server Pro. Your app can recognize a user based on log-in information and deliver personalized content in response. You can use this feature to control who gets to see what content and when they see it.",
    "crumbs": [
      "Share",
      "Deployment",
      "Creating user privileges on Posit Connect and Shiny Server Pro"
    ]
  },
  {
    "objectID": "r/articles/share/permissions/index.html#personalized-data-access",
    "href": "r/articles/share/permissions/index.html#personalized-data-access",
    "title": "Creating user privileges on Posit Connect and Shiny Server Pro",
    "section": "Personalized Data Access",
    "text": "Personalized Data Access\nThe Sales Report app demonstrates how you can use this feature to control data your app displays. You can view this app and its code in the Shiny Gallery.\nWhen a sales person logs into the Sales Report app, Shiny displays the data related only to that sales person.\n\n\n\nA limited display for sales people\n\n\nWhen a manager logs into the Sales Report app, Shiny displays the data for every sales person. This information can help the manager compare performance.\n\n\n\nA full display for managers\n\n\nThe Sales Report app creates this effect by creating personal output for each log-in.\nIf you want to create a similar effect, begin in the server.R file. In that file, you can access your user‚Äôs log-in information with session$user (the topic of the article called ‚ÄúLearn about your user with session$clientData‚Äù).\nFirst, if it‚Äôs not there already, include session as the third argument of the server function. The Sales Report app does this in line 27 of its server.R file. Including session will ensure that the code inside server has access to that variable at runtime.\nserver &lt;- function(input, output, session) { \n\n}\nNext, access and store your user‚Äôs username with session$user. The Sales Report app does this in lines 32-34 of its server.R script.\n  user &lt;- reactive({\n    session$user\n  })\nAfter you store usernames with session$user, you can use the user information with switch, if, and other conditional functions. These functions will build outputs tailored for the user. The Sales Report app does this by testing whether the user‚Äôs log-in matches the names of known manager log-ins (here ‚Äúmanager‚Äù). The Sales Report app includes a helper function that runs this test.\n  isManager &lt;- reactive({\n    if (user() == \"manager\"){\n      return(TRUE)\n    } else{\n      return(FALSE)\n    }\n  })\nIt uses the results to determine the scope of the data set to display.\n  # Based on the logged in user, pull out only the data this user \n  # should be able to see.\n  myData &lt;- reactive({\n    if (isManager()){\n      # If a manager, show everything.\n      return(salesData)\n    } else{\n      # If a regular salesperson, only show their own sales.\n      return(salesData[salesData$salesperson == user(),])\n    }\n  })\nThis approach is very versatile and provides a convenient way to control who has access to which data and which widgets in your Shiny apps.\nThe Airline Delays app pushes this method a step further. This app compares the user log-in to a table of known users. Then it uses renderUI to create a personalized user-interface for each user. See the article ‚ÄúBuild a dynamic UI that reacts to user input‚Äù for more tips on rendering a custom UI with renderUI.",
    "crumbs": [
      "Share",
      "Deployment",
      "Creating user privileges on Posit Connect and Shiny Server Pro"
    ]
  },
  {
    "objectID": "r/articles/share/shiny-server/index.html",
    "href": "r/articles/share/shiny-server/index.html",
    "title": "Introduction to Shiny Server",
    "section": "",
    "text": "Shiny Server is an open source back end program that makes a big difference. It builds a web server specifically designed to host Shiny apps. With Shiny Server you can host your apps in a controlled environment, like inside your organization, so your Shiny app (and whatever data it needs) will never leave your control. You can also use Shiny Server to make your apps available across the Internet when you choose. Shiny Server will host each app at its own web address and automatically start the app when a user visits the address. When the user leaves, Shiny Server will automatically stop the app. This article demonstrates some of the features of Shiny Server and introduce you to the deep literature that is waiting to help you download, install, and configure your own Shiny Server.\n\nOptions for hosting your Shiny apps\nYou can use the free and open source Shiny Server to host your Shiny applications, or you can leverage Posit Connect to scale your applications to a broader audience, restrict access to particular applications, or control the resources consumed by your Shiny applications. With Posit Connect, you can share Shiny applications, R Markdown reports, dashboards and plots, as well as Python-based content, including Flask, Dash, Streamlit and Bokeh, in one convenient place with push-button publishing from the RStudio IDE. Features include scheduled execution of reports and flexible security policies to bring the power of data science to your entire enterprise. You can see a full breakdown of the differences between the two editions here.\nPreviously, professional features of Shiny server were available in Shiny Server Pro only. Posit will continue to support Shiny Server Pro for existing customers, but we strongly recommend customers consider¬†Posit Connect as the professional alternative to Shiny Server Open Source.\nShiny Server runs on a variety on Linux distributions. If you‚Äôre not comfortable with Linux or would prefer to have someone else manage the server on which your Shiny applications are hosted, check out shinyapps.io to learn about hosting your applications in an environment that is managed and maintained by Posit for you. shinyapps.io lets you use a pay-as-you-go model to tap into some of the features only available in Posit Connect, an arrangement that is more approachable for some organizations.\nWe hope to highlight some features of Shiny Server in this article, but for a full discussion on how to manage and configure your server, please see the official Admin Guide. Specifically, we discuss hosting a directory of applications, letting users manage their own applications, and requiring user authentication on an application.\n\n\nHost a directory of applications\n(See this page for a complete step-by-step walkthrough of this example.)\nShiny Server allows you to host a directory full of Shiny applications and other web assets (HTML files, CSS files, etc.) using the site_dir configuration. By default, Shiny Server will use a site_dir to make any applications and assets stored in /srv/shiny-server/ available. You can begin placing Shiny applications inside this directory then referencing them on your server. For instance, a Shiny application stored in /srv/shiny-server/myApp would be available at http://myserver.org:3838/myApp, (where myserver.org is the name of your server) by default. You could also place HTML files in this directory to make them available on your server, as well.\nThis feature is only available in Shiny Server and Shiny Server Pro. Posit Connect, on the other hand, offers push-button deployment.\n\n\nLet users manage their own applications\n(See this page for a complete step-by-step walkthrough of this example.)\nIn some cases, it may be desirable to allow users on a system to manage and update their own Shiny applications stored in their home directories; the user_apps configuration allows you to do just that. Shiny applications hosted inside users‚Äô ShinyApps directory will be available online. For instance, a user who stored a Shiny application in /home/kim/ShinyApps/myApp would be able to access it at http://myserver.org:3838/kim/myApp on a server configured to use user_apps.\n\n\nRequire user authentication on an application\n(See this page for a complete step-by-step walkthrough of this example with Posit Connect and this page for Shiny Server Pro.)\nRequiring user authentication is not available in open source Shiny Server, however both Posit Connect and Shiny Server Pro support various forms of user authentication which can be used to require your users to login before being able to access particular Shiny applications on your server.\nAs of Shiny Server v1.1.0, you can even change the appearance of the login page using the template_dir configuration to make your login page look something like this:\n\n\n\nBlue Shiny Server Pro Login\n\n\n(Inspired by Thibaut Courouble and Orman Clark.)\nOr this:\n\n\n\nBadge Shiny Server Pro Login\n\n\n(Inspired by  Ionut Zamfir.)\n\n\nSummary\nTo recap, Shiny Server open source allows you to share your Shiny applications in a controlled environment. It lets you\n\nAutomatically start and stop your applications as needed on a Linux server\nProvide a unique URL for each application\n\nAs a professional alternative to Shiny Server open source, Posit Connect offers a variety of nice features that build on top of the open source Shiny Server including:\n\nA dashboard to help understand the activity on your server (as shown above)\nThe ability to secure your Shiny applications using SSL (HTTPS)\nThe ability to control which users are allowed to access which applications\nPriority support from Posit\nControls to fine-tune resource consumption per Shiny application\n\nIf you have any questions or would like more information, please visit here for Shiny Server or here for Posit Connect or email us at sales@rstudio.com.",
    "crumbs": [
      "Share",
      "Deployment",
      "Introduction to Shiny Server"
    ]
  },
  {
    "objectID": "r/articles/start/basics/index.html",
    "href": "r/articles/start/basics/index.html",
    "title": "The basic parts of a Shiny app",
    "section": "",
    "text": "The Shiny package comes with eleven built-in examples that demonstrate how Shiny works. This article reviews the first three examples, which demonstrate the basic structure of a Shiny app."
  },
  {
    "objectID": "r/articles/start/basics/index.html#example-1-hello-shiny",
    "href": "r/articles/start/basics/index.html#example-1-hello-shiny",
    "title": "The basic parts of a Shiny app",
    "section": "Example 1: Hello Shiny",
    "text": "Example 1: Hello Shiny\n\n\n\nThe Hello Shiny example is a simple application that plots R‚Äôs built-in faithful dataset with a configurable number of bins. To run the example, type:\nlibrary(shiny)\nrunExample(\"01_hello\")\nShiny applications have two components, a user interface object and a server function, that are passed as arguments to the shinyApp function that creates a Shiny app object from this UI/server pair. The source code for both of these components is listed below.\nIn subsequent sections of the article we‚Äôll break down Shiny code in detail and explain the use of ‚Äúreactive‚Äù expressions for generating output. For now, though, just try playing with the sample application and reviewing the source code to get an initial feel for things. Be sure to read the comments carefully.\nThe user interface is defined as follows:\n\nui\nlibrary(shiny)\nlibrary(bslib)\n\n# Define UI for app that draws a histogram ----\nui &lt;- page_sidebar(\n\n  # App title ----\n  title = \"Hello Shiny!\",\n\n  # Sidebar panel for inputs ----\n  sidebar = sidebar(\n\n    # Input: Slider for the number of bins ----\n    sliderInput(\n      inputId = \"bins\",\n      label = \"Number of bins:\",\n      min = 1,\n      max = 50,\n      value = 30\n    )\n  ),\n\n  # Output: Histogram ----\n  plotOutput(outputId = \"distPlot\")\n)\nThe server-side of the application is shown below. At one level, it‚Äôs very simple ‚Äì a random distribution is plotted as a histogram with the requested number of bins. However, you‚Äôll also notice that the code that generates the plot is wrapped in a call to renderPlot. The comment above the function explains a bit about this, but if you find it confusing, don‚Äôt worry, we‚Äôll cover this concept in much more detail soon.\n\n\nserver\n# Define server logic required to draw a histogram ----\nserver &lt;- function(input, output) {\n\n  # Histogram of the Old Faithful Geyser Data ----\n  # with requested number of bins\n  # This expression that generates a histogram is wrapped in a call\n  # to renderPlot to indicate that:\n  #\n  # 1. It is \"reactive\" and therefore should be automatically\n  #    re-executed when inputs (input$bins) change\n  # 2. Its output type is a plot\n  output$distPlot &lt;- renderPlot({\n    x &lt;- faithful$waiting\n    bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n\n    hist(\n      x,\n      breaks = bins,\n      col = \"#75AADB\",\n      border = \"white\",\n      xlab = \"Waiting time to next eruption (in mins)\",\n      main = \"Histogram of waiting times\"\n    )\n  })\n}\n\n\nshinyApp\nFinally, we use the shinyApp function to create a Shiny app object from the UI/server pair that we defined above.\nshinyApp(ui, server)\nWe save all of this code, the ui object, the server function, and the call to the shinyApp function, in an R script called app.R. This is the same basic structure for all Shiny applications.\nThe next example will show the use of more input controls, as well as the use of reactive functions to generate textual output."
  },
  {
    "objectID": "r/articles/start/basics/index.html#example-2-shiny-text",
    "href": "r/articles/start/basics/index.html#example-2-shiny-text",
    "title": "The basic parts of a Shiny app",
    "section": "Example 2: Shiny Text",
    "text": "Example 2: Shiny Text\n\n\n\nThe Shiny Text application demonstrates printing R objects directly, as well as displaying data frames using HTML tables. To run the example, type:\nlibrary(shiny)\nrunExample(\"02_text\")\nThe first example had a single numeric input specified using a slider and a single plot output. This example has a bit more going on: two inputs and two types of textual output.\nIf you try changing the number of observations to another value, you‚Äôll see a demonstration of one of the most important attributes of Shiny applications: inputs and outputs are connected together ‚Äúlive‚Äù and changes are propagated immediately (like a spreadsheet). In this case, rather than the entire page being reloaded, just the table view is updated when the number of observations change.\nHere is the user interface object for the application. Notice in particular that the sidebarPanel and mainPanel functions are now called with two arguments (corresponding to the two inputs and two outputs displayed):\n\nui\nlibrary(shiny)\nlibrary(bslib)\n\n# Define UI for dataset viewer app ----\nui &lt;- page_sidebar(\n\n  # App title ----\n  title = \"Shiny Text\",\n\n  # Sidebar panel for inputs ----\n  sidebar = sidebar(\n\n    # Input: Selector for choosing dataset ----\n    selectInput(\n      inputId = \"dataset\",\n      label = \"Choose a dataset:\",\n      choices = c(\"rock\", \"pressure\", \"cars\")\n    ),\n\n    # Input: Numeric entry for number of obs to view ----\n    numericInput(\n      inputId = \"obs\",\n      label = \"Number of observations to view:\",\n      value = 10\n    )\n  ),\n\n  # Output: Verbatim text for data summary ----\n  verbatimTextOutput(\"summary\"),\n\n  # Output: HTML table with requested number of observations ----\n  tableOutput(\"view\")\n)\nThe server side of the application has also gotten a bit more complicated. Now we create:\n\nA reactive expression to return the dataset corresponding to the user choice\nTwo other rendering expressions (renderPrint and renderTable) that return the output$summary and output$view values\n\nThese expressions work similarly to the renderPlot expression used in the first example: by declaring a rendering expression you tell Shiny that it should only be executed when its dependencies change. In this case that‚Äôs either one of the user input values (input$dataset or input$obs).\n\n\nserver\n# Define server logic to summarize and view selected dataset ----\nserver &lt;- function(input, output) {\n\n  # Return the requested dataset ----\n  datasetInput &lt;- reactive({\n    switch(\n      input$dataset,\n      \"rock\" = rock,\n      \"pressure\" = pressure,\n      \"cars\" = cars\n    )\n  })\n\n  # Generate a summary of the dataset ----\n  output$summary &lt;- renderPrint({\n    dataset &lt;- datasetInput()\n    summary(dataset)\n  })\n\n  # Show the first \"n\" observations ----\n  output$view &lt;- renderTable({\n    head(datasetInput(), n = input$obs)\n  })\n}\nWe‚Äôve demonstrated more use of reactive expressions but haven‚Äôt really explained how they work yet. The next example will start with this one as a baseline and expand significantly on how reactive expressions work in Shiny."
  },
  {
    "objectID": "r/articles/start/basics/index.html#example-3-reactivity",
    "href": "r/articles/start/basics/index.html#example-3-reactivity",
    "title": "The basic parts of a Shiny app",
    "section": "Example 3: Reactivity",
    "text": "Example 3: Reactivity\n\n\n\nThe Reactivity application is very similar to Hello Text, but goes into much more detail about reactive programming concepts. To run the example, type:\nlibrary(shiny)\nrunExample(\"03_reactivity\")\nThe previous examples have given you a good idea of what the code for Shiny applications looks like. We‚Äôve explained a bit about reactivity, but mostly glossed over the details. In this section, we‚Äôll explore these concepts more deeply. If you want to dive in and learn about the details, see the Understanding Reactivity section, starting with Reactivity Overview.\n\nWhat is Reactivity?\nThe Shiny web framework is fundamentally about making it easy to wire up input values from a web page, making them easily available to you in R, and have the results of your R code be written as output values back out to the web page.\ninput values =&gt; R code =&gt; output values\nSince Shiny web apps are interactive, the input values can change at any time, and the output values need to be updated immediately to reflect those changes.\nShiny comes with a reactive programming library that you will use to structure your application logic. By using this library, changing input values will naturally cause the right parts of your R code to be reexecuted, which will in turn cause any changed outputs to be updated.\n\n\nReactive Programming Basics\nReactive programming is a coding style that starts with reactive values‚Äìvalues that change in response to the user, or over time‚Äìand builds on top of them with reactive expressions‚Äìexpressions that access reactive values and execute other reactive expressions.\nWhat‚Äôs interesting about reactive expressions is that whenever they execute, they automatically keep track of what reactive values they read and what reactive expressions they invoked. If those ‚Äúdependencies‚Äù become out of date, then they know that their own return value has also become out of date. Because of this dependency tracking, changing a reactive value will automatically instruct all reactive expressions that directly or indirectly depend on that value to re-execute.\nThe most common way you‚Äôll encounter reactive values in Shiny is using the input object. The input object, which is passed to your shinyServer function, lets you access the web page‚Äôs user input fields using a list-like syntax. Code-wise, it looks like you‚Äôre grabbing a value from a list or data frame, but you‚Äôre actually reading a reactive value. No need to write code to monitor when inputs change‚Äìjust write reactive expression that read the inputs they need, and let Shiny take care of knowing when to call them.\nIt‚Äôs simple to create reactive expression: just pass a normal expression into reactive. In this application, an example of that is the expression that returns an R data frame based on the selection the user made in the input form:\ndatasetInput &lt;- reactive({\n  switch(\n    input$dataset,\n    \"rock\" = rock,\n    \"pressure\" = pressure,\n    \"cars\" = cars\n  )\n})\nTo turn reactive values into outputs that can viewed on the web page, we assigned them to the output object (also passed to the shinyServer function). Here is an example of an assignment to an output that depends on both the datasetInput reactive expression we just defined, as well as input$obs:\noutput$view &lt;- renderTable({\n   head(datasetInput(), n = input$obs)\n})\nThis expression will be re-executed (and its output re-rendered in the browser) whenever either the datasetInput or input$obs value changes.\n\n\nBack to the Code\nNow that we‚Äôve taken a deeper look at some of the core concepts, let‚Äôs revisit the source code for the Reactivity example and try to understand what‚Äôs going on in more depth. The user interface object has been updated to include a text-input field that defines a caption. Other than that it‚Äôs very similar to the previous example:\n\nui\nlibrary(shiny)\nlibrary(bslib)\n\n# Define UI for dataset viewer app ----\nui &lt;- page_sidebar(\n\n  # App title ----\n  title = \"Reactivity\",\n\n  # Sidebar panel for inputs ----\n  sidebar = sidebar(\n\n    # Input: Text for providing a caption ----\n    # Note: Changes made to the caption in the textInput control\n    # are updated in the output area immediately as you type\n    textInput(\n      inputId = \"caption\",\n      label = \"Caption:\",\n      value = \"Data Summary\"\n    ),\n\n    # Input: Selector for choosing dataset ----\n    selectInput(\n      inputId = \"dataset\",\n      label = \"Choose a dataset:\",\n      choices = c(\"rock\", \"pressure\", \"cars\")\n    ),\n\n    # Input: Numeric entry for number of obs to view ----\n    numericInput(\n      inputId = \"obs\",\n      label = \"Number of observations to view:\",\n      value = 10\n    )\n  ),\n\n  # Output: Formatted text for caption ----\n  h3(textOutput(\"caption\", container = span)),\n\n  # Output: Verbatim text for data summary ----\n  verbatimTextOutput(\"summary\"),\n\n  # Output: HTML table with requested number of observations ----\n  tableOutput(\"view\")\n)\n\n\nserver\nThe server function declares the datasetInput reactive expression as well as three reactive output values. There are detailed comments for each definition that describe how it works within the reactive system:\n# Define server logic to summarize and view selected dataset ----\nserver &lt;- function(input, output) {\n\n  # Return the requested dataset ----\n  # By declaring datasetInput as a reactive expression we ensure\n  # that:\n  #\n  # 1. It is only called when the inputs it depends on changes\n  # 2. The computation and result are shared by all the callers,\n  #    i.e. it only executes a single time\n  datasetInput &lt;- reactive({\n    switch(\n      input$dataset,\n      \"rock\" = rock,\n      \"pressure\" = pressure,\n      \"cars\" = cars\n    )\n  })\n\n  # Create caption ----\n  # The output$caption is computed based on a reactive expression\n  # that returns input$caption. When the user changes the\n  # \"caption\" field:\n  #\n  # 1. This function is automatically called to recompute the output\n  # 2. New caption is pushed back to the browser for re-display\n  #\n  # Note that because the data-oriented reactive expressions\n  # below don't depend on input$caption, those expressions are\n  # NOT called when input$caption changes\n  output$caption &lt;- renderText({\n    input$caption\n  })\n\n  # Generate a summary of the dataset ----\n  # The output$summary depends on the datasetInput reactive\n  # expression, so will be re-executed whenever datasetInput is\n  # invalidated, i.e. whenever the input$dataset changes\n  output$summary &lt;- renderPrint({\n    dataset &lt;- datasetInput()\n    summary(dataset)\n  })\n\n  # Show the first \"n\" observations ----\n  # The output$view depends on both the databaseInput reactive\n  # expression and input$obs, so it will be re-executed whenever\n  # input$dataset or input$obs is changed\n  output$view &lt;- renderTable({\n    head(datasetInput(), n = input$obs)\n  })\n}\nWe‚Äôve reviewed a lot code and covered a lot of conceptual ground in the first three examples. The next article focuses on the mechanics of building a Shiny application from the ground up."
  },
  {
    "objectID": "r/articles/start/cheatsheet/index.html",
    "href": "r/articles/start/cheatsheet/index.html",
    "title": "Shiny for R cheatsheet",
    "section": "",
    "text": "The Shiny for R cheatsheet provides a tour of the shiny package and explains how to build and customize an interactive app.\n\n\nDownload Shiny Cheatsheet\n\n\nSee all cheatsheets"
  },
  {
    "objectID": "r/articles/start/running/index.html",
    "href": "r/articles/start/running/index.html",
    "title": "How to launch a Shiny app",
    "section": "",
    "text": "In previous articles[1, 2] you‚Äôve been calling runApp to run the example applications. This function starts the application and opens up your default web browser to view it. The call is blocking, meaning that it prevents traditional interaction with the console while the application is running.\nTo stop the application you simply interrupt R ‚Äì you can do this by pressing the Ctrl-C in some R front ends, or the Escape key in RStudio,or by clicking the stop button if your R environment provides one.\n\nRunning in a Separate Process\nIf you don‚Äôt want to block access to the console while running your Shiny application you can also run it in a separate process. You can do this by opening a terminal or console window and executing the following, where ~/shinyapp should be replaced with the path to your application:\nR -e \"shiny::runApp('~/shinyapp')\"\nBy default runApp starts the application on a randomly selected port. For example, it might start on port 4700, in which case you can connect to the running application by navigating your browser to http://localhost:4700.\nIn other articles, we discuss some techniques for debugging Shiny applications, including the ability to stop execution and inspect the current environment. To combine these techniques with running your applications in a separate terminal session, you‚Äôll need to call runApp from an interactive R session, instead of with the method here.\n\n\nLive Reloading\nWhen you make changes to your underlying user interface definition or server script you don‚Äôt need to stop and restart your application to see the changes. Simply save your changes and then reload the browser to see the updated application in action.\nOne qualification to this: when a browser reload occurs Shiny explicitly checks the timestamp of the app.R file to see if it needs to be re-sourced. Shiny isn‚Äôt aware of other scripts or data files that change, so if you use those files and modify them, a full stop and restart of the application is needed."
  },
  {
    "objectID": "r/deploy.html",
    "href": "r/deploy.html",
    "title": "Hosting and deployment",
    "section": "",
    "text": "See a comparison of Posit‚Äôs hosting and deployment options for Shiny. If you have any questions about which product is the right fit for you, please email sales@posit.co."
  },
  {
    "objectID": "r/deploy.html#what-about-shiny-server-pro",
    "href": "r/deploy.html#what-about-shiny-server-pro",
    "title": "Hosting and deployment",
    "section": "What About Shiny Server Pro?",
    "text": "What About Shiny Server Pro?\nFor several years, Shiny Server Pro has enabled data science teams to securely share their Shiny applications on a commercially supported platform. However, in response to customer demand to be able to share many other forms of R- and Python-based content (in addition to Shiny applications), a few years ago we introduced a new product: Posit Connect.\nPosit Connect is a publishing platform for all the work your teams create in R and Python. It enables you to share Shiny applications, R Markdown reports, dashboards, plots, APIs, and more in one convenient place. It provides push-button publishing from the RStudio IDE, scheduled execution of reports, and flexible security policies to bring the power of data science to your entire enterprise.\nReflecting the maturity of Posit Connect as a product, and in order to focus our engineering efforts on providing the best experience for our customers in deploying all forms of R and Python data products, we are discontinuing sales of Shiny Server Pro to new customers. We will continue to support Shiny Server Pro for existing customers, but we strongly recommend customers consider Posit Connect ."
  },
  {
    "objectID": "r/gallery/advanced-shiny/bookmarking-with-updatequerystring/index.html",
    "href": "r/gallery/advanced-shiny/bookmarking-with-updatequerystring/index.html",
    "title": "Bookmarking with updateQueryString",
    "section": "",
    "text": "Back to Gallery\n      Bookmarking with updateQueryString\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/advanced-shiny/creating-a-ui-from-a-loop/index.html",
    "href": "r/gallery/advanced-shiny/creating-a-ui-from-a-loop/index.html",
    "title": "Creating a UI from a loop",
    "section": "",
    "text": "Back to Gallery\n      Creating a UI from a loop\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/advanced-shiny/generating-reports/index.html",
    "href": "r/gallery/advanced-shiny/generating-reports/index.html",
    "title": "Generating reports",
    "section": "",
    "text": "Back to Gallery\n      Generating reports\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/advanced-shiny/modal-dialogs/index.html",
    "href": "r/gallery/advanced-shiny/modal-dialogs/index.html",
    "title": "Modal dialogs",
    "section": "",
    "text": "Back to Gallery\n      Modal dialogs\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/advanced-shiny/progress-bar-example/index.html",
    "href": "r/gallery/advanced-shiny/progress-bar-example/index.html",
    "title": "Progress bar example",
    "section": "",
    "text": "Back to Gallery\n      Progress bar example\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/advanced-shiny/server-to-client-custom-messages/index.html",
    "href": "r/gallery/advanced-shiny/server-to-client-custom-messages/index.html",
    "title": "Server-to-client custom messages",
    "section": "",
    "text": "Back to Gallery\n      Server-to-client custom messages\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/application-layout/including-html-text-and-markdown-files/index.html",
    "href": "r/gallery/application-layout/including-html-text-and-markdown-files/index.html",
    "title": "Including HTML, text, and Markdown files",
    "section": "",
    "text": "Back to Gallery\n      Including HTML, text, and Markdown files\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/application-layout/navbar-example/index.html",
    "href": "r/gallery/application-layout/navbar-example/index.html",
    "title": "Navbar Example",
    "section": "",
    "text": "Back to Gallery\n      Navbar Example\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/application-layout/plot-plus-three-columns/index.html",
    "href": "r/gallery/application-layout/plot-plus-three-columns/index.html",
    "title": "Plot plus three columns",
    "section": "",
    "text": "Back to Gallery\n      Plot plus three columns\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/application-layout/shiny-theme-selector/index.html",
    "href": "r/gallery/application-layout/shiny-theme-selector/index.html",
    "title": "Shiny theme selector",
    "section": "",
    "text": "Back to Gallery\n      Shiny theme selector\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/application-layout/vertical-layout/index.html",
    "href": "r/gallery/application-layout/vertical-layout/index.html",
    "title": "Vertical Layout",
    "section": "",
    "text": "Back to Gallery\n      Vertical Layout\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/dynamic-user-interface/dynamic-ui/index.html",
    "href": "r/gallery/dynamic-user-interface/dynamic-ui/index.html",
    "title": "Dynamic UI",
    "section": "",
    "text": "Back to Gallery\n      Dynamic UI\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/education/didacting-modeling/index.html",
    "href": "r/gallery/education/didacting-modeling/index.html",
    "title": "Didactic modeling process: Linear regression",
    "section": "",
    "text": "Back to Gallery\n      Didactic modeling process: Linear regression\n            Oscar Daniel Rivera Baena\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            This application constitutes a didactic modeling process. The user can try to perform a linear regression model based on the ordinary least squares method, step by step (learning environment). The application addresses an actual safety problem in the rural areas of Antioquia - Colombia."
  },
  {
    "objectID": "r/gallery/education/radiant/index.html",
    "href": "r/gallery/education/radiant/index.html",
    "title": "Radiant - A Shiny app for statistics and machine learning",
    "section": "",
    "text": "Back to Gallery\n      Radiant - A Shiny app for statistics and machine learning\n            Vincent Nijs\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            Radiant is an R package for statistics and machine learning with a Shiny user interface"
  },
  {
    "objectID": "r/gallery/extending-shiny/button-styler/index.html",
    "href": "r/gallery/extending-shiny/button-styler/index.html",
    "title": "Interactive Button Styler",
    "section": "",
    "text": "Back to Gallery\n      Interactive Button Styler\n            Emil Hvitfeldt Hansen\n            \n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            Interactively change the css attributes of elements on a page with sliders and buttons."
  },
  {
    "objectID": "r/gallery/extending-shiny/shiny-wysiwyg/index.html",
    "href": "r/gallery/extending-shiny/shiny-wysiwyg/index.html",
    "title": "ShinyWYSIWYG: a Shiny What You See Is What You Get editor",
    "section": "",
    "text": "Back to Gallery\n      ShinyWYSIWYG: a Shiny What You See Is What You Get editor\n            Juan Cruz Rodriguez\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            ShinyWYSIWYG: visually design, by drag and drop, your Shiny apps. Easily create your app events. Then, ShinyWYSIWYG will automatically deliver the corresponding code so that the app is ready to run!"
  },
  {
    "objectID": "r/gallery/finance-banking/real-estate-investment/index.html",
    "href": "r/gallery/finance-banking/real-estate-investment/index.html",
    "title": "Identifying real estate investment opportunities",
    "section": "",
    "text": "Back to Gallery\n      Identifying real estate investment opportunities\n            Philipp Reiner\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            Intelligentsia‚Äôs aim is to provide residential real estate investors with a home value appreciation forecast for neighborhoods within New York City. Our solution ranks NYC census tracts by likelihood of gentrification. A plethora of data were acquired and analyzed to create the Intelligentsia model. Among those data sets are ACS/Census data, Google Search Trends, Yelp ratings, NYC TLC taxicab trips, NYC Subway network and stations, residents‚Äô travel time to work and various datasets from NYC Open Data.\n            This app was recognized with an honorable mention on the 2019 Shiny Contest."
  },
  {
    "objectID": "r/gallery/government-public-sector/city-cycle/index.html",
    "href": "r/gallery/government-public-sector/city-cycle/index.html",
    "title": "City Cycle Race (with STRAVA) - Compare the cycling speed of cities",
    "section": "",
    "text": "Back to Gallery\n      City Cycle Race (with STRAVA) - Compare the cycling speed of cities\n            Sebastian Wolf\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            This Shiny app allows to compare how fast people cycle in your city. This app uses data from strava to compare the cyclists in two cities. How is this possible? Strava is a sports tracking app. Basically whenever people cycle they can track themselves using GPS. Afterwards they will know how fast they went on their track. This is not comparable. Though, strava build in a feature called segments. These segments are tracks of any length all around the world. On each of these segments strava the users can have a virtual race. The time they needed for the segment is stored on a leaderboard. The fastest cyclist is the King of the Mountain on this segment. The data is available for everybody having a strava account via the strava API. This package ( + app) includes the data and allows to crawl it by certain features."
  },
  {
    "objectID": "r/gallery/government-public-sector/dairy-farms/index.html",
    "href": "r/gallery/government-public-sector/dairy-farms/index.html",
    "title": "Pasture Potential Tool for improving dairy farm profitability and environmental impact",
    "section": "",
    "text": "Back to Gallery\n      Pasture Potential Tool for improving dairy farm profitability and environmental impact\n            Simon Woodward\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            The Pasture Potential Tool shows dairy farmers the amount of pasture eaten on comparable farms in their district, and provides them with a target to improve their profitability and environmental footprint."
  },
  {
    "objectID": "r/gallery/government-public-sector/freedom-press-index/index.html",
    "href": "r/gallery/government-public-sector/freedom-press-index/index.html",
    "title": "Freedom of Press Index",
    "section": "",
    "text": "Back to Gallery\n      Freedom of Press Index\n            John Coene\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            An application to visualise the Freedom of Press Index.\n            This app was recognized as a runner up on the 2020 Shiny Contest."
  },
  {
    "objectID": "r/gallery/government-public-sector/lake-profile-dashboard/index.html",
    "href": "r/gallery/government-public-sector/lake-profile-dashboard/index.html",
    "title": "Utah Lake Water Quality Profile Dashboard",
    "section": "",
    "text": "Back to Gallery\n      Utah Lake Water Quality Profile Dashboard\n            Jake\n            \n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            This application is designed to interactively visualize lake profile data collected by Utah Division of Water Quality (DWQ) and cooperators and provide a platform for performing and reviewing aquatic life use based water quality assessments from lake profile data.\n            This app was recognized with an honorable mention on the 2019 Shiny Contest."
  },
  {
    "objectID": "r/gallery/government-public-sector/nz-trade-dash/index.html",
    "href": "r/gallery/government-public-sector/nz-trade-dash/index.html",
    "title": "New Zealand Trade Intelligence Dashboard",
    "section": "",
    "text": "Back to Gallery\n      New Zealand Trade Intelligence Dashboard\n            Wei Zhang\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            The New Zealand Trade Intelligence Dashboard provides up-to-date annual information on trade by commodities, services and trading partners. It presents a full picture of New Zealand?s trading profile through intuitive and interactive graphs and tables. It also provides powerful functionality enabling users to generate their own reports for different commodities, and markets or groups of markets that interest them. All figures, tables and data are downloadable. It works on both PCs and mobile devices.\n            The philosophy of user-centered design is executed throughout the entire UI and functionality design of the shiny app. There will be less than three clicks away for almost any of users needs.\n            The shiny app has the potential to be easily adapted to generate trade intelligence for other countries."
  },
  {
    "objectID": "r/gallery/government-public-sector/soil-profiles/index.html",
    "href": "r/gallery/government-public-sector/soil-profiles/index.html",
    "title": "Visualisation of soil profiles",
    "section": "",
    "text": "Back to Gallery\n      Visualisation of soil profiles\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                    A Shiny App to provides the graphical representation of soil horizons, in the simplest case the color. The app offers a graphical user interface for the package soilprofile2. The focus is on morphological properties such as horizon transitions, texture, structure, root density, and rock content. In addition, soil-forming processes such as hydromorphic soils characteristics can also be displayed."
  },
  {
    "objectID": "r/gallery/interactive-plots/image-interaction-basic/index.html",
    "href": "r/gallery/interactive-plots/image-interaction-basic/index.html",
    "title": "Image interaction - basic",
    "section": "",
    "text": "Back to Gallery\n      Image interaction - basic\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/interactive-plots/plot-interaction-basic/index.html",
    "href": "r/gallery/interactive-plots/plot-interaction-basic/index.html",
    "title": "Plot interaction - basic",
    "section": "",
    "text": "Back to Gallery\n      Plot interaction - basic\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/interactive-plots/plot-interaction-zoom/index.html",
    "href": "r/gallery/interactive-plots/plot-interaction-zoom/index.html",
    "title": "Plot interaction - zoom",
    "section": "",
    "text": "Back to Gallery\n      Plot interaction - zoom\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/interactive-visualizations/google-charts/index.html",
    "href": "r/gallery/interactive-visualizations/google-charts/index.html",
    "title": "Google Charts",
    "section": "",
    "text": "Back to Gallery\n      Google Charts\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/interactive-visualizations/superzip-example/index.html",
    "href": "r/gallery/interactive-visualizations/superzip-example/index.html",
    "title": "SuperZip example",
    "section": "",
    "text": "Back to Gallery\n      SuperZip example\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/life-sciences/ab-test-sample-size/index.html",
    "href": "r/gallery/life-sciences/ab-test-sample-size/index.html",
    "title": "A/B Testing Sample Size Calculator",
    "section": "",
    "text": "Back to Gallery\n      A/B Testing Sample Size Calculator\n            Tim Wilsonname\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            An A/B test sample size calculator that enables the test planner to input different values as part of the planning process and then visualize the impact on the test duration and the likelihood of a Type I or Type II error as a means of providing business users who do not have a strong statistical background a degree of intuition regarding the different levers they can pull in their test design."
  },
  {
    "objectID": "r/gallery/life-sciences/biodiversity-national-parks/index.html",
    "href": "r/gallery/life-sciences/biodiversity-national-parks/index.html",
    "title": "Visualizing Biodiversity in National Parks data",
    "section": "",
    "text": "Back to Gallery\n      Visualizing Biodiversity in National Parks data\n            Alessio Benedetti\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            Biodiversity in National Parks is an app that let you visualize Kaggle‚Äôs biodiversity dataset. By using the National Park Service database of animal and plant species, the application offers a graphical representation of the data with maps and charts."
  },
  {
    "objectID": "r/gallery/life-sciences/explore-panel-data/index.html",
    "href": "r/gallery/life-sciences/explore-panel-data/index.html",
    "title": "ExPanD: Explore Your Data Interactively",
    "section": "",
    "text": "Back to Gallery\n      ExPanD: Explore Your Data Interactively\n            Joachim Gassen\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            ExPanD allows you to interactively explore your data. It is based on the ExPanDaR package and can be used with any dataset. It allows users to explore data and to export their analysis along with the data as an R notebook. Below you find an example exploring fuel economy data.\n            This app was recognized with an honorable mention on the 2019 Shiny Contest."
  },
  {
    "objectID": "r/gallery/life-sciences/hospital-data-antimicrobial/index.html",
    "href": "r/gallery/life-sciences/hospital-data-antimicrobial/index.html",
    "title": "Exploring large hospital data for better use of antimicrobials",
    "section": "",
    "text": "Back to Gallery\n      Exploring large hospital data for better use of antimicrobials\n            Christian Luz\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            This shiny app was developed in the context of a 1339-bed academic tertiary referral hospital to handle data of more than 180,000 admissions. Users can filter patient groups by 17 different criteria and investigate antimicrobial use, microbiological diagnostic use and results including antimicrobial resistance, and outcome in length of stay. Results can easily be stratified and grouped to compare defined patient groups based on individual patient features.\n            All graphs and tables as well as the filtered dataset can be downloaded in various formats. AMS teams can use RadaR to identify areas within their institutions that might benefit from increased support and targeted interventions. Diagnostic and therapeutic procedures can be assessed and analyses can easily be visualized and communicated."
  },
  {
    "objectID": "r/gallery/life-sciences/mote-effect-size/index.html",
    "href": "r/gallery/life-sciences/mote-effect-size/index.html",
    "title": "MOTE: An Effect Size Calculator",
    "section": "",
    "text": "Back to Gallery\n      MOTE: An Effect Size Calculator\n            Erin Buchanan\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            Check out MOTE: Measure of the Effect - a Shiny App to calculate many effect sizes and their confidence intervals. Tutorials for integrating with statistical programs such as JASP, SPSS, and R are integrated into the app!"
  },
  {
    "objectID": "r/gallery/life-sciences/nutrition-calculator/index.html",
    "href": "r/gallery/life-sciences/nutrition-calculator/index.html",
    "title": "Nutrition Calculator - calculate nutrition for recipes",
    "section": "",
    "text": "Back to Gallery\n      Nutrition Calculator - calculate nutrition for recipes\n            Yihan Wu\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            Nutrient Calculator is built as a shiny dashboard where users can easily search and add multiple ingredients from the CNF database, calculate overall nutrient data such as calories and sodium, and see nutrient amounts as percentage recommended daily values. Total calorie count, nutrients amounts which surpass 100% and 50% daily value are highlighted in at the top. Macronutrients, minerals and vitamins as % daily value are visualized on separated bar graphs."
  },
  {
    "objectID": "r/gallery/life-sciences/sdcapp-microdata/index.html",
    "href": "r/gallery/life-sciences/sdcapp-microdata/index.html",
    "title": "sdcApp - microdata disclosure control",
    "section": "",
    "text": "Back to Gallery\n      sdcApp - microdata disclosure control\n            Alexander\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            This graphical user interface of sdcMicro allows you to anonymize microdata even if you are not an expert in the R programming language. Detailed information on how to use this graphical user-interface (GUI) can be found in a tutorial that is included in the sdcMicro package as vignette."
  },
  {
    "objectID": "r/gallery/life-sciences/shroom-edibility-prediction/index.html",
    "href": "r/gallery/life-sciences/shroom-edibility-prediction/index.html",
    "title": "Shrooming - Interactive mushroom edibility predictions with XGBoost",
    "section": "",
    "text": "Back to Gallery\n      Shrooming - Interactive mushroom edibility predictions with XGBoost\n            Vladislav Fridkin\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            Your task is to move the sliders under the model chart and view the effect on prediction accuracy. (Hint: it is really easy to achieve 100% accuracy, the purpose is to explore how changing the different model parameters affect training and validation.)\n            The model uses XGBoost algorithm to predict if a mushroom is edible or poisonous. The baseline is based on the most frequent feature in the training set. Top 10 features are listed to the right of the chart. The data is sourced from the UCI Machine Learning repository. (If your chart appears compressed, try resizing the browser window to knock it back into shape!)"
  },
  {
    "objectID": "r/gallery/miscellaneous/bus-company-simulation/index.html",
    "href": "r/gallery/miscellaneous/bus-company-simulation/index.html",
    "title": "A bus company simulation game",
    "section": "",
    "text": "Back to Gallery\n      A bus company simulation game\n            Marcus Young\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            A bus company simulation game to help teach students about elasticties. You must decide what management action to take at the beginning of each year, in order to continue running a good bus service."
  },
  {
    "objectID": "r/gallery/miscellaneous/dog-medical-history/index.html",
    "href": "r/gallery/miscellaneous/dog-medical-history/index.html",
    "title": "An App to Visualize and Share My Dogs‚Äô Medical History",
    "section": "",
    "text": "Back to Gallery\n      An App to Visualize and Share My Dogs‚Äô Medical History\n            Jenna Allen\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            A shiny app to keep track of and share pet records with vets. Used SQLite and AWS S3 to store data about my dogs‚Äô vaccination and medical records.\n            Pet Records s the winner of the Awwww award of the 2019 Shiny Contest. Jenna, who describes herself as a digital nomad traveling with two dogs, Layla and Lloyd, has built this app for keeping track of her dogs‚Äô medical and vaccine records. The timeline visualizations in the app are extremely effective, and the amount you can drill down ? all the way to vaccine certificates and exam notes in PDF format!"
  },
  {
    "objectID": "r/gallery/miscellaneous/hotshot-dashboard/index.html",
    "href": "r/gallery/miscellaneous/hotshot-dashboard/index.html",
    "title": "The Hotshot Racing Dashboard!",
    "section": "",
    "text": "Back to Gallery\n      The Hotshot Racing Dashboard!\n            Eric Nantz\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            This dashboard is part of a very fun stack of open-source software created for the Official Wimpy‚Äôs World of Linux Gaming Most Official Unofficial Hotshot Racing League Spring Championship (WWOLGMOUHRLSC) competition that took place in early 2021. A group of friends from Martin Wimpress‚Äô Wimpy‚Äôs World discord channel who just so happen to really enjoy racing games decided to have a little competition using the retro-style racing game called Hotshot Racing. On top of the immense fun we had, I thought it was a great time to collect our own real-time data for each race and summarize it all with the power of R and Shiny!\n            After the loading screen completes, the welcome page with high-level statistics are presented with widgets that would be right at home on any racing statistics site. But the part that will likely garner the most attention is the animated racing chart to show the progression of key statistics like total amount of points throughout the season! The remaining tabs contain interactive tables that dive deeper into the analytics of individual player statistics. Each of the players used the same randomly-selected car as a means to even out the playing field. Each car can have wildly different strengths (for instance, some cars can accelerate quickly but with low top speed, etc). Each of the tables allow you to drill down and get a preview of how factors like the in-game drivers, tracks, and more factored in the overall results.\n            This app was recognized with an honorable mention on the 2021 Shiny Contest."
  },
  {
    "objectID": "r/gallery/miscellaneous/lego-world/index.html",
    "href": "r/gallery/miscellaneous/lego-world/index.html",
    "title": "Living in the Lego World",
    "section": "",
    "text": "Back to Gallery\n      Living in the Lego World\n            Abby Kaplan\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            This app is a collection of visualizations based on the Lego data available at Rebrickable 2. They address the question: What is it like to live in the Lego world? That is, what kinds of people do you meet? How are they feeling? What plants and animals do you find around you? Think of each theme as an island on the Lego planet. Each visualization can be faceted by theme, so you can compare fashion, flora and fauna, etc. across themes. The human focus of this app distinguishes it from the various other Lego visualizations that already exist (including one built in Shiny; see About in the app for a fuller list)."
  },
  {
    "objectID": "r/gallery/miscellaneous/pokemon-explorer/index.html",
    "href": "r/gallery/miscellaneous/pokemon-explorer/index.html",
    "title": "Gotta Catch‚Äô Em (Almost) All",
    "section": "",
    "text": "Back to Gallery\n      Gotta Catch‚Äô Em (Almost) All\n            David Granjon\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            This app is a showcase for the tablerDash package, a bootstrap 4 dashboard template for shiny. Explore the 151 first pokemons from the Green, Red and Blue versions, respectively (#pokeApi). It also includes a preliminary fighting system implemented in R and shiny modules."
  },
  {
    "objectID": "r/gallery/miscellaneous/tidy-tuesday/index.html",
    "href": "r/gallery/miscellaneous/tidy-tuesday/index.html",
    "title": "tidytuesday.rocks: A #TidyTuesday Tweet Catalogue",
    "section": "",
    "text": "Back to Gallery\n      tidytuesday.rocks: A #TidyTuesday Tweet Catalogue\n            Neal Grantham\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            Tidy Tuesday is a weekly social data project in R where users explore a new dataset each week and share their findings on Twitter with #TidyTuesday. tidytuesday.rocks collects and organizes all #TidyTuesday tweets so it‚Äôs easy to see how users approached each dataset: the questions they asked, the plots they made, and the code they wrote. Use tidytuesday.rocks to learn from the friendly and talented Tidy Tuesday community and inspire your next great data visualization!\n            This app is one of the runers up of the 2019 Shiny Contest. If you haven‚Äôt heard of #TidyTuesday, you‚Äôre missing out on one of the most dynamic virtual events in the R community. The tidytuesday.rocks app is a tastefully minimalist interface for exploring previous weeks‚Äô datasets and community submissions for visualizations."
  },
  {
    "objectID": "r/gallery/reactive-programming/isolate-demo/index.html",
    "href": "r/gallery/reactive-programming/isolate-demo/index.html",
    "title": "isolate demo",
    "section": "",
    "text": "Back to Gallery\n      isolate demo\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/reactive-programming/reactive-poll-and-file-reader/index.html",
    "href": "r/gallery/reactive-programming/reactive-poll-and-file-reader/index.html",
    "title": "Reactive poll and file reader",
    "section": "",
    "text": "Back to Gallery\n      Reactive poll and file reader\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/reactive-programming/submitbutton-demo/index.html",
    "href": "r/gallery/reactive-programming/submitbutton-demo/index.html",
    "title": "submitButton demo",
    "section": "",
    "text": "Back to Gallery\n      submitButton demo\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/sports/fifa-births/index.html",
    "href": "r/gallery/sports/fifa-births/index.html",
    "title": "App showing the birth locations of all players in the 2018 FIFA World Cup",
    "section": "",
    "text": "Back to Gallery\n      App showing the birth locations of all players in the 2018 FIFA World Cup\n            Phil Straforelli\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            Each player selected to play in the 2018 FIFA World Cup have their birthplaces located on a Leaflet map, displayed in the flag of the player‚Äôs national team. The tooltip over the icon shows the name of the player, and clicking on the icon displays further information as well as the player‚Äôs Wikipedia page."
  },
  {
    "objectID": "r/gallery/sports/masters/index.html",
    "href": "r/gallery/sports/masters/index.html",
    "title": "The Masters",
    "section": "",
    "text": "Back to Gallery\n      The Masters\n            Chris\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            The app offers users a tool to explore and visualize the history of The Masters golf tournament. Among other things, you can see whether scores have changed over time, play with aggregated historical leaderboards, and review players‚Äô scoring averages."
  },
  {
    "objectID": "r/gallery/start-simple/faithful/index.html",
    "href": "r/gallery/start-simple/faithful/index.html",
    "title": "Faithful",
    "section": "",
    "text": "Back to Gallery\n      Faithful\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/start-simple/single-file-shiny-app/index.html",
    "href": "r/gallery/start-simple/single-file-shiny-app/index.html",
    "title": "Single-file shiny app",
    "section": "",
    "text": "Back to Gallery\n      Single-file shiny app\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/start-simple/word-cloud/index.html",
    "href": "r/gallery/start-simple/word-cloud/index.html",
    "title": "Word cloud",
    "section": "",
    "text": "Back to Gallery\n      Word cloud\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/technology/cran-explorer/index.html",
    "href": "r/gallery/technology/cran-explorer/index.html",
    "title": "CRAN Explorer",
    "section": "",
    "text": "Back to Gallery\n      CRAN Explorer\n            Stefan Schliebs\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            A Shiny app to explore CRAN packages and their interdependencies using a custom HTML template and custom widgets.\n            This app is one of the runers up of the 2019 Shiny Contest. There are plenty of Shiny apps for exploring CRAN metadata, but none of them look as striking as this one by nz-stefan! This is a really nice example of HTML Template usage; the separation between the R UI and the raw HTML UI is extremely clean."
  },
  {
    "objectID": "r/gallery/technology/uber-rider/index.html",
    "href": "r/gallery/technology/uber-rider/index.html",
    "title": "ubeRideR",
    "section": "",
    "text": "Back to Gallery\n      ubeRideR\n            Vivek Katial\n            \n                 About the Author\n                         View App\n                         View Code\n                         View on Posit Cloud\n              \n                \n            This is a shiny app I have developed which showcases how to make Shiny apps look nice using HTMLTemplates. The app itself explores my uber data.\n            This app was recognized with an honorable mention on the 2019 Shiny Contest."
  },
  {
    "objectID": "r/gallery/widgets/custom-input-bindings/index.html",
    "href": "r/gallery/widgets/custom-input-bindings/index.html",
    "title": "Custom input bindings",
    "section": "",
    "text": "Back to Gallery\n      Custom input bindings\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/widgets/datatables-demo/index.html",
    "href": "r/gallery/widgets/datatables-demo/index.html",
    "title": "DataTables Demo",
    "section": "",
    "text": "Back to Gallery\n      DataTables Demo\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/widgets/date-and-date-range/index.html",
    "href": "r/gallery/widgets/date-and-date-range/index.html",
    "title": "Date and date range",
    "section": "",
    "text": "Back to Gallery\n      Date and date range\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/widgets/file-download/index.html",
    "href": "r/gallery/widgets/file-download/index.html",
    "title": "File Download",
    "section": "",
    "text": "Back to Gallery\n      File Download\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/widgets/mathjax/index.html",
    "href": "r/gallery/widgets/mathjax/index.html",
    "title": "MathJax",
    "section": "",
    "text": "Back to Gallery\n      MathJax\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/widgets/selectize-examples/index.html",
    "href": "r/gallery/widgets/selectize-examples/index.html",
    "title": "Selectize Examples",
    "section": "",
    "text": "Back to Gallery\n      Selectize Examples\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/widgets/sliders/index.html",
    "href": "r/gallery/widgets/sliders/index.html",
    "title": "Sliders",
    "section": "",
    "text": "Back to Gallery\n      Sliders\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/gallery/widgets/widgets/index.html",
    "href": "r/gallery/widgets/widgets/index.html",
    "title": "Widgets",
    "section": "",
    "text": "Back to Gallery\n      Widgets\n            \n                         View App\n                         View Code"
  },
  {
    "objectID": "r/getstarted/build-an-app/customizing-ui/interface.html#second-level-heading",
    "href": "r/getstarted/build-an-app/customizing-ui/interface.html#second-level-heading",
    "title": "Interface Builder Functions",
    "section": "Second level heading",
    "text": "Second level heading\n\nThird level heading\n\n\n\nLinked text\nIf you have references you want to link to at the bottom of you app, you can use the a tag with the href argument for specifying a URL.\nlibrary(shiny)\nlibrary(bslib)\n\n# Define UI with tags\nui &lt;- page_fluid(\n  tags$h1(\"Awesome title\"),\n  tags$br(), # line break\n  tags$a(\"This app is built with Shiny.\", href = \"https://shyr-test-center.netlify.app/\")\n)\n\n# Define server fn that does nothing :)\nserver &lt;- function(input, output, session) {}\n\n# Create the app object\nshinyApp(ui = ui, server = server)\n\nAwesome title\nThis app is built with Shiny.\n\n\n\nNested tags\nYou can also nest tags within each other to create something like a new paragraph with the p tag and some text in that paragraph where certain words are italicized with the em tag and certain are bolded with the b tag.\nlibrary(shiny)\nlibrary(bslib)\n\n# Define UI with tags\nui &lt;- page_fluid(\n  tags$p(\n    \"Lorem ipsum\",\n    tags$em(\"dolor\"),\n    \"sit amet,\",\n    tags$b(\"consectetur\"),\n    \"adipiscing elit.\"\n    )\n  )\n\n# Define server fn that does nothing :)\nserver &lt;- function(input, output, session) {}\n\n# Create the app object\nshinyApp(ui = ui, server = server)\n\nLorem ipsum dolor sit amet, consectetur adipiscing elit.\n\n\n\nCommon tags\nAdditionally, the most commonly used tags are wrapped in their own functions and you can use them without the tags list.\ntags$p(...)       -&gt; p(...)\ntags$h1(...)      -&gt; h1(...)\ntags$h2(...)      -&gt; h2(...)\ntags$h3(...)      -&gt; h3(...)\ntags$h4(...)      -&gt; h4(...)\ntags$h5(...)      -&gt; h5(...)\ntags$h6(...)      -&gt; h6(...)\ntags$a(...)       -&gt; a(...)\ntags$br(...)      -&gt; br(...)\ntags$div(...)     -&gt; div(...)\ntags$span(...)    -&gt; span(...)\ntags$pre(...)     -&gt; pre(...)\ntags$code(...)    -&gt; code(...)\ntags$img(...)     -&gt; img(...)\ntags$strong(...)  -&gt; strong(...)\ntags$em(...)      -&gt; em(...)\ntags$hr(...)      -&gt; hr(...)\n\n\n\nThese are functions like:\n\na() for anchor text.\ntags$a(\"Anchor text\")\n&lt;a&gt;Anchor text&lt;/a&gt;\na(\"Anchor text\")\n&lt;a&gt;Anchor text&lt;/a&gt;\nbr() for a line break.\ntags$br()\n&lt;br&gt;\nbr()\n&lt;br&gt;\ncode() for displaying code in monospace form\ntags$code(\"Monospace text\")\n&lt;code&gt;Monospace text&lt;/code&gt;\ncode(\"Monospace text\")\n&lt;code&gt;Monospace text&lt;/code&gt;\nAnd the heading functions we mentioned earlier\ntags$h1(\"First level header\")\n&lt;h1&gt;First level header&lt;/h1&gt;\nh1(\"First level header\")\n&lt;h1&gt;First level header&lt;/h1&gt;\n\nThe function names correspond to the tag names, and the functions accept text strings as arguments. For example tags$h1(\"First level heading\") is equivalent to h1(\"First level heading\").\n\n\nHTML\nIf you‚Äôre comfortable with HTML, an alternative is to directly use HTML syntax and wrap your HTML code with the HTML function.\nHTML(\"Hello world, &lt;br/&gt; and then a line break.\")\nHello world, &lt;br/&gt; and then a line break.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Customizing UI",
      "Interface Builder Functions"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/customizing-ui/interface.html#practice",
    "href": "r/getstarted/build-an-app/customizing-ui/interface.html#practice",
    "title": "Interface Builder Functions",
    "section": "Practice",
    "text": "Practice\nNext, let‚Äôs work on some exercises on adding HTML elements to our apps to customize appearance.\nThese next exercises will demo a few of the simpler interface builder options with HTML code.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Customizing UI",
      "Interface Builder Functions"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/customizing-ui/interface.html#practice---add-text-with-html-tags",
    "href": "r/getstarted/build-an-app/customizing-ui/interface.html#practice---add-text-with-html-tags",
    "title": "Interface Builder Functions",
    "section": "Practice - Add text with HTML tags",
    "text": "Practice - Add text with HTML tags\n\nYour turn\n\nAdd explanatory text to your movie app by using HTML tags in the main panel.\nBelow is some sample text you can add. Note that you should replace [NUMBER OF MOVIES] with with the number of movies in the sample, and instead of hardcoding this value, you can use nrow(movies) to calculate it.\n\nThese data were obtained from &lt;a href=\"http://www.imbd.com/\"&gt;IMBD&lt;/a&gt; and\n&lt;a href=\"https://www.rottentomatoes.com/\"&gt;Rotten Tomatoes&lt;/a&gt;.\n\nThe data represent _[NUMBER OF MOVIES]_ randomly sampled movies released between 1972 to 2014 in the United States.\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nNavigate to the Posit Cloud Project titled 4-1a Add text with HTML tags in your Posit Cloud Workspace to see this code in action\n Go to Posit Cloud Project\n\n\n\n\n\n\n\n\n\nWork locally in your RStudio IDE\n\n\n\n\n\n\nDownload the data if you haven‚Äôt already\n\n```{r}\n# Get the data\n\nfile &lt;- \"https://github.com/rstudio-education/shiny-course/raw/main/movies.RData\"\ndestfile &lt;- \"movies.RData\"\n\ndownload.file(file, destfile)\n```\n\nCopy the code below into an R script\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(tools)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    sidebar = sidebar(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.5\n      ),\n\n      sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 2\n      ),\n\n      textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      ),\n\n      actionButton(\n        inputId = \"update_plot_title\",\n        label = \"Update plot title\"\n      )\n    ),\n\n    card(\n      tags$br(),\n      ___, # add text here\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  new_plot_title &lt;- eventReactive(\n    eventExpr = input$update_plot_title,\n    valueExpr = {\n      toTitleCase(input$plot_title)\n    }\n  )\n\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y, color = input$z)) +\n      geom_point(alpha = input$alpha, size = input$size) +\n      labs(title = new_plot_title())\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(tools)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    sidebar = sidebar(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.5\n      ),\n\n      sliderInput(\n        inputId = \"size\",\n        label = \"Size:\",\n        min = 0, max = 5,\n        value = 2\n      ),\n\n      textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text to be used as plot title\"\n      ),\n\n      actionButton(\n        inputId = \"update_plot_title\",\n        label = \"Update plot title\"\n      )\n    ),\n\n    card(\n      tags$br(),\n      tags$p(\n        \"These data were obtained from\",\n        tags$a(\"IMBD\", href = \"http://www.imbd.com/\"), \"and\",\n        tags$a(\"Rotten Tomatoes\", href = \"https://www.rottentomatoes.com/\"), \".\"\n      ),\n      tags$p(\"The data represent\", nrow(movies), \"randomly sampled movies released between 1972 to 2014 in the United States.\"),\n\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  new_plot_title &lt;- eventReactive(\n    eventExpr = input$update_plot_title,\n    valueExpr = {\n      toTitleCase(input$plot_title)\n    }\n  )\n\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y, color = input$z)) +\n      geom_point(alpha = input$alpha, size = input$size) +\n      labs(title = new_plot_title())\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Customizing UI",
      "Interface Builder Functions"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/customizing-ui/interface.html#practice---add-image-with-the-img-tag",
    "href": "r/getstarted/build-an-app/customizing-ui/interface.html#practice---add-image-with-the-img-tag",
    "title": "Interface Builder Functions",
    "section": "Practice - Add image with the img tag",
    "text": "Practice - Add image with the img tag\n\nYour turn\n\nNow let‚Äôs practice adding an image to a very simple app.\nNote that if you‚Äôd like to use a local image for with your app, you‚Äôll first have to save the image in a folder www/ within your root directory. You‚Äôll see what we mean when you run the demo in the Posit Cloud Project. Set a height and width for your image as well.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nNavigate to the Posit Cloud Project titled 4-1b Add image with img tag in your Posit Cloud Workspace for the demo\n Go to Posit Cloud Project\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\n\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_fluid(\n  titlePanel(\"An image\"),\n  tags$img(___),\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {}\n\n# Create the Shiny app ---------------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\n\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_fluid(\n  titlePanel(\"An image\"),\n  tags$img(height = 100, width = 300, src = \"roles_implement.png\"),\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {}\n\n# Create the Shiny app ---------------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Customizing UI",
      "Interface Builder Functions"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/customizing-ui/tabs.html",
    "href": "r/getstarted/build-an-app/customizing-ui/tabs.html",
    "title": "Tabs and tabset panels",
    "section": "",
    "text": "If the amount of information you want to communicate to your users does not fit well on a page, or there is detailed information, like raw data, that you want to make available to your users but not necessarily feature prominently in your app, you can make use of tabs to distribute this information to stackable tab panels.\n\nTab panels\nTabsets are created by combining nav_panel()s in a navigation container. The bslib package provides many styles of navigation containers, including:\n\nnavset_underline() and navset_card_underline()\nnavset_tab() and navset_card_tab()\nnavset_pill_list()\nnavset_pill() and navset_card_pill()\nnavset_hidden()\nnavset_bar()\n\nBelow, we use navset_card_underline() and nav_panel() to create four tab panels. Each tab panel has a unique title and a list of output elements which are rendered vertically within the tab.\nIn this example we display\n\na plot of our data in the first tab,\nsummary statistics in the second tab,\nraw data in the third tab,\nand some background information on our dataset in the fourth tab.\n\nnavset_card_underline(\n\n  nav_panel(\"Plot\", plotOutput(\"plot\")),\n\n  nav_panel(\"Summary\", tableOutput(\"summary\")),\n\n  nav_panel(\"Data\", DT::dataTableOutput(\"data\")),\n\n  nav_panel(\n    \"Reference\",\n    markdown(\n      glue::glue(\n        \"These data were obtained from [IMDB](http://www.imdb.com/) and [Rotten Tomatoes](https://www.rottentomatoes.com/).\n  \n        The data represent {nrow(movies)} randomly sampled movies released between 1972 to 2014 in the United States.\n        \"\n      )\n    )\n  )\n)\n\n\n\n\n\n\n\n\nTabs and reactivity\nNote that in the previous example the user first selected a subset of the data, movies_subset(), then this new sampled data got used in four separate tabs.\nIntroducing tabs into our user interface underlines the importance of creating reactive expressions for shared data.\nIf the dataset is expensive to compute, then the user interface could be slow to render if each tab were required to do the computation.\nInstead, we calculate the data once in a reactive expression, and then have the result be shared by all of the output tabs.\n\n\nnavset_pill_list\nAnother option for laying out tabs is using the navset_pill_list(), which lists the tabs vertically down the side, as opposed to horizontally across the screen.\n\n\n\n\n\n\n\nTabs\nTo recap, use tabs to add navigation to your app. bslib includes various navset_*() functions that define a navigation container. Then, use nav_*() functions to define navigation items.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Customizing UI",
      "Tabs and tabset panels"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/hello-shiny/getting-started.html#here-is-a-shiny-app",
    "href": "r/getstarted/build-an-app/hello-shiny/getting-started.html#here-is-a-shiny-app",
    "title": "Getting Started",
    "section": "Here is a Shiny app",
    "text": "Here is a Shiny app\nAnd not just any app, an app that you will be able to build by the end of this tutorial!\n\n\n\n\nWe‚Äôll go through the technical details of each component of such an app throughout the tutorial, but for now let‚Äôs take a high level view.\n\nWe have:\n\na title for the app,\na series of inputs:\n\nsome of these inputs use drop down menus for selection,\nsome are sliders,\nsome allow for text input, and\nsome are action buttons\n\nand a few outputs:\n\na plot output that the user can interactively update,\na text output that updates alongside it, and\na data table output that also updates alongside these.\n\n\nAs much as it looks like there is a lot going on in this sample app, the app doesn‚Äôt even scratch the surface of what you can build with Shiny.\nI hope you‚Äôre excited to take it all in!",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Hello Shiny!",
      "Getting Started"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/hello-shiny/getting-started.html#background",
    "href": "r/getstarted/build-an-app/hello-shiny/getting-started.html#background",
    "title": "Getting Started",
    "section": "Background",
    "text": "Background\nBefore we get started with Shiny, let‚Äôs talk background‚Ä¶\nThis tutorial assumes that you are familiar with R as a programming language.\nAdditionally, this tutorial uses packages from the tidyverse (e.g.¬†dplyr for data wrangling and ggplot2 for data visualisation). Your Shiny apps can use any package, but if you‚Äôd like to learn more about doing data science with the tidyverse, see here.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Hello Shiny!",
      "Getting Started"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/hello-shiny/getting-started.html#help",
    "href": "r/getstarted/build-an-app/hello-shiny/getting-started.html#help",
    "title": "Getting Started",
    "section": "Help",
    "text": "Help\nThe tutorial is designed for beginners and many of the exercises have plenty of scaffolding to help you along the way.\nThat being said, there are a few other resources that might help your learning.\n\n\n\n\nThe Shiny cheatsheet is a handy-dandy resource that we recommend you keep close by when building Shiny apps.\nThe book Mastering Shiny by Hadley Wickham is available online and is incredibly helpful and thorough.\nThis website‚Äôs Articles section is the most comprehensive knowledge base about all things Shiny and to keep up to date with it as it evolves.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Hello Shiny!",
      "Getting Started"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/hello-shiny/getting-started.html#tips",
    "href": "r/getstarted/build-an-app/hello-shiny/getting-started.html#tips",
    "title": "Getting Started",
    "section": "Tips",
    "text": "Tips\nAlso, let‚Äôs go over three very important tips for learning to develop Shiny apps:\n\nAlways run the entire script containing the R code, not just up to the point where you‚Äôre developing code. For most exercises in this tutorial you will be asked to modify or update existing Shiny code, and even though you might be altering a small portion of the code, you still need to run the entire app code to create the app.\nSometimes the best way to troubleshoot is to run the app and review the error. Not only can the error message be informative, but googling the error message might quickly land you on a solution.\nWatch out for commas! This will mean more as you start to learn Shiny, but just keep in mind, a Shiny error can often be caused by a missing comma. Thankfully, the RStudio IDE will alert you to most of these missing comma or similar syntax errors, like the one shown below.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Hello Shiny!",
      "Getting Started"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/hello-shiny/getting-started.html#anatomy-of-a-shiny-app",
    "href": "r/getstarted/build-an-app/hello-shiny/getting-started.html#anatomy-of-a-shiny-app",
    "title": "Getting Started",
    "section": "Anatomy of a Shiny app",
    "text": "Anatomy of a Shiny app\nAlrighty, let‚Äôs take a look at the anatomy of a Shiny app:\n\n\nStart by loading the package shiny. Load any other packages you need for the app.\nLay out the user interface with a ui object . This will control the appearance of the app.\nDefine the server function that contains instructions needed to build the plots or the outputs.\nEnd the app with a call to shinyapp() function. This will put ui and server components together to create the shiny app.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Hello Shiny!",
      "Getting Started"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/hello-shiny/getting-started.html#data",
    "href": "r/getstarted/build-an-app/hello-shiny/getting-started.html#data",
    "title": "Getting Started",
    "section": "Data",
    "text": "Data\nIn this tutorial we will build a simple movie browser app.\nWe will use the movies dataset, which combines data from two websites: the Internet Movie Database, commonly known as IMDB, and Rotten Tomatoes. The observations are a random sample of 651 movies released in the US between 1970 and 2014.\nSo where does the loading of the data happen in an app?",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Hello Shiny!",
      "Getting Started"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/hello-shiny/getting-started.html#revisit",
    "href": "r/getstarted/build-an-app/hello-shiny/getting-started.html#revisit",
    "title": "Getting Started",
    "section": "Revisit",
    "text": "Revisit\nLet‚Äôs revisit the app layout from a couple sections back.\n\nWe load the data before ui and server definitions so that it can be used in both.\nAlright, time for some practice!\n\n\n\n\n\n\nWhat‚Äôs in an app?\n\n\n\nWhich of these is not generally a part of the Shiny app architecture?\n\nA function that installs an R package\nUser interface\nServer function\nA function that creates Shiny app objects\n\n\n\n\n\n\n\nClick to view the answer\n\n\n\n\n\nA function that installs an R package.\nYou don‚Äôt want to reinstall the package every time you run your app, so you should do this once in your console instead of within your Shiny app",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Hello Shiny!",
      "Getting Started"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/hello-shiny/getting-started.html#practice-first-peek-under-the-hood",
    "href": "r/getstarted/build-an-app/hello-shiny/getting-started.html#practice-first-peek-under-the-hood",
    "title": "Getting Started",
    "section": "Practice: First peek under the hood",
    "text": "Practice: First peek under the hood\nBelow you can see the complete code to reproduce the app we introduced in the previous section. You can use this code to interact with the app yourself, and make small adjustments to it.\nThere are two ways to work with this code:\n\n\n\n\n\n\nInstructions for working on Posit Cloud\n\n\n\n\n\nWe‚Äôve created a Posit Cloud Project for you to test drive this code. The scripts and data are already there!\n\nClick the button  Go to Posit Cloud Workspace\nSelect 1.1 First peek under the hood from the Project list\nFollow these Practice instructions to get started!\n\n\n\n\n\n\n\n\n\n\nInstructions for working locally in your RStudio IDE\n\n\n\n\n\nCreate a new project in your local RStudio IDE and copy the code from these pages into the R script.\n\nOpen RStudio IDE\nCreate a new R project. Select ‚ÄòNew Directory‚Äô and then use ‚ÄòShiny Application‚Äô\nGive your project a name like ‚Äúexample-shiny-app‚Äù\nA file app.R will open with code about ‚ÄúOld Faithful Geyser Data‚Äù\nDelete the code in that file\nCopy the code below and paste it into that file instead\nSave the file as app.R\nFollow these Practice instructions to get started!\n\n\n\n\n\nUse or copy this code\n# Load packages\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\n\n# Get the data\n\nfile &lt;- \"https://github.com/rstudio-education/shiny-course/raw/main/movies.RData\"\ndestfile &lt;- \"movies.RData\"\n\ndownload.file(file, destfile)\n\n# Load data\n\nload(\"movies.RData\")\n\n# Define UI\n\nui &lt;- page_sidebar(\n  sidebar = sidebar(\n    # Select variable for y-axis\n    selectInput(\n      inputId = \"y\",\n      label = \"Y-axis:\",\n      choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n      selected = \"audience_score\"\n    ),\n    # Select variable for x-axis\n    selectInput(\n      inputId = \"x\",\n      label = \"X-axis:\",\n      choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n      selected = \"critics_score\"\n    )\n  ),\n  # Output: Show scatterplot\n  card(plotOutput(outputId = \"scatterplot\"))\n)\n\n# Define server\n\nserver &lt;- function(input, output, session) {\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n}\n\n# Create a Shiny app object\n\nshinyApp(ui = ui, server = server)\n\n\nYour turn\n\nOnce you have the file app.R open locally or on Cloud, click  to run the code and generate the app.\nPlay with the input selectors for the Y-axis and the X-axis and observe how the output changes.\nClose the app by closing the pop-up window or clicking on the red Stop button in the viewer.\nLocate the relevant lines of code in app.R that build the selector widget for the Y-axis. This is in a selectInput() function starting around Line 20, underneath the comment # Select variable for y-axis. Note that this function takes four arguments: inputId, label, choices, and selected. We‚Äôll discuss what each of these mean in detail shortly. For now, change the selected argument to imdb_rating, save your changes, and run the app again by clicking on . What changed?\n\n\n\n\n\n\n\nIf you get an error when you try to rerun the app, you can either try to debug the issue by tracing back your steps or delete everything in app.R and copy and paste the code above into app.R. This will get you back to your starting point. You can use this ‚Äústart over‚Äù approach for any of the exercises in this tutorial.\n\n\n\n\nNow locate the relevant lines of code in app.R that build the selector widget for the X-axis. This is also in a selectInput() function, starting around Line 27, underneath the comment # Select variable for x-axis. Change the selected argument to imdb_rating as well, save your changes, and run the app again. What changed?",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Hello Shiny!",
      "Getting Started"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/hello-shiny/server-function.html",
    "href": "r/getstarted/build-an-app/hello-shiny/server-function.html",
    "title": "Server function",
    "section": "",
    "text": "Now that you‚Äôve had some practice with the UI, it‚Äôs time to move on to the server function.\nAgain, before we get into the details, let‚Äôs remind ourselves of the anatomy of a Shiny app. The basic task of the server function is to define the relationship between inputs and outputs.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Hello Shiny!",
      "Server function"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/hello-shiny/server-function.html#practice-matching-inputs-and-outputs",
    "href": "r/getstarted/build-an-app/hello-shiny/server-function.html#practice-matching-inputs-and-outputs",
    "title": "Server function",
    "section": "Practice: Matching inputs and outputs",
    "text": "Practice: Matching inputs and outputs\nHere is a simple Shiny app. Try entering some text and observe how the text is displayed back to you after a short pause.\n\n\nExample Shiny App\n\n\n\n\n\nThe code for this app is given below, with a few pieces missing (indicated with ___). Each of the blanks are numbered, e.g.¬†([1], [2], etc.)\nlibrary(shiny)\n\nui &lt;- page_fluid(\n\n  textInput(\n    inputId = \"custom_text\",\n    label = \"_[1]_\"\n  ),\n\n  strong(\"Text is shown below:\"),\n\n  _[2]_(outputId = \"_[3]_\")\n\n)\n\nserver &lt;- function(input, output, session){\n\n  output$user_text &lt;- renderText({ input$_[4]_ })\n\n}\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nHow do we match inputs and outputs?\n\n\n\nWhich of the following is false?\n\n[1] should be \"Input some text here:\"\n[2] should be textOutput\n[3] should be \"custom_text\"\n[4] should be \"custom_text\"\n\n\n\n\n\n\n\nClick to View the Answer\n\n\n\n\n\n[3] should be \"custom_text\" is false.\n\n\n\n\n\n\n\nReactivity\nLet‚Äôs also briefly discuss reactivity.\n\nIt‚Äôs easy to build interactive applications with Shiny, but to get the most out of it, you‚Äôll need to understand the reactive programming scheme used by Shiny.\nIn a nutshell Shiny automatically updates outputs, such as plots, when inputs that go into them change.\n\n\nPutting all the pieces together\nBefore we wrap up this section, I should also mention the last component of each Shiny app, which is a call to the aptly named shinyApp() function, which puts the UI and the server pieces together to create a Shiny app object.\n\nTime to put this all into practice!",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Hello Shiny!",
      "Server function"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/hello-shiny/server-function.html#practice-rules-of-server-functions",
    "href": "r/getstarted/build-an-app/hello-shiny/server-function.html#practice-rules-of-server-functions",
    "title": "Server function",
    "section": "Practice: Rules of server functions",
    "text": "Practice: Rules of server functions\n\n\n\n\n\n\nReviewing server functions\n\n\n\nWhich of the following is not true about server functions?\n\nServer functions should include a call to #runApp()\nObjects to be displayed should be saved to #output$\nReactive objects should be built with render*() functions\nInput values should be referred to with input$\n\n\n\n\n\n\n\nClick to View the Answer\n\n\n\n\n\nServer functions should include a call to #runApp()\nThe runApp() function can be used in the Console to run a Shiny application, as an alternative to the Run App button in the RStudio IDE.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Hello Shiny!",
      "Server function"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/hello-shiny/server-function.html#practice-fix-it-up",
    "href": "r/getstarted/build-an-app/hello-shiny/server-function.html#practice-fix-it-up",
    "title": "Server function",
    "section": "Practice: Fix it up",
    "text": "Practice: Fix it up\nBelow is the code for the Shiny app we built earlier, however currently the code is broken. Specifically there are errors in the definition of the server function as well as in the mainPanel of the UI.\n\nYour turn\n\nReview the app and identify errors in the code. (Hint: Refer back to the rules of server functions.)\nDo the render functions match the output functions? If not, make the appropriate change and try running the app. Are there any remaining errors?\nAre the inputs referred to using the correct syntax? If not, make the appropriate change and try running the app. Are there any remaining errors?\nAre the outputs referred to using the correct names? If not, make the appropriate change and try running the app. Are there any remaining errors?\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nNavigate to the project called 1-3 Fix it up after clicking the button below\n Go to Posit Cloud Workspace\n\n\n\n\n\n\n\n\n\nWork locally in your RStudio IDE\n\n\n\n\n\n\nDownload the data if you haven‚Äôt already\n\n```{r}\n# Get the data\n\nfile &lt;- \"https://github.com/rstudio-education/shiny-course/raw/main/movies.RData\"\ndestfile &lt;- \"movies.RData\"\n\ndownload.file(file, destfile)\n```\n\nCopy the code below into an R script\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n  sidebar = sidebar(\n    # Select variable for y-axis\n    selectInput(\n      inputId = \"y\",\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics score\" = \"critics_score\",\n        \"Audience score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n\n    # Select variable for x-axis\n    selectInput(\n      inputId = \"x\",\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics score\" = \"critics_score\",\n        \"Audience score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"critics_score\"\n    ),\n\n    # Select variable for color\n    selectInput(\n      inputId = \"z\",\n      label = \"Color by:\",\n      choices = c(\n        \"Title type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA rating\" = \"mpaa_rating\",\n        \"Critics rating\" = \"critics_rating\",\n        \"Audience rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    )\n  ),\n\n  # Output: Show scatterplot\n  card(plotOutput(outputId = \"scatterPlot\"))\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  output$scatterplot &lt;- renderTable({\n\n    ggplot(data = movies, aes_string(x = x, y = y, color = z)) +\n      geom_point()\n\n  })\n\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n  sidebar = sidebar(\n    # Select variable for y-axis\n    selectInput(\n      inputId = \"y\",\n      label = \"Y-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics score\" = \"critics_score\",\n        \"Audience score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"audience_score\"\n    ),\n\n    # Select variable for x-axis\n    selectInput(\n      inputId = \"x\",\n      label = \"X-axis:\",\n      choices = c(\n        \"IMDB rating\" = \"imdb_rating\",\n        \"IMDB number of votes\" = \"imdb_num_votes\",\n        \"Critics score\" = \"critics_score\",\n        \"Audience score\" = \"audience_score\",\n        \"Runtime\" = \"runtime\"\n      ),\n      selected = \"critics_score\"\n    ),\n\n    # Select variable for color\n    selectInput(\n      inputId = \"z\",\n      label = \"Color by:\",\n      choices = c(\n        \"Title type\" = \"title_type\",\n        \"Genre\" = \"genre\",\n        \"MPAA rating\" = \"mpaa_rating\",\n        \"Critics rating\" = \"critics_rating\",\n        \"Audience rating\" = \"audience_rating\"\n      ),\n      selected = \"mpaa_rating\"\n    )\n  ),\n\n  # Output: Show scatterplot\n  card(\n    plotOutput(outputId = \"scatterplot\")\n  )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y, color = input$z)) +\n      geom_point()\n  })\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Hello Shiny!",
      "Server function"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactive-flow/reactive-flow.html#reactivity-in-spreadsheets",
    "href": "r/getstarted/build-an-app/reactive-flow/reactive-flow.html#reactivity-in-spreadsheets",
    "title": "Reactive Flow",
    "section": "Reactivity, in spreadsheets",
    "text": "Reactivity, in spreadsheets\nOne familiar way of thinking about reactivity is to think in the context of a spreadsheet, like Google Sheets or Microsoft Excel.\n\n\n\nSuppose you write a value into a cell in a spreadsheet‚Ä¶\n\n\n\n\nand then in another cell you write a formula that depends on that cell.\n\n\n\n\nFirst, the formula is calculated with the value you originally typed.\n\n\n\n\nNow when you change the value of the original cell, the result of the formula will automatically update, or in other words, react to this change.\n\n\n\nReactions\nIn a Shiny app reactivity happens in a similar fashion.\nSuppose you have a sliderInput in your app with the inputId of alpha. The value of this input is stored in input$alpha.\n\nSo when the user moves around the slider, the value of the alpha input is updated in the input list.\n\n\nReactivity 101\nReactivity automatically occurs when an input value is used to render an output object, i.e.¬†in the server function below the plot is re-rendered when the value of input$alpha changes based on user input. You, as the app developer, do not need to write code that says ‚ÄúUpdate the plot every time the value of input$alpha changes‚Äù, Shiny automatically takes care of this for you in the render*() function.\n\n\n\nReactive flow\nHere is a roadmap of the reactive flow in Shiny, though for now we‚Äôll just focus on the straight path between an input and an output, and discuss the other features later in the course.\n\n\n\nReactive flow, simplified\n\nThe user selects an input, this input goes through some expression in the server, and an output is rendered. Each time the user changes their input selection, the expression that generates the output will automatically re-execute, and the relevant output will be re-rendered based on the new value of the input.\nIn a Shiny application, there‚Äôs no need to explictly describe the relationships between inputs and outputs and tell R what to do when each input changes, Shiny automatically handles these details for you.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactive Flow",
      "Reactive Flow"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactive-flow/reactive-flow.html#practice-building-a-reactive-widget",
    "href": "r/getstarted/build-an-app/reactive-flow/reactive-flow.html#practice-building-a-reactive-widget",
    "title": "Reactive Flow",
    "section": "Practice: Building a reactive widget",
    "text": "Practice: Building a reactive widget\nAs we saw in the previous sections, reactivity is established by linking an input with an output via a render*() function.\n\nYour turn\n\nAdd a new input widget, a sliderInput, that controls the transparency of the plotted points. This widget should have the ID alpha and its values should range between 0 and 1. You can decide what the displayed label and initial value of the slider should be.\nMake the associated update in the server function.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the Posit Cloud Project titled 2-1a Building a reactive widget in your Posit Cloud Workspace\n Go to Posit Cloud Project\n\n\n\n\n\n\n\n\n\nWork locally in your RStudio IDE\n\n\n\n\n\n\nDownload the data if you haven‚Äôt already\n\n```{r}\n# Get the data\n\nfile &lt;- \"https://github.com/rstudio-education/shiny-course/raw/main/movies.RData\"\ndestfile &lt;- \"movies.RData\"\n\ndownload.file(file, destfile)\n```\n\nCopy the code below into an R script\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(bslib)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n  \n    \n    sidebar = sidebar(\n      \n      selectInput(inputId = \"y\", \n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"audience_score\"),\n\n      selectInput(inputId = \"x\",\n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"critics_score\"),\n\n      # Set alpha level\n      sliderInput(inputId = ___,\n                  label = ___,\n                  min = ___, max = ___,\n                  value = ___)\n    ),\n    \n    card(\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point(alpha = ___)\n  })\n\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(bslib)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n  \n    sidebar = sidebar(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"critics_score\"\n      ),\n\n      sliderInput(\n        inputId = \"alpha\",\n        label = \"Alpha:\",\n        min = 0, max = 1,\n        value = 0.5\n      )\n    ),\n\n    card(\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point(alpha = input$alpha)\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactive Flow",
      "Reactive Flow"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactive-flow/reactive-flow.html#practice-dude-wheres-my-plot",
    "href": "r/getstarted/build-an-app/reactive-flow/reactive-flow.html#practice-dude-wheres-my-plot",
    "title": "Reactive Flow",
    "section": "Practice: Dude, where‚Äôs my plot?",
    "text": "Practice: Dude, where‚Äôs my plot?\nThe server function of this app builds two plots, scatterplot and densityplot, however the app only displays one.\n\nYour turn\n\nRun the app and identify which plot is missing\nMake the necessary update to the app UI to display the missing plot\nReduce the height of the new plot using the height argument in the plotOutput() function (suggested height: height = 200)\n\nHint: Make sure you place commas as appropriate.\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-1b Dude wheres my plot in your Posit Cloud Workspace\n Go to RStudio Cloud Project\n\n\n\n\n\n\n\n\n\nWork locally in your RStudio IDE\n\n\n\n\n\n\nCopy the code below into an R script\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(bslib)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n  \n    \n    sidebar = sidebar(\n      \n      selectInput(inputId = \"y\",\n                  label = \"Y-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"audience_score\"),\n\n      selectInput(inputId = \"x\",\n                  label = \"X-axis:\",\n                  choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n                  selected = \"critics_score\")\n    ),\n    \n    card(\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n\n  output$densityplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x)) +\n      geom_density()\n  })\n\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(bslib)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n\n    sidebar = sidebar(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\"imdb_rating\", \"imdb_num_votes\", \"critics_score\", \"audience_score\", \"runtime\"),\n        selected = \"critics_score\"\n      )\n    ),\n\n    card(\n      plotOutput(outputId = \"scatterplot\"),\n      plotOutput(outputId = \"densityplot\", height = 200)\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x, y = input$y)) +\n      geom_point()\n  })\n\n  output$densityplot &lt;- renderPlot({\n    ggplot(data = movies, aes_string(x = input$x)) +\n      geom_density()\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactive Flow",
      "Reactive Flow"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactive-flow/ui-inputs.html#practice-add-numericinput",
    "href": "r/getstarted/build-an-app/reactive-flow/ui-inputs.html#practice-add-numericinput",
    "title": "UI Inputs",
    "section": "Practice: Add numericInput",
    "text": "Practice: Add numericInput\nThe app below allows users to randomly select a desired number of movies, and displays some information on the selected movies in a tabular output. This table is created using a new function, renderDataTable(), but for now we will keep our focus on the numericInput() widget. We will also learn to define variables outside of the app so that they can be used in multiple spots to make our code more efficient.\n\nYour turn\n\nMake sure entries in the sidebar() are separated by commas\nCalculate n_total (total number of movies in the data set) as nrow(movies) before defining the UI.\nUse n_total instead of the hard-coded \"651\" in the helper text.\nAdd min and max values to the numericInput() widget, where min is 1 and max is n_total.\nChange the default value of the sample size to 30.\nChange the step parameter of numericInput() such that values increase by 1 (instead of 10) when the up arrow is clicked in the numeric input widget in the app UI.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-2a Add numericInput in your Posit Cloud Workspace\n Go to RStudio Cloud Project\n\n\n\n\n\n\n\n\n\nWork locally in your RStudio IDE\n\n\n\n\n\n\nCopy the code below into an R script\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(DT)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n  \n    sidebar = sidebar(\n      \n      HTML(paste(\"Enter a value between 1 and\", \"651\"))\n\n      numericInput(inputId = \"n\",\n                   value = 3,\n                   step = 10)\n\n    ),\n    \n    card(\n      DT::dataTableOutput(outputId = \"moviestable\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  output$moviestable &lt;- DT::renderDataTable({\n    movies_sample &lt;- movies %&gt;%\n      sample_n(input$n) %&gt;%\n      select(title:studio)\n    DT::datatable(data = movies_sample,\n                  options = list(pageLength = 10),\n                  rownames = FALSE)\n  })\n\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(DT)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\nn_total &lt;- nrow(movies)\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n\n    sidebar = sidebar(\n      HTML(paste(\"Enter a value between 1 and\", n_total)),\n\n      numericInput(\n        inputId = \"n\",\n        label = \"Sample size:\",\n        value = 30,\n        min = 1, max = n_total,\n        step = 1\n      )\n    ),\n\n    card(\n      dataTableOutput(outputId = \"moviestable\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  output$moviestable &lt;- renderDataTable({\n    movies_sample &lt;- movies %&gt;%\n      sample_n(input$n) %&gt;%\n      select(title:studio)\n    DT::datatable(\n      data = movies_sample,\n      options = list(pageLength = 10),\n      rownames = FALSE\n    )\n  })\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactive Flow",
      "UI Inputs"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactive-flow/ui-inputs.html#practice-req",
    "href": "r/getstarted/build-an-app/reactive-flow/ui-inputs.html#practice-req",
    "title": "UI Inputs",
    "section": "Practice: req",
    "text": "Practice: req\nThe app below is the one you developed in the previous exercise.\n\nHighlight the code and run it.\nThen, delete the numeric value.\n\nYou will encounter an error: Error: size is not a numeric or integer vector.\nIn order to avoid such errors, which users of your app could very easily encounter, we need to hold back the output from being calculated if the input is missing.\nThe req() function is the simplest and best way to do this, it ensures that values are available (‚Äútruthy‚Äù) before proceeding with a calculation or action. If any of the given values is not truthy, the operation is stopped by raising a ‚Äúsilent‚Äù exception (not logged by Shiny, nor displayed in the Shiny app‚Äôs UI).\n\nYour turn\n\nAdd req(input$n) in the renderDataTable() function in the server before movies_sample is calculated.\nRun your app again and delete the input sample size to confirm that the error doesn‚Äôt appear, and neither does the output table.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-2b req in your Posit Cloud Workspace\n Go to RStudio Cloud Project\n\n\n\n\n\n\n\n\n\nWork locally in your RStudio IDE\n\n\n\n\n\n\nCopy the code below into an R script\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\noptions(\"shiny.sanitize.errors\" = FALSE) # Turn off error sanitization\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\nn_total &lt;- nrow(movies)\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n  \n    sidebar = sidebar(\n      \n      HTML(paste(\"Enter a value between 1 and\", n_total)),\n\n      numericInput(inputId = \"n\",\n                   label = \"Sample size:\",\n                   value = 30,\n                   min = 1, max = n_total,\n                   step = 1)\n\n    ),\n    \n    card(\n      DT::dataTableOutput(outputId = \"moviestable\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  output$moviestable &lt;- DT::renderDataTable({\n    movies_sample &lt;- movies %&gt;%\n      sample_n(input$n) %&gt;%\n      select(title:studio)\n    datatable(data = movies_sample,\n              options = list(pageLength = 10),\n              rownames = FALSE)\n  })\n\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\noptions(\"shiny.sanitize.errors\" = FALSE) # Turn off error sanitization\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\nn_total &lt;- nrow(movies)\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n\n    sidebar = sidebar(\n      HTML(paste(\"Enter a value between 1 and\", n_total)),\n\n      numericInput(\n        inputId = \"n\",\n        label = \"Sample size:\",\n        value = 30,\n        min = 1, max = n_total,\n        step = 1\n      )\n    ),\n\n    card(\n      dataTableOutput(outputId = \"moviestable\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  output$moviestable &lt;- renderDataTable({\n    req(input$n)\n    movies_sample &lt;- movies %&gt;%\n      sample_n(input$n) %&gt;%\n      select(title:studio)\n    datatable(\n      data = movies_sample,\n      options = list(pageLength = 10),\n      rownames = FALSE\n    )\n  })\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactive Flow",
      "UI Inputs"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactive-flow/ui-inputs.html#practice-select-to-selectize",
    "href": "r/getstarted/build-an-app/reactive-flow/ui-inputs.html#practice-select-to-selectize",
    "title": "UI Inputs",
    "section": "Practice: Select to selectize",
    "text": "Practice: Select to selectize\nThe app below can be used to display movies from selected studios. Currently you can only choose one studio, but we‚Äôll modify it to allow for multiple selections. Additionally, there are 211 unique studios represented in this dataset, we need a better way to select than to scroll through such a long list, and we address that with the selectize option, which will suggest names of studios as you type them.\n\nYour turn\n\nView the help function for the selectInput widget by typing ?selectInput in the console, and figure out how to enable the selectize and multiple selection options (or whether they are enabled by default).\nBased on your findings add the necessary arguments to the selectInput widget.\nAdd a call to the req() function in the server, just like you did in the previous exercise but this time requiring that input$studio be available.\nRun the app and (1) confirm that you can select multiple studios, (2) start typing ‚ÄúWarner Bros‚Äù to confirm selectize works, and (3) delete all selections to confirm req is preventing an error from being displayed.\nNow try with selectize = FALSE: Start typing ‚ÄúWarner Bros‚Äù and see how the behaviour changed.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-2c Select to selectize in your Posit Cloud Workspace\n Go to RStudio Cloud Project\n\n\n\n\n\n\n\n\n\nWork locally in your RStudio IDE\n\n\n\n\n\n\nCopy the code below into an R script\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(DT)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\nall_studios &lt;- sort(unique(movies$studio))\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    \n    sidebar = sidebar(\n      selectInput(inputId = \"studio\",\n                  label = \"Select studio:\",\n                  choices = all_studios,\n                  selected = \"20th Century Fox\")\n\n    ),\n    \n    card(\n      DT::dataTableOutput(outputId = \"moviestable\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  output$moviestable &lt;- renderDataTable({\n    movies_from_selected_studios &lt;- movies %&gt;%\n      filter(studio == input$studio) %&gt;%\n      select(title:studio)\n    DT::datatable(data = movies_from_selected_studios,\n              options = list(pageLength = 10),\n              rownames = FALSE)\n  })\n\n}\n\n# Create a Shiny app object ----------------------------------------------------\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(DT)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\nall_studios &lt;- sort(unique(movies$studio))\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n\n    # Input(s)\n    sidebar = sidebar(\n      selectInput(\n        inputId = \"studio\",\n        label = \"Select studio:\",\n        choices = all_studios,\n        selected = \"20th Century Fox\",\n        multiple = TRUE\n      )\n    ),\n\n    # Output(s)\n    card(\n      dataTableOutput(outputId = \"moviestable\")\n    )\n)\n\n# Server\nserver &lt;- function(input, output, session) {\n\n  # Create data table\n  output$moviestable &lt;- renderDataTable({\n    req(input$studio)\n    movies_from_selected_studios &lt;- movies %&gt;%\n      filter(studio %in% input$studio) %&gt;%\n      select(title:studio)\n    DT::datatable(\n      data = movies_from_selected_studios,\n      options = list(pageLength = 10),\n      rownames = FALSE\n    )\n  })\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactive Flow",
      "UI Inputs"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactive-flow/ui-inputs.html#practice-convert-dateinput-to-daterangeinput",
    "href": "r/getstarted/build-an-app/reactive-flow/ui-inputs.html#practice-convert-dateinput-to-daterangeinput",
    "title": "UI Inputs",
    "section": "Practice: Convert dateInput to dateRangeInput",
    "text": "Practice: Convert dateInput to dateRangeInput\nThe app below can be used to display movies from a particular date onwards. Instead we would like to select movies between two given dates. Hence we need to convert the dateInput widget to dateRangeInput. This input will yield a vector (input$date) of length two: the first element is the start date and the second is the end date.\n\nYour turn\n\nReview the help files for the two widgets by typing ?dateInput and ?dateRangeInput in the console.\nUpdate dateInput to dateRangeInput, instead of just a start date (value) specify start and end dates, Jan 1, 2013 and Jan 1, 2014, respectively.\nUpdate the explanatory text to reflect the new functionality of the app.\nChange the startview to \"year\" to make it a bit easier for the user to navigate the calendar.\nUpdate how subsetting is being done in the server function: we need movies released at or after the start date and at or before the end date.\nAdd the necessary req statement to the server to stop the app from trying to create a plot when no dates are specified.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the RStudio Cloud Project titled 2-2d Convert dateInput to dateRangeInput in your Posit Cloud Workspace\n Go to RStudio Cloud Project\n\n\n\n\n\n\n\n\n\nWork locally in your RStudio IDE\n\n\n\n\n\n\nCopy the code below into an R script\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\nmin_date &lt;- min(movies$thtr_rel_date)\nmax_date &lt;- max(movies$thtr_rel_date)\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    \n    sidebar = sidebar(\n      \n      HTML(paste0(\"Movies released since the following date will be plotted. \n                 Pick a date between \", min_date, \" and \", max_date, \".\")),\n\n      br(), br(),\n\n      dateInput(inputId = \"date\",\n                label = \"Select date:\",\n                value = \"2013-01-01\",\n                min = min_date, max = max_date)\n    ),\n    \n    card(\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  output$scatterplot &lt;- renderPlot({\n    movies_selected_date &lt;- movies %&gt;%\n      filter(thtr_rel_date &gt;= as.POSIXct(input$date))\n    ggplot(data = movies_selected_date, aes(x = critics_score, y = audience_score, color = mpaa_rating)) +\n      geom_point()\n  })\n\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\nmin_date &lt;- min(movies$thtr_rel_date)\nmax_date &lt;- max(movies$thtr_rel_date)\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n\n    sidebar = sidebar(\n      HTML(paste0(\"Movies released between the following dates will be plotted. \n                  Pick dates between \", min_date, \" and \", max_date, \".\")),\n\n      br(), br(),\n\n      dateRangeInput(\n        inputId = \"date\",\n        label = \"Select dates:\",\n        start = \"2013-01-01\", end = \"2014-01-01\",\n        min = min_date, max = max_date,\n        startview = \"year\"\n      )\n    ),\n\n    card(\n      plotOutput(outputId = \"scatterplot\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  output$scatterplot &lt;- renderPlot({\n    req(input$date)\n    movies_selected_date &lt;- movies %&gt;%\n      filter(thtr_rel_date &gt;= as.POSIXct(input$date[1]) & thtr_rel_date &lt;= as.POSIXct(input$date[2]))\n    ggplot(data = movies_selected_date, aes(x = critics_score, y = audience_score, color = mpaa_rating)) +\n      geom_point()\n  })\n}\n\n# Create a Shiny app object ----------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactive Flow",
      "UI Inputs"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactivity-essentials/reactive-elements.html",
    "href": "r/getstarted/build-an-app/reactivity-essentials/reactive-elements.html",
    "title": "Reactive Elements",
    "section": "",
    "text": "Diving deeper into reactive programming",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactivity Essentials",
      "Reactive Elements"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactivity-essentials/reactive-elements.html#practice",
    "href": "r/getstarted/build-an-app/reactivity-essentials/reactive-elements.html#practice",
    "title": "Reactive Elements",
    "section": "Practice",
    "text": "Practice\n\n\n\n\n\n\nReactive inputs, outputs and expressions\n\n\n\nWhich of the following is false? Select all that apply.\n\nReactive inputs can only be parents.\nReactive inputs can only be children.\nReactive expressions can be parents.\nReactive expressions can be children.\nReactive outputs can be parents.\nReactive outputs can be children.\n\n\n\n\n\n\n\nClick to View the Answer\n\n\n\n\n\nTrue responses are ‚ÄúReactive inputs can only be children‚Äù and ‚ÄúReactive outputs can be parents.‚Äù\n\n\n\n\n\n\n\nTo illustrate reactivity we‚Äôre going to start with this app once again\n\n\n\n\nAnd end up with an app that‚Ä¶\n\nlets the user subset the data by movie type\nupdates the plot for those selected movie types\nand display some text noting the number of movies in the selection\n\n\nThe subsetted movies data frame gets used in two places, plot and text outputs. Hence, we we‚Äôre going to make use of reactive expressions to build this app.\n\n\n1. ui: Add a UI element for the user to select which movie type(s) of moves they want to plot with selectInput().\n\n\n\n\n\n# Select which types of movies to plot\nselectInput(\n  inputId = \"selected_type\",\n  label = \"Select movie type:\",\n  choices = levels(movies$title_type),\n  selected = \"Feature Film\"\n)\n\nWe define an inputId() that we‚Äôll use to refer to the input element to later in the app\nWe come up with a user facing label\nWe specify the choices users can select from,\nas well as a default choice\n\n\n\n2. server: Filter for chosen title type and save the new data frame as a reactive expression.\nNext, we filter for selected title type and save the new data frame as a reactive expression using the reactive() function.\n\n\n\n\n\n# Create a subset of data filtering for chosen title types\nmovies_subset &lt;- reactive({\n  req(input$selected_type)\n  filter(movies, title_type %in% input$selected_type)\n})\nThis function creates a cached expression that knows it is out of date when its input changes. So you, the Shiny developer, do not need to worry about keeping track of when the input changes, Shiny automatically does that for you.\nTwo more things to note here:\n\nBefore we do any calculations that depends on input$selected_type, we check its availability with the req() function, and\nWe surround the expression with curly braces\n\n\n\n3. server: Use movies_subset (which is reactive) for plotting.\nThe next two steps could happen in either order. Let‚Äôs start with the plot first.\n\n\n\n\n\n# Create scatterplot\noutput$scatterplot &lt;- renderPlot({\n  ggplot(data = movies_subset(),aes_string(x = input$x, y = input$y)) +\n    geom_point()\n})\nYou should be familiar with creating plots using the renderPlot() function by now. But there is something new here. The data frame we‚Äôre using is no longer movies, but the new reactive expression we created. And because it‚Äôs reactive we refer to it with parentheses after its name. This is, once again, a cached expression, meaning that it will only rerun when its inputs change.\n\n\n4. ui & server: Use movies_subset (which is reactive) for printing number of observations.\n\n\n\n\n\nAnd lastly we create the text stating the number of observations in the selection. The obvious choice for creating this output would be renderText(). But I feel like getting a little fancier with this one. Suppose we know a bit of HTML ‚Äì which is true, I really only know a bit of HTML ‚Äì and I want to use some text decoration, like bolding and line breaks in my text output. So we need a rendering function that generates HTML, which is renderUI().\n# ui - Lay out where text should appear on app\ncard( \n  ...\n  # Print number of obs plotted\n  uiOutput(outputId = \"n\"),\n  ...\n)\n# server - Print number of movies plotted\noutput$n &lt;- renderUI({\n  HTML(paste0(\n    \"The plot displays the relationship between the &lt;br&gt;\n              audience and critics' scores of &lt;br&gt;\",\n    nrow(movies_subset()),\n    \" &lt;b&gt;\", input$selected_type, \"&lt;/b&gt; movies.\"\n  ))\n})\nWe use the paste() function to string along the text of the sentence we want displayed on the app. This sentence depends on the value of the number of rows of the movies_subset reactive expression we created earlier, as well as input$selected type.\nUsing simple HTML we add some decoration to the text, and finally wrap the whole thing up in a function that marks the given text as HTML.\nThen on the ui side, we use the counterpart uiOutput() function to lay out the text on the app.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactivity Essentials",
      "Reactive Elements"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactivity-essentials/reactive-elements.html#practice---add-reactive-data-frame",
    "href": "r/getstarted/build-an-app/reactivity-essentials/reactive-elements.html#practice---add-reactive-data-frame",
    "title": "Reactive Elements",
    "section": "Practice - Add reactive data frame",
    "text": "Practice - Add reactive data frame\nWe ended the previous chapter with an app that allows you to download a data file with selected variables from the movies dataset. We will now extend this app by adding a table output of the selected data as well. Given that the same dataset will be used in two outputs, it makes sense to make our code more efficient by using a reactive data frame.\nExtend app by adding reactive data frame, which is a subset, that is used in the plot.\n\nYour turn\n\nDefine movies_selected: a reactive data frame consisting of selected variables (input$selected_var).\nUse the newly constructed movies_selected reactive data frame to avoid reconstructing the subsetted data frame multiple times throughout the app.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the Posit Cloud Project titled 3-1 Add reactive data frame in your Posit Cloud Workspace\n Go to Posit Cloud Project\n\n\n\n\n\n\n\n\n\nWork locally in your RStudio IDE\n\n\n\n\n\n\nDownload the data if you haven‚Äôt already\n\n```{r}\n# Get the data\n\nfile &lt;- \"https://github.com/rstudio-education/shiny-course/raw/main/movies.RData\"\ndestfile &lt;- \"movies.RData\"\n\ndownload.file(file, destfile)\n```\n\nCopy the code below into an R script\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(dplyr)\nlibrary(readr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n\n    sidebar = sidebar(\n      radioButtons(\n        inputId = \"filetype\",\n        label = \"Select filetype:\",\n        choices = c(\"csv\", \"tsv\"),\n        selected = \"csv\"\n      ),\n\n      checkboxGroupInput(\n        inputId = \"selected_var\",\n        label = \"Select variables:\",\n        choices = names(movies),\n        selected = c(\"title\")\n      )\n    ),\n\n    card(\n      dataTableOutput(outputId = \"moviestable\"),\n      downloadButton(\"download_data\", \"Download data\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  # Create reactive data frame\n  movies_selected &lt;- ___\n\n  # Create data table\n  output$moviestable &lt;- DT::renderDataTable({\n    req(input$selected_var)\n    datatable(\n      data = movies %&gt;% select(input$selected_var),\n      options = list(pageLength = 10),\n      rownames = FALSE\n    )\n  })\n\n  # Download file\n  output$download_data &lt;- downloadHandler(\n    filename = function() {\n      paste0(\"movies.\", input$filetype)\n    },\n    content = function(file) {\n      if (input$filetype == \"csv\") {\n        write_csv(movies %&gt;% select(input$selected_var), file)\n      }\n      if (input$filetype == \"tsv\") {\n        write_tsv(movies %&gt;% select(input$selected_var), file)\n      }\n    }\n  )\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(dplyr)\nlibrary(readr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n\n    sidebar = sidebar(\n      radioButtons(\n        inputId = \"filetype\",\n        label = \"Select filetype:\",\n        choices = c(\"csv\", \"tsv\"),\n        selected = \"csv\"\n      ),\n\n      checkboxGroupInput(\n        inputId = \"selected_var\",\n        label = \"Select variables:\",\n        choices = names(movies),\n        selected = c(\"title\")\n      )\n    ),\n\n    card(\n      dataTableOutput(outputId = \"moviestable\"),\n      downloadButton(\"download_data\", \"Download data\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  # Create reactive data frame\n  movies_selected &lt;- reactive({\n    movies %&gt;% select(input$selected_var)\n  })\n\n  # Create data table\n  output$moviestable &lt;- DT::renderDataTable({\n    req(input$selected_var)\n    datatable(\n      data = movies_selected(),\n      options = list(pageLength = 10),\n      rownames = FALSE\n    )\n  })\n\n  # Download file\n  output$download_data &lt;- downloadHandler(\n    filename = function() {\n      paste0(\"movies.\", input$filetype)\n    },\n    content = function(file) {\n      if (input$filetype == \"csv\") {\n        write_csv(movies_selected(), file)\n      }\n      if (input$filetype == \"tsv\") {\n        write_tsv(movies_selected(), file)\n      }\n    }\n  )\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\nPractice: Identify reactive objects\n\n\n\n\n\n\nReactive expressions\n\n\n\nThe movies_selected() reactive expression from the previous exercise is a‚Ä¶\n\nReactive input\nReactive expression\nReactive output\nReactive paradigm\n\n\n\n\n\n\n\nClick to View the Answer\n\n\n\n\n\nThe correct answer is ‚ÄúReactive expression‚Äù.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactivity Essentials",
      "Reactive Elements"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactivity-essentials/recap.html",
    "href": "r/getstarted/build-an-app/reactivity-essentials/recap.html",
    "title": "Reactive Recap",
    "section": "",
    "text": "Let‚Äôs recap what we have learned about reactivity and discuss best practices.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactivity Essentials",
      "Reactive Recap"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactivity-essentials/recap.html#practice---whats-wrong",
    "href": "r/getstarted/build-an-app/reactivity-essentials/recap.html#practice---whats-wrong",
    "title": "Reactive Recap",
    "section": "Practice - What‚Äôs wrong?",
    "text": "Practice - What‚Äôs wrong?\n\nYour turn\n\nWhat‚Äôs wrong with this? Fix it.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the Posit Cloud Project titled 3-5 Whats wrong in your Posit Cloud Workspace\n Go to Posit Cloud Project\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n  title = \"Multiply by 3\",\n  sidebar = sliderInput(\"x\", \"Select x\", min = 1, max = 50, value = 30),\n  textOutput(\"x_updated\")\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  mult_3 &lt;- function(x) {\n    x * 3\n  }\n  output$x_updated &lt;- mult_3(input$x)\n\n}\n\n# Create the Shiny app ---------------------------------------------------------\nshinyApp(ui, server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n  title = \"Multiply by 3\",\n  sidebar = sliderInput(\"x\", \"Select x\", min = 1, max = 50, value = 30),\n  textOutput(\"x_updated\")\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n  mult_3 &lt;- function(x) {\n    x * 3\n  }\n  current_x &lt;- reactive({\n    mult_3(input$x)\n  })\n  output$x_updated &lt;- renderText({\n    current_x()\n  })\n}\n\n# Create the Shiny app ---------------------------------------------------------\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactivity Essentials",
      "Reactive Recap"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactivity-essentials/using-reactives.html",
    "href": "r/getstarted/build-an-app/reactivity-essentials/using-reactives.html",
    "title": "Using Reactives",
    "section": "",
    "text": "In this section we discuss why we use reactives.",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactivity Essentials",
      "Using Reactives"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactivity-essentials/using-reactives.html#practice---find-missing-reactives",
    "href": "r/getstarted/build-an-app/reactivity-essentials/using-reactives.html#practice---find-missing-reactives",
    "title": "Using Reactives",
    "section": "Practice - Find missing reactives",
    "text": "Practice - Find missing reactives\nIn the following app code there are a number of spots where reactives are not used properly.\n\nYour turn\n\nDebug the app, making sure reactives are being used correctly.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the Posit Cloud Project titled 3-2a Find missing reactives in your Posit Cloud Workspace\n Go to Posit Cloud Project\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tools)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n  title = \"Movie browser\",\n  sidebar = sidebar(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text for plot title\"\n      ),\n\n      checkboxGroupInput(\n        inputId = \"selected_type\",\n        label = \"Select movie type(s):\",\n        choices = c(\"Documentary\", \"Feature Film\", \"TV Movie\"),\n        selected = \"Feature Film\"\n      )\n    ),\n\n    card(\n      plotOutput(outputId = \"scatterplot\"),\n      textOutput(outputId = \"description\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  # Create a subset of data filtering for selected title types\n  movies_subset &lt;- reactive({\n    req(input$selected_type)\n    filter(movies, title_type %in% input$selected_type)\n  })\n\n  # Convert plot_title toTitleCase\n  output$pretty_plot_title &lt;- toTitleCase(input$plot_title)\n\n  # Create scatterplot object the plotOutput function is expecting\n  output$scatterplot &lt;- renderPlot({\n    ggplot(\n      data = movies_subset,\n      aes_string(x = input$x, y = input$y, color = input$z)\n    ) +\n      geom_point() +\n      labs(title = pretty_plot_title)\n  })\n\n  # Create descriptive text\n  output$description &lt;- renderText({\n    paste0(\"The plot above titled '\", pretty_plot_title, \"' visualizes the relationship between \", input$x, \" and \", input$y, \", conditional on \", input$z, \".\")\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(tools)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n  title = \"Movie browser\",\n  sidebar = sidebar(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      textInput(\n        inputId = \"plot_title\",\n        label = \"Plot title\",\n        placeholder = \"Enter text for plot title\"\n      ),\n\n      checkboxGroupInput(\n        inputId = \"selected_type\",\n        label = \"Select movie type(s):\",\n        choices = c(\"Documentary\", \"Feature Film\", \"TV Movie\"),\n        selected = \"Feature Film\"\n      )\n    ),\n\n    card(\n      plotOutput(outputId = \"scatterplot\"),\n      textOutput(outputId = \"description\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  # Create a subset of data filtering for selected title types\n  movies_subset &lt;- reactive({\n    req(input$selected_type)\n    filter(movies, title_type %in% input$selected_type)\n  })\n\n  # Convert plot_title toTitleCase\n  pretty_plot_title &lt;- reactive({\n    toTitleCase(input$plot_title)\n  })\n\n  # Create scatterplot object the plotOutput function is expecting\n  output$scatterplot &lt;- renderPlot({\n    ggplot(\n      data = movies_subset(),\n      aes_string(x = input$x, y = input$y, color = input$z)\n    ) +\n      geom_point() +\n      labs(title = pretty_plot_title())\n  })\n\n  # Create descriptive text\n  output$description &lt;- renderText({\n    paste0(\"The plot above titled '\", pretty_plot_title(), \"' visualizes the relationship between \", input$x, \" and \", input$y, \", conditional on \", input$z, \".\")\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactivity Essentials",
      "Using Reactives"
    ]
  },
  {
    "objectID": "r/getstarted/build-an-app/reactivity-essentials/using-reactives.html#practice---find-inconsistencies-in-what-the-app-is-reporting",
    "href": "r/getstarted/build-an-app/reactivity-essentials/using-reactives.html#practice---find-inconsistencies-in-what-the-app-is-reporting",
    "title": "Using Reactives",
    "section": "Practice - Find inconsistencies in what the app is reporting",
    "text": "Practice - Find inconsistencies in what the app is reporting\nIn this exercise we go on a hunt for mismatched used of reactives.\n\nYour turn\n\nRun the sample code and view the app. Do the number of movies plotted match the number cited in the text below the app?\nIf not, fix the app code.\n\n\n\n\n\n\n\nUse Posit Cloud\n\n\n\n\n\nComplete the exercise by navigating to the Posit Cloud Project titled 3-2b Find inconsistencies in what the app is reporting in your Posit Cloud Workspace\n Go to Posit Cloud Project\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    sidebar = sidebar(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      checkboxGroupInput(\n        inputId = \"selected_type\",\n        label = \"Select movie type(s):\",\n        choices = c(\"Documentary\", \"Feature Film\", \"TV Movie\"),\n        selected = \"Feature Film\"\n      ),\n\n      numericInput(\n        inputId = \"n_samp\",\n        label = \"Sample size:\",\n        min = 1, max = nrow(movies),\n        value = 3\n      )\n    ),\n\n    card(\n      plotOutput(outputId = \"scatterplot\"),\n      uiOutput(outputId = \"n\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  # Create a subset of data filtering for selected title types\n  movies_subset &lt;- reactive({\n    req(input$selected_type)\n    filter(movies, title_type %in% input$selected_type)\n  })\n\n  # Create new df that is n_samp obs from selected type movies\n  movies_sample &lt;- reactive({\n    req(input$n_samp)\n    sample_n(movies_subset(), input$n_samp)\n  })\n\n  # Create scatterplot object the plotOutput function is expecting\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies_sample(), aes_string(x = input$x, y = input$y, color = input$z)) +\n      geom_point()\n  })\n\n  # Print number of movies plotted\n  output$n &lt;- renderUI({\n    types &lt;- factor(movies_subset()$title_type, levels = input$selected_type)\n    counts &lt;- table(types)\n    HTML(paste(\"There are\", counts, input$selected_type, \"movies plotted in the plot above. &lt;br&gt;\"))\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\nShow solution - see the code for the solution to the exercise above\n\n\n\n\n\n# Load packages ----------------------------------------------------------------\n\nlibrary(shiny)\nlibrary(bslib)\nlibrary(ggplot2)\nlibrary(dplyr)\n\n# Load data --------------------------------------------------------------------\n\nload(\"movies.RData\")\n\n# Define UI --------------------------------------------------------------------\n\nui &lt;- page_sidebar(\n    sidebar = sidebar(\n      selectInput(\n        inputId = \"y\",\n        label = \"Y-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"audience_score\"\n      ),\n\n      selectInput(\n        inputId = \"x\",\n        label = \"X-axis:\",\n        choices = c(\n          \"IMDB rating\" = \"imdb_rating\",\n          \"IMDB number of votes\" = \"imdb_num_votes\",\n          \"Critics Score\" = \"critics_score\",\n          \"Audience Score\" = \"audience_score\",\n          \"Runtime\" = \"runtime\"\n        ),\n        selected = \"critics_score\"\n      ),\n\n      selectInput(\n        inputId = \"z\",\n        label = \"Color by:\",\n        choices = c(\n          \"Title Type\" = \"title_type\",\n          \"Genre\" = \"genre\",\n          \"MPAA Rating\" = \"mpaa_rating\",\n          \"Critics Rating\" = \"critics_rating\",\n          \"Audience Rating\" = \"audience_rating\"\n        ),\n        selected = \"mpaa_rating\"\n      ),\n\n      checkboxGroupInput(\n        inputId = \"selected_type\",\n        label = \"Select movie type(s):\",\n        choices = c(\"Documentary\", \"Feature Film\", \"TV Movie\"),\n        selected = \"Feature Film\"\n      ),\n\n      numericInput(\n        inputId = \"n_samp\",\n        label = \"Sample size:\",\n        min = 1, max = nrow(movies),\n        value = 3\n      )\n    ),\n\n    card(\n      plotOutput(outputId = \"scatterplot\"),\n      uiOutput(outputId = \"n\")\n    )\n)\n\n# Define server ----------------------------------------------------------------\n\nserver &lt;- function(input, output, session) {\n\n  # Create a subset of data filtering for selected title types\n  movies_subset &lt;- reactive({\n    req(input$selected_type)\n    filter(movies, title_type %in% input$selected_type)\n  })\n\n  # Create new df that is n_samp obs from selected type movies\n  movies_sample &lt;- reactive({\n    req(input$n_samp)\n    sample_n(movies_subset(), input$n_samp)\n  })\n\n  # Create scatterplot object the plotOutput function is expecting\n  output$scatterplot &lt;- renderPlot({\n    ggplot(data = movies_sample(), aes_string(x = input$x, y = input$y, color = input$z)) +\n      geom_point()\n  })\n\n  # Print number of movies plotted\n  output$n &lt;- renderUI({\n    types &lt;- movies_sample()$title_type %&gt;%\n      factor(levels = input$selected_type)\n    counts &lt;- table(types)\n    HTML(paste(\"There are\", counts, input$selected_type, \"movies plotted in the plot above. &lt;br&gt;\"))\n  })\n}\n\n# Create the Shiny app object --------------------------------------------------\n\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/2-square-fill.svg){.sidebar-icon} Build an App",
      "Reactivity Essentials",
      "Using Reactives"
    ]
  },
  {
    "objectID": "r/getstarted/next-steps/index.html",
    "href": "r/getstarted/next-steps/index.html",
    "title": "Next Steps",
    "section": "",
    "text": "Looking for next steps? We‚Äôve got you covered. Here are resources to designed to help you learn whatever is next for you.\nQuickly get your Shiny app on the web using shinyapps.io.",
    "crumbs": [
      "Home",
      "![](/images/3-square-fill.svg){.sidebar-icon} Next Steps"
    ]
  },
  {
    "objectID": "r/getstarted/next-steps/index.html#mastering-shiny",
    "href": "r/getstarted/next-steps/index.html#mastering-shiny",
    "title": "Next Steps",
    "section": "Mastering Shiny",
    "text": "Mastering Shiny\n\nBy Hadley Wickham\n\n\n\nA free, online book designed to take you from basic Shiny to creating your own customized apps.\nRead Now",
    "crumbs": [
      "Home",
      "![](/images/3-square-fill.svg){.sidebar-icon} Next Steps"
    ]
  },
  {
    "objectID": "r/getstarted/next-steps/index.html#gallery",
    "href": "r/getstarted/next-steps/index.html#gallery",
    "title": "Next Steps",
    "section": "Gallery",
    "text": "Gallery\nCheck out the Shiny Gallery! Here you can find a myriad of Shiny apps to be inspired by and learn from.\nFeature Demos - Feature demos are a series of apps created by the Shiny developers, designed to highlight specific features of the shiny package. Each app is presented along with its source code to help you implement these features in your apps.\nUser Showcase - The Shiny User Showcase is comprised of contributions from the Shiny app developer community. The apps are categorized into application areas and presented with a brief description, tags, and for many, the source code.",
    "crumbs": [
      "Home",
      "![](/images/3-square-fill.svg){.sidebar-icon} Next Steps"
    ]
  },
  {
    "objectID": "r/getstarted/next-steps/index.html#api-reference",
    "href": "r/getstarted/next-steps/index.html#api-reference",
    "title": "Next Steps",
    "section": "API Reference",
    "text": "API Reference\nReference docs - Here you can find upgrade notes and function references for the latest, and previous, version(s) of the Shiny package.",
    "crumbs": [
      "Home",
      "![](/images/3-square-fill.svg){.sidebar-icon} Next Steps"
    ]
  },
  {
    "objectID": "r/getstarted/next-steps/index.html#articles",
    "href": "r/getstarted/next-steps/index.html#articles",
    "title": "Next Steps",
    "section": "Articles",
    "text": "Articles\nArticles - See written tutorials ranging from beginner to intermediate, covering every step of the Shiny app development pipeline.",
    "crumbs": [
      "Home",
      "![](/images/3-square-fill.svg){.sidebar-icon} Next Steps"
    ]
  },
  {
    "objectID": "r/getstarted/next-steps/index.html#shiny-videos",
    "href": "r/getstarted/next-steps/index.html#shiny-videos",
    "title": "Next Steps",
    "section": "Shiny Videos",
    "text": "Shiny Videos\nShiny video series - Learn about recent releases and features, and hear from Shiny team folks as they create and explain projects ranging from a deep dive into their favorite package, to building interactive games with Shiny, and everything in between!",
    "crumbs": [
      "Home",
      "![](/images/3-square-fill.svg){.sidebar-icon} Next Steps"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson2/index.html",
    "href": "r/getstarted/shiny-basics/lesson2/index.html",
    "title": "Build a user interface",
    "section": "",
    "text": "Now that you understand the structure of a Shiny app, it‚Äôs time to build your first app from scratch.\nThis lesson will show you how to build a user interface for your app. You will learn how to lay out the user interface and then add text, images, and other HTML elements to your Shiny app.\nWe‚Äôll use the App-1 app you made in Lesson 1. To get started, open its app.R file. Edit the script to match the one below:\nThis code is the bare minimum needed to create a Shiny app. The result is an empty app with a blank user interface, an appropriate starting point for this lesson.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Build a user interface"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson2/index.html#layout",
    "href": "r/getstarted/shiny-basics/lesson2/index.html#layout",
    "title": "Build a user interface",
    "section": "Layout",
    "text": "Layout\nUse the page_sidebar function to create a page with a sidebar. You lay out the user interface of your app by placing elements in the page_sidebar function. The ui function below creates a user interface with a title, sidebar panel, and main panel.\nui &lt;- page_sidebar(\n  title = \"title panel\",\n  sidebar = sidebar(\"sidebar\"),\n  \"main contents\"\n)\n\n\n\nYou can add additional elements to the main panel of the page by supplying them to page_sidebar.\nBy default, the sidebar panel will appear on the left side of your app. You can move it to the right side by giving sidebar the optional argument position = \"right\".\nui &lt;- page_sidebar(\n  title = \"title panel\",\n  sidebar = sidebar(\"Sidebar\", position = \"right\"),\n  \"Main contents\"\n)\n\n\n\npage_sidebar creates a sidebar layout that fills the page, and is a quick way to create a page with a sidebar. If you‚Äôd like to create a floating sidebar layout that can appear anywhere on the page, use page_fluid and layout_sidebar.\nui &lt;- page_fluid(\n  layout_sidebar(\n    sidebar = sidebar(\"Sidebar\"),\n    \"Main contents\"\n  )   \n)\nYou can also create more advanced layouts. For example, page_navbar creates a multi-page user interface that includes a navigation bar. Or you can use layout_columns or layout_rows to build your layout up from a grid system. If you‚Äôd like to learn more about these advanced options, read the Shiny Application Layout Guide. We will stick with layout_sidebar in this tutorial.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Build a user interface"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson2/index.html#cards",
    "href": "r/getstarted/shiny-basics/lesson2/index.html#cards",
    "title": "Build a user interface",
    "section": "Cards",
    "text": "Cards\nCards are a common organizing unit for modern user interfaces. You can use the function card() to create a card in your Shiny app.\nui &lt;- page_sidebar(\n  title = \"title panel\",\n  sidebar = sidebar(\"Sidebar\"),\n  card()\n)\ncard() creates a regular container with borders and padding.\n Use cards to grouped related information. Add content to a card by supplying arguments to card().\nui &lt;- page_sidebar(\n  title = \"title panel\",\n  sidebar = sidebar(\"Sidebar\"),\n  card(\n    \"Card content\"\n  )\n)\nYou can also use functions like card_header(), card_footer(), and card_image() to add card elements to a card. For example, card_header() adds a header.\nui &lt;- page_sidebar(\n  title = \"title panel\",\n  sidebar = sidebar(\"Sidebar\"),\n  card(\n    card_header(\"Card header\"),\n    \"Card body\"\n  )\n)\n\nSee the bslib Cards article to learn more about cards.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Build a user interface"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson2/index.html#value-boxes",
    "href": "r/getstarted/shiny-basics/lesson2/index.html#value-boxes",
    "title": "Build a user interface",
    "section": "Value boxes",
    "text": "Value boxes\nValue boxes are another useful UI component. Use value boxes to highlight important values in your app.\nCreate a value box with the function value_box(). Define the value box‚Äôs title and value with the title and value arguments.\nui &lt;- page_sidebar(\n  ...\n  value_box(\n    title = \"Value box\",\n    value = 100\n  ),\n  ...\n)\nOptionally, set the value box‚Äôs theme and use the showcase argument to add UI elements like icons to the value box. Note: to use Bootstrap icons, use the function bsicons::bs_icon().\nui &lt;- page_sidebar(\n  title = \"title panel\",\n  sidebar = sidebar(\"Sidebar\"),\n  value_box(\n    title = \"Value box\",\n    value = 100,\n    showcase = bsicons::bs_icon(\"bar-chart\"),\n    theme = \"teal\"\n  ),\n  card(\"Card\"),\n  card(\"Another card\")\n)\n To learn more about value boxes, including how to add multiple value boxes to your app, see the bslib Value Boxes article.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Build a user interface"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson2/index.html#your-turn",
    "href": "r/getstarted/shiny-basics/lesson2/index.html#your-turn",
    "title": "Build a user interface",
    "section": "Your turn",
    "text": "Your turn\nYou can use Shiny‚Äôs layout, card, and value box functions to create attractive and useful user interfaces. See how well you understand these functions by recreating the Shiny app pictured below. Use the examples in this tutorial to work on it and then test it out.\nOur app.R script is found under the Model Answer button, but don‚Äôt just copy and paste it. Make sure you understand how the code works before moving on.\n\n\nModel Answer\n\n\n\n\n\n\nView Answer\n\n\n\n\n\nlibrary(shiny)\nlibrary(bslib)\n\n# Define UI\nui &lt;- page_sidebar(\n  title = \"My Shiny App\",\n  sidebar = sidebar(\n    \"Shiny is available on CRAN, so you can install it in the usual way from your R console:\",\n    code('install.packages(\"shiny\")'),\n  ),\n  card(\n    card_header(\"Introducing Shiny\"),\n    \"Shiny is a package from Posit that makes it incredibly easy to build interactive web applications with R.\n    For an introduction and live examples, visit the Shiny homepage (https://shyr-test-center.netlify.app).\",\n    card_image(\"www/shiny.svg\", height = \"300px\"),\n    card_footer(\"Shiny is a product of Posit.\")\n  )\n)\n\n# Define server logic ----\nserver &lt;- function(input, output) {\n\n}\n\n# Run the app ----\nshinyApp(ui = ui, server = server)",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Build a user interface"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson2/index.html#recap",
    "href": "r/getstarted/shiny-basics/lesson2/index.html#recap",
    "title": "Build a user interface",
    "section": "Recap",
    "text": "Recap\nWith your new skills, you can:\n\ncreate a user interface with a page_* function\ncreate a card and add content to it\ncreate a value box\n\nNow that you can place simple content in your user interface, let‚Äôs look at how you would place more complicated content, like widgets. Widgets are interactive web elements that your user can use to control the app. They are also the subject of Lesson 3.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Build a user interface"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson4/index.html",
    "href": "r/getstarted/shiny-basics/lesson4/index.html",
    "title": "Display reactive output",
    "section": "",
    "text": "Time to give your Shiny app a ‚Äúlive‚Äù quality! This lesson will teach you how to build reactive output to displays in your Shiny app. Reactive output automatically responds when your user toggles a widget.\nBy the end of this lesson, you‚Äôll know how to make a simple Shiny app with two reactive lines of text. Each line will display the values of a widget based on your user‚Äôs input.\nThis new Shiny app will need its own, new directory. Create a folder in your working directory named census-app. This is where we‚Äôll save the app.R file that you make in this lesson.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Display reactive output"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson4/index.html#two-steps",
    "href": "r/getstarted/shiny-basics/lesson4/index.html#two-steps",
    "title": "Display reactive output",
    "section": "Two steps",
    "text": "Two steps\nYou can create reactive output with a two step process.\n\nAdd an R object to your user interface.\nTell Shiny how to build the object in the server function. The object will be reactive if the code that builds it calls a widget value.\n\n\nStep 1: Add an R object to the UI\nShiny provides a family of functions that turn R objects into output for your user interface. Each function creates a specific type of output.\n\n\n\nOutput function\nCreates\n\n\n\n\ndataTableOutput\nDataTable\n\n\nhtmlOutput\nraw HTML\n\n\nimageOutput\nimage\n\n\nplotOutput\nplot\n\n\ntableOutput\ntable\n\n\ntextOutput\ntext\n\n\nuiOutput\nraw HTML\n\n\nverbatimTextOutput\ntext\n\n\n\nYou can add output to the user interface in the same way that you added HTML elements and widgets.\nFor example, the ui object below uses textOutput to add a reactive line of text to the main panel of the Shiny app pictured above.\nui &lt;- page_sidebar(\n  title = \"censusVis\",\n  sidebar = sidebar(\n    helpText(\n      \"Create demographic maps with information from the 2010 US Census.\"\n    ),\n    selectInput(\n      \"var\",\n      label = \"Choose a variable to display\",\n      choices = \n        c(\"Percent White\",\n          \"Percent Black\",\n          \"Percent Hispanic\",\n          \"Percent Asian\"),\n      selected = \"Percent White\"\n    ),\n    sliderInput(\n      \"range\",\n      label = \"Range of interest:\",\n      min = 0, \n      max = 100, \n      value = c(0, 100)\n    )\n  ),\n  textOutput(\"selected_var\")\n)\nNotice that textOutput takes an argument, the character string \"selected_var\". Each of the *Output functions require a single argument: a character string that Shiny will use as the name of your reactive element. Your users will not see this name, but you will use it later.\n\n\nStep 2: Provide R code to build the object.\nPlacing a function in ui tells Shiny where to display your object. Next, you need to tell Shiny how to build the object.\nWe do this by providing the R code that builds the object in the server function.\nThe server function plays a special role in the Shiny process; it builds a list-like object named output that contains all of the code needed to update the R objects in your app. Each R object needs to have its own entry in the list.\nYou can create an entry by defining a new element for output within the server function, like below. The element name should match the name of the reactive element that you created in the ui.\nIn the server function below, output$selected_var matches textOutput(\"selected_var\") in your ui.\nserver &lt;- function(input, output) {\n\n  output$selected_var &lt;- renderText({\n    \"You have selected this\"\n  })\n\n}\nYou do not need to explicitly state in the server function to return output in its last line of code. R will automatically update output through reference class semantics.\nEach entry to output should contain the output of one of Shiny‚Äôs render* functions. These functions capture an R expression and do some light pre-processing on the expression. Use the render* function that corrresponds to the type of reactive object you are making.\n\n\n\nrender function\ncreates\n\n\n\n\nrenderDataTable\nDataTable\n\n\nrenderImage\nimages (saved as a link to a source file)\n\n\nrenderPlot\nplots\n\n\nrenderPrint\nany printed output\n\n\nrenderTable\ndata frame, matrix, other table like structures\n\n\nrenderText\ncharacter strings\n\n\nrenderUI\na Shiny tag object or HTML\n\n\n\nEach render* function takes a single argument: an R expression surrounded by braces, {}. The expression can be one simple line of text, or it can involve many lines of code, as if it were a complicated function call.\nThink of this R expression as a set of instructions that you give Shiny to store for later. Shiny will run the instructions when you first launch your app, and then Shiny will re-run the instructions every time it needs to update your object.\nFor this to work, your expression should return the object you have in mind (a piece of text, a plot, a data frame, etc.). You will get an error if the expression does not return an object, or if it returns the wrong type of object.\n\n\nUse widget values\nIf you run the app with the server function above, it will display ‚ÄúYou have selected this‚Äù in the main panel. However, the text will not be reactive. It will not change even if you manipulate the widgets of your app.\nYou can make the text reactive by asking Shiny to call a widget value when it builds the text. Let‚Äôs look at how to do this.\nTake a look at the first line of code in the server function. Do you notice that the server function mentions two arguments, input and output? You already saw that output is a list-like object that stores instructions for building the R objects in your app.\ninput is a second list-like object. It stores the current values of all of the widgets in your app. These values will be saved under the names that you gave the widgets in your ui.\nSo for example, our app has two widgets, one named \"var\" and one named \"range\" (you gave the widgets these names in Lesson 3). The values of \"var\" and \"range\" will be saved in input as input$var and input$range. Since the slider widget has two values (a min and a max), input$range will contain a vector of length two.\nShiny will automatically make an object reactive if the object uses an input value. For example, the server function below creates a reactive line of text by calling the value of the select box widget to build the text.\nserver &lt;- function(input, output) {\n\n  output$selected_var &lt;- renderText({\n    paste(\"You have selected\", input$var)\n  })\n\n}\nShiny tracks which outputs depend on which widgets. When a user changes a widget, Shiny will rebuild all of the outputs that depend on the widget, using the new value of the widget as it goes. As a result, the rebuilt objects will be completely up-to-date.\nThis is how you create reactivity with Shiny, by connecting the values of input to the objects in output. Shiny takes care of all of the other details.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Display reactive output"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson4/index.html#launch-your-app-and-see-the-reactive-output",
    "href": "r/getstarted/shiny-basics/lesson4/index.html#launch-your-app-and-see-the-reactive-output",
    "title": "Display reactive output",
    "section": "Launch your app and see the reactive output",
    "text": "Launch your app and see the reactive output\nWhen you are ready, update your server and ui functions to match those above. Then launch your Shiny app by running runApp(\"census-app\", display.mode = \"showcase\") at the command line. Your app should look like the app below, and your statement should update instantly as you change the select box widget.\nWatch the server portion of the script. When Shiny rebuilds an output, it highlights the code it is running. This temporary highlighting can help you see how Shiny generates reactive output.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Display reactive output"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson4/index.html#your-turn",
    "href": "r/getstarted/shiny-basics/lesson4/index.html#your-turn",
    "title": "Display reactive output",
    "section": "Your turn",
    "text": "Your turn\nAdd a second line of reactive text to the main panel of your Shiny app. This line should display ‚ÄúYou have chosen a range that goes from something to something‚Äù, and each something should show the current minimum (min) or maximum (max) value of the slider widget.\nDon‚Äôt forget to update both your ui object and your server function.\n\nModel answer\n\n\n\n\n\n\nView Answer\n\n\n\n\n\nAdd the second line of text in the same way that you added the first one. Use textOutput in ui to place the second line of text in the main panel. Use renderText in server to tell Shiny how to build the text. You‚Äôll need to use the same name to refer to the text in both scripts (e.g., \"min_max\").\nYour text should use both the slider‚Äôs min value (saved as input$range[1]) and its max value (saved as input$range[2]).\nRemember that your text will be reactive as long as you connect input values to output objects. Shiny creates reactivity automatically when it recognizes these connections.\nlibrary(shiny)\n\nui &lt;- page_sidebar(\n  title = \"censusVis\",\n  sidebar = sidebar(\n    helpText(\n      \"Create demographic maps with information from the 2010 US Census.\"\n    ),\n    selectInput(\n      \"var\",\n      label = \"Choose a variable to display\",\n      choices = c(\"Percent White\",\n                  \"Percent Black\",\n                  \"Percent Hispanic\",\n                  \"Percent Asian\"),\n      selected = \"Percent White\"\n    ),\n    sliderInput(\n      \"range\",\n      label = \"Range of interest:\",\n      min = 0, max = 100, value = c(0, 100)\n    )\n  ),\n  textOutput(\"selected_var\"),\n  textOutput(\"min_max\") \n)\n\nserver &lt;- function(input, output) {\n  \n  output$selected_var &lt;- renderText({\n    paste(\"You have selected\", input$var)\n  })\n  \n  output$min_max &lt;- renderText({\n    paste(\"You have chosen a range that goes from\",\n          input$range[1], \"to\", input$range[2])\n  })\n  \n}\n\nshinyApp(ui, server)",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Display reactive output"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson4/index.html#recap",
    "href": "r/getstarted/shiny-basics/lesson4/index.html#recap",
    "title": "Display reactive output",
    "section": "Recap",
    "text": "Recap\nIn this lesson, you created your first reactive Shiny app. Along the way, you learned to\n\nuse an *Output function in the ui to place reactive objects in your Shiny app,\nuse a render* function in the server to tell Shiny how to build your objects,\nsurround R expressions by curly braces, {}, in each render* function,\nsave your render* expressions in the output list, with one entry for each reactive object in your app, and\ncreate reactivity by including an input value in a render* expression.\n\nIf you follow these rules, Shiny will automatically make your objects reactive.\nIn Lesson 5 you will create a more sophisticated reactive app that relies on R scripts and external data.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Display reactive output"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson6/index.html",
    "href": "r/getstarted/shiny-basics/lesson6/index.html",
    "title": "Use reactive expressions",
    "section": "",
    "text": "Shiny apps wow your users by running fast, instantly fast. But what if your app needs to do a lot of slow computation?\nThis lesson will show you how to streamline your Shiny apps with reactive expressions. Reactive expressions let you control which parts of your app update when, which prevents unnecessary computation that can slow down your app.\nTo get started:\nStockVis use R‚Äôs quantmod package, so you‚Äôll need to install quantmod with install.packages(\"quantmod\") if you do not already have it.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Use reactive expressions"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson6/index.html#a-new-app-stockvis",
    "href": "r/getstarted/shiny-basics/lesson6/index.html#a-new-app-stockvis",
    "title": "Use reactive expressions",
    "section": "A new app: stockVis",
    "text": "A new app: stockVis\nThe stockVis app looks up stock prices by ticker symbol and displays the results as a line chart. The app lets you\n\nSelect a stock to examine\nPick a range of dates to review\nChoose whether to plot stock prices or the log of the stock prices on the y axis, and\nDecide whether or not to correct prices for inflation.\n\n\n\n\nNote that the ‚ÄúAdjust prices for inflation‚Äù check box doesn‚Äôt work yet. One of our tasks in this lesson is to fix this check box.\nBy default, stockVis displays the SPY ticker (an index of the entire S&P 500). To look up a different stock, type in a stock symbol that Yahoo finance will recognize. You can look up Yahoo‚Äôs stock symbols here. Some common symbols are GOOG (Google), AAPL (Apple), and GS (Goldman Sachs).\nstockVis relies heavily on two functions from the quantmod package:\n\nIt usesgetSymbols to download financial data straight into R from websites like Yahoo finance and the Federal Reserve Bank of St.¬†Louis.\nIt uses chartSeries to display prices in an attractive chart.\n\nstockVis also relies on an R script named helpers.R, which contains a function that adjusts stock prices for inflation.\n\nCheck boxes and date ranges\nThe stockVis app uses a few new widgets.\n\na date range selector, created with dateRangeInput, and\na couple of check boxes made with checkboxInput. Check box widgets are very simple. They return a TRUE when the check box is checked, and a FALSE when the check box is not checked.\n\nThe check boxes are named log and adjust in the ui object, which means you can look them up as input$log and input$adjust in the server function. If you‚Äôd like to review how to use widgets and their values, check out Lesson 3 and Lesson 4.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Use reactive expressions"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson6/index.html#streamline-computation",
    "href": "r/getstarted/shiny-basics/lesson6/index.html#streamline-computation",
    "title": "Use reactive expressions",
    "section": "Streamline computation",
    "text": "Streamline computation\nThe stockVis app has a problem.\nExamine what will happen when you click ‚ÄúPlot y axis on the log scale.‚Äù The value of input$log will change, which will cause the entire expression in renderPlot to re-run:\noutput$plot &lt;- renderPlot({\n  data &lt;- getSymbols(input$symb, src = \"yahoo\",\n                     from = input$dates[1],\n                     to = input$dates[2],\n                     auto.assign = FALSE)\n\n  chartSeries(data, theme = chartTheme(\"white\"),\n              type = \"line\", log.scale = input$log, TA = NULL)\n})\nEach time renderPlot re-runs\n\nit re-fetches the data from Yahoo finance with getSymbols, and\nit re-draws the chart with the correct axis.\n\nThis is not good, because you do not need to re-fetch the data to re-draw the plot. In fact, Yahoo finance will cut you off if you re-fetch your data too often (because you begin to look like a bot). But more importantly, re-running getSymbols is unnecessary work, which can slow down your app and consume server bandwidth.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Use reactive expressions"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson6/index.html#reactive-expressions",
    "href": "r/getstarted/shiny-basics/lesson6/index.html#reactive-expressions",
    "title": "Use reactive expressions",
    "section": "Reactive expressions",
    "text": "Reactive expressions\nYou can limit what gets re-run during a reaction with reactive expressions.\nA reactive expression is an R expression that uses widget input and returns a value. The reactive expression will update this value whenever the original widget changes.\nTo create a reactive expression use the reactive function, which takes an R expression surrounded by braces (just like the render* functions).\nFor example, here‚Äôs a reactive expression that uses the widgets of stockVis to fetch data from Yahoo.\ndataInput &lt;- reactive({\n  getSymbols(input$symb, src = \"yahoo\",\n    from = input$dates[1],\n    to = input$dates[2],\n    auto.assign = FALSE)\n})\nWhen you run the expression, it will run getSymbols and return the results, a data frame of price data. You can use the expression to access price data in renderPlot by calling dataInput().\noutput$plot &lt;- renderPlot({\n  chartSeries(dataInput(), theme = chartTheme(\"white\"),\n    type = \"line\", log.scale = input$log, TA = NULL)\n})\nReactive expressions are a bit smarter than regular R functions. They cache their values and know when their values have become outdated. What does this mean? The first time that you run a reactive expression, the expression will save its result in your computer‚Äôs memory. The next time you call the reactive expression, it can return this saved result without doing any computation (which will make your app faster).\nThe reactive expression will only return the saved result if it knows that the result is up-to-date. If the reactive expression has learned that the result is obsolete (because a widget has changed), the expression will recalculate the result. It then returns the new result and saves a new copy. The reactive expression will use this new copy until it too becomes out of date.\nLet‚Äôs summarize this behavior:\n\nA reactive expression saves its result the first time you run it.\nThe next time the reactive expression is called, it checks if the saved value has become out of date (i.e., whether the widgets it depends on have changed).\nIf the value is out of date, the reactive object will recalculate it (and then save the new result).\nIf the value is up-to-date, the reactive expression will return the saved value without doing any computation.\n\nYou can use this behavior to prevent Shiny from re-running code unnecessarily. Consider how a reactive expression will work in the new stockVis app below.\nserver &lt;- function(input, output) {\n\n  dataInput &lt;- reactive({\n    getSymbols(input$symb, src = \"yahoo\",\n               from = input$dates[1],\n               to = input$dates[2],\n               auto.assign = FALSE)\n  })\n\n  output$plot &lt;- renderPlot({\n\n    chartSeries(dataInput(), theme = chartTheme(\"white\"),\n                type = \"line\", log.scale = input$log, TA = NULL)\n  })\n\n}\nWhen you click ‚ÄúPlot y axis on the log scale‚Äù, input$log will change and renderPlot will re-execute. Now\n\nrenderPlot will call dataInput()\ndataInput will check that the dates and symb widgets have not changed\ndataInput will return its saved data set of stock prices without re-fetching data from Yahoo\nrenderPlot will re-draw the chart with the correct axis.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Use reactive expressions"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson6/index.html#dependencies",
    "href": "r/getstarted/shiny-basics/lesson6/index.html#dependencies",
    "title": "Use reactive expressions",
    "section": "Dependencies",
    "text": "Dependencies\nWhat if your user changes the stock symbol in the symb widget?\nThis will make the plot drawn by renderPlot out of date, but renderPlot no longer calls input$symb. Will Shiny know that input$symb has made plot out of date?\nYes, Shiny will know and will redraw the plot. Shiny keeps track of which reactive expressions an output object depends on, as well as which widget inputs. Shiny will automatically re-build an object if\n\nan input value in the objects‚Äôs render* function changes, or\na reactive expression in the objects‚Äôs render* function becomes obsolete\n\nThink of reactive expressions as links in a chain that connect input values to output objects. The objects in output will respond to changes made anywhere downstream in the chain. (You can fashion a long chain because reactive expressions can call other reactive expressions.)\nOnly call a reactive expression from within a reactive or a render*function. Why? Only these R functions are equipped to deal with reactive output, which can change without warning. In fact, Shiny will prevent you from calling reactive expressions outside of these functions.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Use reactive expressions"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson6/index.html#warm-up",
    "href": "r/getstarted/shiny-basics/lesson6/index.html#warm-up",
    "title": "Use reactive expressions",
    "section": "Warm up",
    "text": "Warm up\nTime to fix the broken check box for ‚ÄúAdjust prices for inflation.‚Äù Your user should be able to toggle between prices adjusted for inflation and prices that have not been adjusted.\nThe adjust function in helpers.R uses the Consumer Price Index data provided by the Federal Reserve Bank of St.¬†Louis to transform historical prices into present day values. But how can you implement this in the app?\nHere‚Äôs one solution below, but it is not ideal. Can you spot why? Once again it has to do with input$log.\nserver &lt;- function(input, output) {\n\n  dataInput &lt;- reactive({\n    getSymbols(input$symb, src = \"yahoo\",\n        from = input$dates[1],\n        to = input$dates[2],\n        auto.assign = FALSE)\n  })\n\n  output$plot &lt;- renderPlot({\n    data &lt;- dataInput()\n    if (input$adjust) data &lt;- adjust(dataInput())\n\n    chartSeries(data, theme = chartTheme(\"white\"),\n        type = \"line\", log.scale = input$log, TA = NULL)\n  })\n}\n\n\n\n\n\n\nView Answer\n\n\n\n\n\nadjust is called inside renderPlot. If the adjust box is checked, the app will readjust all of the prices each time you switch from a normal y scale to a logged y scale. This readjustment is unnecessary work.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Use reactive expressions"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson6/index.html#your-turn",
    "href": "r/getstarted/shiny-basics/lesson6/index.html#your-turn",
    "title": "Use reactive expressions",
    "section": "Your Turn",
    "text": "Your Turn\nFix this problem by adding a new reactive expression to the app. The reactive expression should take the value of dataInput and return an adjusted (or not adjusted) copy of the data.\nWhen you think you have it, compare your solution to the model answer below. Make sure you understand what calculations will happen and what calculations will not happen in your app when your user clicks ‚ÄúPlot y axis on the log scale‚Äù.\n\n\n\n\n\n\nView Answer\n\n\n\n\n\nserver &lt;- function(input, output) {\n\n  dataInput &lt;- reactive({\n      getSymbols(input$symb, src = \"yahoo\",\n          from = input$dates[1],\n          to = input$dates[2],\n          auto.assign = FALSE)\n  })\n\n  finalInput &lt;- reactive({\n    if (!input$adjust) return(dataInput())\n    adjust(dataInput())\n  })\n\n  output$plot &lt;- renderPlot({\n    chartSeries(finalInput(), theme = chartTheme(\"white\"),\n        type = \"line\", log.scale = input$log, TA = NULL)\n  })\n}\nNow you have isolated each input in its own reactive expression or render* function. If an input changes, only out of date expressions will re-run.\nHere‚Äôs an example of the flow:\n\nA user clicks ‚ÄúPlot y axis on the log scale.‚Äù\nrenderPlot re-runs.\nrenderPlot calls finalInput.\nfinalInput checks with dataInput and input$adjust.\nIf neither has changed, finalInput returns its saved value.\nIf either has changed, finalInput calculates a new value with the current inputs. It will pass the new value to renderPlot and store the new value for future queries.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Use reactive expressions"
    ]
  },
  {
    "objectID": "r/getstarted/shiny-basics/lesson6/index.html#recap",
    "href": "r/getstarted/shiny-basics/lesson6/index.html#recap",
    "title": "Use reactive expressions",
    "section": "Recap",
    "text": "Recap\nYou can make your apps faster by modularizing your code with reactive expressions.\n\nA reactive expression takes input values, or values from other reactive expressions, and returns a new value\nReactive expressions save their results, and will only re-calculate if their input has changed\nCreate reactive expressions with reactive({ })\nCall reactive expressions with the name of the expression followed by parentheses ()\nOnly call reactive expressions from within other reactive expressions or render* functions\n\nYou can now create sophisticated, streamlined Shiny apps. The final lesson in this tutorial will show you how to share your apps with others.",
    "crumbs": [
      "Home",
      "![](/images/1-square-fill.svg){.sidebar-icon} Shiny Basics",
      "Use reactive expressions"
    ]
  },
  {
    "objectID": "r/help.html#shiny",
    "href": "r/help.html#shiny",
    "title": "Getting help",
    "section": "Shiny",
    "text": "Shiny\nThe first place to look for help with Shiny is Posit Community, which is a warm and welcoming place to ask any questions you might have about Shiny (as well as tidyverse and all things Posit). The web site is running Discourse, which is an excellent community discussion platform. Our developers monitor Posit Community and answer questions periodically.\nYou can also check the ‚Äúshiny‚Äù tag on Stack Overflow for existing answers, or post your own question. Note that questions posted on Stack Overflow are not closely monitored by our developers."
  },
  {
    "objectID": "r/help.html#shinyapps.io",
    "href": "r/help.html#shinyapps.io",
    "title": "Getting help",
    "section": "shinyapps.io",
    "text": "shinyapps.io\nFor questions about shinyapps.io or the rsconnect package, check the shinyapps-users Google group.\nCustomers with Starter, Basic, Standard or Pro subscriptions to shinyapps.io can open a case with our support engineers by sending an email to shinyapps-support@posit.co."
  },
  {
    "objectID": "r/help.html#posit-connect-and-shiny-server-pro",
    "href": "r/help.html#posit-connect-and-shiny-server-pro",
    "title": "Getting help",
    "section": "Posit Connect and Shiny Server Pro",
    "text": "Posit Connect and Shiny Server Pro\nCustomers with Posit Connect or Shiny Server Pro subscriptions can contact our dedicated support team for our commercial offerings at support@rstudio.com."
  },
  {
    "objectID": "r/help.html#sales",
    "href": "r/help.html#sales",
    "title": "Getting help",
    "section": "Sales",
    "text": "Sales\nFor sales questions, please email sales@rstudio.com."
  },
  {
    "objectID": "r/reference/shiny/0.11/upgrade.html",
    "href": "r/reference/shiny/0.11/upgrade.html",
    "title": "Upgrade notes for Shiny 0.11",
    "section": "",
    "text": "Shiny 0.11 switches away from the Bootstrap 2 web framework to the next version, Bootstrap 3. This is in part because Bootstrap 2 is no longer being developed, and in part because it allows us to tap into the ecosystem of Bootstrap 3 themes."
  },
  {
    "objectID": "r/reference/shiny/0.11/upgrade.html#known-issues-for-migration",
    "href": "r/reference/shiny/0.11/upgrade.html#known-issues-for-migration",
    "title": "Upgrade notes for Shiny 0.11",
    "section": "Known issues for migration",
    "text": "Known issues for migration\n\n\nIn Bootstrap 3, images in &lt;img&gt; tags are no longer automatically scaled to the width of their container. If you use img() in your UI code, or &lt;img&gt; tags in your raw HTML source, it‚Äôs possible that they will be too large in the new version of Shiny. To address this you can add the img-responsive class:\n{% highlight r %} img(src = ‚Äúpicture.png‚Äù, class = ‚Äúimg-responsive‚Äù) {% endhighlight %}\nThe R code above will generate the following HTML:\n{% highlight html %}  {% endhighlight %}\n\nThe sliders have been replaced. Previously, Shiny used the jslider library, but now it uses ion.RangeSlider. The new sliders have an updated appearance, and they have allowed us to fix many long-standing interface issues with the sliders.\n\nThe sliderInput() function no longer uses the format or locale options. Instead, you can use pre, post, and sep options to control the prefix, postfix, and thousands separator.\nupdateSliderInput() can now control the min, max, value, and step size of a slider. Previously, only the value could be controlled this way, and if you wanted to change other values, you needed to use Shiny‚Äôs dynamic UI.\n\n\nIf in your HTML you are using custom CSS classes that are specific to Bootstrap, you may need to update them for Bootstrap 3. See the Bootstrap migration guide. {::nomarkdown}\n\n{:/nomarkdown}\nIf you encounter other migration issues, please let us know on the shiny-discuss mailing list, or on the Shiny issue tracker."
  },
  {
    "objectID": "r/reference/shiny/0.11/upgrade.html#using-shinybootstrap2",
    "href": "r/reference/shiny/0.11/upgrade.html#using-shinybootstrap2",
    "title": "Upgrade notes for Shiny 0.11",
    "section": "Using shinybootstrap2",
    "text": "Using shinybootstrap2\nIf you would like to use Shiny 0.11 with Bootstrap 2, you can use the shinybootstrap2 package. Installation and usage instructions are on available on the project page. We recommend that you do this only as a temporary solution because future development on Shiny will use Bootstrap 3."
  },
  {
    "objectID": "r/reference/shiny/0.11/upgrade.html#installing-an-older-version-of-shiny",
    "href": "r/reference/shiny/0.11/upgrade.html#installing-an-older-version-of-shiny",
    "title": "Upgrade notes for Shiny 0.11",
    "section": "Installing an older version of Shiny",
    "text": "Installing an older version of Shiny\nIf you want to install a specific version of Shiny other than the latest CRAN release, you can use the install_version() function from devtools:\n{% highlight r %} # Install devtools if you don‚Äôt already have it: install.package(‚Äúdevtools‚Äù)"
  },
  {
    "objectID": "r/reference/shiny/0.11/upgrade.html#themes",
    "href": "r/reference/shiny/0.11/upgrade.html#themes",
    "title": "Upgrade notes for Shiny 0.11",
    "section": "Themes",
    "text": "Themes"
  },
  {
    "objectID": "r/reference/shiny/0.12.1/upgrade.html",
    "href": "r/reference/shiny/0.12.1/upgrade.html",
    "title": "Upgrade notes for Shiny 0.12.1",
    "section": "",
    "text": "Fixed an issue where unbindAll() causes subsequent bindAll() to be ignored for previously bound outputs. (#856)\nUndeprecate dataTableOutput and renderDataTable, which had been deprecated in favor of the new DT package. The DT package is a bit too new and has a slightly different API, we were too hasty in deprecating the existing Shiny functions."
  },
  {
    "objectID": "r/reference/shiny/0.13.0/upgrade.html",
    "href": "r/reference/shiny/0.13.0/upgrade.html",
    "title": "Upgrade notes for Shiny 0.13.0",
    "section": "",
    "text": "Fixed #962: plot interactions did not work with the development version of ggplot2 (after ggplot2 1.0.1).\nFixed #902: the drag_drop plugin of the selectize input did not work.\nFixed #933: updateSliderInput() does not work when only the label is updated.\nMultiple imageOutput/plotOutput calls can now share the same brush id. Shiny will ensure that performing a brush operation will clear any other brush with the same id.\nAdded placeholder option to textInput.\nImproved support for Unicode characters on Windows (#968).\nFixed bug in selectInput and selectizeInput where values with double quotes were not properly escaped.\nrunApp() can now take a path to any .R file that yields a shinyApp object; previously, the path had to be a directory that contained an app.R file (or server.R if using separately defined server and UI). Similarly, introduced shinyAppFile() function which creates a shinyApp object for an .R file path, just as shinyAppDir() does for a directory path.\nIntroduced Shiny Modules, which are designed to 1) simplify the reuse of Shiny UI/server logic and 2) make authoring and maintaining complex Shiny apps much easier. See the article linked from ?callModule.\ninvalidateLater and reactiveTimer no longer require an explicit session argument; the default value uses the current session.\nAdded session$reload() method, the equivalent of hitting the browser‚Äôs Reload button.\nAdded shiny.autoreload option, which will automatically cause browsers to reload whenever Shiny app files change on disk. This is intended to shorten the feedback cycle when tweaking UI code.\nErrors are now printed with stack traces! This should make it tremendously easier to track down the causes of errors in Shiny. Try it by calling stop(\"message\") from within an output, reactive, or observer. Shiny itself adds a lot of noise to the call stack, so by default, it attempts to hide all but the relevant levels of the call stack. You can turn off this behavior by setting options(shiny.fullstacktrace=TRUE) before or during app startup.\nFixed #1018: the selected value of a selectize input is guaranteed to be selected in server-side mode.\nAdded req function, which provides a simple way to prevent a reactive, observer, or output from executing until all required inputs and values are available. (Similar functionality has been available for a while using validate/need, but req provides a much simpler and more direct interface.)\nImprove stability with Shiny Server when many subapps are used, by deferring the loading of subapp iframes until a connection has first been established with the server.\nUpgrade to Font Awesome 4.5.0.\nUpgraded to Bootstrap 3.3.5.\nUpgraded to jQuery 1.12.4\nSwitched to an almost-complete build of jQuery UI with the exception of the datepicker extension, which conflicts with Shiny‚Äôs date picker.\nAdded fillPage function, an alternative to fluidPage, fixedPage, etc. that is designed for apps that fill the entire available page width/height.\nAdded fillRow and fillCol functions, for laying out proportional grids in fillPage. For modern browsers only.\nAdded runGadget, paneViewer, dialogViewer, and browserViewer functions to support Shiny Gadgets. More detailed docs about gadgets coming soon."
  },
  {
    "objectID": "r/reference/shiny/0.14.2/upgrade.html",
    "href": "r/reference/shiny/0.14.2/upgrade.html",
    "title": "Upgrade notes for Shiny 0.14.2",
    "section": "",
    "text": "This is a maintenance release of Shiny, with some bug fixes and minor new features."
  },
  {
    "objectID": "r/reference/shiny/0.14.2/upgrade.html#full-changelog",
    "href": "r/reference/shiny/0.14.2/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 0.14.2",
    "section": "Full changelog",
    "text": "Full changelog\n\nMinor new features and improvements\n\nAdded a fade argument to modalDialog() ‚Äì setting it to FALSE will remove the usual fade-in animation for that modal window. (#1414)\nFixed a ‚Äúduplicate binding‚Äù error that occurred in some edge cases involving insertUI and nested uiOutput. (#1402)\nFixed #1422: When using the shiny.trace option, allow specifying to only log SEND or RECV messages, or both. (PR #1428)\nFixed #1419: Allow overriding a JS custom message handler. (PR #1445)\nAdded exportTestValues() function, which allows a test driver to query the session for values internal to an application‚Äôs server function. This only has an effect if the shiny.testmode option is set to TRUE. (#1436)\n\n\n\nBug fixes\n\nFixed #1427: make sure that modals do not close incorrectly when an element inside them is triggered as hidden. (#1430)\nFixed #1404: stack trace tests were not compatible with the byte-code compiler in R-devel, which now tracks source references.\nsliderInputBinding.setValue() now sends a slider‚Äôs value immediately, instead of waiting for the usual 250ms debounce delay. (#1429)"
  },
  {
    "objectID": "r/reference/shiny/1.0.0/upgrade.html",
    "href": "r/reference/shiny/1.0.0/upgrade.html",
    "title": "Upgrade notes for Shiny 1.0.0",
    "section": "",
    "text": "Shiny has reached a milestone: version 1.0.0! In the last year, we‚Äôve added two major features that we considered essential for a 1.0.0 release: bookmarking, and support for testing Shiny applications. As usual, this version of Shiny also includes many minor features and bug fixes.\nHere are some highlights from this release. For more details, see the full changelog below."
  },
  {
    "objectID": "r/reference/shiny/1.0.0/upgrade.html#support-for-testing-shiny-applications",
    "href": "r/reference/shiny/1.0.0/upgrade.html#support-for-testing-shiny-applications",
    "title": "Upgrade notes for Shiny 1.0.0",
    "section": "Support for testing Shiny applications",
    "text": "Support for testing Shiny applications\nShiny now supports automated testing of applications, with the shinytest package. Shinytest has not yet been released on CRAN, but will be soon. (#18, #1464)"
  },
  {
    "objectID": "r/reference/shiny/1.0.0/upgrade.html#debouncethrottle-reactives",
    "href": "r/reference/shiny/1.0.0/upgrade.html#debouncethrottle-reactives",
    "title": "Upgrade notes for Shiny 1.0.0",
    "section": "Debounce/throttle reactives",
    "text": "Debounce/throttle reactives\nNow there‚Äôs an official way to slow down reactive values and expressions that invalidate too quickly. Pass a reactive expression to the new debounce or throttle function, and get back a modified reactive expression that doesn‚Äôt invalidate as often. (#1510)"
  },
  {
    "objectID": "r/reference/shiny/1.0.0/upgrade.html#full-changelog",
    "href": "r/reference/shiny/1.0.0/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 1.0.0",
    "section": "Full changelog",
    "text": "Full changelog\n\nBreaking changes\n\nAdded a new placeholder argument to verbatimTextOutput(). The default is FALSE, which means that, if there is no content for this output, no representation of this slot will be made in the UI. Previsouly, even if there was no content, you‚Äôd see an empty rectangle in the UI that served as a placeholder. You can set placeholder = TRUE to revert back to that look. (#1480)\n\n\n\nNew features\n\nAdded support for testing Shiny applications with the shinytest package. (#18, #1464)\nAdded debounce and throttle functions, to control the rate at which reactive values and expressions invalidate. (#1510)\n\n\n\nMinor new features and improvements\n\nAddressed #1486 by adding a new argument to observeEvent and eventReactive, called ignoreInit (defaults to FALSE for backwards compatibility). When set to TRUE, the action (i.e.¬†the second argument: handlerExpr and valueExpr, respectively) will not be triggered when the observer/reactive is first created/initialized. In other words, ignoreInit = TRUE ensures that the observeEvent (or eventReactive) is never run right away. For more info, see the documentation (?observeEvent). (#1494)\nAdded a new argument to observeEvent called once. When set to TRUE, it results in the observer being destroyed (stop observing) after the first time that handlerExpr is run (i.e.¬†once = TRUE guarantees that the observer only runs, at most, once). For more info, see the documentation (?observeEvent). (#1494)\nAddressed #1358: more informative error message when calling runApp() inside of an app‚Äôs app.R (or inside ui.R or server.R). (#1482)\nAdded a more descriptive JS warning for insertUI() when the selector argument does not match anything in DOM. (#1488)\nAdded support for injecting JavaScript code when the shiny.testmode option is set to TRUE. This makes it possible to record test events interactively. (#1464)\nAdded ability through arguments to the a tag function called inside downloadButton() and downloadLink(). Closes #986. (#1492)\nImplemented #1512: added a userData environment to session, for storing arbitrary session-related variables. Generally, session-scoped variables are created just by declaring normal variables that are local to the Shiny server function, but session$userData may be more convenient for some advanced scenarios. (#1513)\n\n\n\nBug fixes\n\nFixed #969: allow navbarPage‚Äôs fluid param to control both containers. (#1481)\nFixed #1438: unbindAll() should not be called when inserting content with insertUI() (#1449)\nFixed bug causing &lt;meta&gt; tags associated with HTML dependencies of Shiny R Markdown files to be rendered incorrectly. (#1463)\nFixed #1359: shinyApp() options argument ignored when passed to runApp(). (#1483)\nFixed #117: Reactive expressions now release references to cached values as soon as they are invalidated, potentially making those cached values eligible for garbage collection sooner. Previously, this would not occur until the next cached value was calculated and stored. (#1504)\nFixed #1013: flushReact should be called after app loads. Observers set up outside of server functions were not running until after the first user connects. (#1503)\nFixed #1453: When using a modal dialog with easyClose=TRUE in a Shiny gadget, pressing Esc would close both the modal and the gadget. Now pressing Esc only closes the modal. (#1523)\n\n\n\nLibrary updates"
  },
  {
    "objectID": "r/reference/shiny/1.0.2/upgrade.html",
    "href": "r/reference/shiny/1.0.2/upgrade.html",
    "title": "Upgrade notes for Shiny 1.0.2",
    "section": "",
    "text": "This is a hotfix release of Shiny. The primary reason for this release is because the web host for MathJax JavaScript library is scheduled to be shut down in the next few weeks. After it is shut down, Shiny applications that use MathJax will no longer be able to load the MathJax library if they are run with Shiny 1.0.1 and below. (If you don‚Äôt know whether your application uses MathJax, it probably does not.) For more information about why the MathJax CDN is shutting down, see https://www.mathjax.org/cdn-shutting-down/."
  },
  {
    "objectID": "r/reference/shiny/1.0.2/upgrade.html#full-changelog",
    "href": "r/reference/shiny/1.0.2/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 1.0.2",
    "section": "Full changelog",
    "text": "Full changelog\n\nMinor new features and improvements\n\nAdded a shiny:sessioninitialized Javascript event, which is fired at the end of the initialize method of the Session object. This allows us to listen for this event when we want to get the value of things like Shiny.user. (#1568)\nFixed #1649: allow the choices argument in checkboxGroupInput() to be NULL (or c()) to keep backward compatibility with Shiny &lt; 1.0.1. This will result in the same thing as providing choices = character(0). (#1652)\nThe official URL for accessing MathJax libraries over CDN has been deprecated and will be removed soon. We have switched to a new rstudio.com URL that we will support going forward. (#1664)\n\n\n\nBug fixes"
  },
  {
    "objectID": "r/reference/shiny/1.0.4/upgrade.html",
    "href": "r/reference/shiny/1.0.4/upgrade.html",
    "title": "Upgrade notes for Shiny 1.0.4",
    "section": "",
    "text": "There are three headlining features in this release of Shiny. It is now possible to add and remove tabs from a tabPanel; there is a new function, onStop(), which registers callbacks that execute when an application exits; and fileInputs now can have files dragged and dropped on them. In addition to these features, this release has a number of minor features and bug fixes. See the full changelog below for more details."
  },
  {
    "objectID": "r/reference/shiny/1.0.4/upgrade.html#full-changelog",
    "href": "r/reference/shiny/1.0.4/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 1.0.4",
    "section": "Full changelog",
    "text": "Full changelog\n\nNew features\n\nImplemented #1668: dynamic tabs: added functions (insertTab, appendTab, prependTab, removeTab, showTab and hideTab) that allow you to do those actions for an existing tabsetPanel. (#1794)\nImplemented #1213: Added a new function, onStop(), which can be used to register callback functions that are invoked when an application exits, or when a user session ends. (Multiple sessions can be connected to a single running Shiny application.) This is useful if you have finalization/clean-up code that should be run after the application exits. (#1770\nImplemented #1155: Files can now be drag-and-dropped on fileInput controls. The appearance of fileInput controls while files are being dragged can be modified by overriding the shiny-file-input-active and shiny-file-input-over classes. (#1782)\n\n\n\nMinor new features and improvements\n\nAddressed #1688: trigger a new shiny:outputinvalidated event when an output gets invalidated, at the same time that the recalculating CSS class is added. (#1758, thanks @andrewsali!)\nAddressed #1508: fileInput now permits the same file to be uploaded multiple times. (#1719)\nAddressed #1501: The fileInput control now retains uploaded file extensions on the server. This fixes readxl‚Äôs readxl::read_excel and other functions that must recognize a file‚Äôs extension in order to work. (#1706)\nFor conditionalPanels, Shiny now gives more informative messages if there are errors evaluating or parsing the JavaScript conditional expression. (#1727)\nAddressed #1586: The conditionalPanel function now accepts an ns argument. The ns argument can be used in a module UI function to scope the condition expression to the module‚Äôs own input and output IDs. (#1735)\nWith options(shiny.testmode=TRUE), the Shiny process will send a message to the client in response to a changed input, even if no outputs have changed. This helps to streamline testing using the shinytest package. (#1747)\nAddressed #1738: The updateTextInput and updateTextAreaInput functions can now update the placeholder. (#1742)\nConverted examples to single file apps, and made updates and enhancements to comments in the example app scripts. (#1685)\nAdded new snapshotPreprocessInput() and snapshotPreprocessOutput() functions, which is used for preprocessing and input and output values before taking a test snapshot. (#1760, #1789)\nThe HTML generated by renderTable() no longer includes comments with the R version, xtable version, and timestamp. (#1771)\nAdded a function isRunning to test whether a Shiny app is currently running. (#1785)\nAdded a function setSerializer, which allows authors to specify a function for serializing the value of a custom input. (#1791)\n\n\n\nBug fixes\n\nFixed #1546: make it possible (without any hacks) to write arbitrary data into a module‚Äôs session$userData (which is exactly the same environment as the parent‚Äôs session$userData). To be clear, it allows something like session$userData$x &lt;- TRUE, but not something like session$userData &lt;- TRUE (that is not allowed in any context, whether you‚Äôre in the main app, or in a module) (#1732).\nFixed #1701: There was a partial argument match in the generateOptions function. (#1702)\nFixed #1710: ReactiveVal objects did not have separate dependents. (#1712)\nFixed #1438: unbindAll() should not be called when inserting content with insertUI(). A previous fix (#1449) did not work correctly. (#1736)\nFixed #1755: dynamic htmlwidgets sent the path of the package on the server to the client. (#1756)\nFixed #1763: Shiny‚Äôs private random stream leaked out into the main random stream. (#1768)\nFixed #1680: options(warn=2) was not respected when running an app. (#1790)\nFixed #1772: ensure that runApp() respects the shinyApp(onStart = function()) argument. (#1770)"
  },
  {
    "objectID": "r/reference/shiny/1.1.0/upgrade.html",
    "href": "r/reference/shiny/1.1.0/upgrade.html",
    "title": "Upgrade notes for Shiny 1.1.0",
    "section": "",
    "text": "This is a significant release for Shiny, with a major new feature that was nearly a year in the making: support for asynchronous operations! Until now, R‚Äôs single-threaded nature meant that performing long-running calculations or tasks from Shiny would bring your app to a halt for other users of that process. This release of Shiny deeply integrates the promises package to allow you to execute some tasks asynchronously, including as part of reactive expressions and outputs. See the promises documentation to learn more."
  },
  {
    "objectID": "r/reference/shiny/1.1.0/upgrade.html#full-changelog",
    "href": "r/reference/shiny/1.1.0/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 1.1.0",
    "section": "Full changelog",
    "text": "Full changelog\n\nBreaking changes\n\nextractStackTrace and formatStackTrace are deprecated and will be removed in a future version of Shiny. As far as we can tell, nobody has been using these functions, and a refactor has made them vestigial; if you need this functionality, please file an issue.\n\n\n\nNew features\n\nSupport for asynchronous operations! Built-in render functions that expected a certain kind of object to be yielded from their expr, now generally can handle a promise for that kind of object. Reactive expressions and observers are now promise-aware as well. (#1932)\nIntroduced two changes to the (undocumented but widely used) JavaScript function Shiny.onInputChange(name, value). First, we changed the function name to Shiny.setInputValue (but don‚Äôt worry‚Äìthe old function name will continue to work). Second, until now, all calls to Shiny.onInputChange(inputId, value) have been ‚Äúdeduplicated‚Äù; that is, anytime an input is set to the same value it already has, the set is ignored. With Shiny v1.1, you can now add an options object as the third parameter: Shiny.setInputValue(\"name\", value, {priority: \"event\"}). When the priority option is set to \"event\", Shiny will always send the value and trigger reactivity, whether it is a duplicate or not. This closes #928, which was the most upvoted open issue by far! Thanks, @daattali. (#2018)\n\n\n\nMinor new features and improvements\n\nAddressed #1978: shiny:value is now triggered when duplicate output data is received from the server. (Thanks, @andrewsali! #1999)\nIf a shiny output contains a css class of shiny-report-size, its container height and width are now reported in session$clientData. So, for an output with an id with \"myID\", the height/width can be accessed via session$clientData[['output_myID_height']]/session$clientData[['output_myID_width']]. Addresses #1980. (Thanks, @cpsievert! #1981)\nAdded a new autoclose = TRUE parameter to dateInput() and dateRangeInput(). This closed #1969 which was a duplicate of much older issue, #173. The default value is TRUE since that seems to be the common use case. However, this will cause existing apps with date inputs (that update to this version of Shiny) to have the datepicker be immediately closed once a date is selected. For most apps, this is actually desired behavior; if you wish to keep the datepicker open until the user clicks out of it use autoclose = FALSE. (#1987)\nThe version of Shiny is now accessible from Javascript, with Shiny.version. There is also a new function for comparing version strings, Shiny.compareVersion(). (#1826, #1830)\nAddressed #1851: Stack traces are now smaller in some places do.call() is used. (#1856)\nStack traces have been improved, with more aggressive de-noising and support for deep stack traces (stitching together multiple stack traces that are conceptually part of the same async operation).\nAddressed #1859: Server-side selectize is now significantly faster. (Thanks to @dselivanov #1861)\n#1989: The server side of outputs can now be removed (e.g.¬†output$plot &lt;- NULL). This is not usually necessary but it does allow some objects to be garbage collected, which might matter if you are dynamically creating and destroying many outputs. (Thanks, @mmuurr! #2011)\nRemoved the (ridiculously outdated) ‚Äúexperimental feature‚Äù tag from the reference documentation for renderUI. (#2036)\nAddressed #1907: the ignoreInit argument was first added only to observeEvent. Later, we also added it to eventReactive, but forgot to update the documentation. Now done, thanks @flo12392! (#2036)\n\n\n\nBug fixes\n\nFixed #1006: Slider inputs sometimes showed too many digits. (#1956)\nFixed #1958: Slider inputs previously displayed commas after a decimal point. (#1960)\nThe internal URLdecode() function previously was a copy of httpuv::decodeURIComponent(), assigned at build time; now it invokes the httpuv function at run time.\nFixed #1840: with the release of Shiny 1.0.5, we accidently changed the relative positioning of the icon and the title text in navbarMenus and tabPanels. This fix reverts this behavior back (i.e.¬†the icon should be to the left of the text and/or the downward arrow in case of navbarMenus). (#1848)\nFixed #1600: URL-encoded bookmarking did not work with sliders that had dates or date-times. (#1961)\nFixed #1962: File dragging and dropping broke in the presence of jQuery version 3.0 as introduced by the rhandsontable htmlwidget. (#2005)\nImproved the error handling inside the addResourcePath() function, to give end users more informative error messages when the directoryPath argument cannot be normalized. This is especially useful for runtime: shiny_prerendered Rmd documents, like learnr tutorials. (#1968)\nChanged script tags in reactlog (inst/www/reactive-graph.html) from HTTP to HTTPS in order to avoid mixed content blocking by most browsers. (Thanks, @jekriske-lilly! #1844)\nAddressed #1784: runApp() will avoid port 6697, which is considered unsafe by Chrome.\nFixed #2000: Implicit calls to xxxOutput not working inside modules. (Thanks, @GregorDeCillia! #2010)\nFixed #2021: Memory leak with reactiveTimer and invalidateLater. (#2022)\n\n\n\nLibrary updates\n\nUpdated to ion.rangeSlider 2.2.0. (#1955)"
  },
  {
    "objectID": "r/reference/shiny/1.1.0/upgrade.html#known-issues",
    "href": "r/reference/shiny/1.1.0/upgrade.html#known-issues",
    "title": "Upgrade notes for Shiny 1.1.0",
    "section": "Known issues",
    "text": "Known issues"
  },
  {
    "objectID": "r/reference/shiny/1.3.0/upgrade.html#full-changelog",
    "href": "r/reference/shiny/1.3.0/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 1.3.0",
    "section": "Full changelog",
    "text": "Full changelog\n\nNew features\n\nRevamped Shiny‚Äôs reactlog viewer which debugs reactivity within a shiny application. This allows users to traverse the reactivity history of a shiny application, filter to the dependency tree of a selected reactive object, and search for matching reactive objects. See ?reactlogShow for more details and how to enable this feature. (#2107)\nShiny now serves static files on a background thread. This means that things like JavaScript and CSS assets can be served without blocking or being blocked by the main R thread, and should result in significantly better performance for heavily loaded servers. (#2280)\n\n\n\nMinor new features and improvements\n\nThe Shiny-Shared-Secret security header is now checked using constant-time comparison to prevent timing attacks (thanks @dirkschumacher!). (#2319)\n\n\n\nBug fixes\n\nFixed #2245: updateSelectizeInput() did not update labels. (#2248)\nFixed #2308: When restoring a bookmarked application, inputs with a leading . would not be restored. (#2311)\nFixed #2305, #2322, #2351: When an input in dynamic UI is restored from bookmarks, it would keep getting set to the same value. (#2360)\nFixed #2349, #2329, #1817: These were various bugs triggered by the presence of the networkD3 package‚Äôs Sankey plot in an app. Impacted features included dateRangeInput, withProgressBar, and bookmarking (#2359)\n\n\n\nDocumentation Updates\n\nFixed #2247: renderCachedPlot now supports using promises for either expr or cacheKeyExpr. (Shiny v1.2.0 supported async expr, but only if cacheKeyExpr was async as well; now you can use any combination of sync/async for expr and cacheKeyExpr.) #2261"
  },
  {
    "objectID": "r/reference/shiny/1.3.2/upgrade.html#full-changelog",
    "href": "r/reference/shiny/1.3.2/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 1.3.2",
    "section": "Full changelog",
    "text": "Full changelog\n\nBug fixes\n\nFixed #2285, #2288: Static CSS/JS resources in subapps in R Markdown documents did not render properly. (#2386)\nFixed #2280: Shiny applications that used a www/index.html file did not serve up the index file. (#2382)"
  },
  {
    "objectID": "r/reference/shiny/1.5.0/upgrade.html#full-changelog",
    "href": "r/reference/shiny/1.5.0/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 1.5.0",
    "section": "Full changelog",
    "text": "Full changelog\n\nBreaking changes\n\nFixed #2869: Until this release, renderImage() had a dangerous default of deleteFile = TRUE. (Sorry!) Going forward, calls to renderImage() will need an explicit deleteFile argument; for now, failing to provide one will result in a warning message, and the file will be deleted if it appears to be within the tempdir(). (#2881)\n\n\n\nNew features\n\nThe new shinyAppTemplate() function creates a new template Shiny application, where components are optional, such as helper files in an R/ subdirectory, a module, and various kinds of tests. (#2704)\nrunTests() is a new function that behaves much like R CMD check. runTests() invokes all of the top-level R files in the tests/ directory inside an application, in that application‚Äôs environment. (#2585)\ntestServer() is a new function for testing reactive behavior inside server functions and modules. (#2682, #2764, #2807)\nThe new moduleServer function provides a simpler interface for creating and using modules. (#2773)\nResolved #2732: markdown() is a new function for writing Markdown with Github extensions directly in Shiny UIs. Markdown rendering is performed by the commonmark package. (#2737)\nThe getCurrentOutputInfo() function can now return the background color (bg), foreground color (fg), accent (i.e., hyperlink) color, and font information of the output‚Äôs HTML container. This information is reported by plotOutput(), imageOutput(), and any other output bindings containing a class of .shiny-report-theme. This feature allows developers to style an output‚Äôs contents based on the container‚Äôs CSS styling. (#2740)\n\n\n\nMinor new features and improvements\n\nFixed #2042, #2628: In a dateInput and dateRangeInput, disabled months and years are now a lighter gray, to make it easier to see that they are disabled. (#2690)\ngetCurrentOutputInfo() previously threw an error when called from outside of an output; now it returns NULL. (#2707 and #2858)\nAdded a label to observer that auto-reloads R/ directory to avoid confusion when using reactlog. (#58)\ngetDefaultReactiveDomain() can now be called inside a session$onSessionEnded callback and will return the calling session information. (#2757)\nAdded a 'function' class to reactive() and reactiveVal() objects. (#2793)\nAdded a new option (type = \"hidden\") to tabsetPanel(), making it easier to set the active tab via other input controls (e.g., radioButtons()) rather than tabs or pills. Use this option in conjunction with updateTabsetPanel() and the new tabsetPanelBody() function (see help(tabsetPanel) for an example and more details). (#2814)\nAdded function updateActionLink() to update an actionLink() label and/or icon value. (#2811)\nFixed #2856: Bumped jQuery 3 from 3.4.1 to 3.5.1. (#2857)\n\n\n\nBug fixes\n\nFixed #2606: debounce() would not work properly if the code in the reactive expression threw an error on the first run. (#2652)\nFixed #2653: The dataTableOutput() could have incorrect output if certain characters were in the column names. (#2658)\n\n\n\nDocumentation Updates\n\n\nLibrary updates\n\nUpdated from Font-Awesome 5.3.1 to 5.13.0, which includes icons related to COVID-19. For upgrade notes, see https://github.com/FortAwesome/Font-Awesome/blob/master/UPGRADING.md. (#2891)"
  },
  {
    "objectID": "r/reference/shiny/1.7.0/upgrade.html#full-changelog",
    "href": "r/reference/shiny/1.7.0/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 1.7.0",
    "section": "Full changelog",
    "text": "Full changelog\n\nBreaking changes\n\nThe format and locale arguments to sliderInput() have been removed. They have been deprecated since 0.10.2.2 (released on 2014-12-08).\nClosed #3403: insertTab()‚Äôs position parameter now defaults to \"after\" instead of \"before\". This has the benefit of allowing us to fix a bug in positioning when target = NULL, but has the drawback of changing the default behavior when target is not NULL. (#3404)\n\n\n\nNew features and improvements\n\nBootstrap 5 support. (#3410 and rstudio/bslib#304)\n\nAs explained here, to opt-in to Bootstrap 5, provide bslib::bs_theme(version = 5) to a page layout function with a theme argument (e.g., fluidPage(), navbarPage(), etc).\n\nClosed #3322, #3313, #1823, #3321, #3320, #1928, and #2310: Various improvements to navbarPage(), tabsetPanel(), tabPanel(), navbarMenu(), etc. Also, these functions are now powered by the bslib package‚Äôs new nav() API (consider using bslib‚Äôs API to create better looking and more fully featured navs). (#3388)\nAll uses of list(...) have been replaced with rlang::list2(...). This means that you can use trailing , without error and use rlang‚Äôs !!! operator to ‚Äúsplice‚Äù a list of argument values into .... We think this‚Äôll be particularly useful for passing a list of tabPanel() to their consumers (i.e., tabsetPanel(), navbarPage(), etc). For example, tabs &lt;- list(tabPanel(\"A\", \"a\"), tabPanel(\"B\", \"b\")); navbarPage(!!!tabs). (#3315 and #3328)\ninstallExprFunction() and exprToFunction() are now able to handle quosures when quoted = TRUE. So render-functions which call these functions (such as with htmlwidgets) can now understand quosures. Users can also use rlang::inject() to unquote a quosure for evaluation. This also means that render function no longer need env and quoted parameters; that information can be embedded into a quosure which is then passed to the render function. Better documentation was added for how to create render functions. (#3472)\nicon(lib=\"fontawesome\") is now powered by the fontawesome package, which will make it easier to use the latest FA icons in the future (by updating the fontawesome package). (#3302)\nClosed #3397: renderPlot() new uses ggplot2::get_alt_text() to inform an alt text default (for ggplot2 plots). (#3398)\nmodalDialog() gains support for size = \"xl\". (#3410)\nAddressed #2521: Updated the list of TCP ports that will be rejected by default in runapp.R, adding 5060, 5061 and 6566. Added documentation describing the port range (3000:8000) and which ports are rejected. (#3456)\n\n\n\nOther improvements\n\nShiny‚Äôs core JavaScript code was converted to TypeScript. For the latest development information, please see the README.md in ./srcts. (#3296)\nSwitched from digest::digest() to rlang::hash() for hashing. (#3264)\nSwitched from internal Stack class to fastmap::faststack(), and used fastmap::fastqueue(). (#3176)\nSome long-deprecated functions and function parameters were removed. (#3137)\n\n\n\nBug fixes\n\nClosed #3345: Shiny now correctly renders htmltools::htmlDependency()(s) with a list() of script attributes when used in a dynamic UI context. This fairly new htmlDependency() feature was added in htmltools v0.5.1. (#3395)\nFixed #2666 and #2670: nearPoints() and brushedPoints() weren‚Äôt properly account for missing values (#2666 was introduced in v1.4.0). (#2668)\nClosed #3374: quoToFunction() now works correctly with nested quosures; and as a result, quasi-quotation with rendering function (e.g., renderPrint(), renderPlot(), etc) now works as expected with nested quosures. (#3373)\nExported register_devmode_option(). This method was described in the documentation for devmode() but was never exported. See ?devmode() for more details on how to register Shiny Developer options using register_devmode_option(). (#3364)\nClosed #3484: In the RStudio IDE on Mac 11.5, selected checkboxes and radio buttons were not visible. (#3485)\n\n\n\nLibrary updates\n\nClosed #3286: Updated to Font-Awesome 5.15.2. (#3288)\nUpdated to jQuery 3.6.0. (#3311)"
  },
  {
    "objectID": "r/reference/shiny/1.7.2/upgrade.html#full-changelog",
    "href": "r/reference/shiny/1.7.2/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 1.7.2",
    "section": "Full changelog",
    "text": "Full changelog\n\nBreaking changes\n\nClosed #3626: renderPlot() (and plotPNG()) now uses ragg::agg_png() by default when the {ragg} package is installed. To restore the previous behavior, set options(shiny.useragg = FALSE). (#3654)\n\n\n\nNew features and improvements\n\nClosed #1545: insertUI() now executes &lt;script&gt; tags. (#3630)\nfileInput() can set the capture attribute to facilitates user access to a device‚Äôs media capture mechanism, such as a camera, or microphone, from within a file upload control (W3C HTML Media Capture). (Thanks to khaled-alshamaa, #3481)\nClosed tidyverse/dplyr#5552: Compatibility of dplyr 1.0 (and rlang chained errors in general) with req(), validate(), and friends.\nClosed tidyverse/dplyr#6154: Values from an actionButton() had S3 classes in the incorrect order.\nClosed #3346: Default for ref input in runGithub() changed from \"master\" to \"HEAD\". (#3564)\nClosed #3619: In R 4.2, splitLayout() no longer raises warnings about incorrect length in an if statement. (Thanks to @dmenne, #3625)\n\n\n\nBug fixes\n\nClosed #3250:rlang/{tidyeval} conditions (i.e., warnings and errors) are no longer filtered from stack traces. (#3602)\nClosed #3581: Errors in throttled/debounced reactive expressions no longer cause the session to exit. (#3624)\nClosed #3657: throttle.ts and the Throttler typescript objects it provides now function as intended. (Thanks gto @dvg-p4, #3659)\nThe auto-reload feature (options(shiny.autoreload=TRUE)) was not being activated by devmode(TRUE), despite a console message asserting that it was. (#3620)\nClosed #2297: If an error occurred in parsing a value in a bookmark query string, an error would be thrown and nothing would be restored. Now a message is displayed and that value is ignored. (Thanks to @daattali, #3385)\nRestored the previous behavior of automatically guessing the Content-Type header for downloadHandler functions when no explicit contentType argument is supplied. (#3393)\nPreviously, updating an input value without a corresponding Input binding element did not trigger a JavaScript shiny:inputchanged event. Now, if no Input binding element is found, the shiny:inputchanged event is triggered on window.document. (#3584)\nClosed #2955: Input and output bindings previously attempted to use el['data-input-id'], but that never worked. They now use el.getAttribute('data-input-id') instead. (#3538)\n\n\n\nMinor improvements\n\nWhen taking a test snapshot, the sort order of the json keys of the input, output, and export fields is currently sorted using the locale of the machine. This can lead to inconsistent test snapshot results. To opt-in to a consistent ordering of snapshot fields with shinytest, please set the global option options(shiny.snapshotsortc = TRUE). shinytest2 users do not need to set this value. (#3515)\nClosed rstudio/shinytest2#222: When restoring a context (i.e., bookmarking) from a URL, Shiny now better handles a trailing = after _inputs_ and _values_. (#3648)\nShiny‚Äôs internal HTML dependencies are now mounted dynamically instead of statically. (#3537)\nHTML dependencies that are sent to dynamic UI now have better type checking, and no longer require a dep.src.href field. (#3537)"
  },
  {
    "objectID": "r/reference/shiny/1.7.4/upgrade.html#full-changelog",
    "href": "r/reference/shiny/1.7.4/upgrade.html#full-changelog",
    "title": "Upgrade notes for Shiny 1.7.4",
    "section": "Full changelog",
    "text": "Full changelog\n\nBreaking changes\n\nClosed #3719: Output container sizes, which are available via session$clientData and getCurrentOutputInfo(), no longer round to the nearest pixel (i.e., they are now more exact, possibly fractional values). (#3720)\nClosed #3704, #3735, and #3740: renderPlot() no longer generates an error (or segfault) when it executes before the output is visible. Instead, it‚Äôll now use the graphics device‚Äôs default size for it‚Äôs initial size. Relatedly, plotPNG() now ignores NULL values for width/height (and uses the device‚Äôs default width/height instead). (#3739)\n\n\n\nNew features and improvements\n\nplotOutput(), imageOutput(), and uiOutput() gain a fill argument. If TRUE (the default for plotOutput()), the output container is allowed to grow/shrink to fit a fill container (created via htmltools::bindFillRole()) with an opinionated height. This means plotOutput() will grow/shrink by default inside of bslib::card_body_fill(), but imageOutput() and uiOutput() will have to opt-in to similar behavior with fill = TRUE. (#3715)\nClosed #3687: Updated jQuery-UI to v1.13.2. (#3697)\nInternal: Added clearer and strict TypeScript type definitions (#3644)"
  },
  {
    "objectID": "r/reference/shiny/1.8.0/upgrade.html#breaking-changes",
    "href": "r/reference/shiny/1.8.0/upgrade.html#breaking-changes",
    "title": "Upgrade notes for Shiny 1.8.0",
    "section": "Breaking changes",
    "text": "Breaking changes\n\nClosed #3899: The JS function Shiny.bindAll() is now asynchronous. This change is driven by the recent push toward making dynamic UI rendering asynchronous, which is necessary for shinylive (and should‚Äôve happened when it was first introduced in Shiny v1.7.5). The vast majority of existing Shiny.bindAll() uses should continue to work as before, but some cases may break if downstream code relies on it being synchronous (i.e., blocking the main thread). In this case, consider placing any downstream code in a .then() callback (or await the result in a async function). (#3929)\n\nSince renderContent() calls bindAll() (after it inserts content), it now returns a Promise&lt;void&gt; instead of void, which can be useful if downstream code needs to wait for the binding to complete."
  },
  {
    "objectID": "r/reference/shiny/1.8.0/upgrade.html#new-features-and-improvements",
    "href": "r/reference/shiny/1.8.0/upgrade.html#new-features-and-improvements",
    "title": "Upgrade notes for Shiny 1.8.0",
    "section": "New features and improvements",
    "text": "New features and improvements\n\nUpdated selectizeInput()‚Äôs selectize.js dependency from v0.12.4 to v0.15.2. In addition to many bug fixes and improvements, this update also adds several new plugin options. (#3875)\nShiny‚Äôs CSS styling (for things like showNotification(), withProgress(), inputPanel(), etc.), has been updated with bslib‚Äôs upcoming CSS-only dark mode feature in mind. (#3882, #3914)\nDefault styles for showNotification() were tweaked slightly to improve accessibility, sizing, and padding. (#3913)\nShiny inputs and htmlwidgets are no longer treated as draggable inside of absolutePanel()/fixedPanel() with draggable = TRUE. As a result, interactions like zooming and panning now work as expected with widgets like plotly and leaflet when they appear in a draggable panel. (#3752, #3933)\nFor InputBindings, the .receiveMessage() method can now be asynchronous or synchronous (previously it could only be synchronous). (#3930)"
  },
  {
    "objectID": "r/reference/shiny/1.8.0/upgrade.html#bug-fixes",
    "href": "r/reference/shiny/1.8.0/upgrade.html#bug-fixes",
    "title": "Upgrade notes for Shiny 1.8.0",
    "section": "Bug fixes",
    "text": "Bug fixes\n\nfileInput() no longer has unwanted round corners applied to the buttonLabel. (#3879)\nFixed #3898: wrapFunctionLabel() no longer throws an error if the name is longer than 10000 bytes. (#3903)"
  },
  {
    "objectID": "r/reference/shiny/1.9.0/upgrade.html#new-busy-indication-feature",
    "href": "r/reference/shiny/1.9.0/upgrade.html#new-busy-indication-feature",
    "title": "Upgrade notes for Shiny 1.9.0",
    "section": "New busy indication feature",
    "text": "New busy indication feature\nAdd the new useBusyIndicators() function to any UI definition to:\n\nAdd a spinner overlay on calculating/recalculating outputs.\nShow a page-level pulsing banner when Shiny is busy calculating something (e.g., a download, side-effect, etc), but no calculating/recalculating outputs are visible.\n\nIn a future version of Shiny, busy indication will be enabled by default, so we encourage you to try it out now, provide feedback, and report any issues.\nIn addition, various properties of the spinners and pulse can be customized with busyIndicatorOptions(). For more details, see ?busyIndicatorOptions. (#4040, #4104)"
  },
  {
    "objectID": "r/reference/shiny/1.9.0/upgrade.html#new-features-and-improvements",
    "href": "r/reference/shiny/1.9.0/upgrade.html#new-features-and-improvements",
    "title": "Upgrade notes for Shiny 1.9.0",
    "section": "New features and improvements",
    "text": "New features and improvements\n\nThe client-side TypeScript code for Shiny has been refactored so that the Shiny object is now an instance of class ShinyClass. (#4063)\nIn TypeScript, the Shiny object has a new property initializedPromise, which is a Promise-like object that can be awaited or chained with .then(). This Promise-like object corresponds to the shiny:sessioninitialized JavaScript event, but is easier to use because it can be used both before and after the events have occurred. (#4063)\nOutput bindings now include the .recalculating CSS class when they are first bound, up until the first render. This makes it possible/easier to show progress indication when the output is calculating for the first time. (#4039)\nA new shiny.client_devmode option controls client-side devmode features, in particular the client-side error console introduced in shiny 1.8.1, independently of the R-side features of shiny::devmode(). This usage is primarily intended for automatic use in Shinylive. (#4073)\nAdded function reactlogAddMark() to programmatically add _mark_ed locations in the reactlog log without the requirement of keyboard bindings during an idle reactive moment. (#4103)"
  },
  {
    "objectID": "r/reference/shiny/1.9.0/upgrade.html#bug-fixes",
    "href": "r/reference/shiny/1.9.0/upgrade.html#bug-fixes",
    "title": "Upgrade notes for Shiny 1.9.0",
    "section": "Bug fixes",
    "text": "Bug fixes\n\ndownloadButton() and downloadLink() are now disabled up until they are fully initialized. This prevents the user from clicking the button/link before the download is ready. (#4041)\nOutput bindings that are removed, invalidated, then inserted again (while invalidated) now correctly include the .recalculating CSS class. (#4039)\nFixed a recent issue with uiOutput() and conditionalPanel() not properly lower opacity when recalculation (in a Bootstrap 5 context). (#4027)\nImage outputs that were scaled by CSS had certain regions that were unresponsive to hover/click/brush handlers. (#3234)"
  },
  {
    "objectID": "r/reference/shiny/latest/upgrade.html#new-busy-indication-feature",
    "href": "r/reference/shiny/latest/upgrade.html#new-busy-indication-feature",
    "title": "Upgrade notes for Shiny 1.9.0",
    "section": "New busy indication feature",
    "text": "New busy indication feature\nAdd the new useBusyIndicators() function to any UI definition to:\n\nAdd a spinner overlay on calculating/recalculating outputs.\nShow a page-level pulsing banner when Shiny is busy calculating something (e.g., a download, side-effect, etc), but no calculating/recalculating outputs are visible.\n\nIn a future version of Shiny, busy indication will be enabled by default, so we encourage you to try it out now, provide feedback, and report any issues.\nIn addition, various properties of the spinners and pulse can be customized with busyIndicatorOptions(). For more details, see ?busyIndicatorOptions. (#4040, #4104)"
  },
  {
    "objectID": "r/reference/shiny/latest/upgrade.html#new-features-and-improvements",
    "href": "r/reference/shiny/latest/upgrade.html#new-features-and-improvements",
    "title": "Upgrade notes for Shiny 1.9.0",
    "section": "New features and improvements",
    "text": "New features and improvements\n\nThe client-side TypeScript code for Shiny has been refactored so that the Shiny object is now an instance of class ShinyClass. (#4063)\nIn TypeScript, the Shiny object has a new property initializedPromise, which is a Promise-like object that can be awaited or chained with .then(). This Promise-like object corresponds to the shiny:sessioninitialized JavaScript event, but is easier to use because it can be used both before and after the events have occurred. (#4063)\nOutput bindings now include the .recalculating CSS class when they are first bound, up until the first render. This makes it possible/easier to show progress indication when the output is calculating for the first time. (#4039)\nA new shiny.client_devmode option controls client-side devmode features, in particular the client-side error console introduced in shiny 1.8.1, independently of the R-side features of shiny::devmode(). This usage is primarily intended for automatic use in Shinylive. (#4073)\nAdded function reactlogAddMark() to programmatically add _mark_ed locations in the reactlog log without the requirement of keyboard bindings during an idle reactive moment. (#4103)"
  },
  {
    "objectID": "r/reference/shiny/latest/upgrade.html#bug-fixes",
    "href": "r/reference/shiny/latest/upgrade.html#bug-fixes",
    "title": "Upgrade notes for Shiny 1.9.0",
    "section": "Bug fixes",
    "text": "Bug fixes\n\ndownloadButton() and downloadLink() are now disabled up until they are fully initialized. This prevents the user from clicking the button/link before the download is ready. (#4041)\nOutput bindings that are removed, invalidated, then inserted again (while invalidated) now correctly include the .recalculating CSS class. (#4039)\nFixed a recent issue with uiOutput() and conditionalPanel() not properly lower opacity when recalculation (in a Bootstrap 5 context). (#4027)\nImage outputs that were scaled by CSS had certain regions that were unresponsive to hover/click/brush handlers. (#3234)"
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Shiny Blog",
    "section": "",
    "text": "Shiny Blog\n\nNews, tips, and commentary about all things Shiny.\n\n\n\n\n\n\n  \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Jul 22, 2024\n            \n\n            \n              Announcing Shiny for Python 1.0\n            \n\n            \n              Shiny for Python's level of quality, runtime stability, API and feature set make it ready for a big announcement.\n            \n\n            \n              Shiny Team\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Jul 19, 2024\n            \n\n            \n              shinyswatch v0.7.0\n            \n\n            \n              Customizable shinyswatch themes and an improved theme picker round out shinyswatch v0.7.0.\n            \n\n            \n              Garrick Aden-Buie\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              May 22, 2024\n            \n\n            \n              Reintroducing the Shiny Extension for VS¬†Code\n            \n\n            \n              The v1.0.0 release of the Shiny extension for VS Code now supports running both\nShiny for Python and Shiny for R apps, as well as new ShinyLive features.\n\n            \n\n            \n              Garrick Aden-Buie\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              May 9, 2024\n            \n\n            \n              Editable data tables in Shiny for Python 0.9.0\n            \n\n            \n              Editable data frames, empowered renderers, browser error console, and more in Shiny for Python 0.9.0.\n            \n\n            \n              Shiny Team\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Apr 5, 2024\n            \n\n            \n              Introducing Shiny for Python Templates\n            \n\n            \n              Get started quickly with Shiny for Python's new app templates.\n            \n\n            \n              Shiny Team\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Mar 27, 2024\n            \n\n            \n              Shiny for R updates: Extended tasks, JavaScript errors, and many bslib improvements\n            \n\n            \n              An overview of recent Shiny for R updates, including extended tasks, JavaScript errors, and many bslib improvements.\n\n            \n\n            \n              Carson Sievert\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Feb 26, 2024\n            \n\n            \n              Introducing Component and Layout Galleries for Shiny for Python\n            \n\n            \n              Qucikly see and choose Shiny for Python's Components and Layouts in these new galleries.\n            \n\n            \n              Daniel Chen, Sara Altman, Garrett Grolemund\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Jan 29, 2024\n            \n\n            \n              Introducing: Shiny Express\n            \n\n            \n              A brand new way to write Shiny apps in Python\n            \n\n            \n              Shiny Team\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Dec 22, 2023\n            \n\n            \n              Shiny for Python 0.6.1\n            \n\n            \n              Templates, an improved debugger, and a sneak peek at Shiny Express\n            \n\n            \n              Shiny Team\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Nov 30, 2023\n            \n\n            \n              Shiny for R updates: new default look, dark mode, shinylive updates, and more\n            \n\n            \n              An overview of recent Shiny for R updates, a new default look, dark mode, shinylive updates, and more.\n\n            \n\n            \n              Carson Sievert, Garrick Aden-Buie\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Nov 15, 2023\n            \n\n            \n              Shiny for Python 0.6.0\n            \n\n            \n              Fewer decorators, new page functions and, many new components\n            \n\n            \n              Shiny Team\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Oct 30, 2023\n            \n\n            \n              ShinyUiEditor: Out of Alpha\n            \n\n            \n              We're excited to announce that ShinyUiEditor, a drag-and-drop interface for building Shiny apps, is officially out of its \"alpha\" stage.\n            \n\n            \n              Nick Strayer\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Aug 16, 2023\n            \n\n            \n              Shiny for R updates: tooltips, popovers, a new theme, and more\n            \n\n            \n              An overview of recent Shiny for R updates, including tooltips, popovers, a new theme, and more.\n\n            \n\n            \n              Carson Sievert, Garrick Aden-Buie\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Aug 9, 2023\n            \n\n            \n              Shiny for Python 0.5.0\n            \n\n            \n              Style tweaks, table filtering, tooltips--and an appearance on the Talk Python podcast!\n            \n\n            \n              Joe Cheng\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Jun 28, 2023\n            \n\n            \n              Shiny for Python 0.4.0\n            \n\n            \n              Better tables and sidebars!\n            \n\n            \n              Winston Chang\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Jun 7, 2023\n            \n\n            \n              Towards easy, delightful, and customizable dashboards in Shiny for R with {bslib}\n            \n\n            \n              The {bslib} R package nows makes it very easy to make delightful and customizable dashboard in Shiny for R. This post walks through a Shiny app which quickly illustrates what's possible with these components.\n\n            \n\n            \n              Carson Sievert\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              May 12, 2023\n            \n\n            \n              AI chat apps with Shiny for Python\n            \n\n            \n              The easiest way to build an AI chat app.\n            \n\n            \n              Winston Chang\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              May 8, 2023\n            \n\n            \n              Shiny on Hugging Face\n            \n\n            \n              Deploy Shiny on Hugging Face with the click of a button\n            \n\n            \n              Gordon Shotwell\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Apr 18, 2023\n            \n\n            \n              Shiny for Python out of alpha\n            \n\n            \n              Shiny for Python has moved from alpha to general availability.\n            \n\n            \n              Winston Chang\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Mar 28, 2023\n            \n\n            \n              Shiny Conf 2023 Recap\n            \n\n            \n              Appsilon's Shiny Conf 2023 was a big success, with many incredible speakers (including 3 members of our team!)\n            \n\n            \n              Andrew Holz\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Mar 15, 2023\n            \n\n            \n              New to the ShinyUiEditor: bslib Cards!\n            \n\n            \n              The latest version of {shinyuieditor} includes the new card component from {bslib}. In this post, we describe how you can use these cards and a new static-text component to easily organize your app's content in a visually appealing way.\n            \n\n            \n              Nick Strayer\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Dec 20, 2022\n            \n\n            \n              Announcing new R Shiny UI components\n            \n\n            \n              The {bslib} R package recently added new user interface (UI) components, including (full-screen) Cards, Value Boxes, and a responsive column wrapping layout. Start using them today in Shiny, R Markdown, and/or Quarto.\n\n            \n\n            \n              Carson Sievert\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Dec 15, 2022\n            \n\n            \n              The Past and Future of Shiny\n            \n\n            \n              To celebrate Shiny's 10th anniversary, let's talk about how we started and where we're going.\n            \n\n            \n              Joe Cheng\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Apr 27, 2021\n            \n\n            \n              Weather App Story Pt. 3: Styling\n            \n\n            \n              The bslib package allows for extremely easy customization of your Shiny app's style using the bootstrap css framework. It also allows you to update theming in a running app to create dynamicly styled apps.\n            \n\n            \n              Nick Strayer\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Jan 22, 2021\n            \n\n            \n              Weather App Story Pt. 2: Caching\n            \n\n            \n              Here we demonstrate how the bindCache() function can greatly speed up a Shiny app with little effort.\n            \n\n            \n              Nick Strayer\n            \n          \n        \n      \n    \n    \n    \n      \n        \n\n          \n          \n            \n            \n          \n\n          \n            \n              Jan 4, 2021\n            \n\n            \n              Weather App Story Pt. 1: About\n            \n\n            \n              Functionality and architecture overview of the Weather Lookup app.\n            \n\n            \n              Nick Strayer\n            \n          \n        \n      \n    \n    \n\n\nNo matching items"
  },
  {
    "objectID": "blog/posts/shiny-python-0.9.0/index.html",
    "href": "blog/posts/shiny-python-0.9.0/index.html",
    "title": "Editable data tables in Shiny for Python 0.9.0",
    "section": "",
    "text": "Shiny for Python 0.9.0 is out! This version brings some exciting new features and improvements to the Shiny ecosystem. You can read the full changelog for a complete list of changes."
  },
  {
    "objectID": "blog/posts/shiny-python-0.9.0/index.html#editable-data-tables-and-data-grids",
    "href": "blog/posts/shiny-python-0.9.0/index.html#editable-data-tables-and-data-grids",
    "title": "Editable data tables in Shiny for Python 0.9.0",
    "section": "Editable Data Tables and Data Grids",
    "text": "Editable Data Tables and Data Grids\n\nOne of the most exciting new features in this release is the ability to make your DataTable and DataGrid components editable. By setting editable=True within DataGrid or DataTable, you can allow users to directly edit the cells in your tables. This opens up a whole new range of possibilities for interactive data applications!\nfrom shiny.express import render\n\n@render.data_frame\ndef dt():\n    return render.DataGrid(my_data, editable=True)\n\n@render.data_frame\ndef edited_dt():\n    return dt.data_view()"
  },
  {
    "objectID": "blog/posts/shiny-python-0.9.0/index.html#empowered-data-frame-renderer",
    "href": "blog/posts/shiny-python-0.9.0/index.html#empowered-data-frame-renderer",
    "title": "Editable data tables in Shiny for Python 0.9.0",
    "section": "Empowered Data Frame Renderer",
    "text": "Empowered Data Frame Renderer\nYou may have noticed in the previous example that we are now calling methods on the dt renderer object itself to access the edited data. This is part of a broader effort to empower the renderers with additional methods that make it easier to work with anything related to the renderer.\nTypically, we would retrieve this Output related information via the input object (e.g.¬†input.&lt;ID&gt;_&lt;KEY&gt;). This feels a little magical in that is just appears within the input object. There are no hints other than disconnected documentation on what input values are available or even what their values represent.\nUsing @render.data_frame decorator, we upgrade your render function into a Renderer class instance that has helper methods specific to the renderer. The Shiny Team is currently exploring what methods we can add to empower the data frame renderer. So far, the data frame renderer has been enhanced with these extra methods for you to reactively access computed values:\n\n.data() - Reactive value of the original data frame.\n.data_view(*, selected:bool = False) - Reactive value of the data frame with all applied edits, column filters, and column sorting. If selected=True, only the selected rows/columns are returned. \n.input_cell_selection() - Reactive value of the data frame‚Äôs selected cells. This returns a dictionary that contains type and possibly rows and columns that contain the selected row and column indices, respectively.\n.update_cell_selection(selection) - Method to update the selected cells of the data frame. The selection argument should be a dictionary that contains type and possibly rows and columns that contain the selected row and column indices, respectively. \n.set_patch_fn(fn) - Decorator to set a function that will be called when the user makes an edit to the data frame. The function should accept a single patch dictionary as an argument and return an upgraded value. \n\n(Link to data frame renderer helper methods and attributes.)\nBy adding the helper methods, we gain documentation, typing support, and an explicit way to access the data frame‚Äôs accessory information.\nWe‚Äôre excited about this approach and are looking at ways we can bring it to other outputs. Please let us know what you think!"
  },
  {
    "objectID": "blog/posts/shiny-python-0.9.0/index.html#changes-to-row-selection-with-data-tables-and-data-grids",
    "href": "blog/posts/shiny-python-0.9.0/index.html#changes-to-row-selection-with-data-tables-and-data-grids",
    "title": "Editable data tables in Shiny for Python 0.9.0",
    "section": "Changes to row selection with Data Tables and Data Grids",
    "text": "Changes to row selection with Data Tables and Data Grids\nIn addition to editability, we‚Äôve also made some changes to the way row selection works in these components. The row_selection parameter has been deprecated in favor of the new selection_mode parameter. You can now use selection_mode=\"row\" for single row selection or selection_mode=\"rows\" for multiple row selection.\nAlso note that the way to access which selected rows has changed. Previously, if your table output was named dt, then you would access the selected rows with input.dt_selected_rows(). As of 0.9.0, you instead should use dt.input_cell_selection()[\"rows\"].\n@render.data_frame\ndef dt():\n    return DataGrid(my_data)\n\n@reactive.effect\ndef _():\n  # Old way\n  selected_rows = input.dt_selected_rows()\n\n  # New in v0.9.0\n  selected_rows = dt.input_cell_selection()[\"rows\"]\nIn case you‚Äôre wondering, we are planning to add support for other types of selections, like columns and rectangular regions.\nUpdate: .input_row_selection() and input.&lt;ID&gt;_selected_rows() were prematurely removed in v0.9.0 and will be restored (as deprecated) in the next release."
  },
  {
    "objectID": "blog/posts/shiny-python-0.9.0/index.html#error-console",
    "href": "blog/posts/shiny-python-0.9.0/index.html#error-console",
    "title": "Editable data tables in Shiny for Python 0.9.0",
    "section": "Error Console",
    "text": "Error Console\nShiny for Python 0.9.0 includes an error console that surfaces client-side errors directly in the browser‚Äôs UI when running applications locally. The error console also catches common issues, such as duplicated input or output IDs, that can only be caught when the app is running.\n\nThe error console is enabled by default when you launch your app with shiny run or via the Shiny VS Code extension. The error console is automatically disabled when your app is deployed to a server, but can also be manually disabled with shiny run --no-dev-mode."
  },
  {
    "objectID": "blog/posts/shiny-python-0.9.0/index.html#shiny-express-in-quarto-dashboards",
    "href": "blog/posts/shiny-python-0.9.0/index.html#shiny-express-in-quarto-dashboards",
    "title": "Editable data tables in Shiny for Python 0.9.0",
    "section": "Shiny Express in Quarto Dashboards",
    "text": "Shiny Express in Quarto Dashboards\nShiny Express syntax is now supported within Quarto Dashboards! This makes it even easier to create interactive data dashboards with Shiny and Quarto.\n\n\nQuarto code\n\n---\ntitle: \"Palmer Penguins\"\nformat: dashboard\nserver: shiny\n---\n\n```{python}\n#| context: setup\nimport seaborn as sns\nfrom shiny.express import render, ui, input\npenguins = sns.load_dataset(\"penguins\")\n```\n\n# {.sidebar}\n\n```{python}\nspecies = list(penguins[\"species\"].value_counts().index)\nui.input_checkbox_group(\n    \"species\", \"Species:\",\n    species, selected = species\n)\n```\n\n# Plots\n\n```{python}\n@render.plot\ndef depth():\n    data = penguins[penguins[\"species\"].isin(input.species())]\n    return sns.displot(\n        data, x = \"bill_depth_mm\",\n        hue = \"species\", kind = \"kde\",\n        fill = True\n    )\n```"
  },
  {
    "objectID": "blog/posts/shiny-python-0.9.0/index.html#other-improvements",
    "href": "blog/posts/shiny-python-0.9.0/index.html#other-improvements",
    "title": "Editable data tables in Shiny for Python 0.9.0",
    "section": "Other Improvements",
    "text": "Other Improvements\nThe shiny create CLI command now includes additional templates and an option to open the new Shiny Templates website where you can find templates to quickly jump start your app. This makes it easier than ever to get started with Shiny for Python! üèéÔ∏èüí®\n\nLayout components have received several improvements in this release. The col_widths argument of ui.layout_columns() now sets the sm breakpoint by default, providing better responsiveness on smaller screens. ui.card() and ui.value_box() now have an id argument that allows you to track the full-screen state of these components. You can also now set min_height and max_height on ui.value_box(), ui.layout_columns(), and ui.layout_column_wrap() to ensure that your layouts always stay within a certain size range.\n\nWe‚Äôre thrilled to bring you these new features and improvements in Shiny for Python 0.9.0. As always, if you have any questions or feedback, please join us on Discord or open an issue on GitHub. Happy Shiny-ing!"
  },
  {
    "objectID": "getstarted.html",
    "href": "getstarted.html",
    "title": "Interact. Analyze. Communicate.",
    "section": "",
    "text": "Interact. Analyze. Communicate.\n\n\nTake a fresh, interactive approach to telling your data story with Shiny. Let users interact with your data and your analysis. And do it all with R or Python:\n\n  \n    \n      \n        \n         \n        \n        \n          Get Started in R\n        \n      \n    \n  \n  \n    \n      \n        \n         \n        \n        \n          Get Started in Python"
  },
  {
    "objectID": "r/reference/shiny/template/template.html",
    "href": "r/reference/shiny/template/template.html",
    "title": "TITLE_PLACEHOLDER",
    "section": "",
    "text": "CONTENT_PLACEHOLDER"
  },
  {
    "objectID": "r/articles/build/js-build-widget/index.html#introduction",
    "href": "r/articles/build/js-build-widget/index.html#introduction",
    "title": "How to build a JavaScript based widget",
    "section": "Introduction",
    "text": "Introduction\nShiny is a web application framework that makes it easy to build interactive web applications (apps) straight from R. A key feature of shiny is that users can create powerful apps driven by R without having to know HTML, CSS, or JavaScript. However, incorporating these technologies into your apps can greatly enhance the power of shiny.\nFurthermore, in recent years there has been a shift from using base R graphics to using interactive JavaScript web components for data analysis and data visualization. In order to use the functionality offered in these frameworks, we have to construct R bindings to JavaScript libraries.\nThe htmlwidgets package provides a framework for creating such bindings and allows you to bring the best of JavaScript into R using a set of easy-to-follow conventions. After a widget has been constructed, embedding it into a shiny app or R Markdown document only takes a few lines of code. For some examples on what htmlwidgets can do, take a look at the showcase on the htmlwidgets website.\nEven though using an htmlwidget is easy, constructing one may be challenging at first as you have to know a number of concepts in order to create a widget. These include things such as how to build an R package and how to use some basic JavaScript, CSS and HTML. However, you don‚Äôt need to be an expert in these things to create quite useful new functionality.\nThe tutorials below are intended for the intermediate shiny enthusiast with limited experience in HTML, CSS and/or JavaScript, who wants to learn how to extend shiny. A useful first step in this process is to be able to create your own htmlwidgets.\n\nCreating a dashboard app\nThe widgets we are going to build are all based on c3.js, which in turn is built on the more extensive JavaScript visualization library d3.js. C3.js provides a variety of chart types, such as gauges, pie charts, stacked bar charts, stacked area charts and charts to display time series. Furthermore, c3.js provides a variety of APIs and callbacks to access and update the state of a chart after it‚Äôs rendered.\nIn order to master the technique of creating widgets, we will construct an interactive dashboard application which includes a variety of htmlwidgets based on c3.js. A screenshot of the end result can be seen below. A live version of a more complete version of our dashboard can be seen here (this app is best viewed on a high res screen).\n\n\n\nthe end result of the tutorials\n\n\n\nDuring the tutorials that follow, we will gradually build more complex widgets with more functionality. The end result will be a fully functional dashboard. An advantage of using JavaScript over base R graphics is that we have access to various types of events e.g.¬†hover, click and drag events. For instance, the dashboard will have a nice brush-able timeline component.\n\n\n\n\na brush-able timeline which acts as a data filter\n\n\n\nThe timeline acts as a time based filter for all of the data in the other charts. In the tutorials, we will take a deeper look into the notion of sending data from the client to the server and back using shiny. This functionality will be based mainly around three pivotal functions: the JavaScript functions Shiny.onInputChange, Shiny.addCustomMessageHandler and the R Shiny function sendCustomMessage. A great introduction to these functions is offered in this blog post, and we will discuss each function in detail within the tutorials as well.\n\n\n\nDashboard data\nThe data in the dashboard represents data from an insurance company that screens persons who apply for a new insurance during underwriting. Underwriting is the process in which an insurance company assesses whether or not it should accept a person into their portfolio. If the risk for specific type of claims is deemed too high, the insurer may decide to reject an application. For the purposes of the tutorials, we use a toy dataset of 20,000 rows which looks like this:\n\n\n  id       date score result    branch   product    process    label\n1  1 2014-04-10     0  GREEN Generated Property      Claims    Phone\n2  2 2015-10-22    60  AMBER Generated Property     New car    Phone\n3  3 2015-11-10   150    RED    Damage Property  Acceptance Internet\n4  4 2015-11-06    25  GREEN    Damage Liability     Claims    Phone\n5  5 2014-09-29    10  GREEN    Damage      Pets Acceptance Internet\n6  6 2014-01-28     5  GREEN    Damage Property  New driver   Agency\n\n\nEach row represents a new screening. The column id provides a unique case, while the column date indicates the date at which a person was screened. The column score indicates the risk score estimated by the insurance company. Higher scores indicate that the person has a higher estimated probability to file a claim or to commit fraud somewhere in the future. The column result refers to a discretized version of the score column. For our dashboard this is the most important variable. Scores between 0 and 50 are mapped to GREEN, while scores from 51 to 75 are mapped to AMBER. Scores above 100 are mapped to RED, which indicates the highest risk group. The final four columns indicate the branch, product, process, and label associated with the policy application. The exact meaning of these categories depends on the insurer. Their main purpose is to help the insurer to process new policy applications more quickly.\nIn the screenshot above, the four gauges indicate the percentage of RED cases for a specific time period. You can select the percentages for different risk groups with the drop-down menu on the left. The four pie charts indicate the distribution of the screenings over the various processes, labels, product and branches. The bar + line chart is an example of a c3.js combination chart with dual y-axes and a single x-axis indicating time. The gray bars indicate the total number of screenings for each week (left y-axis), while the green, amber and red lines correspond to the percentage of cases which are estimated as GREEN, AMBER or RED, respectively (right y-axis). Finally, the bottom chart shows the same information, but this time as a stacked area chart. The toggle button on the left allows you to toggle between displaying percentages or absolute counts.\nFor each chart type, we‚Äôll create a separate htmlwidget. For the toggle button, we‚Äôll make a shiny input binding (see below).\n\n\nCreating a dynamic help system\nIn addition to teaching you how to create widgets, the tutorials will teach you how to create an interactive, dynamic help system, complete with animated transitions. The help system is based on another JavaScript library, intro.js. This library allows you to create a step-by-step guide for a website. It will draw a nice box around elements of your choice, combined with an annotation layer and a navigation system. Here‚Äôs an example of how the help will look for one of the gauges in the dashboard.\n\n\n\nthe help system\n\n\n\n\nCreating your own input binding\nWe end the tutorials with the creation of a custom input binding. Input bindings are components that capture events from the client, i.e.¬†the webpage, and send it to Shiny. A simple example of an input binding is an action button. It captures a click event from the user and sends it to shiny. Here, we‚Äôll create a nice looking toggle switch based on the bootstrap-switch JavaScript library. We‚Äôll use the switch to toggle a c3.js stacked area chart to display either absolute counts or percentages. Here‚Äôs an example of the switch we will be creating. Press the button and see what happens!\n\n\n\n\n\n\n\n\n\n\n\n\nan example of a custom input binding in the form of a toggle switch\n\n\n\n\nTutorial materials\nAll the content related to the examples below can be found on this GITHUB repo. GITHUB is a code hosting platform for version control and collaboration. You can find more information on GITHUB here. You can also download the tutorial materials as a single ZIP file. Over the course of the next months various additional tutorials will be made available in this repo.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to build a JavaScript based widget"
    ]
  },
  {
    "objectID": "r/articles/build/js-build-widget/index.html#stand-alone-examples",
    "href": "r/articles/build/js-build-widget/index.html#stand-alone-examples",
    "title": "How to build a JavaScript based widget",
    "section": "Stand alone examples",
    "text": "Stand alone examples\nWe will start with the most simple visualization c3.js offers: a gauge. Before involving R and shiny, we will make a simple stand alone JavaScript HTML version to show how the component and c3.js work in general.\nEach stand alone example is presented in a jsfiddle, which is a webpage where you can interactively run HTML, CSS and JavaScript code. By clicking ‚ÄúEdit in JSFiddle‚Äù in the panel below, you can alter the code and see what the effect of your change is. Working with fiddles is a great way to learn how a specific library or piece of code works. For example, by changing the value 75 on the first line of the JavaScript panel and clicking on the ‚ÄúRun‚Äù button in the left corner you will see the value of the gauge change.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to build a JavaScript based widget"
    ]
  },
  {
    "objectID": "r/articles/build/js-build-widget/index.html#recipe-to-construct-charts",
    "href": "r/articles/build/js-build-widget/index.html#recipe-to-construct-charts",
    "title": "How to build a JavaScript based widget",
    "section": "Recipe to construct charts",
    "text": "Recipe to construct charts\nWhat steps are needed to create a chart in HTML / JavaScript compared to R? It turns out that the typical steps are to:\n\ninclude library specific CSS and JavaScript files\ncreate a container element in which we can house the chart\nmake sure we have data in the right format to feed to the chart\nrender the chart in the container using library specific instructions\n\nand, optionally, to\n\nsend updates to the chart, e.g.¬†update its data or update parameters that alter the appearance of the chart",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to build a JavaScript based widget"
    ]
  },
  {
    "objectID": "r/articles/build/js-build-widget/index.html#a-first-example",
    "href": "r/articles/build/js-build-widget/index.html#a-first-example",
    "title": "How to build a JavaScript based widget",
    "section": "A first example",
    "text": "A first example\nLet start with a first example, let‚Äôs make a c3.js gauge chart! Here is the complete code for our first example:\n&lt;html&gt;\n&lt;head&gt;\n    &lt;link href=\"c3.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;div id=\"chart1\"&gt;&lt;/div&gt;\n\n&lt;script src=\"d3.v3.min.js\" charset=\"utf-8\"&gt;&lt;/script&gt;\n&lt;script src=\"c3.min.js\"&gt;&lt;/script&gt;\n\n&lt;script&gt;\nvar gaugeData = {data: 75};\n\nvar chart1 = c3.generate({\n  bindto: '#chart1',\n  data: {\n    json: gaugeData,\n    type: 'gauge',\n  },\n  gauge: {\n    min: 0,\n    max: 100\n  }\n});\n&lt;/script&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;\nThis code corresponds to example_01_gauge.html in the examples folder of this repository.\nLet‚Äôs break down this code into the steps stated in the previous section.\n\nstep 1\nIn our example, we include one CSS file and two JavaScript files. This happens at lines 3, 9 and 10, respectively. The CSS file describes how to style elements on the screen, while the JavaScript files implement the logic to render and update the charts.\n\n\nstep 2\nCreating a container element is easy, it can almost always be a simple div. The div tag defines a division or a section in an HTML document. This tag is one of the most common tags used in HTML pages. In our case, it looks like this\n&lt;div id=\"chart1\"&gt;&lt;/div&gt;\nHere we have given the div an id. The value of this id is unique and helps us to locate the element later on, for example when we assign CSS styles to the element.\nIn case you‚Äôre new to HTML and these terms are not yet familiar, don‚Äôt worry. It is not very hard to pick up a basic understanding of how HTML pages are structured, which elements exists and what they do. You may have to familiarize yourself with some new terminology though. In general, it greatly helps to have a basic understanding of HTML elements and CSS selectors such as ids and classes. Luckily, a basic understanding is often all you need. W3Schools offers a great set of quick, easy to understand tutorials on HTML, CSS and JavaScript.\nThe most important part here is this:\n\nWe want to be able to create elements on a page and to target them in order to be able to call a function on them, which will alter the state and content in that element.\n\n\n\nstep 3\nStep 3 is often the most difficult step. Besides data collection, cleaning and organizing, e.g.¬†using dplyr and tidyr, we must send data from shiny to the web browser. R, however, works with dataframes, vectors and lists, while JavaScript works with things like objects and arrays and often uses JSON to describe data.\nIn the end, whatever we use in R must be translated into something JavaScript understands. Unfortunately, each chart library has its own conventions on how the data should be represented. As a widget builder, it is your task to make the translation from R to JavaScript.\nIn the example above, the JavaScript data looks like this\nvar gaugeData = {data: 75};\nThe code creates a variable called gaugeData. gaugeData is an example of a JavaScript object that has a key / value pair, with a key called data and a value of 75.\nWhen we use R to set the value of the gauge to 75, we must make sure that the final data that is sent to the chart looks like this. In this case, the data representation we‚Äôre after is simple. However, in general this often is harder.\nInternally, shiny and htmlwidgets use the R package jsonlite to convert R data structures to JSON. For more information about jsonlite, take a look at the package vignette. Especially useful are the fromJSON and toJSON functions. The first tells you how an R object will be translated into JSON, while the latter does the reverse. Just play around to see how it works!\nFor a quick example in R, run this:\n\nif (!require(\"jsonlite\"))\n  install.packages(\"jsonlite\")\n\nlibrary(jsonlite)\ntoJSON(list(data = 75))\n\n{\"data\":[75]} \n\n\n\n\nstep 4\nAt this point, we have included the required CSS and JavaScript scripts, set up a container element with an id equal to chart1 and have constructed a JSON dataset called gaugeData. We are now ready to construct the chart.\nUnfortunately, different chart libraries use different conventions to set up charts, so the code you see below will be very specific to c3.js. However, learning this example will help you to understand other libraries as well. The important part is that you understand which steps are needed, not specifically what syntax is used. Remember, a good chart library already makes it easy to construct a chart, and given some examples, the syntax is often easy to master. Luckily, c3.js comes with many examples. For some inspiration take a look at these!\nAll c3.js components are initialized by calling the function c3.generate. This function takes a single object as its argument, which supplies c3 with all of the information that it requires to generate the component. In the example above, the relevant code chunk looks like this:\nvar chart1 = c3.generate({\n  bindto: '#chart1',\n  data: {\n    json: gaugeData,\n    type: 'gauge',\n  },\n  gauge: {\n    min: 0,\n    max: 100\n  }\n});\nThe first item in this object is bindto which tells c3 which element on the HTML page we want to target to put the component into. Here, the value is #chart1. This string is an example of what‚Äôs known as a CSS selector. The # symbol is CSS syntax which tells the browser to select an element from the HTML page that has the value that comes after # symbol as its id.\nNext we pass in the previously constructed JavaScript variable gaugeData, which holds the data for the chart.\nvar gaugeData = {data: 75};\nHere the data is provided as a key value pair with the name ‚Äòdata‚Äô and value 75. Naming the data is not required for the gauge, but the data will need to be named when we extend the visual later on. In actual widgets, the data is usually passed from R to the browser by shiny, which internally relies on the R library jsonlite. In the example above, however, we manually created the data object.\nIn the code chunk below, we pass the variable that holds the data and tell c3 that we want to construct a chart of type ‚Äògauge‚Äô\ndata: {\n  json: gaugeData,\n  type: 'gauge'\n}\nC3 has different ways of providing components with data (see here). In our examples we typically pick the JSON format as shiny uses jsonlite to convert R data structures to JSON (see above).\nFinally, we supply the component with some gauge specific options which in this example are the minimum and maximum values of the gauge.\ngauge: {\n  min: 0,\n  max: 100\n}",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to build a JavaScript based widget"
    ]
  },
  {
    "objectID": "r/articles/build/js-build-widget/index.html#extending-the-gauge",
    "href": "r/articles/build/js-build-widget/index.html#extending-the-gauge",
    "title": "How to build a JavaScript based widget",
    "section": "Extending the gauge",
    "text": "Extending the gauge\nA desirable aspect of a well designed widget is the possibility to update the data in the widget after we have constructed the chart. You can do this from Shiny, but before we look at that, let‚Äôs examine how to update the widget with JavaScript. We‚Äôll extend our first example by updating the data via JavaScript. We‚Äôll set some additional style properties to our gauge that did not appear in the previous example, and we will repeatedly change its value via a timer.\nIn the example below, we see C3.js nicely animates the transition from one value to another. For this to happen, we need to know both the current state of the gauge and the new state we want the gauge to be in.\n\n\nHere‚Äôs the code for the complete example:\n&lt;html&gt;\n&lt;head&gt;\n    &lt;!-- required css style file for C3.js --&gt;\n    &lt;link href=\"c3.min.css\" rel=\"stylesheet\" type=\"text/css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;!-- container element in which we will create the chart --&gt;\n&lt;div id=\"chart1\"&gt;&lt;/div&gt;\n\n&lt;!-- required javascript libraries--&gt;\n&lt;script src=\"d3.v3.min.js\" charset=\"utf-8\"&gt;&lt;/script&gt;\n&lt;script src=\"c3.min.js\"&gt;&lt;/script&gt;\n\n&lt;!-- javascript block to render and update the chart--&gt;\n&lt;script&gt;\n\n    var gaugeData = {'data': 80.0}\n\n    // create a chart and set options\n    // note that we bind the chart to the element with id equal to chart1 via the c3.js API\n    var chart = c3.generate({\n        bindto: '#chart1',\n        data: {\n            json: gaugeData,\n            type: 'gauge',\n        },\n        gauge: {\n            label:{\n                //returning the value here and not the ratio\n                format: function(value, ratio){ return value;}\n            },\n            min: 0,\n            max: 100,\n            width: 15,\n            units: 'value' //this is only the text for the label\n        }\n    });\n\n    // this function will update every 2000 milliseconds\n    // and create a new value between 0 and 100\n    setInterval(function () {\n\n        // create a random value between 0 and 100, rounded to 2 digits\n        var newValue = Math.floor(100 * Math.random());\n\n        // create a data array holding the random value\n        var newData = {'data', newValue };\n\n        // tell the chart to load the new data\n        chart.load({\n          json: newData\n        });\n    }, 2000);\n\n\n&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;\nThis code corresponds to ‚Äúexample_02_gauge.html‚Äù in the examples folder of this repository. As we can see, the call to c3.generate is a bit more involved. With respect to the specific options used, we refer to the c3.js examples and reference for details.\nIn the example above, we wrapped the code to update the value of the gauge into another function, called setInterval. SetInterval is a standard JavaScript function that repeatedly executes a given function every ms milliseconds:\nsetInterval( functionDefinition , ms );\nIn our case the complete function call looks like this\nsetInterval(function () {\n\n    // create a random value between 0 and 100, rounded to 2 digits\n    var newValue = Math.floor(100 * Math.random());\n\n    // create a data array holding the random value\n    var newData = { 'data': newValue };\n\n    // tell the chart to load the new data\n    chart.load({\n      json: newData\n    });\n  }, 2000);\nHere we supplied the function we want to be executed as a so called anonymous function, which means we directly pass in the function definition without assigning it a name. Another way would be to first create a named function and then to pass the name of that function as a first argument to setInterval.\nInside the anonymous function we draw a random number and use it to create a new data object, using the same name as before i.e.¬†‚Äòdata‚Äô.\n// create a random value between 0 and 100, rounded to 2 digits\nvar newValue = Math.floor(100 * Math.random());\n\n// create a data array holding the random value\nvar newData = { 'data': newValue };\nFinally, we tell c3.js to load the new data to the already existing gauge.\nchart.load({\n  json: newData\n});\nNote that c3 automagically transitions the chart from the old state to the new state! The transition duration can be changed, which defaults to 350 milliseconds.\nIn JavaScript terms, the function load in the previous code block is called a method , which is called on the object chart. You can think of methods as special functions that are part of a JavaScript object. Typically, methods perform actions on objects, e.g.¬†to set or retrieve values. C3 has many methods depending on the specific chart, see here for a complete overview.\nAt this stage we have covered all ingredients to make a fully functional gauge. Time to create a real htmlwidget!",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to build a JavaScript based widget"
    ]
  },
  {
    "objectID": "r/articles/build/js-build-widget/index.html#creating-the-widget",
    "href": "r/articles/build/js-build-widget/index.html#creating-the-widget",
    "title": "How to build a JavaScript based widget",
    "section": "Creating the widget",
    "text": "Creating the widget\nWe are now back in the R world!\nIn order to create htmlwidgets, we need the htmlwidgets and devtools packages. In case you don‚Äôt have these installed already, please run:\ninstall.packages(\"htmlwidgets\")\ninstall.packages(\"devtools\")\nNext, load the packages into R:\nlibrary(\"htmlwidgets\")\nlibrary(\"devtools\")\nIn order to create an htmlwidget, we need to create an R package. This is where devtools comes in. In case you‚Äôre new to R package building, please see here for a proper introduction.\nLuckily, the devtools and htmlwidget packages make it very easy to create a new package and to set up a basic skeleton for our widget. The next code chunk creates a new R package that contains template code which we can use to build our widget:\n# create package using devtools\ndevtools::create(\"C3\")\n\n# navigate to package dir\nsetwd(\"C3\")\n\n# create widget scaffolding\nscaffoldWidget(\"C3Gauge\", edit = FALSE)\n\n# install package so we can test it\ninstall()\nAt first these steps may appear a bit technical, as might the explanation stated below. Don‚Äôt worry, soon these steps become second nature once you have created a few widgets.\nThe scaffoldWidget function is the function which creates the actual template. With the first argument, we specify the name we want our widget to have i.e.¬†C3Gauge. We set the edit argument to FALSE because for now we do not want the created files to be opened.\nAfter executing the above code, we now have a dummy widget that creates a simple div on the page with dynamic text in it.\nTo check if everything works, we install our newly created package. The next code snippet loads the package we just created and runs the template code which should display a simple ‚Äúhello world!‚Äù message in the viewer pane in RStudio.\nlibrary(C3)\nC3Gauge(\"hello, world\")\n\nOk, what just happened?\nThe previous sequence generated a number of folders and files for us in the current working directory.\ndevtools::create(\"C3\")\nFirst, the call to create generates a C3 folder in our working directory, which includes an empty R folder and some additional files required to create an R package. This command is similar (though not identical) to creating a package via the RSTUDIO file menu.\nscaffoldWidget(\"C3Gauge\",edit=FALSE)\nNext, scaffoldWidget creates three more files being\n\nan R file, see R/C3Gauge.R\na yaml file, see inst/htmlwidgets/C3Gauge.yaml\na JavaScript file, see inst/htmlwidgets/C3Gauge.js\n\nInside our C3 folder we can see that R generated an ‚ÄúR‚Äù folder and an ‚Äúinst‚Äù folder. The ‚Äúinst‚Äù folder is a generic R package folder where all external package dependencies are stored. We use this whenever we want to include files in our package.\nWithin the ‚Äúinst‚Äù folder an ‚Äúhtmlwidget‚Äù sub folder is created. Here you‚Äôll find the following files:\n\nC3Gauge.js: This file contains the client side code of our binding. In our case, this will be the JavaScript code described in the above examples extended with some extra logic to handle data coming from R.\nC3Gauge.yaml: This file lists all dependencies and their location in the folder structure for the widget.\n\nThe ‚ÄúR‚Äù folder contains the file ‚ÄúC3Gauge.R‚Äù, which contains a template function ‚ÄòC3Gauge‚Äô (see below).\n\n\nIncluding external dependencies\nBefore we can create our gauge, we need to include several external dependencies i.e.¬†we need to include c3.min.js, c3.min.css and d3.v3.min.js from the extended gauge example (see above).\nTo separate external code dependencies from our widget code, it is often convenient to create a separate ‚Äúlib‚Äù folder in which we copy all external dependencies. As a first step, manually create a ‚Äúlib‚Äù folder in the ‚Äúhtmlwidgets‚Äù folder. Then, unzip the content of this ZIP file into the ‚Äúlib‚Äù folder. The ZIP file contains c3.min.js, c3.min.css and d3.v3.min.js and makes sure that everyone who creates this widget uses the same version of these files. A more advanced way of including such dependencies is to use bower (see the bowerPkg argument in scaffoldWidget).\nThe next step is to edit the C3Gauge.yaml file R created for us. This file specifies the external dependencies we want to use and their location within the /inst folder. In our case, the yaml file we‚Äôre after looks like this:\ndependencies:\n- name: d3\n  version: 3.5.16\n  src: htmlwidgets\n  script: ./lib/d3.v3.min.js\n- name: c3\n  version: 0.4.10\n  src: htmlwidgets\n  script: ./lib/c3.min.js\n  style: ./lib/c3.min.css\nYou can copy/paste the above chunk into the C3Gauge.yaml file R created for us. Of note, the yaml file is sensitive to the way you indent it, so make sure you use the correct number of spaces. We have now set up everything to create our first widget!\n\n\nStep I: writing JavaScript code for our widget\nIn order to create our widget, we have to write some JavaScript code inside a JavaScript template file that R automatically created. More specifically, we need to replace some of the dummy code R generated for us and fill in the details of our chart functions in HTMLWidgets.widget. Let‚Äôs take a closer look at the C3Gauge.js template code that R just generated:\nHTMLWidgets.widget({\n\n  name: 'C3Gauge',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // TODO: define shared variables for this instance\n\n    return {\n\n      renderValue: function(x) {\n\n        // TODO: code to render the widget, e.g.\n        el.innerText = x.message;\n\n      },\n\n      resize: function(width, height) {\n\n        // TODO: code to re-render the widget with a new size\n\n      }\n\n    };\n  }\n});\nIn HTMLWidgets.widget we have to give our component a name and we have to define the function factory. Currently, the value of ‚Äòtype‚Äô can only have a single value being ‚Äúoutput‚Äù. In this tutorial we take a shortcut and only implement a naive version of the renderValue function. Luckily, c3.js handles re-sizing automatically, so we don‚Äôt have to tell our widget what to do in case its container element changes size i.e.¬†we don‚Äôt explicitly have to write a resize function.\nAs a first step, let‚Äôs copy the code from our previous JavaScript example in the renderValue function. For the moment let‚Äôs not worry how JavaScript gets its data from R.\n      renderValue: function(x) {\n\n        var gaugeData = {'data': 80.0};\n\n        // create a chart and set options\n        // note that via the c3.js API we bind the chart to the element with id equal to chart1\n        var chart = c3.generate({\n            bindto: el,\n            data: {\n                json: gaugeData,\n                type: 'gauge',\n            },\n            gauge: {\n                label:{\n                    //returning here the value and not the ratio\n                    format: function(value, ratio){ return value;}\n                },\n                min: 0,\n                max: 100,\n                width: 15,\n                units: 'value' //this is only the text for the label\n            }\n        });\n\n      },\nIf we re-install our package, reload the library and execute the C3Gauge function, we can see the example is rendered in R.\ndevtools::install()\nlibrary(C3)\nC3Gauge(\"\")\nHooray, you just created your first c3 gauge widget!\n\n\nStep II: writing R code for our widget\nWe now have a gauge we can render from R. However, we can‚Äôt yet set the value of the gauge from R! In order to do so we have to adjust the code inside C3Gauge.R, another file R automatically created for us:\nC3Gauge &lt;- function(message, width = NULL, height = NULL) {\n\n  # forward options using x\n  x = list(\n    message = message\n  )\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'C3Gauge',\n    x,\n    width = width,\n    height = height,\n    package = 'C3'\n  )\n}\nBy default this function is created with three arguments: message, width and height.\nIn the template code R generated, the message argument is any data that is passed on to the renderValue function in the C3Gauge.js code.\nThe body of C3Gauge consists of two parts. First, a list called x is created which will contain all data passed on to the widget. This can be a single value, a data.frame or a complex list holding all sorts of things. Next, the createWidget function is called with a name, our data x, the widget width, height and package, the name of the package our widget is in.\nIf we look back at how we initialized our data in the stand alone examples, we can see the gauge wants the data to be in the following JavaScript format:\n{'data': 80.0}\nBy default htmlwidgets uses the toJSON function from the jsonlite package to convert data from R to the JSON format. As stated in the previous sections, often it takes a bit of experimentation to see which R structure results in the correct JSON when passed via jsonlite::toJSON(). It turns out in this case we need:\nx &lt;- list(data=80)\nIndeed, a call to jsonlite::toJSON(x) shows that this becomes the JavaScript below:\n{\"data\":[80]}\nThe added brackets simply mean that the data has become a one dimensional array, which is equivalent to a single value.\nThus, in order to get the data in the form above, we only have to rename the message to data in the C3Gauge function inside C3Gauge.R which gives us the JSON object we want:\n# forward options using x\nx = list(\n  data = message\n)\nIn C3Gauge.js, we have to make one modification: we remove the line where we create gaugeData. Instead of passing the static gaugeData to the C3 generate function, we pass on our list created in R. In other words, we change the line where our data is specified to the following:\njson: x\nWe now have specified all the code segments we need for a first gauge widget whose value we can specify with R!\nIn summary, the complete code in C3Gauge.R now looks like this:\n#' &lt;Add Title&gt;\n#'\n#' &lt;Add Description&gt;\n#'\n#' @import htmlwidgets\n#'\n#' @export\nC3Gauge &lt;- function(message, width = NULL, height = NULL) {\n\n  # forward options using x\n  x = list(\n    data = message\n  )\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'C3Gauge',\n    x,\n    width = width,\n    height = height,\n    package = 'C3'\n  )\n}\nwhile the code in C3Gauge.js looks like this:\nHTMLWidgets.widget({\n\n  name: 'C3Gauge',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // TODO: define shared variables for this instance\n\n    return {\n\n       renderValue: function(x) {\n\n        // create a chart and set options\n        // note that via the c3.js API we bind the chart to the element with id equal to chart1\n        var chart = c3.generate({\n            bindto: el,\n            data: {\n                json: x,\n                type: 'gauge',\n            },\n            gauge: {\n                label:{\n                    //returning here the value and not the ratio\n                    format: function(value, ratio){ return value;}\n                },\n                min: 0,\n                max: 100,\n                width: 15,\n                units: 'value' //this is only the text for the label\n            }\n        });\n\n      },\n\n      resize: function(width, height) {\n\n        // TODO: code to re-render the widget with a new size\n\n      }\n\n    };\n  }\n});\n\nThe next code chunk renders a gauge with a value of 50:\ndevtools::install()\nlibrary(C3)\nC3Gauge(50)\nWe can also use our widget in a shiny context. The following code produces an app with a single gauge, whose value you can update by pressing the action button.\nlibrary(C3)\nlibrary(shiny)\n\nrunApp(list(\n  ui = bootstrapPage(\n    actionButton(\"update\",\"update gauge\"),\n\n    # example use of the automatically generated output function\n    C3GaugeOutput(\"gauge1\")\n  ),\n  server = function(input, output) {\n\n    # reactive that generates a random value for the gauge\n    value = reactive({\n      input$update\n      round(runif(1,0,100),2)\n    })\n\n    # example use of the automatically generated render function\n    output$gauge1 &lt;- renderC3Gauge({\n      # C3Gauge widget\n      C3Gauge(value())\n    })\n  }\n))\nIn case you just want run the above example app without performing all the steps described above, run the following command in R which installs a more complete version of our C3 gauges, described in the next tutorial:\ndevtools::install_github(\"FrissAnalytics/shinyJsTutorials/widgets/C3\")",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to build a JavaScript based widget"
    ]
  },
  {
    "objectID": "r/articles/build/js-build-widget/index.html#next-tutorial",
    "href": "r/articles/build/js-build-widget/index.html#next-tutorial",
    "title": "How to build a JavaScript based widget",
    "section": "Next tutorial",
    "text": "Next tutorial\nIn the next tutorial, we‚Äôll create a new version of our gauge widget that updates its value via a smooth transition, similar to the one demonstrated in the stand alone examples, by changing the renderValue method in the above JavaScript code. In addition, we‚Äôll elaborate on related JavaScript concepts such as closures, events and objects. Next to an extended gauge, we‚Äôll create widgets for a c3 pie chart, line bar chart and stacked area chart; and we will send events from these charts to shiny and back to the browser.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to build a JavaScript based widget"
    ]
  },
  {
    "objectID": "r/articles/build/js-widget-functionality/index.html#introduction",
    "href": "r/articles/build/js-widget-functionality/index.html#introduction",
    "title": "How to add functionality to JavaScript widgets",
    "section": "Introduction",
    "text": "Introduction\nIn the previous tutorial, we created a simple C3 based gauge widget. In this tutorial, we expand the widget to create smooth transitions like those in the showcase dashboard app. We also provide code and examples for the other charts types shown in the dashboard: a pie chart, a line + bar chart and a stacked area chart. In this tutorial, we focus on pairing charts and data in such a way that C3 can animate the transition between old and new data.\n\n\n\nexample of a gauge with animated transitions between old and new data\n\nBefore we do all that, let‚Äôs take a better look at the HTMLWidgets.widget function we saw in the first tutorial, which is related to the concept of factory methods and closures.\n\nFactory methods and closures\nIn the previous tutorial, we saw that the skeleton of our widget initially looks like this\nHTMLWidgets.widget({\n\n  name: 'C3Gauge',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // TODO: define shared variables for this instance\n\n    return {\n\n      renderValue: function(x) {\n\n        // TODO: code to render the widget, e.g.\n        el.innerText = x.message;\n\n      },\n\n      resize: function(width, height) {\n\n        // TODO: code to re-render the widget with a new size\n\n      }\n\n    };\n  }\n});\nIf you are new to JavaScript, this code may look a bit strange. We see that factory is a method, but the return type is not a simple value. What‚Äôs with that?\nThe construction above is a design pattern that software engineers call a factory method. This pattern contains a method that returns an object instance. That may sound complicated, so let‚Äôs dig a little deeper to see what it means.\nIn more general terms, a factory method like this:\nfactory: function () {return {\n  a: function() { ... },\n  b: function() { ... }\n}};\nis equivalent to:\n// factory is a method of some object\nfactory: function () {\n\n  // define a new object\n  var obj = new Object();\n\n  // create a method a for it\n  obj.a = function() { ... };\n\n  // create a method b for it\n  obj.b = function() { ... };\n\n  // return the object instance\n  return obj;\n}\nHence, in our case, the factory method in HTMLWidgets.widget returns an object of the widget instance. This object itself has two methods i.e.¬†renderValue, which draws our widget, and resize, which resizes the widget (if necessary).\nIn the implementation above, renderValue and resize are both implemented as closures, which means that the functions remember the scope they were created in and have access to the variables defined in that scope. A more in depth discussion on JavaScript closures is offered here. Of note, the concept of closures also exists in R, see here.\nThe implication of renderValue and resize being closures is that they have access to the el, width and height parameters passed to factory. Furthermore, we can initialize variables in the body of factory (above the definitions of renderValue and resize) that we want to use during the lifetime of our widget.\nNow that we have a better understanding of what our HTMLWidgets.widget function is doing, let‚Äôs add some transitions to our gauge widget!",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to add functionality to JavaScript widgets"
    ]
  },
  {
    "objectID": "r/articles/build/js-widget-functionality/index.html#adding-transitions-to-a-c3-gauge",
    "href": "r/articles/build/js-widget-functionality/index.html#adding-transitions-to-a-c3-gauge",
    "title": "How to add functionality to JavaScript widgets",
    "section": "Adding transitions to a C3 gauge",
    "text": "Adding transitions to a C3 gauge\nEven though the gauge widget from the first tutorial works, we can improve it. The current widget always creates a completely new gauge if we send it a value via shiny (using the renderC3Gauge function, see tutorial 1). It would be nicer if the widget used an animation to smoothly transition from its old state to its new state, as in the example at the top of the page. Luckily, C3 can create such transitions automatically. To take advantage of this, we will have to modify the code of our factory method.\nIn pseudo code, our new factory method will looks something like this:\nfactory: function(el, width, height){\n\n  // we can define any variables we wish to use to keep track of the state of the widget here\n  // lets create an empty chart\n  var chart = null;\n\n  return {\n      renderValue: function(x) {\n\n        // check if the chart exists\n        if(chart === null){\n\n           // the chart did not exist and we want to create a new chart\n           chart = createChart(x);\n\n           // store the chart on el so we can get it later\n           el.chart  = chart;\n        }\n\n        // at this stage the chart always exists\n        // get the chart stored in el and update it\n        el.chart.updateChart(x);\n\n      }\n  }\n}\nTo understand the pseudo code, it is helpful to realize that there are two basic stages in the lifetime of a chart:\n\nthe chart does not yet exist\nthe chart already exists and we want to pass in new data, set options or send messages to it\n\nThe factory method has three arguments: el, width and height. Here el is the container element created by htmlwidgets in which we will house our chart. On top, we create a variable called chart, which we initially set to null, indicating that the chart does not yet exist.\nInside the renderValue method, we first check if the chart exists. If the chart does not exist, we create a chart via the toy function createChart, which in this case uses information in x. Subsequently, we store the chart on el, so we can access it later.\nTechnically, the closure allows us to render the chart even in the first line, i.e.¬†at the line var chart = null;. In C3, however, we often need information stored in x to create a chart. Note that x contains the data and chart options passed via shiny from R to JavaScript (using jsonlite, see tutorial 1). As C3 often needs information in x during initialization, here we initialize the chart inside the renderValue method and subsequently check if the chart was already created. This is slightly inelegant, however, it is quite easy and the overhead is minimal.\nNote that the chart will exist in all subsequent calls to renderValue. In those instances, we first retrieve the chart via el, which we can access because renderValue is a closure. Second, we call an update method on the chart, which will again use information stored in x.\nLet‚Äôs convert the previous pseudo code into actual code for our gauge!\nThe next JavaScript code block shows how we can load new data into a C3 based chart created via c3.generate.\nvar chart = c3.generate({\n  // chart code here\n  ...\n});\n\n// some data\nvar newData = 50;\n\n// load data into the chart\nchart.load({\n  json: newData\n});\nIf we combine this code snippet with the previous factory pseudo code we end up with the code we‚Äôre looking for:\nHTMLWidgets.widget({\n\n  name: 'C3Gauge',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // create an empty chart\n    var chart = null;\n\n    return {\n\n      renderValue: function(x) {\n\n        // check if the chart exists\n        if(chart === null){\n\n          // the chart did not exist and we want to create a new chart via c3.generate\n          chart = c3.generate({\n                bindto: el,\n                data: {\n                    json: x,\n                    type: 'gauge',\n                },\n                gauge: {\n                    label:{\n                        format: function(value, ratio){ return value;}\n                    },\n                    min: 0,\n                    max: 100,\n                    width: 15,\n                    units: 'value'\n                }\n            });\n\n          // store the chart on el so we can get it later\n          el.chart = chart;\n        }\n\n        // at this stage the chart always exists\n        // get the chart stored in el and update it\n        el.chart.load({json: x});\n\n      }\n    };\n  }\n});\nOf note, for brevity here we omitted the resize method (which is optional).\n\nCode repository and demo app\nYou can find the complete code for the updated gauge widget, as well as the code for the widgets below at this repo, which contains a C3 package. The C3 package contains updated code for the gauge widget, a pie chart widget, a combination bar + line chart and a stacked area chart. The code of the latter three widgets is discussed in detail below. The R code of these widgets can be found here. The JavaScript and YAML files for each widget are located here.\nYou can install the updated C3 package by running the following command in R:\ndevtools::install_github(\"FrissAnalytics/shinyJsTutorials/tutorials/materials2/C3\")\nIn order to help you understand the various C3 widgets in this tutorial, we‚Äôve built a shiny C3 demo app that shows how you can use these widgets in a shiny context. You can download this dashboard here. To see the app in action press the screenshot below! In the next tutorials we will extend the capabilities of these widgets even further when we take a closer look at JavaScript events.\n\n\n\ndemo app with animated C3 widgets. Click on the image to launch the app!\n\n\nWe show you how to create the widgets below, which you can subsequently render with C3Gauge,C3Pie,C3LineBarChart, and C3StackedAreaChart.\nIn a shiny app (in ui.r), these functions are paired with the output functions: C3GaugeOutput, C3PieOutput, C3LineBarChartOutput, C3StackedAreaChartOutput, and (in server.R) with the render functions: renderC3Gauge, renderC3Pie, renderC3LineBarChart, renderC3StackedAreaChart.\nNote that you can also use the widgets in a Markdown document as well!\nYou can also experiment with code changes right in the browser with an online htmlwidget fiddle app, as discussed in the next section.\n\n\nHtmlwidget fiddle app\nIt can become a bit cumbersome to build, install and load a package each time you want to test something, especially if you just want to play around with an example and experiment to find out how something works. For the purpose of this tutorial series, we created a small helper online app similar to a JavaScript fiddle. You can use the app to change code and immediately see the impact. You can find the online app here.\n\n\n\nhtmlwidget fiddle app. Play with C3 code & create a package right from the browser!\n\n\n\nAbout the app\nAll widgets in this tutorial series are available in the app. You can select a widget in the drop-down list after which its JavaScript code, R code, and YAML contents are loaded in the corresponding tabs. You can then play around with code changes and see the effect by pressing the ‚Äòrender widget‚Äô button. In the Widgetcall tab, you can add your own data and provide the widget render call.\nYou can also export the code as a zipped R package, which can be installed by opening the .Rproj file in RStudio and running devtools::install(). Currently, the functionality of this app is limited to rendering C3 based charts. We plan to update the functionality of this app during the course of the tutorial series, i.e.¬†by allowing you to add additional JavaScript and CSS files.\nNow we‚Äôre all set, let‚Äôs make some more widgets!",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to add functionality to JavaScript widgets"
    ]
  },
  {
    "objectID": "r/articles/build/js-widget-functionality/index.html#c3-data-update-pattern",
    "href": "r/articles/build/js-widget-functionality/index.html#c3-data-update-pattern",
    "title": "How to add functionality to JavaScript widgets",
    "section": "C3 data update pattern",
    "text": "C3 data update pattern\nThe gauge is by far the most simple visualization C3 offers. More complex charts require more complex data objects. In C3, each data series is associated with a unique key. These keys help us to keep track of which data series are in the chart, which data parts need an update and which data we want to remove.\nTo be more specific, when C3 loads a new data set via the load method, it will overwrite data if the key you provide is already present. However, when the key is not already present, the data you provide for that key will be added to the data it already has! As a consequence, if you want to remove data, you‚Äôll have to explicitly remove it for a given key. To illustrate this process, consider the following example.\nAssume we have the following data: {key1 = 10, key2 = 25}, and in a next step we want to use: {key1 = 20, key3 = 30}. Notice that in the new data key2 is not present. Without unloading, loading the new data set will result in the data {key1 = 20, key2 = 25, key3 = 30}. In this case C3 updates the data for key1, retains the data for key2, and adds the data for key3. In order to make the correct update, we need to remove the data for key2, which we can do via an unload statement (see below).",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to add functionality to JavaScript widgets"
    ]
  },
  {
    "objectID": "r/articles/build/js-widget-functionality/index.html#c3-pie-chart",
    "href": "r/articles/build/js-widget-functionality/index.html#c3-pie-chart",
    "title": "How to add functionality to JavaScript widgets",
    "section": "C3 pie chart",
    "text": "C3 pie chart\nWith the gauge chart fully handled, let‚Äôs create a C3 based pie chart with animated transitions! Just like in our first tutorial, let‚Äôs first take a look at the HTML and JavaScript code via a JSfiddle.\n\n\nThe steps for creating other C3 widgets are very similar to the process described for the gauge widget. In the remainder of the tutorial, we will therefore focus on complete code segments for the R and JavaScript parts, in which various parts are explained via code comments inside the code blocks.\nIn the charts below, we use various C3 specific chart options. A complete overview of all these options (including additional classes & methods) can be found in the C3 reference. In addition, the complete R, YAML and JavaScript code for all the widgets constructed in this tutorial can be found here.\nSimilar to the first tutorial, we can create the template code for a C3 pie widget via the R command:\nhtmlwidgets::scaffoldWidget(\"C3Pie\", edit = FALSE)\nThis command creates a C3Pie.js and C3Pie.yaml file in the inst/htmlwidgets folder and a C3Pie.R file in the R folder of your package (see tutorial 1).\nThe R part of our code looks like this:\nC3Pie &lt;- function(values, legendPosition = \"bottom\", width = NULL, height = NULL) {\n\n  # forward options using x\n  x = list(\n    values = values,\n    legendPosition = legendPosition\n  )\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'C3Pie',\n    x,\n    width = width,\n    height = height,\n    package = 'C3'\n  )\n}\nNote that we added two arguments i.e.¬†values, which contains the individual pie values and legendPosition, which takes as values ‚Äòbottom‚Äô, ‚Äòright‚Äô, and ‚Äòinset‚Äô (see here).\nAs before, all data is passed from R by the variable x, which is a list. Subsequently, shiny will tacitly pass this object via the R package jsonlite, to JavaScript. Remember, after this step we are talking about a JavaScript object, which is very different to the R object you started with. As noted before, this step is one of the hardest (and often most confusing) steps in creating htmlwidgets.\n\n\n\nall objects that are send from R to JavaScript, or from JavaScript to R, are tacitly passed and processed by shiny via jsonlite\n\n\nBack to our widget, in JavaScript, we can subsequently access the two variables from above via x.value and x.legendPosition, respectively. In the R code above, values is a list object. For instance, we can specify the pie data as list('data1'=30,'data2'=120).\nAs noted in the tutorial 1, it is worthwhile to experiment with jsonlite to see how R structures are converted from R to JavaScript.\nFor instance, in R run:\n\njsonlite::toJSON(list('data1'=30,'data2'=120))\n\n{\"data1\":[30],\"data2\":[120]} \n\n\nThe output results in {\"data1\":[30],\"data2\":[120]}. Aside from the extra brackets, the output looks like the structure we would like to have. The extra brackets imply an array with a single value, which for this purpose is the same as a single number.\nThe JavaScript code for our pie widget looks like this:\nHTMLWidgets.widget({\n\n  name: 'C3Pie',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // create an empty chart\n    var chart = null;\n\n    return {\n\n      renderValue: function(x) {\n\n        // if the chart does not exist, create it via c3.generate\n        if(chart === null){\n\n           // create a pie chart, see http://c3js.org/samples/chart_pie.html\n             chart = c3.generate({\n                bindto: el,\n                data: {\n                    json : [],\n                    type : 'pie'\n                },\n            legend: {\n                position: x.legendPosition\n              }\n            });\n        }\n\n        // at this stage the chart always exists\n        // get difference in keys\n        var old_keys = _.keys(chart.x());\n        var new_keys = _.keys(x.values);\n        var diff     = _.difference(old_keys,new_keys);\n\n        // load the new data (stored in x.values)\n        chart.load({\n          json:\n            x.values,\n\n            // unload data that we don't want anymore\n            unload: diff\n        });\n      }\n    };\n  }\n});\nIn the JavaScript code above, just before the chart.load command, we compute the difference between keys in the old (current) data and the new data. In R, computing set differences is easy via setdiff. However, this function is not available in JavaScript, so how can we compute this difference?\nLuckily, in JavaScript there are many tool-belt helper libraries that offer handy functions for manipulating data. A popular library worth checking out is underscore, which we use to help us work with data keys. Here we used the underscore functions _.keys and _.difference. Via _.keys we extract the key information out of the appropriate objects and via _.difference we compute the set difference:\n  var old_keys = _.keys(chart.x());\n  var new_keys = _.keys(x.values);\n  var diff     = _.difference(old_keys,new_keys);\nNotice that all of the functions in underscore start with a _, hence the name. You don‚Äôt need a complete understanding of the last code snipped to follow the rest of this tutorial, but we highly recommend you check out what underscore can do, as being able to work with JavaScript objects and arrays is really helpful in building widgets!\nFor the remaining two charts (discussed below) we use the same concept, but the objects we put in _.keys are slightly different.\nFinally, the YAML file for our pie widget looks like this:\ndependencies:\n- name: d3\n  version: 3.5.0\n  src: htmlwidgets/lib/d3\n  script: ./d3.min.js\n- name: c3\n  version: 0.4.10\n  src: htmlwidgets/lib/c3\n  script: ./c3.min.js\n  style: ./c3.min.css\n- name: underscore\n  version: 1.8.3\n  src: htmlwidgets/lib/underscore\n  script: ./underscore-min.js\nNote that we added a reference to underscore.\nYou can test drive the C3 pie widget via:\nC3Pie(values=list(data1=200,data2=300,data3=100))",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to add functionality to JavaScript widgets"
    ]
  },
  {
    "objectID": "r/articles/build/js-widget-functionality/index.html#c3-combination-chart",
    "href": "r/articles/build/js-widget-functionality/index.html#c3-combination-chart",
    "title": "How to add functionality to JavaScript widgets",
    "section": "C3 combination chart",
    "text": "C3 combination chart\nInstead of creating a single chart, like a line chart or a bar chart, C3 allows you to create combination charts that combine several chart types into a single chart.\n\n\nIn this segment, we will combine a bar chart with a set of line charts. In addition, we‚Äôll add a sub-chart to it which we‚Äôll use in a later tutorial to create a time based filter.\n\n\nLooking at the fiddle, you can see we have a lot more options to deal with. To keep things simple, we‚Äôre not going to parameterize all of them. In the widget below, the user provides a single dataframe called dataset, with a time column (used for the x-axis) and a set of additional columns (used as y-values) for the bar and line series. Furthermore, the user must specify a colors variable that holds the display colors for the bar and line charts.\nHere‚Äôs the complete R code for our C3LineBarChart widget:\nC3LineBarChart &lt;- function(dataset, colors, width = NULL, height = NULL) {\n\n  # forward options using x\n  x = list(\n    dataset  = dataset,\n    colors   = colors\n  )\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'C3LineBarChart',\n    x,\n    width = width,\n    height = height,\n    package = 'C3'\n  )\n}\nFrom the JSfiddle we can see C3 want the data in this format:\nvar dataSet = [\n        {\"Time\":\"2016-01-01\",\"GREEN\":1,\"RED\":2,\"Total\":3},\n        {\"Time\":\"2016-01-02\",\"GREEN\":4,\"RED\":5,\"Total\":6},\n        {\"Time\":\"2016-01-03\",\"GREEN\":7,\"RED\":9,\"Total\":9}\n];\nFrom R, we can obtain this format by providing the data as a dataframe. Let‚Äôs test this assertion with jsonlite:\n\n    dataset &lt;- data.frame(Time  = c(\"2016-01-01\",\"2016-01-02\",\"2016-01-03\"),\n                          GREEN = c(1,4,7),\n                          RED   = c(2,5,9),\n                          Total = c(3,6,9) )\n\n    jsonlite::toJSON(dataset)\n\n[{\"Time\":\"2016-01-01\",\"GREEN\":1,\"RED\":2,\"Total\":3},{\"Time\":\"2016-01-02\",\"GREEN\":4,\"RED\":5,\"Total\":6},{\"Time\":\"2016-01-03\",\"GREEN\":7,\"RED\":9,\"Total\":9}] \n\n\nNice, precisely what we need!\nThe complete JavaScript code for our C3LineBarChart looks like this:\nHTMLWidgets.widget({\n\n  name: 'C3LineBarChart',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // create an empty chart\n    var chart = null;\n\n    return {\n\n      renderValue: function(x) {\n\n        // if the chart does not exist, create it via c3.generate\n        if(chart===null){\n\n            keys = _.keys(x.dataset);\n\n            chart = c3.generate({\n\n              // specify the container element we want the chart to render in\n                bindto: el,\n                data: {\n\n                  // intialize with an empty array\n                    json: [],\n                    keys: {\n                          // use Time for x-axis\n                          x: \"Time\",\n\n                      // use the remaining data for y-values\n                        value: keys,\n                    },\n\n                    // set chart types\n                    types: {\n\n                    // default is line, we want totals to be displayed as bars\n                        Total: 'bar'\n                    },\n                    axes: {\n                      // extra y-axis\n                        Total: 'y2'\n                    }\n                },\n                axis: {\n                    x: {\n                      //  x axis as timeseries\n                        type: \"timeseries\",\n\n                        // tick format x-axis\n                        tick: {\n                            format: \"%Y-%m-%d\"\n                        }\n                    },\n                    y2: {\n                      // we want a second y-axis\n                        show: true\n                    }\n                },\n\n                // display a subchart - this will be used for brushing in a later stage\n                subchart: {\n                    show: true\n                }\n            });\n        }\n\n        // at this stage the chart always exists\n        // get difference in keys\n        var old_keys = _.keys(chart.x());\n        var new_keys = _.keys(x.dataset);\n        var diff     = _.difference(old_keys,new_keys);\n\n        // update the data and colors\n        chart.load({\n          json  : x.dataset,\n          colors: x.colors,\n\n          // unload data that we don't need anymore\n          unload: diff\n        });\n      }\n    };\n  }\n});\nAs you can see, this code is a bit more involved. However, for the most part, we are only specifying specific C3 options. An overview of the complete set of available options can be found in the C3 reference.\nThe concept of rendering this chart is the same as for the pie chart. We make sure we hand the data to JavaScript in the correct format, we initialize a chart with an empty array, we compute any differences in keys relevant to unloading specific series and then we load and unload data.\nYou can build your practical experience by using our htmlwidgets fiddle app to experiment with creating and setting options for C3 charts. When you do this, its probably best to keep a separate tab open with the C3 reference.\nOf note, we will use the sub-chart we created here in a later part of the tutorial series to pick up brush events and to send information back to shiny so we can create a brush-able time based filter.\nFinally, the YAML file for this widget is the same as for our pie chart.\nWhen we install our C3 package, we can create a C3LineBarChart via:\ndataset &lt;- data.frame(Time=c(\"2016-01-05\",\"2016-01-12\",\"2016-01-24\"),\n                      GREEN=c(0.1,0,0.2),\n                      RED=c(0.9,1,0.8),\n                      Total=c(320,210,190))\ncolors      &lt;- list(Total=\"gray\",GREEN=\"Green\",RED=\"Red\")\nC3LineBarChart(dataset = dataset,colors=colors)",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to add functionality to JavaScript widgets"
    ]
  },
  {
    "objectID": "r/articles/build/js-widget-functionality/index.html#c3-stacked-area-chart",
    "href": "r/articles/build/js-widget-functionality/index.html#c3-stacked-area-chart",
    "title": "How to add functionality to JavaScript widgets",
    "section": "C3 stacked area chart",
    "text": "C3 stacked area chart\nOur last chart is very similar to the combination chart above. Here we create a C3 stacked area chart. As all of the concepts for this widget are repetitions from the previous charts, we keep the description of this widget brief. Here‚Äôs a fiddle showing how to code a C3 stacked area chart:\n\n\nThe corresponding R code for our stacked area chart widget looks like this:\nHTMLWidgets.widget({\n\n  name: 'C3StackedAreaChart',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // create an empty chart\n    var chart = null;\n\n    return {\n\n      renderValue: function(x) {\n\n        // if the chart does not exist, create it via c3.generate\n        if(chart===null){\n\n          var keys = _.keys(x.dataset);\n\n            chart = c3.generate({\n                bindto: el,\n                data: {\n                    json: [],\n                    keys: {\n                        x: \"Time\",\n                          value: keys,\n                    }\n                },\n                axis: {\n                    x: {\n                        type: \"timeseries\",\n                        tick: {\n                            format: \"%Y-%m-%d\"\n                        }\n                    }\n                }\n            });\n\n      }\n\n      // at this stage the chart always exists\n      // get difference in keys\n      var old_keys = _.keys(chart.x());\n      var new_keys = _.keys(x.dataset);\n      var diff     = _.difference(old_keys,new_keys);\n\n      //chart.groups([x.groups]);\n\n      // update the data\n      chart.load({\n        // new data\n        json  : x.dataset,\n\n        // new colors\n        colors: x.colors,\n\n        // remove data we no longer need (if any)\n        unload: diff,\n\n        // set types\n        types : x.types\n      });\n    }\n   };\n}});\nFinally, like before, the YAML file is similar to the one for the line bar chart and pie chart.\nIn R, the stacked area chart widget can be rendered via the following snippet:\ndataset &lt;- data.frame(\n  Time  = c(\"2016-01-05\",\"2016-01-12\",\"2016-01-24\"),\n  GREEN = c(0.5,0.2,0.3),\n  RED   = c(0.5,0.8,0.7))\n\ncolors  &lt;- list(GREEN = \"green\", RED = \"red\")\n\nC3StackedAreaChart(dataset,colors)\nNote that we create a named list to set the colors such that the data keys line up with the display colors we want to use.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to add functionality to JavaScript widgets"
    ]
  },
  {
    "objectID": "r/articles/build/js-widget-functionality/index.html#next-tutorial",
    "href": "r/articles/build/js-widget-functionality/index.html#next-tutorial",
    "title": "How to add functionality to JavaScript widgets",
    "section": "Next tutorial",
    "text": "Next tutorial\nAt this stage we have created code for all four widgets in the showcase dashboard app! In the next tutorial, we see how we can send messages from R to our widgets and back. The messages allow us to manipulate charts from R and to create linked visualizations in which one widget reacts to another widget.",
    "crumbs": [
      "Build",
      "Frontend",
      "Shiny extensions",
      "How to add functionality to JavaScript widgets"
    ]
  },
  {
    "objectID": "blog/posts/bslib-dashboards/index.html",
    "href": "blog/posts/bslib-dashboards/index.html",
    "title": "Towards easy, delightful, and customizable dashboards in Shiny for R with {bslib}",
    "section": "",
    "text": "I‚Äôm excited to share that the latest release of the {bslib} R package makes a significant step towards being our recommended way to create Shiny dashboards. Grab it now from CRAN with:\nThis release includes a major overhaul of our documentation, including new and updated articles and better organization of content. The bslib site nows groups these articles by whether you‚Äôre just get started, or want to dive deeper into theming, UI components, or layouts. If you‚Äôre primarily interested in making dashboards, make sure to visit the Getting Started with dashboards article.\nIn this blog post, I‚Äôll discuss some of the new features that contribute to the dashboarding experience, as well as why we‚Äôve chosen bslib as the home for this work. You can run the examples in this post yourself (without having to install anything!) in this Posit Cloud project."
  },
  {
    "objectID": "blog/posts/bslib-dashboards/index.html#footnotes",
    "href": "blog/posts/bslib-dashboards/index.html#footnotes",
    "title": "Towards easy, delightful, and customizable dashboards in Shiny for R with {bslib}",
    "section": "Footnotes",
    "text": "Footnotes\n\nJoe Cheng‚Äôs presentation demoed new theming features in the {bootstraplib} package, which evolved into the package known as bslib and was released to CRAN in 2021.‚Ü©Ô∏é"
  },
  {
    "objectID": "r/articles/improve/usage-metrics/index.html",
    "href": "r/articles/improve/usage-metrics/index.html",
    "title": "Shiny App Usage Tracking",
    "section": "",
    "text": "You may want to track visitors to your Shiny application and analyze how they interact with it. This article will demonstrate techniques for implementing 3rd party tools that track and analyze usage metrics.",
    "crumbs": [
      "Improve",
      "Scale",
      "Measure usage",
      "Shiny App Usage Tracking"
    ]
  },
  {
    "objectID": "r/articles/improve/usage-metrics/index.html#background",
    "href": "r/articles/improve/usage-metrics/index.html#background",
    "title": "Shiny App Usage Tracking",
    "section": "Background",
    "text": "Background\nThere are two types of metrics that can be tracked and analyzed for a Shiny application: usage metrics and hosting metrics.\nUsage metrics provide valuable insights such as the number of unique visitors to an application, a user‚Äôs typical behavior (what inputs are changed, time on the application) and information about the visitor (location, browser, screen size). Implementing usage metrics typically requires Javascript. This article does not provide a comprehensive overview, but most Shiny users should be able to implement these techniques.\nHosting metrics deal with how responsive the application is to concurrent use, how fast the application loads, and what server resources are appropriate for the application. Tools and techniques for analyzing hosting metrics are covered in the admin guides for shinyapps.io, Posit Connect, and Shiny Server and additionally in support articles on Performance Tuning in Shiny Server Pro and Performance Tuning in Posit Connect.\n\nGoogle Analytics / Matomo\nThere are many 3rd party tools that provide usage tracking for web applications. Picking the appropriate tool will depend on your requirements. Luckily, the steps necessary to integrate these tools with Shiny applications are similar. This article covers the patterns along with specific examples for Google Analytics and Matomo.\nGoogle Analytics is a popular cloud-based tool for usage tracking that includes free and paid plans. See this article for detailed step-by-step instructions to setting up Google Analytics with a basic Shiny application. This article will extend the patterns to add event and user ID tracking.\nMatomo is an open-source tool that can be hosted on-premise. Subscription based support and online, hosted versions are also available.\nOnce you‚Äôve selected a specific platform and setup the tool there are three common steps to integrate usage tracking into a Shiny application:\n\nAdd a Tracking ID\nIncorporate Event Tracking\nCapture User ID\n\nStep 1 is required for Steps 2 and 3. Steps 2 and 3 are often optional and are independent (Step 3 can be implemented with or without Step 2 and vice-versa).\n\n\nAdding Javascript to Shiny Applications\nAll 3 steps will require adding Javascript to your Shiny application. There are a few ways to do so:\n\nAdd a separate .js file to the application directory and include the file by using the function includeScript(). Warning: the includeScript function places the content of the script inside a pair of script tags &lt;script&gt;&lt;/script&gt;. If you copy and paste Javascript code into a .js file be sure to remove these tags. This method is nice because is separates the tracking code from the application code.\nAdd the Javascript within the Shiny application‚Äôs UI code using the tags$script function. Similar to includeScript, this function expects Javascript so do not include the script tags &lt;script&gt;&lt;/script&gt;. For example:\n\n```{r}\n# pseudocode\nui &lt;- fluidPage(\n    tags$script(HTML(\n     // Javascript code\n    )),\n    ...\n)\n```\nJavascript can be inserted into the body of the HTML file or in the head of the file. Some usage tracking code needs to go in the head. To place code in the head of the HTML file use the tags$head function in combination with one of the methods above.",
    "crumbs": [
      "Improve",
      "Scale",
      "Measure usage",
      "Shiny App Usage Tracking"
    ]
  },
  {
    "objectID": "r/articles/improve/usage-metrics/index.html#step-1-enable-tracking",
    "href": "r/articles/improve/usage-metrics/index.html#step-1-enable-tracking",
    "title": "Shiny App Usage Tracking",
    "section": "Step 1: Enable Tracking",
    "text": "Step 1: Enable Tracking\nThe first step to enable tracking is to add tracking code. This code is typically provided after registering the Shiny application and is designed to be copied directly into the head of the HTML file.\n\nTemplate\n```{r}\n# pseudocode\nui &lt;- fluidPage(\n    tags$head(tags$script(HTML(\n     // Copy and Paste from 3rd Party Provider\n    ))),\n    ...\n)\n```\nThis code sets up tracking for page views. Every time a browser requests your application, this Javascript code records and sends information on the browser‚Äôs location, the type of device, screen resolution, and potentially other metrics. Depending on provider, this code can also provide insight into page load times.\n\n\nGoogle Analytics\nGoogle Analytics 4 uses the Google tag and gtag.js to collect user interaction data. As of July 1, 2023, this method completely replaces the previous style of page tracking, called Universal Analytics.\n```{r}\nui &lt;- fluidPage(\n    tags$head(HTML(\"\n&lt;!-- Google tag (gtag.js) --&gt;\n&lt;script async src=\\\"https://www.googletagmanager.com/gtag/js?id=TAG_ID\\\"&gt;&lt;/script&gt;\n&lt;script&gt;\n  window.dataLayer = window.dataLayer || [];\n  function gtag(){dataLayer.push(arguments);}\n  gtag('js', new Date());\n\n  gtag('config', 'TAG_ID');\n&lt;/script&gt;\"\n    )),\n    ...\n)\n```\n\n\n\n\n\n\nNote\n\n\n\nBe sure to replace both TAG_ID above with your Google Analytics tag ID.\n\n\n\n\nMatomo\n```{r}\nui &lt;- fluidPage(\n    tags$head(HTML(\n      \"&lt;script&gt;\n      var _paq = _paq || [];\n      _paq.push(['trackPageView']);\n      _paq.push(['enableLinkTracking']);\n      _paq.push(['enableHeartBeatTimer']);\n      (function() {\n        var u='&lt;YOUR_MATOMO_SERVER_URL/matomo&gt;';\n        _paq.push(['setTrackerUrl', u+'matomo.php']);\n        _paq.push(['setSiteId', '2']);\n        var d=document,\n            g=d.createElement('script'),\n            s=d.getElementsByTagName('script')[0];\n            g.type='text/javascript';\n            g.async=true; g.defer=true;\n            g.src=u+'matomo.js';\n            s.parentNode.insertBefore(g,s);\n      })();\n    &lt;/script&gt;\"\n    )),\n    ...\n)\n```",
    "crumbs": [
      "Improve",
      "Scale",
      "Measure usage",
      "Shiny App Usage Tracking"
    ]
  },
  {
    "objectID": "r/articles/improve/usage-metrics/index.html#step-2-event-tracking",
    "href": "r/articles/improve/usage-metrics/index.html#step-2-event-tracking",
    "title": "Shiny App Usage Tracking",
    "section": "Step 2: Event Tracking",
    "text": "Step 2: Event Tracking\nIn addition to page loads, it can be valuable to track the events that occur on a specific page. An event is an action that a user can take. For example, changing a select input would be an event. Most tracking tools provide a Javascript function for tracking events. Tracking events can provide insight into the actions a user is taking in an application: which inputs are changed, how frequently they change, and the order in which they change.\nThe following template adds basic tracking for an application‚Äôs inputs. The template relies on Shiny‚Äôs Javascript events.\n\nTemplate\n```{r}\n# pseudocode\nui &lt;- fluidPage(\n   tags$script(HTML(\n   \"$(document).on('shiny:inputchanged', function(event) {\n     trackingFunction('trackEvent',\n       'input', 'updates', event.name, event.value);\n  });\"\n  )),\n  ...\n)\n```\nThis template has a number of parts:\n\nshiny:inputchanged acts as a trigger. The subsequent function is called anytime the app‚Äôs inputs change. (To conceptually understand, think of this process as being similar to Shiny‚Äôs observeEvent(input, {function}) pattern). Sometimes shiny:inputchanged will be triggered without the inputs changing, see this article for details.\nevent When the input changes, the Javascript function will have access to the event object. The event object includes the name of the input that was changed, event.name, and the new value of the input, event.value.\ntrackingFunction This is a made up function! This function will be implemented by the 3rd party metrics provider. See the specific examples below for Matomo and Google Analytics. Usually this function looks like: trackingFunction('trackEvent',Category, Action, Label, Value). The function is responsible for recording the event. Category, Action, Label, and Value provide more information about the event that can be helpful when analyzing user‚Äôs history. In this template I set Label equal to event.name and Value to event.value. I‚Äôve hardcoded Category to input and Action to updates. The Google Analytics help page provides more information.\n\nAs an example, imagine a simple Shiny application with a selectInput named ‚Äòmodel‚Äô that can be either ‚ÄòA‚Äô or ‚ÄòB‚Äô and a numericInput named ‚Äòvalue‚Äô. If I interact with the application, the trackingFunction from our template would send the following information to the metrics server:\n02:00:00  192.154.0.45 'input' 'updates' model 'A'\n02:01:00  192.154.0.45 'input' 'updates' model 'B'\n02:01:00  192.154.0.45 'input' 'updates' value 30\nThis trace corresponds to a user with IP address 192.154.0.45 who toggled the select input between ‚ÄòA‚Äô and ‚ÄòB‚Äô and set the numeric input to 30. Category was hardcoded as ‚Äòinput‚Äô and Action was hardcoded as ‚Äòupdates‚Äô.\nA variation of this template would be:\n```{r}\n#pseudocode\nui &lt;- fluidPage(\n   # -- Plotting Controls\n   numericInput(plot, ...),\n   textInput(ignored, ...),\n\n   # -- Model Input\n   selectInput(model, ...),\n\n   # -- Tracking Code\n   tags$script(HTML(\n     \"$(document).on('shiny:inputchanged', function(event) {\n       if (event.name === 'model) {\n         trackingFunction(['trackEvent', 'Modeling Input',\n           'Class of Model', event.name, event.value]);\n       }\n       if (event.name === 'value') {\n         trackingFunction(['trackEvent', 'Plotting Control',\n           'Class of Model', event.name, event.value]);\n       }\n     });\"\n  )),\n  ...\n)\n```\nThis modified template uses if statements to filter by the name of the input. Changes to the model and plot inputs are tracked, but not changes to textInput. model inputs and plot inputs are labelled separately using the ‚ÄòCategory‚Äô attribute.\nThe event tracking code can be specialized to accommodate many levels of tracking.\n\n\nGoogle Analytics\n```{r}\nui &lt;- fluidPage(\n   numericInput(bins, ...),\n   selectInput(col, ...),\n\n   tags$script(HTML(\n     \"$(document).on('shiny:inputchanged', function(event) {\n       if (event.name === 'bins' || event.name === 'col') {\n          const data = {\n            name: event.name,\n            value: event.value\n          };\n          gtag('event', 'input_updates', data);\n       }\n     });\"\n  )),\n  # ...\n)\n```\n\n\nMatomo\n```{r}\nui &lt;- fluidPage(\n   numericInput(bins, ...),\n   selectInput(col, ...),\n\n   tags$script(HTML(\n     \"$(document).on('shiny:inputchanged', function(event) {\n       if (event.name === 'bins' || event.name === 'col') {\n         _paq.push(['trackEvent', 'input',\n           'updates', event.name, event.value]);\n       }\n     });\"\n  )),\n  # ...\n)\n```",
    "crumbs": [
      "Improve",
      "Scale",
      "Measure usage",
      "Shiny App Usage Tracking"
    ]
  },
  {
    "objectID": "r/articles/improve/usage-metrics/index.html#step-3-user-id-tracking",
    "href": "r/articles/improve/usage-metrics/index.html#step-3-user-id-tracking",
    "title": "Shiny App Usage Tracking",
    "section": "Step 3: User ID Tracking",
    "text": "Step 3: User ID Tracking\nIt is also valuable to link usage metrics to specific users. To do so, we can send the username to the metrics server. Sending the username only works for applications that require authentication. For other applications session$user is null. Sending the username is similar to sending an event.\n\n\n\n\n\n\nNote\n\n\n\nThis feature requires Shiny version 1.0.1 or above.\n\n\n\nTemplate\n```{r}\n#pseudocode\ntags$script(HTML(\n    \"$(document).one('shiny:idle', function(){\n       trackingFunction('setUserId', Shiny.user)\n       trackingFunction('trackPageView');\n     })\"\n))\n```\nThere are a few components:\n\n$(document).one('shiny:idle' This portion of JQuery makes sure the function fires once after the application has loaded.\nShiny.user This object contains the username\ntrackingFunction('setUserId', Shiny.user) Similar to event tracking, this is a made up function. The specific function to use will be implemented by the 3rd party tracking tool.\ntrackingFunction('trackPageView') After setting the username, any events sent to the metrics server will be associated with the username. However, the initial page load occurs before the Shiny.user object is available and before the username is sent to the metrics server. This code tells the metrics server to link the page view to the username.\n\nThe relevant GA and Matomo code snippets:\n\n\nGoogle Analytics\n```{r}\nui &lt;- fluidPage(\n  tags$script(HTML(\n    \"$(document).one('shiny:idle',\n      function() {\n        gtag('set', { userId: Shiny.user });\n        gtag('event', 'page_view');\n      }\n     );\"\n  )),\n  #...\n)\n```\n\n\nMatomo\n```{r}\nui &lt;- fluidPage(\n  tags$script(HTML(\n    \"$(document).one('shiny:idle',\n      function() {\n        _paq.push(['setUserId', Shiny.user]);\n        _paq.push(['trackPageView']);\n      }\n     );\"\n  )),\n  #...\n)\n```",
    "crumbs": [
      "Improve",
      "Scale",
      "Measure usage",
      "Shiny App Usage Tracking"
    ]
  },
  {
    "objectID": "r/articles/improve/usage-metrics/index.html#full-examples",
    "href": "r/articles/improve/usage-metrics/index.html#full-examples",
    "title": "Shiny App Usage Tracking",
    "section": "Full Examples",
    "text": "Full Examples\nThe following examples are working applications for both Matomo and Google Analytics. For these examples, the Javascript is written to a separate file and included using the includeScript function. Note that you will have to setup Matomo or Google Analytics before using these examples.\n\n\napp.R\nlibrary(shiny)\n\nui &lt;- fluidPage(\n\n  # -- Add Tracking JS File\n  tags$head(\n    tags$script(\n      async = NA,\n      # !! Replace with your TAG_ID !!\n      src = \"https://www.googletagmanager.com/gtag/js?id=TAG_ID\"\n    )\n  )\n  tags$head(includeScript(\"google-analytics.js\")),\n\n  # ...or remove the above and use matomo.js instead\n  # tags$head(includeScript(\"matomo.js\")),\n\n  # -- Application UI\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"bins\", \"Number of bins:\",\n                  min = 1, max = 50, value = 30),\n      selectInput(\"col\", \"Barplot Color\",\n                  c(\"blue\", \"grey\", \"purple\", \"orange\"), selected = \"grey\")\n    ),\n\n    mainPanel(\n      h1(textOutput(\"user\")),\n      plotOutput(\"distPlot\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n\n  output$user &lt;- renderText({\n    paste0(\"Hello \", session$user,\n      \"! This app is tracked by Matomo\")\n  })\n\n  output$distPlot &lt;- renderPlot({\n    x &lt;- faithful[, 2]\n    bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n    hist(x, breaks = bins, col = input$col, border = 'white')\n\n  })\n\n}\n\nshinyApp(ui = ui, server = server)\n\n\n\n\ngoogle-analytics.js\n// Initial Tracking Setup Code\nwindow.dataLayer = window.dataLayer || [];\nfunction gtag(){dataLayer.push(arguments);}\ngtag('js', new Date());\n\n// !! Replace with your TAG_ID !!\ngtag('config', 'TAG_ID');\n\ngtag('event', 'page_view');\n\n// Event Tracking Code\n$(document).on('shiny:inputchanged', function(event) {\n  if(event.name == 'bins' || event.name == 'col'){\n    const data = {\n      name: event.name,\n      value: event.value\n    };\n    gtag('event', 'input_updates', data);\n  }\n});\n\n// User Tracking Code\n$(document).one('shiny:idle', function() {\n  gtag('set', { userId: Shiny.user });\n});\n\n\n\n\nmatomo.js\n// Initial Tracking Code\nvar _paq = _paq || [];\n_paq.push(['enableLinkTracking']);\n_paq.push(['enableHeartBeatTimer']);\n(function() {\n  var u = '&lt;YOUR_MATOMO_URL&gt;';\n  _paq.push(['setTrackerUrl', u+'matomo.php']);\n  _paq.push(['setSiteId', '&lt;YOUR_APP_ID&gt;']);\n  var d = document,\n  g = d.createElement('script'),\n  s = d.getElementsByTagName('script')[0];\n  g.type = 'text/javascript';\n  g.async = true;\n  g.defer = true;\n  g.src = u+'matomo.js';\n  s.parentNode.insertBefore(g,s);\n})();\n\n// Event Tracking Code\n$(document).on('shiny:inputchanged', function(event) {\n  if (event.name === 'bins' || event.name === 'col') {\n    _paq.push(['trackEvent', 'input',\n      'updates', event.name, event.value]);\n  }\n});\n\n// User Tracking Code\n$(document).one('shiny:idle', function(){\n  _paq.push(['setUserId', Shiny.user]);\n  _paq.push(['trackPageView']);\n});",
    "crumbs": [
      "Improve",
      "Scale",
      "Measure usage",
      "Shiny App Usage Tracking"
    ]
  },
  {
    "objectID": "blog/posts/bslib-tooltips/index.html",
    "href": "blog/posts/bslib-tooltips/index.html",
    "title": "Shiny for R updates: tooltips, popovers, a new theme, and more",
    "section": "",
    "text": "The Shiny team is delighted to share that we‚Äôve just released updates for 12 different R packages that contribute to the Shiny experience. These updates include many improvements and bug fixes that aren‚Äôt explicitly covered here, but the release notes section of this post provides links to the full list of changes for each package. That said, there are a few new features in bslib that we‚Äôre particularly excited to highlight for you!"
  },
  {
    "objectID": "blog/posts/bslib-tooltips/index.html#bslib",
    "href": "blog/posts/bslib-tooltips/index.html#bslib",
    "title": "Shiny for R updates: tooltips, popovers, a new theme, and more",
    "section": "bslib",
    "text": "bslib\nIn the last release of bslib (0.5.0), we made significant strides towards bslib being our recommended way to build modern Shiny dashboards. In this release, we‚Äôve added more features to help you make even better dashboards.\nTooltips and popovers\nOne essential quality of any great website is that it provides the user with the right amount of information at the right time. In technically-oriented apps, you might want to provide a definition for a term, a description of a model parameter, or an input that updates a specific plot, but you don‚Äôt want these details to overwhelm the user when they‚Äôre not needed.\nIn this release, we‚Äôve added bslib::tooltip() and bslib::popover() to help you do just that. By putting this additional information in a tooltip or these additional controls in a popover, you can provide the detail your users need on demand, right where they need it.\nHere‚Äôs a quick demo. In this example, we have a card containing a plot that compares the body mass of our favorite penguins across species. We‚Äôve leveraged bslib‚Äôs new tooltip and popover features in a few ways:\n\nAn info icon next to the card title includes a tooltip that describes how the penguin body mass is measured.\nA gear icon in the upper left corner of the card includes a popover with a few controls for customizing the plot.\nIn the footer, a ‚ÄúLearn more‚Äù link opens a popover with the full citation for the data used in the plot.\n\n\n\n\n\n\n\n  Try on Posit Cloud    Source\n\n\n\n\nLearn more in the new\nTooltips & Popovers article.\n\n\n\nTowards a new Shiny theme\nThis release of bslib introduces a new theme that we intend on making the default experience for bslib-powered apps. Since this theme is still a work-in-progress, you must currently must be opt-in to use it by providing bs_theme(preset = \"shiny\") to the theme argument of the relevant page function, for example:\nlibrary(shiny)\nlibrary(bslib)\n\nui &lt;- page_sidebar(\n  theme = bs_theme(preset = \"shiny\"),\n  # ...\n)\nThe screen recording below gives you a preview of the new Shiny preset theme. One exciting difference between the Shiny preset and other Bootswatch themes, is that we‚Äôve taken this opportunity to re-think the appearance of Shiny-specific widgets, like sliderInput() and selectInput().\nWant to see this theme in action? Just install the updated bslib package and run bslib::bs_theme_preview() in your R console!\n\n\n\n\n\n\n   Try on Posit Cloud    Source\n\n\n\n\nLearn more about\nreal-time theming with bslib.\n\n\n\nImproved Quarto integration\nSince bslib components are designed to both work with Shiny and to render statically they can be added to any Bootstrap-compatible page.\nIn practice, however, due to nuances in how Quarto provides Boostrap, some bslib components weren‚Äôt quite working as expected in Quarto documents. But this release fixes that issue!\nTo demonstrate, here‚Äôs an example of a fullscreen-capable bslib::card() in a Quarto document.\n\n\n\n\n\n\n  Try on Posit Cloud    Source\n\n\n\n\nYou can also\nuse bslib components in R Markdown.\n\n\n\nNew input_switch()\n\nTurning a feature on or off is a common action in many Shiny apps. With Shiny‚Äôs default UI, this is typically done with a checkboxInput(). But checkboxes don‚Äôt always give an obvious visual cue of turning an option on or off.\nIn this release, we‚Äôve added a new input_switch() with a modern appearance. Here‚Äôs a quick live preview of how it looks and feels:\n\nbslib::input_switch(\"switch\", \"Turn Up Awesomeness\", FALSE)\n\n\n\n\nTurn Up Awesomeness\n\n\n\n\n\n\n\n\n\n\n\nThe new bslib is extra, extra awesome!"
  },
  {
    "objectID": "blog/posts/bslib-tooltips/index.html#looking-forward",
    "href": "blog/posts/bslib-tooltips/index.html#looking-forward",
    "title": "Shiny for R updates: tooltips, popovers, a new theme, and more",
    "section": "Looking forward",
    "text": "Looking forward\nWe‚Äôre excited to continue improving Shiny for R, and in the near-term we plan to focus on making bslib a more complete UI framework with great looking defaults. Here are a few things currently towards the top of our roadmap:\n\nMake the new Shiny preset theme the default for bslib-powered apps.\n\nWe have refreshed style updates in the works for card()s, sidebar(), and much more.\nAnd we‚Äôd love to get your feedback on the new theme!\n\n\nMore UI components, such as offcanvas, button groups, etc.\nMore incorporation of bslib as part of the Getting Started experience on shyr-test-center.netlify.app.\nMore bslib-focused example galleries, starter templates, and articles.\n\n\n\n\n\n\n\nJoin us at posit::conf(2023)!\n\n\n\nWe‚Äôre also excited to see you at posit::conf(2023) this September! Currently, there are 35 sessions on the schedule that mention Shiny, including a handful of UI-focused workshops and talks."
  },
  {
    "objectID": "blog/posts/bslib-tooltips/index.html#release-notes",
    "href": "blog/posts/bslib-tooltips/index.html#release-notes",
    "title": "Shiny for R updates: tooltips, popovers, a new theme, and more",
    "section": "Release notes",
    "text": "Release notes\nThere are a lot of changes and updates in the Shiny universe that we haven‚Äôt covered in this post. Dive into the release notes linked below to learn more about changes in each package.\nThank you, everyone! üíô We‚Äôd like to thank everyone who contributed to all of the packages released in this cycle. Your contributions are what make Shiny great!\nbslib v0.5.1\n\n@ariebh, @asadow, @chrisbrownlie, @cpsievert, @ctrlxctrlc, @daattali, @gadenbuie, @ideusoes, @Liripo, @michael-dewar, @nteetor, @PaulC91, @philiph99, @riskcede, @schloerke, @Teebusch, @tillea, and @wch.\nshiny v1.7.5\n\n@AlexWaterboyBezzina, @apalacio9502, @aronatkins, @asadow, @BajczA475, @barracuda156, @brooksambrose, @cpsievert, @daattali, @dipterix, @dkori, @drag05, @dvg-p4, @emillykkejensen, @EricKrantz, @gadenbuie, @galachad, @Gathuh, @GShotwell, @hadley, @hcsun1, @ifoxfoot, @ismirsehregal, @jcheng5, @jessekps, @johnkarlen, @juwitt, @kathi-resan, @kennedymwavu, @kevinushey, @king-of-poppk, @KRRLP-PL, @Liripo, @magarick, @MalteSteinCytel, @matt4815162342, @maxheld83, @Mkranj, @nolanjj, @norahAlbarrak, @pawelru, @pbosetti, @RaviSekha, @RosalynLP, @sanjmeh, @SarenT, @schloerke, @shahronak47, @stefanedwards, @stla, @stuvet, @timbrock, @tomjemmett, @vivigirardin, @vnijs, @wch, and @Zhenglei-BCS.\nhtmltools v0.5.6\n\n@ccamara, @cpsievert, @daattali, @gadenbuie, @PaulC91, @schloerke, @ShixiangWang, and @warnes.\nflexdashboard v0.6.2\n\n@actuarial-lonewolf, @cpsievert, @danielludolf, @DataStrategist, @erm-eanway, @gadenbuie, and @nplatonov.\nleaflet v2.1.3\n\n@antoine4ucsd, @daattali, @gadenbuie, @Jakka, @jaseeverett, @johnbaums, @JosephStewart, @Landon-Getting, @lime-n, @Rafnuss, @ramyareddy161, @rhijmans, @rl-utility-man, and @warnes.\nleaflet.providers v1.13.0\n\n@gadenbuie, @jennybc, @joker234, @kent37, @mgzjys, and @schloerke.\nshinytest2 v0.3.0\n\n@andrewbaxter439, @arepsz, @AskPascal, @cpsievert, @epruesse, @gadenbuie, @gladkia, @hugo-pH, @matt-sd-watson, @maxheld83, @parmsam-pfizer, @PaulinCharliquart, @schloerke, @stla, and @sybrohee.\nchromote v0.1.2\n\n@ashbythorpe, @gadenbuie, @hadley, @Ljupch0, @moladokun, @mrcaseb, @nick-youngblut, @stla, @Waschoi, @wch, and @yogat3ch.\nwebshot2 v0.1.1\n\n@aengels-git, @brunomioto, @cderv, @charleswidnall, @egehankinik, @gadenbuie, @iMissile, @kangjf1943, @lijinbio, @Liripo, @Minh-AnhHuynh, @PatrickRWright, @RKonstantinR, @schloerke, @trafficonese, and @tvqt.\npromises v1.2.1\n\n@bakaburg1, @bguillod, @can-taslicukur, @CarlijnB, @chris31415926535, @cpsievert, @CrossD, @gadenbuie, @gdeoli, @HenrikBengtsson, @hf778, @jcheng5, @jennybc, @king-of-poppk, @lz100, @maxheld83, @mrkaye97, @pawelru, @schloerke, @tzakharko, and @vspinu.\nthematic v0.1.3\n\n@biomystery, @boram1024, @cboettig, @cbrnr, @cpsievert, @dmenne, @Fluke95, @gadenbuie, @gtritchie, @jennybc, @kbzsl, @mvwestendorp, @PaulC91, @r2evans, @rishabhshah-92, @schloerke, @stephan-koenig, @uhkeller, and @yixuan.\nbsicons v0.1.1\n\n@cpsievert, and @sanjmeh."
  },
  {
    "objectID": "r/gallery/index.html",
    "href": "r/gallery/index.html",
    "title": "Gallery",
    "section": "",
    "text": "Welcome to the Shiny Gallery! Below you can find a myriad of Shiny apps to be inspired by and to learn from. We have organized the apps in two main categories:"
  }
]