{
  "hash": "fcb26b6773e372edae979cad5dd863b1",
  "result": {
    "markdown": "---\ntitle: How to add functionality to JavaScript widgets\ndate: 2017-07-12\ndescription: >\n  In this article, we expand the widget to create smooth transitions like those\n  in the showcase dashboard app. We also provide code and examples for the other\n  charts types shown in the dashboard -- a pie chart, a line + bar chart and a\n  stacked area chart.\nauthor:\n  - Hermann Sontrop\n  - Erwin Schuijtvlot\nresources:\n  - \"*.png\"\nexecute:\n  freeze: true\n---\n\n\n## Introduction\n\nIn the [previous](http://shiny.rstudio.com/tutorial/js-lesson1/) tutorial, we created a simple [C3](http://c3js.org/) based gauge widget. In this tutorial, we expand the widget to create smooth transitions like those in the [showcase dashboard app](https://js-tutorial.shinyapps.io/dashboardApp/). We also provide code and examples for the other charts types shown in the dashboard: a pie chart, a line + bar chart and a stacked area chart. In this tutorial, we focus on pairing charts and data in such a way that C3 can animate the transition between old and new data.\n\n\n<iframe width='100%' height='300' src='https://jsfiddle.net/FrissAnalytics/tx38gstp/9/embedded/result' allowfullscreen='allowfullscreen' frameborder='0'></iframe>\n\n<div style = \"text-align:center; margin-bottom:25px\" >example of a gauge with animated transitions between old and new data</div>\n\nBefore we do all that, let's take a better look at the `HTMLWidgets.widget` function we saw in the [first tutorial](http://shiny.rstudio.com/tutorial/js-lesson1/), which is related to the concept of factory methods and closures.\n\n\n### Factory methods and closures\n\nIn the previous tutorial, we saw that the skeleton of our widget initially looks like this\n\n```javascript\nHTMLWidgets.widget({\n\n  name: 'C3Gauge',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // TODO: define shared variables for this instance\n\n    return {\n\n      renderValue: function(x) {\n\n        // TODO: code to render the widget, e.g.\n        el.innerText = x.message;\n\n      },\n\n      resize: function(width, height) {\n\n        // TODO: code to re-render the widget with a new size\n\n      }\n\n    };\n  }\n});\n```\nIf you are new to JavaScript, this code may look a bit strange. We see that `factory` is a [method](http://www.w3schools.com/js/js_object_methods.asp), but the return type is not a simple value. What's with that?\n\nThe construction above is a design pattern that software engineers call a [factory](http://www.oodesign.com/factory-method-pattern.html) method. This pattern contains a method that returns an object instance. That may sound complicated, so let's dig a little deeper to see what it means.\n\nIn more general terms, a factory method like this:\n\n```javascript\nfactory: function () {return {\n  a: function() { ... },\n  b: function() { ... }\n}};\n```\n\nis equivalent to:\n\n```javascript\n// factory is a method of some object\nfactory: function () {\n\n  // define a new object\n  var obj = new Object();\n\n  // create a method a for it\n  obj.a = function() { ... };\n\n  // create a method b for it\n  obj.b = function() { ... };\n\n  // return the object instance\n  return obj;\n}\n```\n\nHence, in our case, the `factory` method in HTMLWidgets.widget returns an `object` of the widget instance. This object itself has two methods i.e. `renderValue`, which draws our widget, and `resize`, which resizes the widget (if necessary).\n\nIn the implementation above, `renderValue` and `resize` are both implemented as <a href='http://www.w3schools.com/js/js_function_closures.asp'>closures</a>, which means that the functions remember the scope they were created in and have access to the variables defined in that scope. A more in depth discussion on JavaScript closures is offered [here](https://developer.mozilla.org/en/docs/Web/JavaScript/Closures). Of note, the concept of closures also exists in R, see [here](http://adv-r.had.co.nz/Functional-programming.html#closures).\n\n\nThe implication of `renderValue` and `resize` being closures is that they have access to the `el`, `width` and `height` parameters passed to `factory`. Furthermore, we can initialize variables in the body of `factory` (above the definitions of `renderValue` and `resize`) that we want to use during the lifetime of our widget.\n\n\nNow that we have a better understanding of what our `HTMLWidgets.widget` function is doing, let's add some transitions to our gauge widget!\n\n## Adding transitions to a C3 gauge\n\nEven though the gauge widget from the first tutorial works, we can improve it. The current widget always creates a completely new gauge if we send it a value via shiny (using the `renderC3Gauge` function, see [tutorial 1](http://shiny.rstudio.com/tutorial/js-lesson1/)). It would be nicer if the widget used an animation to smoothly transition from its old state to its new state, as in the example at the top of the page. Luckily, C3 can create such transitions automatically. To take advantage of this, we will have to modify the code of our factory method.\n\nIn pseudo code, our new factory method will looks something like this:\n\n\n```javascript\nfactory: function(el, width, height){\n\n  // we can define any variables we wish to use to keep track of the state of the widget here\n  // lets create an empty chart\n  var chart = null;\n\n  return {\n      renderValue: function(x) {\n\n        // check if the chart exists\n        if(chart === null){\n\n           // the chart did not exist and we want to create a new chart\n           chart = createChart(x);\n\n           // store the chart on el so we can get it later\n           el.chart  = chart;\n        }\n\n        // at this stage the chart always exists\n        // get the chart stored in el and update it\n        el.chart.updateChart(x);\n\n      }\n  }\n}\n```\n\nTo understand the pseudo code, it is helpful to realize that there are two basic stages in the lifetime of a chart:\n\n  1) the chart does not yet exist\n  2) the chart already exists and we want to pass in new data, set options or send messages to it\n\nThe factory method has three arguments: `el`, `width` and `height`. Here `el` is the container element created by htmlwidgets in which we will house our chart. On top, we create a variable called `chart`, which we initially set to null, indicating that the chart does not yet exist.\n\nInside the `renderValue` method, we first check if the chart exists. If the chart does not exist, we create a chart via the toy function createChart, which in this case uses information in `x`. Subsequently, we store the chart on `el`, so we can access it later.\n\nTechnically, the closure allows us to render the chart even in the first line, i.e. at the line `var chart = null;`. In C3, however, we often need information stored in `x` to create a chart. Note that `x` contains the data and chart options passed via shiny from R to JavaScript (using jsonlite, see [tutorial 1](http://shiny.rstudio.com/tutorial/js-lesson1/)). As C3 often needs information in `x` during initialization, here we initialize the chart inside the `renderValue` method and subsequently check if the chart was already created. This is slightly inelegant, however, it is quite easy and the overhead is minimal.\n\nNote that the chart will exist in all subsequent calls to `renderValue`. In those instances, we first retrieve the chart via `el`, which we can access because `renderValue` is a closure. Second, we call an update method on the chart, which will again use information stored in `x`.\n\nLet's convert the previous pseudo code into actual code for our gauge!\n\nThe next JavaScript code block shows how we can load new data into a C3 based chart created via [c3.generate](http://c3js.org/gettingstarted.html#generate).\n\n```javascript\nvar chart = c3.generate({\n  // chart code here\n  ...\n});\n\n// some data\nvar newData = 50;\n\n// load data into the chart\nchart.load({\n  json: newData\n});\n```\n\nIf we combine this code snippet with the previous factory pseudo code we end up with the code we're looking for:\n\n```javascript\nHTMLWidgets.widget({\n\n  name: 'C3Gauge',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // create an empty chart\n    var chart = null;\n\n    return {\n\n      renderValue: function(x) {\n\n        // check if the chart exists\n        if(chart === null){\n\n          // the chart did not exist and we want to create a new chart via c3.generate\n          chart = c3.generate({\n        \t\tbindto: el,\n        \t\tdata: {\n        \t\t\tjson: x,\n        \t\t\ttype: 'gauge',\n        \t\t},\n        \t\tgauge: {\n        \t\t\tlabel:{\n        \t\t\t\tformat: function(value, ratio){ return value;}\n        \t\t\t},\n        \t\t\tmin: 0,\n        \t\t\tmax: 100,\n        \t\t\twidth: 15,\n        \t\t\tunits: 'value'\n        \t\t}\n        \t});\n\n          // store the chart on el so we can get it later\n          el.chart = chart;\n        }\n\n        // at this stage the chart always exists\n        // get the chart stored in el and update it\n        el.chart.load({json: x});\n\n      }\n    };\n  }\n});\n\n```\nOf note, for brevity here we omitted the `resize` method (which is optional).\n\n### Code repository and demo app\n\nYou can find the complete code for the updated gauge widget, as well as the code for the widgets below at [this](https://github.com/FrissAnalytics/shinyJsTutorials/tree/master/tutorials/materials2/C3) repo, which contains a C3 package. The C3 package contains updated code for the gauge widget, a pie chart widget, a combination bar + line chart and a stacked area chart. The code of the latter three widgets is discussed in detail below. The R code of these widgets can be found [here](https://github.com/FrissAnalytics/shinyJsTutorials/tree/master/tutorials/materials2/C3/R). The JavaScript and YAML files for each widget are located [here](https://github.com/FrissAnalytics/shinyJsTutorials/tree/master/tutorials/materials2/C3/inst/htmlwidgets).\n\nYou can install the updated C3 package by running the following command in R:\n\n```r\ndevtools::install_github(\"FrissAnalytics/shinyJsTutorials/tutorials/materials2/C3\")\n```\n\nIn order to help you understand the various C3 widgets in this tutorial, we've built a shiny C3 demo app that shows how you can use these widgets in a shiny context. You can download this dashboard [here](https://github.com/FrissAnalytics/shinyJsTutorials/tree/master/tutorials/materials2/C3_demo). To see the app in action press the screenshot below! In the next tutorials we will extend the capabilities of these widgets even further when we take a closer look at JavaScript [events](http://www.w3schools.com/js/js_events.asp).\n\n\n<p style = \"margin: 40px 0px\">\n  <a href = \"https://js-tutorial.shinyapps.io/C3_demo/\" target = \"_blank\"><img src = \"C3_dashboard.png\" width=\"100%\"></img></a>\n  <div style = \"text-align:center\">demo app with animated C3 widgets. Click on the image to launch the app!</div>\n</p>\n\n\nWe show you how to create the widgets below, which you can subsequently render with `C3Gauge`,`C3Pie`,`C3LineBarChart`, and `C3StackedAreaChart`.\n\n\nIn a shiny app (in ui.r), these functions are paired with the output functions: `C3GaugeOutput`, `C3PieOutput`, `C3LineBarChartOutput`, `C3StackedAreaChartOutput`, and (in server.R) with the render functions: `renderC3Gauge`, `renderC3Pie`, `renderC3LineBarChart`, `renderC3StackedAreaChart`.\n\nNote that you can also use the widgets in a Markdown document as well!\n\nYou can also experiment with code changes right in the browser with an online htmlwidget fiddle app, as discussed in the next section.\n\n\n### Htmlwidget fiddle app\n\nIt can become a bit cumbersome to build, install and load a package each time you want to test something, especially if you just want to play around with an example and experiment to find out how something works. For the purpose of this tutorial series, we created a small helper online app similar to a JavaScript fiddle. You can use the app to change code and immediately see the impact. You can find the online app [here](https://js-tutorial.shinyapps.io/WidgetFiddle/).\n\n<p style = \"margin:25px 0px\">\n  <a href = \"https://js-tutorial.shinyapps.io/WidgetFiddle/\" target = \"_blank\"><img src = \"htmlwidgetsFiddle_app.png\" width=\"100%\"></img></a>\n  <div style = \"text-align:center\">htmlwidget fiddle app. Play with C3 code & create a package right from the browser!</div>\n</p>\n\n#### About the app\n\nAll widgets in this tutorial series are available in the app. You can select a widget in the drop-down list after which its JavaScript code, R code, and YAML contents are loaded in the corresponding tabs. You can then play around with code changes and see the effect by pressing the 'render widget' button. In the Widgetcall tab, you can add your own data and provide the widget render call.\n\n\nYou can also export the  code as a zipped R package, which can be installed by opening the .Rproj file in RStudio and running `devtools::install()`. Currently, the functionality of this app is limited to rendering C3 based charts. We plan to update the functionality of this app during the course of the tutorial series, i.e. by allowing you to add additional JavaScript and CSS files.\n\nNow we're all set, let's make some more widgets!\n\n## C3 data update pattern\n\nThe gauge is by far the most simple visualization C3 offers. More complex charts require more complex data objects. In C3, each data series is associated with a unique `key`. These keys help us to keep track of which data series are in the chart, which data parts need an update and which data we want to remove.\n\n\nTo be more specific, when C3 loads a new data set via the `load` method, it will overwrite data if the key you provide is already present. However, when the key is not already present, the data you provide for that key will be added to the data it already has! As a consequence, if you want to remove data, you'll have to explicitly remove it for a given key. To illustrate this process, consider the following example.\n\nAssume we have the following data: `{key1 = 10, key2 = 25}`, and in a next step we want to use: `{key1 = 20, key3 = 30}`. Notice that in the new data key2 is *not* present. Without unloading, loading the new data set will result in the data `{key1 = 20, key2 = 25, key3 = 30}`. In this case C3 updates the data for key1, retains the data for key2, and adds the data for key3. In order to make the correct update, we need to remove the data for key2, which we can do via an `unload` statement (see below).\n\n\n## C3 pie chart\n\nWith the gauge chart fully handled, let's create a C3 based pie chart with animated transitions! Just like in our [first tutorial](http://shiny.rstudio.com/tutorial/js-lesson1/), let's first take a look at the HTML and JavaScript code via a JSfiddle.\n\n<iframe width='100%' height='450' style = 'padding-bottom:25px' src='https://jsfiddle.net/FrissAnalytics/umu7Lnrv/12/embedded/result,js,html' allowfullscreen='allowfullscreen' frameborder='0'></iframe>\n\nThe steps for creating other C3 widgets are very similar to the process described for the gauge widget. In the remainder of the tutorial, we will therefore focus on complete code segments for the R and JavaScript parts, in which various parts are explained via code comments inside the code blocks.\n\nIn the charts below, we use various C3 specific chart options. A complete overview of all these options (including additional classes & methods) can be found in the [C3 reference](http://c3js.org/reference.html). In addition, the complete R, YAML and JavaScript code for all the widgets constructed in this tutorial can be found [here](https://github.com/FrissAnalytics/shinyJsTutorials/tree/master/tutorials/materials2/C3).\n\n\nSimilar to the [first tutorial](http://shiny.rstudio.com/tutorial/js-lesson1/), we can create the template code for a C3 pie widget via the R command:\n\n```R\nhtmlwidgets::scaffoldWidget(\"C3Pie\", edit = FALSE)\n```\n\nThis command creates a C3Pie.js and C3Pie.yaml file in the inst/htmlwidgets folder and a C3Pie.R file in the R folder of your package (see [tutorial 1](http://shiny.rstudio.com/tutorial/js-lesson1/)).\n\nThe R part of our code looks like this:\n\n```R\nC3Pie <- function(values, legendPosition = \"bottom\", width = NULL, height = NULL) {\n\n  # forward options using x\n  x = list(\n    values = values,\n    legendPosition = legendPosition\n  )\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'C3Pie',\n    x,\n    width = width,\n    height = height,\n    package = 'C3'\n  )\n}\n\n```\n\nNote that we added two arguments i.e. `values`, which contains the individual pie values and `legendPosition`, which takes as values 'bottom', 'right', and 'inset' (see [here](http://c3js.org/reference.html#legend-position)).\n\n\nAs before, all data is passed from R by the variable `x`, which is a list. Subsequently, shiny will tacitly pass this object via the R package [jsonlite](https://cran.r-project.org/web/packages/jsonlite/vignettes/json-aaquickstart.html), to JavaScript. Remember, after this step we are talking about a JavaScript object, which is very different to the R object you started with. As noted before, this step is one of the hardest (and often most confusing) steps in creating htmlwidgets.\n\n\n<p style = \"margin:25px\">\n  <a href = \"https://cran.r-project.org/web/packages/jsonlite/vignettes/json-aaquickstart.html\" target = \"_blank\"><img src = \"jsonlite.svg\" width=\"100%\"></img></a>\n  <div style = \"text-align:center\">all objects that are send from R to JavaScript, or from JavaScript to R, are tacitly passed and processed by shiny via jsonlite</div>\n</p>\n\nBack to our widget, in JavaScript, we can subsequently access the two variables from above via `x.value` and `x.legendPosition`, respectively. In the R code above, `values` is a list object. For instance, we can specify the pie data as `list('data1'=30,'data2'=120)`.\n\n\nAs noted in the [tutorial 1](http://shiny.rstudio.com/tutorial/js-lesson1/#step-3), it is worthwhile to experiment with [jsonlite](https://cran.r-project.org/web/packages/jsonlite/vignettes/json-aaquickstart.html) to see how R structures are converted from R to JavaScript.\n\n\nFor instance, in R run:\n\n\n::: {.cell}\n\n```{.r .cell-code}\njsonlite::toJSON(list('data1'=30,'data2'=120))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n{\"data1\":[30],\"data2\":[120]} \n```\n:::\n:::\n\n\nThe output results in `{\"data1\":[30],\"data2\":[120]}`. Aside from the extra brackets, the output looks like the structure we would like to have. The extra brackets imply an array with a single value, which for this purpose is the same as a single number.\n\nThe JavaScript code for our pie widget looks like this:\n\n\n```javascript\nHTMLWidgets.widget({\n\n  name: 'C3Pie',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // create an empty chart\n    var chart = null;\n\n    return {\n\n      renderValue: function(x) {\n\n        // if the chart does not exist, create it via c3.generate\n        if(chart === null){\n\n           // create a pie chart, see http://c3js.org/samples/chart_pie.html\n             chart = c3.generate({\n                bindto: el,\n                data: {\n                    json : [],\n                    type : 'pie'\n                },\n            legend: {\n                position: x.legendPosition\n              }\n            });\n        }\n\n        // at this stage the chart always exists\n        // get difference in keys\n        var old_keys = _.keys(chart.x());\n        var new_keys = _.keys(x.values);\n        var diff     = _.difference(old_keys,new_keys);\n\n        // load the new data (stored in x.values)\n        chart.load({\n          json:\n            x.values,\n\n            // unload data that we don't want anymore\n            unload: diff\n        });\n      }\n    };\n  }\n});\n```\n\nIn the JavaScript code above, just before the `chart.load` command, we compute the difference between keys in the old (current) data and the new data. In R, computing set differences is easy via `setdiff`. However, this function is not available in JavaScript, so how can we compute this difference?\n\nLuckily, in JavaScript there are many tool-belt helper libraries that offer handy functions for manipulating data. A popular library worth checking out is [underscore](http://underscorejs.org/), which we use to help us work with data keys. Here we used the underscore functions [_.keys](http://underscorejs.org/#keys) and [_.difference](http://underscorejs.org/#difference). Via `_.keys` we extract the key information out of the appropriate objects and via `_.difference` we compute the set difference:\n\n\n``` javascript\n  var old_keys = _.keys(chart.x());\n  var new_keys = _.keys(x.values);\n  var diff     = _.difference(old_keys,new_keys);\n```\n\nNotice that all of the functions in underscore start with a `_`, hence the name. You don't need a complete understanding of the last code snipped to follow the rest of this tutorial, but we highly recommend you check out what underscore can do, as being able to work with JavaScript objects and arrays is really helpful in building widgets!\n\nFor the remaining two charts (discussed below) we use the same concept, but the objects we put in `_.keys` are slightly different.\n\nFinally, the YAML file for our pie widget looks like this:\n\n```javascript\ndependencies:\n- name: d3\n  version: 3.5.0\n  src: htmlwidgets/lib/d3\n  script: ./d3.min.js\n- name: c3\n  version: 0.4.10\n  src: htmlwidgets/lib/c3\n  script: ./c3.min.js\n  style: ./c3.min.css\n- name: underscore\n  version: 1.8.3\n  src: htmlwidgets/lib/underscore\n  script: ./underscore-min.js\n```\n\nNote that we added a reference to underscore.\n\nYou can test drive the C3 pie widget via:\n\n```R\nC3Pie(values=list(data1=200,data2=300,data3=100))\n```\n\n## C3 combination chart\n\nInstead of creating a single chart, like a line chart or a bar chart, C3 allows you to create [combination charts](http://c3js.org/samples/chart_combination.html) that combine several chart types into a single chart.\n\n<iframe width='100%' height='300' style = \"padding-bottom:25px\" src='https://fiddle.jshell.net/FrissAnalytics/gzx4sxqn/embedded/result,js,html' allowfullscreen='allowfullscreen' frameborder='0'></iframe>\n\n\nIn this segment, we will combine a bar chart with a set of line charts. In addition, we'll add a sub-chart to it which we'll use in a later tutorial to create a time based filter.\n\n<iframe width='100%' height='400' src='https://fiddle.jshell.net/FrissAnalytics/hu5j1yan/embedded/result,js,html' allowfullscreen='allowfullscreen' frameborder='0'></iframe>\n\n\nLooking at the fiddle, you can see we have a lot more options to deal with. To keep things simple, we're not going to parameterize all of them. In the widget below, the user provides a single dataframe called `dataset`, with a time column (used for the x-axis) and a set of additional columns (used as y-values) for the bar and line series. Furthermore, the user must specify a `colors` variable that holds the display colors for the bar and line charts.\n\n\nHere's the complete R code for our C3LineBarChart widget:\n\n```R\nC3LineBarChart <- function(dataset, colors, width = NULL, height = NULL) {\n\n  # forward options using x\n  x = list(\n    dataset  = dataset,\n    colors   = colors\n  )\n\n  # create widget\n  htmlwidgets::createWidget(\n    name = 'C3LineBarChart',\n    x,\n    width = width,\n    height = height,\n    package = 'C3'\n  )\n}\n```\n\nFrom the JSfiddle we can see C3 want the data in this format:\n\n``` javascipt\nvar dataSet = [\n\t\t{\"Time\":\"2016-01-01\",\"GREEN\":1,\"RED\":2,\"Total\":3},\n\t\t{\"Time\":\"2016-01-02\",\"GREEN\":4,\"RED\":5,\"Total\":6},\n\t\t{\"Time\":\"2016-01-03\",\"GREEN\":7,\"RED\":9,\"Total\":9}\n];\n```\n\nFrom R, we can obtain this format by providing the data as a dataframe. Let's test this assertion with jsonlite:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n    dataset <- data.frame(Time  = c(\"2016-01-01\",\"2016-01-02\",\"2016-01-03\"),\n                          GREEN = c(1,4,7),\n                          RED   = c(2,5,9),\n                          Total = c(3,6,9) )\n\n    jsonlite::toJSON(dataset)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[{\"Time\":\"2016-01-01\",\"GREEN\":1,\"RED\":2,\"Total\":3},{\"Time\":\"2016-01-02\",\"GREEN\":4,\"RED\":5,\"Total\":6},{\"Time\":\"2016-01-03\",\"GREEN\":7,\"RED\":9,\"Total\":9}] \n```\n:::\n:::\n\n\nNice, precisely what we need!\n\nThe complete JavaScript code for our C3LineBarChart looks like this:\n\n```javascript\nHTMLWidgets.widget({\n\n  name: 'C3LineBarChart',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // create an empty chart\n    var chart = null;\n\n    return {\n\n      renderValue: function(x) {\n\n        // if the chart does not exist, create it via c3.generate\n        if(chart===null){\n\n            keys = _.keys(x.dataset);\n\n          \tchart = c3.generate({\n\n          \t  // specify the container element we want the chart to render in\n          \t\tbindto: el,\n          \t\tdata: {\n\n          \t\t  // intialize with an empty array\n          \t\t\tjson: [],\n          \t\t\tkeys: {\n          \t\t\t      // use Time for x-axis\n          \t\t\t      x: \"Time\",\n\n          \t\t\t  // use the remaining data for y-values\n          \t\t\t\tvalue: keys,\n          \t\t\t},\n\n          \t\t\t// set chart types\n          \t\t\ttypes: {\n\n          \t\t  \t// default is line, we want totals to be displayed as bars\n          \t\t\t\tTotal: 'bar'\n          \t\t\t},\n          \t\t\taxes: {\n          \t\t\t  // extra y-axis\n          \t\t\t\tTotal: 'y2'\n          \t\t\t}\n          \t\t},\n          \t\taxis: {\n          \t\t\tx: {\n          \t\t\t  //  x axis as timeseries\n          \t\t\t\ttype: \"timeseries\",\n\n          \t\t\t\t// tick format x-axis\n          \t\t\t\ttick: {\n          \t\t\t\t\tformat: \"%Y-%m-%d\"\n          \t\t\t\t}\n          \t\t\t},\n          \t\t\ty2: {\n          \t\t\t  // we want a second y-axis\n          \t\t\t\tshow: true\n          \t\t\t}\n          \t\t},\n\n          \t\t// display a subchart - this will be used for brushing in a later stage\n          \t\tsubchart: {\n          \t\t\tshow: true\n          \t\t}\n          \t});\n        }\n\n        // at this stage the chart always exists\n        // get difference in keys\n        var old_keys = _.keys(chart.x());\n        var new_keys = _.keys(x.dataset);\n        var diff     = _.difference(old_keys,new_keys);\n\n        // update the data and colors\n        chart.load({\n          json  : x.dataset,\n          colors: x.colors,\n\n          // unload data that we don't need anymore\n          unload: diff\n        });\n      }\n    };\n  }\n});\n```\n\nAs you can see, this code is a bit more involved. However, for the most part, we are only specifying specific C3 options. An overview of the complete set of available options can be found in the [C3 reference](http://c3js.org/reference.html).\n\n\nThe concept of rendering this chart is the same as for the pie chart. We make sure we hand the data to JavaScript in the correct format, we initialize a chart with an empty array, we compute any differences in keys relevant to unloading specific series and then we load and unload data.\n\n\nYou can build your practical experience by using our [htmlwidgets fiddle app](https://js-tutorial.shinyapps.io/WidgetFiddle/) to experiment with creating and setting options for C3 charts. When you do this, its probably best to keep a separate tab open with the [C3 reference](http://c3js.org/reference.html).\n\nOf note, we will use the sub-chart we created here in a later part of the tutorial series to pick up brush events and to send information back to shiny so we can create a brush-able time based filter.\n\n\nFinally, the YAML file for this widget is the same as for our pie chart.\n\nWhen we install our [C3 package](https://github.com/FrissAnalytics/shinyJsTutorials/tree/master/tutorials/materials2/C3), we can create a C3LineBarChart via:\n\n```R\ndataset <- data.frame(Time=c(\"2016-01-05\",\"2016-01-12\",\"2016-01-24\"),\n                      GREEN=c(0.1,0,0.2),\n                      RED=c(0.9,1,0.8),\n                      Total=c(320,210,190))\ncolors      <- list(Total=\"gray\",GREEN=\"Green\",RED=\"Red\")\nC3LineBarChart(dataset = dataset,colors=colors)\n```\n\n\n## C3 stacked area chart\n\nOur last chart is very similar to the combination chart above. Here we create a C3 [stacked area chart](http://c3js.org/samples/chart_area_stacked.html). As all of the concepts for this widget are repetitions from the previous charts, we keep the description of this widget brief. Here's a fiddle showing how to code a C3 stacked area chart:\n\n\n<iframe width='100%' height='420' style = \"padding-bottom:25px\" src='https://fiddle.jshell.net/FrissAnalytics/b71gsdy9/embedded/result,js,html' allowfullscreen='allowfullscreen' frameborder='0'></iframe>\n\nThe corresponding R code for our stacked area chart widget looks like this:\n\n\n```R\nHTMLWidgets.widget({\n\n  name: 'C3StackedAreaChart',\n\n  type: 'output',\n\n  factory: function(el, width, height) {\n\n    // create an empty chart\n    var chart = null;\n\n    return {\n\n      renderValue: function(x) {\n\n        // if the chart does not exist, create it via c3.generate\n        if(chart===null){\n\n          var keys = _.keys(x.dataset);\n\n        \tchart = c3.generate({\n        \t\tbindto: el,\n        \t\tdata: {\n        \t\t\tjson: [],\n        \t\t\tkeys: {\n        \t\t\t    x: \"Time\",\n        \t\t\t\t  value: keys,\n        \t\t\t}\n        \t\t},\n        \t\taxis: {\n        \t\t\tx: {\n        \t\t\t\ttype: \"timeseries\",\n        \t\t\t\ttick: {\n        \t\t\t\t\tformat: \"%Y-%m-%d\"\n        \t\t\t\t}\n        \t\t\t}\n        \t\t}\n        \t});\n\n      }\n\n      // at this stage the chart always exists\n      // get difference in keys\n      var old_keys = _.keys(chart.x());\n      var new_keys = _.keys(x.dataset);\n      var diff     = _.difference(old_keys,new_keys);\n\n      //chart.groups([x.groups]);\n\n      // update the data\n      chart.load({\n        // new data\n        json  : x.dataset,\n\n        // new colors\n        colors: x.colors,\n\n        // remove data we no longer need (if any)\n        unload: diff,\n\n        // set types\n        types : x.types\n      });\n    }\n   };\n}});\n```\n\nFinally, like before, the YAML file is similar to the one for the line bar chart and pie chart.\n\nIn R, the stacked area chart widget can be rendered via the following snippet:\n\n``` r\ndataset <- data.frame(\n  Time  = c(\"2016-01-05\",\"2016-01-12\",\"2016-01-24\"),\n  GREEN = c(0.5,0.2,0.3),\n  RED   = c(0.5,0.8,0.7))\n\ncolors  <- list(GREEN = \"green\", RED = \"red\")\n\nC3StackedAreaChart(dataset,colors)\n```\n\nNote that we create a named list to set the colors such that the data keys line up with the display colors we want to use.\n\n## Next tutorial\n\nAt this stage we have created code for all four widgets in the [showcase dashboard app](https://js-tutorial.shinyapps.io/dashboardApp/)! In the next tutorial, we see how we can send messages from R to our widgets and back. The messages allow us to manipulate charts from R and to create linked visualizations in which one widget reacts to another widget.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}